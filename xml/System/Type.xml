<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5f9b6827175638b5a5d149f571d2678f014ec849" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429881" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` est la racine de la <xref:System.Reflection> fonctionnalité et est le principal moyen d’accéder aux métadonnées. Utilisez les membres de <xref:System.Type> pour obtenir des informations sur une déclaration de type, sur les membres d’un type (par exemple, les constructeurs, méthodes, champs, propriétés et événements d’une classe), ainsi que le module et l’assembly dans lequel la classe est déployée.  
  
 Aucune autorisation n’est requise pour utiliser la réflexion pour obtenir des informations sur les types et leurs membres, indépendamment de leurs niveaux d’accès de code. Aucune autorisation n’est requise pour le code pour utiliser la réflexion pour accéder aux membres publics ou autres membres dont les niveaux d’accès les rendre visibles pendant la compilation normale. Toutefois, votre code peut utiliser la réflexion pour accéder aux membres qui seraient normalement inaccessibles, tels que les méthodes privées ou internes ou les champs protégés d’un type de votre classe n’hérite pas, votre code doit avoir <xref:System.Security.Permissions.ReflectionPermission>. Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type` est une classe de base abstraite qui permet des implémentations multiples. Le système fournit toujours la classe dérivée `RuntimeType`. Dans la réflexion, toutes les classes commençant par le mot Runtime sont créés une seule fois par objet dans les opérations de comparaison système et la prise en charge.  
  
> [!NOTE]
>  Dans les scénarios multithread, ne verrouillent pas <xref:System.Type> objets afin de synchroniser l’accès à `static` données. Tout autre code, sur lequel vous n’avez aucun contrôle, pourrait également verrouiller votre type de classe. Cela peut entraîner un blocage. Au lieu de cela, synchroniser l’accès aux données statiques en verrouillant privé `static` objet.  
  
> [!NOTE]
>  Une classe dérivée peut accéder à des membres protégés des classes de base du code appelant. En outre, l’accès est autorisé pour les membres de l’assembly de l’assembly du code appelant. En règle générale, si vous êtes autorisé à accéder dans le code à liaison anticipée, puis vous sont également autorisé à accéder dans le code à liaison tardive.  
  
> [!NOTE]
>  Les interfaces qui étendent les autres interfaces n’héritent pas les méthodes définies dans les interfaces étendues.  
  
 Dans cette section :  
  
 [Quels types de représenter par un objet de Type ?](#WhatTypes)   
 [Récupération d’un objet de Type](#Retrieve)   
 [Comparaison d’égalité des objets de type](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Quels types de représenter par un objet de Type ?  
 Cette classe est thread-safe ; plusieurs threads peuvent lire simultanément à partir d’une instance de ce type. Une instance de la <xref:System.Type> classe peut représenter l’un des types suivants :  
  
-   Classes  
  
-   Types de valeur  
  
-   Tableaux  
  
-   Interfaces  
  
-   Énumérations  
  
-   Délégués  
  
-   Types génériques construits et définitions de type générique  
  
-   Arguments de type et les paramètres de type des types génériques construits, définitions de type générique et des définitions de méthode générique  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Récupération d’un objet de Type  
 Le <xref:System.Type> objet associé à un type particulier peut être obtenu de plusieurs manières :  
  
-   L’instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> méthode retourne un <xref:System.Type> objet qui représente le type d’une instance. Étant donné que tous les types managés dérivent <xref:System.Object>, le <xref:System.Object.GetType%2A> méthode peut être appelée sur une instance de n’importe quel type.  
  
     L’exemple suivant appelle la <xref:System.Object.GetType%2A?displayProperty=nameWithType> méthode pour déterminer le type d’exécution de chaque objet dans un tableau d’objets.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   La méthode statique <xref:System.Type.GetType%2A?displayProperty=nameWithType> méthodes retournent un <xref:System.Type> objet qui représente un type spécifié par son nom complet.  
  
-   Le <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, et <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> méthodes retournent `Type` objets qui représentent les types définis dans un module. La première méthode peut être utilisée pour obtenir un tableau de <xref:System.Type> objets pour tous les types publics et privés définis dans un module. (Vous pouvez obtenir une instance de `Module` via la <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> (méthode), ou via le <xref:System.Type.Module%2A?displayProperty=nameWithType> propriété.)  
  
-   Le <xref:System.Reflection.Assembly?displayProperty=nameWithType> objet contient un nombre de méthodes pour extraire les classes définies dans un assembly, y compris <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, et <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   Le <xref:System.Type.FindInterfaces%2A> méthode retourne une liste filtrée de types d’interfaces prises en charge par un type.  
  
-   Le <xref:System.Type.GetElementType%2A> méthode retourne un `Type` objet qui représente l’élément.  
  
-   Le <xref:System.Type.GetInterfaces%2A> et <xref:System.Type.GetInterface%2A> méthodes retournent <xref:System.Type> objets représentant les types interface pris en charge par un type.  
  
-   Le <xref:System.Type.GetTypeArray%2A> méthode retourne un tableau de <xref:System.Type> objets représentant les types spécifiés par un ensemble arbitraire d’objets. Les objets sont spécifiés avec un tableau de type <xref:System.Object>.  
  
-   Le <xref:System.Type.GetTypeFromProgID%2A> et <xref:System.Type.GetTypeFromCLSID%2A> méthodes sont fournies pour l’interopérabilité COM. Elles retournent un <xref:System.Type> objet qui représente le type spécifié par un `ProgID` ou `CLSID`.  
  
-   Le <xref:System.Type.GetTypeFromHandle%2A> méthode est fournie pour l’interopérabilité. Elle retourne un `Type` objet qui représente le type spécifié par un handle de classe.  
  
-   C# `typeof` opérateur, C++ `typeid` (opérateur) et Visual Basic `GetType` opérateur obtenir la `Type` objet pour un type.  
  
-   Le <xref:System.Type.MakeGenericType%2A> méthode retourne un <xref:System.Type> objet représentant un type générique construit, qui est un type construit ouvert si sa <xref:System.Type.ContainsGenericParameters%2A> propriété renvoie `true`, et un fermé type créée, dans le cas contraire. Un type générique peut être instancié uniquement s’il est fermé.  
  
-   Le <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, et <xref:System.Type.MakeByRefType%2A> méthodes retournent <xref:System.Type> les objets qui représentent, respectivement, un tableau d’un type spécifié, un pointeur vers un type spécifié et le type de paramètre de référence (`ref` en c#, `ByRef`en Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Comparaison d’égalité des objets de type  
 A <xref:System.Type> objet que représente un type est unique ; autrement dit, deux <xref:System.Type> références d’objet font référence au même objet si et seulement si elles représentent le même type. Ainsi, pour la comparaison de <xref:System.Type> objets à l’aide de l’égalité des références. L’exemple suivant compare la <xref:System.Type> objets qui représentent un nombre de valeurs entières pour déterminer s’ils sont du même type.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 L’exemple suivant montre quelques fonctionnalités représentatives de <xref:System.Type>. C# `typeof` (opérateur) (`GetType` opérateur en Visual Basic, `typeid` opérateur dans Visual C++) est utilisée pour obtenir un <xref:System.Type> objet représentant <xref:System.String>. À partir de ce <xref:System.Type> objet, le <xref:System.Type.GetMethod%2A> méthode est utilisée pour obtenir un <xref:System.Reflection.MethodInfo> représentant le <xref:System.String.Substring%2A> surcharge qui prend un emplacement de départ et une longueur.  
  
 Pour identifier la signature de surcharge, l’exemple de code crée un tableau temporaire contenant deux <xref:System.Type> représentant des objets `int` (`Integer` en Visual Basic).  
  
> [!NOTE]
>  Pour être précis, le tableau contient deux références à l’instance de <xref:System.Type> qui représente `int` dans le domaine d’application actuel. Pour n’importe quel type, il existe une seule instance de <xref:System.Type> par domaine d’application.  
  
 L’exemple de code utilise le <xref:System.Reflection.MethodInfo> pour appeler le <xref:System.String.Substring%2A> méthode sur la chaîne « Hello, World ! » et affiche le résultat.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <block subset="none" type="overrides">
      <para>Lorsque vous héritez de <see langword="Type" />, vous devez substituer les membres suivants :- <see cref="P:System.Type.Assembly" />   
  
-    <see cref="P:System.Type.AssemblyQualifiedName" />   
  
-    <see cref="P:System.Type.BaseType" />   
  
-    <see cref="P:System.Type.FullName" />   
  
-    <see cref="M:System.Type.GetAttributeFlagsImpl" />   
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  -   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Type" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est appelé par les classes dérivées lors de la construction d’objets de type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared. For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</summary>
        <value>Instance de <see cref="T:System.Reflection.Assembly" /> qui décrit l'assembly contenant le type actuel. Pour les types génériques, l'instance décrit l'assembly qui contient la définition de type générique, et non pas l'assembly qui crée et utilise un type construit particulier.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le courant <xref:System.Type> objet représente un type générique construit, cette propriété retourne l’assembly qui contient la définition de type générique. Par exemple, supposons que vous créez un assembly nommé MyGenerics.dll, qui contient la définition de type générique `MyGenericStack<T>` (`MyGenericStack(Of T)` en Visual Basic, `generic<T> ref class MyGenericStack` en C++). Si vous créez une instance de `MyGenericStack<int>` (`MyGenericStack(Of Integer)` en Visual Basic) dans un autre assembly, le <xref:System.Type.Assembly%2A> propriété pour le type construit retourne un <xref:System.Reflection.Assembly> objet qui représente MyGenerics.dll.  
  
 De même, si le courant <xref:System.Type> objet représente un paramètre générique non assigné `T`, cette propriété retourne l’assembly qui contient le type générique qui définit `T`.  
  
 Si le <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriété n’est pas disponible sur une implémentation particulière de .NET, tels que .NET Core ou de la plateforme Windows universelle, utilisez le <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> propriété à la place.      
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant affiche le nom de l’assembly associé à la classe et le nom qualifié complet du type.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</summary>
        <value>Le nom qualifié d'assembly du <see cref="T:System.Type" />, qui inclut le nom de l'assembly à partir duquel le <see cref="T:System.Type" /> a été chargé ou <see langword="null" /> si l'instance actuelle représente un paramètre de type générique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nom qualifié d’assembly d’un type se compose du nom de type, y compris son espace de noms, suivie par une virgule, suivie par le nom complet de l’assembly. Le nom complet d’un assembly est obtenu à l’aide de la <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriété.  
  
> [!NOTE]
>  Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly. Par exemple, « ProcessorArchitecture = msil ». Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité. Consultez <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 Tous les compilateurs qui prennent en charge le common language runtime émettent le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogé, conformément aux conventions suivantes.  
  
|délimiteur|Signification|  
|---------------|-------------|  
|Barre oblique inverse (\\)|Caractère d’échappement.|  
|Virgule ()|Précède le nom de l’Assembly.|  
|Signe plus (+)|Précède une classe imbriquée.|  
|Point (.)|Indique les identificateurs d’espace de noms.|  
|Crochets ([])|Après un nom de type, indique un tableau de ce type.<br /><br /> - ou -<br /><br /> Pour un type générique, englobe la liste d’arguments de type générique.<br /><br /> - ou -<br /><br /> Dans une liste d’arguments de type, englobe un type qualifié d’assembly.|  
  
 Par exemple, le nom qualifié d’assembly pour une classe peut ressembler à ceci :  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Si l’espace de noms contenait un signe plus, par exemple TopNamespace, puis le signe plus (+) serait précédé d’un caractère d’échappement (\\) pour l’empêcher d’être interprété comme un séparateur d’imbrication. La réflexion émettrait cette chaîne comme suit :  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».  
  
 Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>. Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly. <xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système. <xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.  
  
 Noms de types peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau. Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.  
  
 Les espaces ne sont pertinentes dans tous les composants de nom de type, à l’exception du nom de l’assembly. Nom de l’assembly, les espaces avant le séparateur ',', mais des espaces après le séparateur ',' sont ignorées.  
  
 Les arguments génériques de types génériques sont eux-mêmes qualifiés par le nom de l’assembly. Par exemple, dans le nom de type qualifié d’assembly pour `MyGenericClass<int>` (`MyGenericClass(Of Integer)` en Visual Basic), `int` est développé pour le nom de type qualifié d’assembly pour <xref:System.Int32>.  
  
 Si le courant <xref:System.Type> objet représente un paramètre générique, cette propriété retourne `null`.  
  
   
  
## Examples  
 L’exemple suivant affiche le nom de l’assembly associé à la classe et le nom qualifié complet du type.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 L’exemple suivant compare les chaînes retournées par la <xref:System.Type.ToString%2A> (méthode) et le `Name`, <xref:System.Type.FullName%2A>, et <xref:System.Type.AssemblyQualifiedName%2A> propriétés.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the attributes associated with the <see cref="T:System.Type" />.</summary>
        <value>Objet <see cref="T:System.Reflection.TypeAttributes" /> qui représente l'ensemble d'attributs du <see cref="T:System.Type" />, à moins que le <see cref="T:System.Type" /> représente un paramètre de type générique, cas dans lequel la valeur est non spécifiée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains membres de le <xref:System.Reflection.TypeAttributes> énumération sont des masques qui représentent un groupe de valeurs. Chaque groupe comprend un seul membre dont la valeur sous-jacente est égale à zéro. Par exemple, la valeur sous-jacente de la <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> membre dans le <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> groupe est égal à zéro, car est le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> membre dans le <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> groupe. Pour cette raison, vous devez utiliser le masque avant de tester ces valeurs. Cet exemple en fournit une illustration.  
  
> [!TIP]
>  La plupart des cas, les propriétés telles que <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, et <xref:System.Type.IsSpecialName%2A> sont plus faciles à utiliser que les attributs de type.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété retourne les attributs de la définition de type générique. Par exemple, les attributs retournés pour `MyGenericClass<int>` (`MyGenericClass(Of Integer)` en Visual Basic) sont les attributs de `MyGenericClass<T>` (`MyGenericClass(Of T)` en Visual Basic).  
  
 Si actuel <xref:System.Type> représente un paramètre de type générique, autrement dit, si le <xref:System.Type.IsGenericParameter%2A> propriété renvoie `true` : le <xref:System.Reflection.TypeAttributes> valeur retournée par cette propriété n’est pas spécifié.  
  
   
  
## Examples  
 L’option de l’exemple suivant <xref:System.Type.Attributes%2A> propriété.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</summary>
        <value>
          <see cref="T:System.Type" /> dont le <see cref="T:System.Type" /> actuel hérite directement ou <see langword="null" /> si le <see langword="Type" /> actuel représente la classe <see cref="T:System.Object" /> ou une interface.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de base est le type à partir duquel le type actuel hérite directement. <xref:System.Object> est le seul type qui n’a pas un type de base, par conséquent `null` est retourné en tant que type de base de <xref:System.Object>.  
  
 Interfaces héritent de zéro ou plusieurs interfaces de base ; Par conséquent, cette propriété retourne `null` si le `Type` objet représente une interface. Les interfaces de base peuvent être déterminés avec <xref:System.Type.GetInterfaces%2A> ou <xref:System.Type.FindInterfaces%2A>.  
  
 Si le courant <xref:System.Type> représente un type générique construit, le type de base reflète les arguments génériques. Observez, par exemple, les déclarations suivantes :  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Pour le type construit `C<int>` (`C(Of Integer)` en Visual Basic), la <xref:System.Type.BaseType%2A> propriété renvoie `B<int>`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type d’une définition de type générique, <xref:System.Type.BaseType%2A> retourne la contrainte de classe, autrement dit, la classe que le paramètre de type doit hériter. S’il n’existe aucune contrainte de classe, <xref:System.Type.BaseType%2A> retourne <xref:System.Object?displayProperty=nameWithType>.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Type.BaseType%2A> propriété.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 L’exemple suivant utilise la récursivité pour afficher la hiérarchie d’héritage complète de chaque classe trouvé dans un assembly. L’exemple définit une classe nommée `C` qui dérive d’une classe nommée `B`, qui, à son tour, dérive une classe nommée `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</summary>
        <value>
          <see langword="true" /> si l'objet <see cref="T:System.Type" /> est lui-même un paramètre de type générique ou a des paramètres de type pour lesquels les types spécifiques n'ont pas été fournis ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour créer une instance d’un type, il ne doit exister aucune définitions de type générique ou les types construits ouverts dans les arguments de type du type lui-même, dans les types génériques englobants, ou dans tous les éléments du type. Une autre façon d’autres termes est que quand examinées de manière récursive, le type ne doit contenir aucun paramètre de type générique.  
  
 Étant donné que les types peuvent être arbitrairement complexes, il est difficile de cette décision. Pour plus de commodité et pour réduire le risque d’erreur, le <xref:System.Type.ContainsGenericParameters%2A> propriété fournit un moyen standard de faire la distinction entre les types construits fermés, ce qui peuvent être instanciées, et ouvrez construit des types, qui ne peut pas. Si le <xref:System.Type.ContainsGenericParameters%2A> propriété renvoie `true`, le type ne peut pas être instancié.  
  
 Le <xref:System.Type.ContainsGenericParameters%2A> propriété recherche de manière récursive pour les paramètres de type. Par exemple, elle retourne `true` pour un tableau dont les éléments sont de type `A<T>` (`A(Of T)` en Visual Basic), même si le tableau n’est pas lui-même générique. Ceci contraste avec le comportement de la <xref:System.Type.IsGenericType%2A> propriété qui retourne `false` pour les tableaux.  
  
 Pour un ensemble d’exemples de classes et d’un tableau indiquant les valeurs de la <xref:System.Type.ContainsGenericParameters%2A> propriété, consultez <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple suivant définit une classe générique avec deux paramètres de type et définit ensuite une deuxième classe générique qui dérive de la première classe. Classe de base de la classe dérivée a deux arguments de type : le premier est <xref:System.Int32> et le second est un paramètre de type du type dérivé. L’exemple affiche des informations sur ces classes génériques, y compris les positions rapportées par le <xref:System.Type.GenericParameterPosition%2A> propriété.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</summary>
        <value>Si le <see cref="T:System.Type" /> actuel représente un paramètre de type d'une méthode générique, <see cref="T:System.Reflection.MethodBase" /> qui représente la méthode de déclaration ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode de déclaration est une définition de méthode générique. Autrement dit, si <xref:System.Type.DeclaringMethod%2A> ne retourne pas `null`, puis `DeclaringMethod.IsGenericMethodDefinition` retourne `true`.  
  
 Le <xref:System.Type.DeclaringType%2A> et <xref:System.Type.DeclaringMethod%2A> identifient les propriétés de la définition de type générique ou la définition de méthode générique dans laquelle le paramètre de type générique a été initialement défini :  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> propriété retourne un <xref:System.Reflection.MethodInfo>, qui <xref:System.Reflection.MethodInfo> représente une définition de méthode générique et en cours <xref:System.Type> objet représente un paramètre de type de cette définition de méthode générique.  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> propriété renvoie `null`, puis le <xref:System.Type.DeclaringType%2A> propriété retourne toujours un <xref:System.Type> objet représentant une définition de type générique et en cours <xref:System.Type> objet représente un paramètre de type du type générique définition.  
  
-   Mise en route le <xref:System.Type.DeclaringMethod%2A> propriété sur un type dont <xref:System.Type.IsGenericParameter%2A> propriété `false` lève une <xref:System.InvalidOperationException>.  
  
 Le <xref:System.Reflection.MethodBase> qui est retourné par la <xref:System.Type.DeclaringMethod%2A> propriété est un <xref:System.Reflection.MethodInfo> dans le cas d’une méthode générique, ou un <xref:System.Reflection.ConstructorInfo> dans le cas d’un constructeur générique.  
  
> [!NOTE]
>  Dans le .NET Framework version 2.0, les constructeurs génériques ne sont pas pris en charge.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant définit une classe qui possède une méthode générique, assigne un argument de type à la méthode et appelle la méthode générique construite résultante. Elle affiche également des informations sur la définition de méthode générique et la méthode construite. Lors de l’affichage des informations sur les paramètres de type de la définition de méthode générique, dans le `DisplayGenericMethodInfo` (méthode), l’exemple de code affiche la valeur de la <xref:System.Type.DeclaringMethod%2A> propriété pour le paramètre de type générique de la méthode.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type that declares the current nested type or generic type parameter.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant le type englobant, si le type actuel est un type imbriqué ; ou définition du type générique, si le type actuel est un paramètre de type d'un type générique ; ou type qui déclare la méthode générique, si le type actuel est un paramètre de type d'une méthode générique ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le courant <xref:System.Type> objet représente un paramètre de type d’un type générique, cette propriété retourne la définition de type générique.  
  
 Si le courant <xref:System.Type> objet représente un paramètre de type d’une méthode générique, cette propriété retourne le type qui contient la définition de méthode générique. Si le type est générique, la définition de type générique est retournée. Autrement dit, le code suivant retourne la définition de type générique de la <xref:System.Collections.Generic.List%601> classe générique qui contient le <xref:System.Collections.Generic.List%601.ConvertAll%2A> méthode générique :  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, la <xref:System.Type.DeclaringType%2A> et <xref:System.Type.DeclaringMethod%2A> propriétés identifient la définition de type générique ou la définition de méthode générique où la paramètre de type générique a été initialement définie :  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> propriété retourne un <xref:System.Reflection.MethodInfo>, qui <xref:System.Reflection.MethodInfo> représente une définition de méthode générique et en cours <xref:System.Type> objet représente un paramètre de type de cette définition de méthode générique.  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> propriété renvoie `null`, puis le <xref:System.Type.DeclaringType%2A> propriété retourne toujours un <xref:System.Type> objet représentant une définition de type générique et en cours <xref:System.Type> objet représente un paramètre de type du type générique définition.  
  
-   Mise en route le <xref:System.Type.DeclaringType%2A> propriété sur un type dont <xref:System.Type.IsGenericParameter%2A> propriété `false` lève une <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Cet exemple affiche le type de déclaration d’une méthode dans une classe dérivée.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</summary>
        <value>Référence au binder par défaut utilisé par le système.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le binder par défaut fourni avec le common language runtime est applicable dans toutes les cas plus spécifiques. Si vous avez besoin d’un classeur qui applique des règles différentes de celles du binder par défaut fournie, qui définissent un type dérivé le <xref:System.Reflection.Binder> classe et passez une instance de ce type à l’aide de la `binder` paramètre de l’un de la <xref:System.Type.InvokeMember%2A> surcharges.  
  
 La réflexion modélise les règles d’accessibilité du système de type commun. Par exemple, si l’appelant est dans le même assembly, l’appelant ne doit-elle pas des autorisations spéciales pour les membres internes. Sinon, l’appelant doit <xref:System.Security.Permissions.ReflectionPermission>. Cela est cohérent avec la recherche de membres protégés, privés et ainsi de suite.  
  
 Le principe est que <xref:System.Reflection.Binder.ChangeType%2A> doit effectuer que des conversions étendues, qui ne perdent jamais de données. La conversion de valeur qui est un entier signé 32 bits à une valeur qui est un entier signé 64 bits est un exemple de conversion étendue. Elle se distingue d’une conversion restrictive, ce qui peut perdre des données. Un exemple d’une conversion restrictive convertit un entier signé 64 bits à un entier signé 32 bits.  
  
 Le tableau suivant répertorie les conversions prises en charge par le binder par défaut.  
  
|Type de source|Type de cible|  
|-----------------|-----------------|  
|Tout type|Son type de base.|  
|Tout type|L’interface qu’elle implémente.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Sans référence|Par référence.|  
  
   
  
## Examples  
 L’exemple suivant obtient le binder par défaut à partir de la `DefaultBinder` propriété et appelle un membre de MyClass en passant la `DefaultBinder` valeur en tant que paramètre à <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Separates names in the namespace of the <see cref="T:System.Type" />. This field is read-only.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents an empty array of type <see cref="T:System.Type" />. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Montre l’exemple de code suit le `EmptyTypes` champ utilisé dans un de la `GetConstructor` méthodes pour obtenir un constructeur qui ne prend aucun paramètre.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />. For the comparison to succeed, <c>o</c> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</param>
        <summary>Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</summary>
        <returns>
          <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />. This method also returns <see langword="false" /> if: .  
  
-   <paramref name="o" /> is <see langword="null" />.  
  
-   <paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode substitue <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Il convertit `o` à un objet de type <xref:System.Type> et appelle le <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Type.Equals%28System.Object%29> pour comparer différentes <xref:System.Type> avec différentes instances de l’objet <xref:System.Object> instances.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Deux choses sont particulièrement important de noter à propos de l’exemple :  
  
-   La comparaison d’un <xref:System.Type> objet qui représente un entier avec un <xref:System.Reflection.TypeInfo> objet qui représente un entier en retour `true` car <xref:System.Reflection.TypeInfo> est dérivée de <xref:System.Type>.  
  
-   La comparaison d’un <xref:System.Type> objet qui représente un <xref:System.Collections.Generic.IList%601> objet (un type générique ouvert) avec un `List(Of String)` (un type générique fermé) renvoie `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</param>
        <summary>Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</summary>
        <returns>
          <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise `Equals` pour comparer deux types.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the member filter used on attributes. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce champ conserve une référence au délégué utilisé par le <xref:System.Type.FindMembers%2A> (méthode). La méthode encapsulée par ce délégué prend deux paramètres : le premier est un <xref:System.Reflection.MemberInfo> objet et le second est un `Object`. La méthode détermine si le `MemberInfo` objet correspond aux critères spécifiés par le `Object`. Le `Object` peuvent être affectés à la valeur de l’un des champs sur les classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, ou <xref:System.Reflection.MethodImplAttributes>.  
  
 Par exemple, le `Object` peut avoir la valeur d’un champ de `FieldAttributes` comme Public. Dans ce cas, lorsque le `FilterAttribute` délégué est appelé, elle retournera `true` uniquement si la méthode représentée par le `MemberInfo` objet est décoré avec l’attribut de champ public dans les métadonnées.  
  
   
  
## Examples  
 L’exemple suivant obtient la `FilterAttribute` délégué, il passe en tant que paramètre à la <xref:System.Type.FindMembers%2A> (méthode) et affiche les membres spécifiés et leurs attributs.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the case-sensitive member filter used on names. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce champ conserve une référence au délégué utilisé par le <xref:System.Type.FindMembers%2A> (méthode). La méthode encapsulée par ce délégué prend deux paramètres : le premier est un <xref:System.Reflection.MemberInfo> objet et le second est un `Object`. La méthode détermine si le `MemberInfo` objet correspond aux critères spécifiés par le `Object`. Le `Object` est affectée à une valeur de chaîne, ce qui peut se terminer par un « * » caractère générique. Seule fin chaîne génériques est prise en charge.  
  
 Par exemple, le `Object` peut avoir la valeur « Octets * ». Dans ce cas, lorsque le `FilterName` délégué est appelé, elle retournera `true` uniquement si la méthode représentée par le `MemberInfo` objet a un nom qui commence par « Byte ».  
  
   
  
## Examples  
 L’exemple de code suivant obtient les méthodes associées défini par l’utilisateur `Application` type.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the case-insensitive member filter used on names. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce champ conserve une référence au délégué utilisé par le <xref:System.Type.FindMembers%2A> (méthode). La méthode encapsulée par ce délégué prend deux paramètres : le premier est un <xref:System.Reflection.MemberInfo> objet et le second est un `Object`. La méthode détermine si le `MemberInfo` objet correspond aux critères spécifiés par le `Object`. Le `Object` est affectée à une valeur de chaîne, ce qui peut se terminer par un « * » caractère générique. Seule fin chaîne génériques est prise en charge.  
  
 Par exemple, le `Object` peut avoir la valeur « Octets * ». Dans ce cas, lorsque le `FilterName` délégué est appelé, il retourne true uniquement si la méthode représentée par le `MemberInfo` objet a un nom qui commence par « octets », indépendamment de la casse.  
  
   
  
## Examples  
 L’exemple suivant obtient la `MemberFilter` délégué, il passe en tant que paramètre à la <xref:System.Type.FindMembers%2A> (méthode) et affiche les méthodes et leurs attributs de la `String` classe qui commencent par la lettre « c », en ignorant la casse.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">The delegate that compares the interfaces against <c>filterCriteria</c>.</param>
        <param name="filterCriteria">The search criteria that determines whether an interface should be included in the returned array.</param>
        <summary>Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</summary>
        <returns>An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array of type <see cref="T:System.Type" /> if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Le <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> et <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> délégués fournis par le <xref:System.Reflection.Module?displayProperty=nameWithType> classe peut également être utilisée, à la place du <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> déléguer.  
  
 Toutes les interfaces implémentées par cette classe sont considérées comme lors de la recherche, si déclaré par une classe de base ou cette classe elle-même.  
  
 Cette méthode recherche dans la hiérarchie de classe de base, retournant chacune des interfaces correspondantes de chacune des classes implémente ainsi que toutes les correspondances des interfaces chacun de ces implémente les interfaces (autrement dit, la fermeture transitive des interfaces correspondantes est retournée). Aucune interface double n’est retournés.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, <xref:System.Type.FindInterfaces%2A> recherche toutes les interfaces déclarées dans les contraintes sur le paramètre de type, et toutes les interfaces héritent via les interfaces déclarées dans les contraintes. Si le courant <xref:System.Type> représente un argument de type d’un type générique, <xref:System.Type.FindInterfaces%2A> recherche toutes les interfaces implémentées par le type, qu’ils correspondent aux contraintes ou non.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> peut retourner des interfaces génériques, même sur des types qui ne sont pas génériques. Par exemple, un type non générique peut implémenter `IEnumerable<int>` (`IEnumerable(Of Integer)` en Visual Basic).  
  
   
  
## Examples  
 L’exemple suivant recherche l’interface spécifiée implémentée ou héritée par le type spécifié, puis affiche les noms d’interface.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A static initializer is invoked and throws an exception.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">An object that indicates the type of member to search for.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <param name="filter">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <c>filterCriteria</c> and <see langword="false" /> otherwise. You can use the <see langword="FilterAttribute" />, <see langword="FilterName" />, and <see langword="FilterNameIgnoreCase" /> delegates supplied by this class. The first uses the fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> as search criteria, and the other two delegates use <see langword="String" /> objects as the search criteria.</param>
        <param name="filterCriteria">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.  The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</param>
        <summary>Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</summary>
        <returns>A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.  -or-  An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Instance` pour inclure les membres d’instance dans la recherche.  
  
-   Spécifiez `BindingFlags.Static` pour inclure les membres statiques dans la recherche.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Les valeurs valides pour <xref:System.Type.MemberType%2A> sont définis dans <xref:System.Reflection.MemberInfo>. Si aucun membre n’est trouvé, un tableau vide est retourné.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique ou une méthode générique, <xref:System.Type.FindMembers%2A> traite tous les membres déclarés par la contrainte de classe et les contraintes d’interface du paramètre de type.  
  
   
  
## Examples  
 L’exemple suivant recherche tous les membres dans une classe qui correspondent aux critères de recherche spécifiés, puis affiche les membres correspondants.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the fully qualified name of the type, including its namespace but not its assembly.</summary>
        <value>Nom qualifié complet du type, y compris son espace de noms, mais sans l'assembly ; ou <see langword="null" /> si l'instance actuelle représente un paramètre de type générique, un type de tableau, un type pointeur, un type <see langword="byref" /> reposant sur un paramètre de type ou un type générique qui n'est pas une définition de type générique mais contient des paramètres de type non résolus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, le nom qualifié complet de le <xref:System.String> est de type `System.String`. Ceci contraste avec le nom qualifié d’assembly retourné par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, qui est constitué du nom complet et le nom complet de l’assembly.  
  
 Si le type actuel représente un type générique fermé, les arguments de type dans la chaîne retournée par la <xref:System.Type.FullName%2A> propriété sont qualifiés par leur nom complet de l’assembly, bien que la représentation sous forme de chaîne du type générique lui-même n’est pas qualifiée par son intégral nom de l’assembly. L’exemple suivant illustre la différence dans la propriété FullName pour un type qui représente la définition de type générique et un qui représente un type générique fermé.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Cette propriété retourne `null` si :  
  
-   En cours <xref:System.Type> objet représente un paramètre de type d’un type générique.  
  
     L’exemple suivant récupère le paramètre de type de la <xref:System.Nullable%601> type et tente d’afficher son <xref:System.Type.FullName%2A> propriété.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   En cours <xref:System.Type> objet représente un type de tableau, un type pointeur, ou un `byref` type qui est basé sur un paramètre de type générique.  
  
     L’exemple suivant définit un type générique, `Generictype1<T>`, avec trois méthodes : `Display(T[])`, qui est transmis à un tableau de type T ; `HandleT(T)`, qui est transmis à un objet T ; et `ChangeValue(ref T)`, un objet de T qui est passé par référence. C# et Visual Basic n’autorisent pas nous pouvons T en tant que pointeur dans le `HandleT` (méthode), nous avons appeler le <xref:System.Type.MakePointerType%2A> méthode sur le <xref:System.Type> objet qui représente le type de paramètre pour créer un pointeur vers un type générique. La sortie de l’exemple montre que dans les trois cas, le <xref:System.Type.FullName%2A> propriété est `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   Le type actuel contient des paramètres de type générique qui n’ont pas été remplacés par des types spécifiques (autrement dit, le <xref:System.Type.ContainsGenericParameters%2A> propriété renvoie `true`), mais le type n’est pas une définition de type générique (autrement dit, la <xref:System.Type.IsGenericTypeDefinition%2A> retourne de la propriété `false`  
  
     Dans l’exemple suivant, `Derived<T>` hérite `Base<T>`. Le <xref:System.Type.BaseType%2A> propriété obtient le <xref:System.Type> objet qui représente le type de base de `Derived<T>`et son <xref:System.Type.FullName%2A> propriété renvoie `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Pour obtenir un <xref:System.Type.FullName%2A> qui n’est pas `null`, vous pouvez utiliser la <xref:System.Type.GetGenericTypeDefinition%2A> méthode pour obtenir la définition de type générique, comme l’illustre l’exemple.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant affiche le nom complet du type spécifié.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 L’exemple suivant compare les chaînes retournées par la <xref:System.Type.ToString%2A> (méthode) et le `Name`, <xref:System.Type.FullName%2A>, et <xref:System.Type.AssemblyQualifiedName%2A> propriétés.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</summary>
        <value>Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.GenericParameterAttributes" /> qui décrit la covariance et les contraintes spéciales du paramètre de type générique actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété contient des indicateurs qui décrivent les contraintes spéciales et des indicateurs qui décrivent si le paramètre de type générique actuel est covariant. Utilisez le <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> valeur pour sélectionner les indicateurs de covariance et utiliser le <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> valeur pour sélectionner les indicateurs de contrainte.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant définit un type générique `Test` avec deux paramètres de type qui possèdent des contraintes différentes. Lorsque le programme s’exécute, les contraintes sont examinées à l’aide de la <xref:System.Type.GenericParameterAttributes%2A> propriété et la <xref:System.Type.GetGenericParameterConstraints%2A> (méthode).  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Type" /> object is not a generic type parameter. That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</summary>
        <value>Position d'un paramètre de type dans la liste des paramètres de type du type générique ou de la méthode qui a défini le paramètre. La numérotation des positions commence à zéro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GenericParameterPosition%2A> propriété retourne la position d’un paramètre de type dans la liste de paramètres de la définition de type générique ou la définition de méthode générique où le paramètre de type a été défini à l’origine. Le <xref:System.Type.DeclaringType%2A> et <xref:System.Type.DeclaringMethod%2A> propriétés identifient la définition de type ou de méthode générique :  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> propriété retourne un <xref:System.Reflection.MethodInfo>, qui <xref:System.Reflection.MethodInfo> représente une définition de méthode générique et en cours <xref:System.Type> objet représente un paramètre de type de cette définition de méthode générique.  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> propriété renvoie `null`, puis le <xref:System.Type.DeclaringType%2A> propriété retourne toujours un <xref:System.Type> objet représentant une définition de type générique et en cours <xref:System.Type> objet représente un paramètre de type du type générique définition.  
  
 Pour fournir le contexte correct pour la valeur de la <xref:System.Type.GenericParameterPosition%2A> propriété, il est nécessaire identifier le type générique ou la méthode un paramètre de type appartient. Par exemple, considérez la valeur de retour de la méthode générique `GetSomething` dans le code suivant :  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 Le type retourné par `GetSomething` varie selon les arguments de type fournis à la classe `A` et `GetSomething` lui-même. Vous pouvez obtenir un <xref:System.Reflection.MethodInfo> pour `GetSomething`, et à partir de que vous pouvez obtenir le type de retour. Lorsque vous examinez les paramètres de type de retour, <xref:System.Type.GenericParameterPosition%2A> retourne 0 pour les deux. La position de `V` est 0 car `V` est le premier paramètre de type dans la liste de paramètres de type pour la classe `A`. La position de `X` est 0 car `X` est le premier paramètre de type dans la liste de paramètres de type `GetSomething`.  
  
> [!NOTE]
>  Appel de la <xref:System.Type.GenericParameterPosition%2A> propriété provoque une exception si actuel <xref:System.Type> ne représente pas un paramètre de type. Lorsque vous examinez les arguments de type d’un type construit ouvert, utilisez la <xref:System.Type.IsGenericParameter%2A> propriété pour indiquer à qui sont des paramètres de type et les types. Le <xref:System.Type.IsGenericParameter%2A> propriété renvoie `true` pour un paramètre de type ; vous pouvez ensuite utiliser le <xref:System.Type.GenericParameterPosition%2A> méthode à obtenir sa position, utilisez la <xref:System.Type.DeclaringMethod%2A> et <xref:System.Type.DeclaringType%2A> propriétés afin de déterminer la méthode générique ou type de définition qui le définit .  
  
   
  
## Examples  
 L’exemple suivant définit une classe générique avec deux paramètres de type et une deuxième classe générique qui dérive de la première classe. Classe de base de la classe dérivée a deux arguments de type : le premier est <xref:System.Int32>, et le deuxième est un paramètre de type du type dérivé. L’exemple affiche des informations sur ces classes génériques, y compris les positions rapportées par le <xref:System.Type.GenericParameterPosition%2A> propriété.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The current type does not represent a type parameter. That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an array of the generic type arguments for this type.</summary>
        <value>Tableau des arguments de type générique pour ce type.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété obtient uniquement les arguments de type générique ; Autrement dit, les types qui ont été spécifiées pour les paramètres de type générique du type actuel. Si le type actuel est une définition de type générique, cette propriété retourne un tableau vide.  
  
> [!NOTE]
>  Si un type générique est utilisé dans une méthode générique ou dans un autre type générique, certaines de ses arguments de type générique peuvent être des paramètres de type générique de la méthode ou le type englobant.  
  
 Pour obtenir les paramètres de type générique d’un type qui représente une définition de type générique, utilisez le <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> propriété. Pour obtenir un <xref:System.Reflection.TypeInfo> objet en cours <xref:System.Type> de l’objet, utilisez la <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> méthode d’extension.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the number of dimensions in an array.</summary>
        <returns>An integer that contains the number of dimensions in the current type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche le nombre de dimensions dans un tableau.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</exception>
        <exception cref="T:System.ArgumentException">The current type is not an array.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitmask indicating the attributes associated with the <see cref="T:System.Type" />.</summary>
        <returns>A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a specific constructor of the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.  -or-  An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters. Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</param>
        <summary>Searches for a public instance constructor whose parameters match the types in the specified array.</summary>
        <returns>An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de méthode recherche des constructeurs d’instance publics et ne peut pas être utilisée pour obtenir un initialiseur de classe (.cctor). Pour obtenir un initialiseur de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si le constructeur demandé est non public, cette méthode retourne `null`.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes. Vous pouvez uniquement omettre les paramètres lors de l’appel.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.ConstructorInfo> avec les paramètres de type remplacés par les arguments de type approprié. Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode retourne toujours `null`.  
  
   
  
## Examples  
 L’exemple suivant obtient le type de `MyClass`, obtient le <xref:System.Reflection.ConstructorInfo> de l’objet et affiche la signature du constructeur.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> is <see langword="null" />.  -or-  One of the elements in <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.  -or-  An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.  -or-  <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter.</param>
        <summary>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</summary>
        <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance. Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes. Vous pouvez uniquement omettre les paramètres lors de l’appel.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.ConstructorInfo> avec les paramètres de type remplacés par les arguments de type approprié. Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode retourne toujours `null`.  
  
   
  
## Examples  
 Le programme suivant obtient le type de `MyClass1` classe, obtient le <xref:System.Reflection.ConstructorInfo> correspondant aux indicateurs de liaison spécifiée de l’objet et affiche la signature du constructeur.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> is <see langword="null" />.  -or-  One of the elements in <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.  -or-  <paramref name="modifiers" /> is multidimensional.  -or-  <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.  -or-  An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</param>
        <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array. The default binder does not process this parameter.</param>
        <summary>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</summary>
        <returns>An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance. Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes. Vous pouvez uniquement omettre les paramètres lors de l’appel.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.ConstructorInfo> avec les paramètres de type remplacés par les arguments de type approprié. Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode retourne toujours `null`.  
  
   
  
## Examples  
 L’exemple suivant obtient le type de `MyClass1`, obtient le <xref:System.Reflection.ConstructorInfo> objet qui correspond aux indicateurs de liaison spécifiés et affiche la signature du constructeur.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> is <see langword="null" />.  -or-  One of the elements in <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.  -or-  <paramref name="modifiers" /> is multidimensional.  -or-  <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.  -or-  An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</param>
        <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array. The default binder does not process this parameter.</param>
        <summary>When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</summary>
        <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance. Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Cette méthode implémente <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> is <see langword="null" />.  -or-  One of the elements in <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.  -or-  <paramref name="modifiers" /> is multidimensional.  -or-  <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</exception>
        <exception cref="T:System.NotSupportedException">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the constructors of the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns all the public constructors defined for the current <see cref="T:System.Type" />.</summary>
        <returns>An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor). If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetConstructors%2A> méthode ne retourne pas les constructeurs dans un ordre particulier, tel que l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les constructeurs sont retournés, car cet ordre varie.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Cette surcharge de méthode appelle la <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> la surcharge de méthode, avec <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> en Visual Basic). Elle ne trouvera pas d’initialiseurs de classe (.cctor). Pour rechercher des initialiseurs de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.ConstructorInfo> objets avec les paramètres de type remplacés par les arguments de type approprié. Par exemple, si classe `C<T>` a un constructeur `C(T t1)` (`Sub New(ByVal t1 As T)` en Visual Basic), l’appel <xref:System.Type.GetConstructors%2A> sur `C<int>` retourne un <xref:System.Reflection.ConstructorInfo> représentant `C(int t1)` en c# (`Sub New(ByVal t1 As Integer)` en Visual Basic).  
  
 Si le courant <xref:System.Type> représente un paramètre de type générique, la <xref:System.Type.GetConstructors%2A> méthode retourne un tableau vide.  
  
   
  
## Examples  
 Cet exemple montre la sortie de la <xref:System.Type.GetConstructors%2A> de surcharge à partir d’une classe qui possède deux constructeurs d’instance et un constructeur statique.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 La sortie de ce code est :  
  
 2  
  
 False  
  
 False  
  
 Étant donné que la <xref:System.Type.GetConstructors> surcharge utilise uniquement <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> et <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, le constructeur statique n’est ni compté par le `for` expression ni évalué par `IsStatic`.  
  
 Pour rechercher des constructeurs statiques, utilisez le <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> de surcharge et passez la combinaison (logique `OR`) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, comme illustré dans l’exemple de code suivant :  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 À présent, la sortie :  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <summary>When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</summary>
        <returns>An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined. Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetConstructors%2A> méthode ne retourne pas les constructeurs dans un ordre particulier, tel que l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les constructeurs sont retournés, car cet ordre varie.  
  
 `bindingAttr` peut être utilisé pour spécifier s’il faut retourner uniquement les constructeurs publics ou les constructeurs publics et non publics.  
  
 Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance. Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche. Constructeurs de classes de base ne sont pas retournés.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.ConstructorInfo> objets avec les paramètres de type remplacés par les arguments de type approprié. Par exemple, si classe `C<T>` a un constructeur `C(T t1)` (`Sub New(ByVal t1 As T)` en Visual Basic), l’appel <xref:System.Type.GetConstructors%2A> sur `C<int>` retourne un <xref:System.Reflection.ConstructorInfo> représentant `C(int t1)` en c# (`Sub New(ByVal t1 As Integer)` en Visual Basic).  
  
 Si le courant <xref:System.Type> représente un paramètre de type générique, la <xref:System.Type.GetConstructors%2A> méthode retourne un tableau vide.  
  
   
  
## Examples  
 Cet exemple montre la sortie de la <xref:System.Type.GetConstructors> de surcharge à partir d’une classe qui possède deux constructeurs d’instance et un constructeur statique.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 La sortie de ce code est :  
  
 2  
  
 False  
  
 False  
  
 Étant donné que la <xref:System.Type.GetConstructors%2A> surcharge utilise uniquement <xref:System.Reflection.BindingFlags.Public> et <xref:System.Reflection.BindingFlags.Instance>, le constructeur statique n’est ni compté par le `for` expression ni évalué par `IsStatic`.  
  
 Pour rechercher des constructeurs statiques, utilisez le <xref:System.Type.GetConstructors%2A> de surcharge et passez la combinaison (ou logique) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, comme illustré dans l’exemple de code suivant :  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 À présent, la sortie :  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</summary>
        <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.  -or-  An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetDefaultMembers%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MemberInfo> objets avec les paramètres de type remplacés par les arguments de type approprié. Par exemple, si classe `C<T>` a une propriété `P` qui retourne `T`, l’appel <xref:System.Type.GetDefaultMembers%2A> sur `C<int>` retourne `int P` en c# (`Property P As Integer` en Visual Basic).  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant obtient les informations de membre par défaut de `MyClass` et affiche les membres par défaut.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</summary>
        <returns>The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne `null` pour la <xref:System.Array> classe.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le `GetElementType` (méthode).  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value whose name is to be retrieved.</param>
        <summary>Returns the name of the constant that has the specified value, for the current enumeration type.</summary>
        <returns>The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The current type is not an enumeration.  -or-  <paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the names of the members of the current enumeration type.</summary>
        <returns>An array that contains the names of the members of the enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments du tableau de valeur de retour sont triés par les valeurs binaires (autrement dit, les valeurs non signées) des constantes énumérées. Si le tableau contient des constantes énumérées avec la même valeur, l’ordre de leurs noms correspondants n’est pas spécifié.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current type is not an enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the underlying type of the current enumeration type.</summary>
        <returns>The underlying type of the current enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le type sous-jacent d’une énumération en c# et Visual Basic est <xref:System.Int32>. Autres types d’entiers peuvent être spécifiés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current type is not an enumeration.  -or-  The enumeration type is not valid, because it contains more than one instance field.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of the values of the constants in the current enumeration type.</summary>
        <returns>An array that contains the values. The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The current type is not an enumeration.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</param>
        <summary>Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</summary>
        <returns>The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un événement est considérée comme publique de la réflexion s’il a au moins une méthode ou l’accesseur est public. Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 La recherche de `name` respecte la casse. La recherche inclut les événements d’instance public de static et public.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.EventInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les événements de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Reflection.EventInfo> de l’objet et obtient l’événement pour une classe de bouton pour l’événement spécifié.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <summary>When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</summary>
        <returns>The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les événements à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les événements publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les événements non publics (c'est-à-dire les événements privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les événements déclarés sur le <xref:System.Type>, pas les événements qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Un événement est considérée comme publique de la réflexion s’il a au moins une méthode ou l’accesseur est public. Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.EventInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les événements de la contrainte de classe.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> méthode pour rechercher un type pour un événement public ou non public nommé « Cliquez » qui n’est pas `static` (`Shared` en Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</summary>
        <returns>An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.  -or-  An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un événement est considérée comme publique de la réflexion s’il a au moins une méthode ou l’accesseur est public. Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Le <xref:System.Type.GetEvents%2A> méthode ne retourne pas les événements dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les événements sont retournés, car cet ordre varie.  
  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.EventInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les événements de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant obtient un tableau de <xref:System.Reflection.EventInfo> des objets, tous les événements pour un `Button` de classe et affiche les noms des événements. Pour compiler l’exemple Visual Basic, utilisez la ligne de commande suivante :  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <summary>When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
        <returns>An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.  -or-  An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetEvents%2A> méthode ne retourne pas les événements dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les événements sont retournés, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les événements à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les événements publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les événements non publics (c'est-à-dire les événements privés, internes et protégés) dans la recherche. Seuls protégés et des événements internes sur les classes de base sont retournés ; événements privés sur les classes de base ne sont pas retournés.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les événements déclarés sur le <xref:System.Type>, pas les événements qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Un événement est considérée comme publique de la réflexion s’il a au moins une méthode ou l’accesseur est public. Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.EventInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les événements de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant obtient un tableau de <xref:System.Reflection.EventInfo> objets qui correspondent aux indicateurs de liaison spécifiés, obtient tous les événements pour un `Button` de classe et affiche les noms des événements. Pour compiler l’exemple Visual Basic, utilisez la ligne de commande suivante :  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a specific field of the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the data field to get.</param>
        <summary>Searches for the public field with the specified name.</summary>
        <returns>An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse. La recherche inclut des champs d’instance publics de static et public.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.FieldInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les champs de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant obtient la `Type` de l’objet pour la classe spécifiée, qui obtient le <xref:System.Reflection.FieldInfo> objet pour le champ et affiche la valeur du champ.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the data field to get.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <summary>Searches for the specified field, using the specified binding constraints.</summary>
        <returns>An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les champs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les champs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les champs non publics (autrement dit, les champs privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les champs déclarés sur le <xref:System.Type>, pas les champs qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.FieldInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les champs de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant obtient la `Type` de l’objet pour la classe spécifiée, qui obtient le <xref:System.Reflection.FieldInfo> objet pour le champ qui correspond aux indicateurs de liaison spécifiés et affiche la valeur du champ.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the fields of the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns all the public fields of the current <see cref="T:System.Type" />.</summary>
        <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.  -or-  An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les champs sont retournés, car cet ordre varie.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.FieldInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les champs publics de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de la `GetFields()` (méthode).  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <summary>When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
        <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.  -or-  An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les champs sont retournés, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les champs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les champs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les champs non publics (autrement dit, les champs privés, internes et protégés) dans la recherche. Seuls protégés et les champs internes sur les classes de base sont retournés ; les champs privés sur les classes de base ne sont pas retournés.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les champs déclarés sur le <xref:System.Type>, pas les champs qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.FieldInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les champs publics de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de la `GetFields(BindingFlags)` (méthode).  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</summary>
        <returns>An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type. Returns an empty array if the current type is not a generic type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments du tableau sont retournés dans l’ordre dans lequel elles apparaissent dans la liste d’arguments de type pour le type générique.  
  
-   Si le type actuel est un type construit fermé (autrement dit, le <xref:System.Type.ContainsGenericParameters%2A> propriété renvoie `false`), le tableau retourné par la <xref:System.Type.GetGenericArguments%2A> méthode contient les types qui ont été attribuées aux paramètres de type générique de la définition de type générique .  
  
-   Si le type actuel est une définition de type générique, le tableau contient les paramètres de type.  
  
-   Si le type actuel est un type construit ouvert (autrement dit, le <xref:System.Type.ContainsGenericParameters%2A> propriété renvoie `true`) dans lequel des types spécifiques n’ont pas été assignés à tous les paramètres de type et les paramètres de type de placer des types ou méthodes génériques, le tableau contient les types et les paramètres de type. Utilisez le <xref:System.Type.IsGenericParameter%2A> propriété pour les distinguer. Pour une démonstration de ce scénario, consultez l’exemple de code pour le <xref:System.Type.ContainsGenericParameters%2A> propriété.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Type.GetGenericArguments%2A> méthode pour afficher les arguments de type d’un type construit et les paramètres de type de sa définition de type générique.  
  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.Type.IsGenericTypeDefinition%2A> propriété. Consultez l’exemple plus complet pour l’exemple de sortie.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class. Derived classes must provide an implementation.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</summary>
        <returns>An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque contrainte sur un paramètre de type générique est exprimée comme une <xref:System.Type> objet. Utilisez le <xref:System.Type.IsClass%2A> propriété pour déterminer si une contrainte est la contrainte de classe de base ; si la propriété retourne `false`, la contrainte est une contrainte d’interface. Si un paramètre de type a aucune contrainte de classe et les contraintes d’interface, un tableau vide est retourné.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant définit un type générique `Test` avec deux paramètres de type qui possèdent des contraintes différentes. Lorsque le programme s’exécute, les contraintes sont examinées à l’aide de la <xref:System.Type.GenericParameterAttributes%2A> propriété et la <xref:System.Type.GetGenericParameterConstraints%2A> (méthode).  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Type" /> object is not a generic type parameter. That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</summary>
        <returns>A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une définition de type générique est un modèle à partir de laquelle d’autres types peuvent être construits. Par exemple, à partir de la définition de type générique `G<T>` (exprimé en syntaxe c# ; `G(Of T)` en Visual Basic ou `generic <typename T> ref class G` en C++) vous pouvez construire et instancier le type `G<int>` (`G(Of Integer)` en Visual Basic). Étant donné un <xref:System.Type> objet représentant ce type construit, le <xref:System.Type.GetGenericTypeDefinition%2A> méthode retourne la définition de type générique.  
  
 Si deux types construits sont créés à partir de la même définition de type générique, à l’aide des mêmes arguments de type, le <xref:System.Type.GetGenericTypeDefinition%2A> méthode retourne la même <xref:System.Type> objet pour les deux types.  
  
 Si vous appelez le <xref:System.Type.GetGenericTypeDefinition%2A> méthode sur un <xref:System.Type> objet qui représente déjà une définition de type générique, elle renvoie l’actuel <xref:System.Type>.  
  
> [!IMPORTANT]
>  Un tableau de types génériques n’est pas lui-même générique. Dans le code c# `A<int>[] v;` ou le code Visual Basic `Dim v() As A(Of Integer)`, le type de variable `v` n’est pas générique. Utilisez <xref:System.Type.IsGenericType%2A> pour déterminer si un type est générique avant d’appeler <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant crée une instance d’un type construit à l’aide de la création d’instance ordinaire, puis utilise le <xref:System.Type.GetType%2A> et <xref:System.Type.GetGenericTypeDefinition%2A> méthodes pour récupérer le type construit et la définition de type générique. Cet exemple utilise le type générique <xref:System.Collections.Generic.Dictionary%602> type ; le type construit représente un <xref:System.Collections.Generic.Dictionary%602> de `Test` objets avec des clés de chaîne.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The current type is not a generic type.  That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class. Derived classes must provide an implementation.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this instance.</summary>
        <returns>The hash code for this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode substitue <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant affiche le code de hachage de la `System.Windows.Forms.Button` classe.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the interface to get. For generic interfaces, this is the mangled name.</param>
        <summary>Searches for the interface with the specified name.</summary>
        <returns>An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Type> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les contraintes d’interface et toutes les interfaces héritées des contraintes de classe ou interface.  
  
> [!NOTE]
>  Pour les interfaces génériques, le `name` paramètre est le nom tronqué, se terminant par un accent grave (\`) et le nombre de paramètres de type. Cela est vrai pour les définitions d’interface générique et les interfaces génériques construits. Par exemple, pour rechercher `IExample<T>` (`IExample(Of T)` en Visual Basic) ou `IExample<string>` (`IExample(Of String)` en Visual Basic), recherchez ``"IExample`1"``.  
  
   
  
## Examples  
 Le de code suivant montre comment utiliser le <xref:System.Type.GetInterface%28System.String%29> méthode pour rechercher le <xref:System.Collections.Hashtable> de classes pour la <xref:System.Runtime.Serialization.IDeserializationCallback> interface et répertorie les méthodes de l’interface.  
  
 L’exemple de code montre également le <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> surcharge de méthode et la <xref:System.Type.GetInterfaceMap%2A> (méthode).  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the interface to get. For generic interfaces, this is the mangled name.</param>
        <param name="ignoreCase">
          <see langword="true" /> to ignore the case of that part of <c>name</c> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).  -or-  <see langword="false" /> to perform a case-sensitive search for all parts of <c>name</c>.</param>
        <summary>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</summary>
        <returns>An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ignoreCase` paramètre s’applique uniquement au nom d’interface simple, pas à l’espace de noms. La partie de `name` qui spécifie l’espace de noms doive respecter la casse, ou l’interface est introuvable. Par exemple, la chaîne « System.icomparable » recherche les <xref:System.IComparable> interface, mais la chaîne « system.icomparable » n’est pas.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Type> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les contraintes d’interface et toutes les interfaces héritées des contraintes de classe ou interface.  
  
> [!NOTE]
>  Pour les interfaces génériques, le `name` paramètre est le nom tronqué, se terminant par un accent grave (\`) et le nombre de paramètres de type. Cela est vrai pour les définitions d’interface générique et les interfaces génériques construits. Par exemple, pour rechercher `IExample<T>` (`IExample(Of T)` en Visual Basic) ou `IExample<string>` (`IExample(Of String)` en Visual Basic), recherchez `"IExample`1 » '.  
  
   
  
## Examples  
 Le de code suivant montre comment utiliser le <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> méthode pour effectuer une recherche sans respecter la casse de la <xref:System.Collections.Hashtable> de classes pour la <xref:System.Collections.IEnumerable> interface.  
  
 L’exemple de code montre également le <xref:System.Type.GetInterface%28System.String%29> surcharge de méthode et la <xref:System.Type.GetInterfaceMap%2A> (méthode).  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">The interface type to retrieve a mapping for.</param>
        <summary>Returns an interface mapping for the specified interface type.</summary>
        <returns>An object that represents the interface mapping for <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le mappage d’interface indique le mode de mappage d’une interface dans les membres réels sur une classe qui implémente cette interface.  
  
 Si actuel <xref:System.Type> représente un type générique construit, type de paramètres sont remplacés par les arguments de type appropriés dans les éléments de la <xref:System.Reflection.InterfaceMapping> retourné par cette méthode.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Type.GetInterfaceMap%2A> méthode pour déterminer comment la <xref:System.IFormatProvider> interface mappe à <xref:System.Globalization.CultureInfo> méthodes et comment la <xref:System.IAppDomainSetup> interface mappe à <xref:System.AppDomainSetup> propriétés. Notez que, étant donné que la <xref:System.IAppDomainSetup> interface définit un ensemble de propriétés, retournés <xref:System.Reflection.InterfaceMapping> objet inclut distinct <xref:System.Reflection.MethodInfo> objets pour d’une propriété accesseurs get et set.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" /> is not implemented by the current type.  -or-  The <paramref name="interfaceType" /> parameter does not refer to an interface.  -or-  <paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class. Derived classes must provide an implementation.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</summary>
        <returns>An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.  -or-  An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetInterfaces%2A> méthode ne retourne pas les interfaces dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les interfaces sont retournées, car cet ordre varie.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Type> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les contraintes d’interface et toutes les interfaces héritées des contraintes de classe ou interface.  
  
   
  
## Examples  
 L’exemple suivant obtient le type de la classe spécifiée et affiche toutes les interfaces que le type implémente ou en hérite. Pour compiler l’exemple Visual Basic, utilisez les commandes de compilateur suivantes :  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">A static initializer is invoked and throws an exception.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the specified members of the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the public members to get.</param>
        <summary>Searches for the public members with the specified name.</summary>
        <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse. La recherche inclut les membres d’instance publics de static et public.  
  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le <xref:System.Type.GetMember%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Cette surcharge de méthode ne trouvera pas d’initialiseurs de classe (.cctor). Pour rechercher des initialiseurs de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MemberInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant affiche tous les membres de la `String` classe qui commencent par la lettre C.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the members to get.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return an empty array.</param>
        <summary>Searches for the specified members, using the specified binding constraints.</summary>
        <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le <xref:System.Type.GetMember%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier « .cctor » pour `name`, et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic) pour `bindingAttr`. Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MemberInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant affiche tous les membres statiques publics de la `myString` classe qui commencent par la lettre C.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the members to get.</param>
        <param name="type">The value to search for.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return an empty array.</param>
        <summary>Searches for the specified members of the specified member type, using the specified binding constraints.</summary>
        <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le <xref:System.Type.GetMember%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier « .cctor » pour `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> pour `type`, et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> dans Visual Basic) pour `bindingAttr`. Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MemberInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant affiche toutes les méthodes de la `myString` classe qui commencent par la lettre C.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">A derived class must provide an implementation.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns all the public members of the current <see cref="T:System.Type" />.</summary>
        <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.  -or-  An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le <xref:System.Type.GetMembers%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Cette surcharge de méthode appelle la <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> la surcharge de méthode, avec <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> en Visual Basic). Elle ne trouvera pas d’initialiseurs de classe (.cctor). Pour rechercher des initialiseurs de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MemberInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Type.GetMembers> surcharge de méthode pour collecter des informations sur tous les membres publics d’une classe spécifiée.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), to return an empty array.</param>
        <summary>When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
        <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.  -or-  An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le <xref:System.Type.GetMembers%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche. Seuls protégés et des membres internes sur les classes de base sont retournés ; les membres privés sur les classes de base ne sont pas retournés.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Appel de cette méthode avec uniquement le `Public` indicateur ou uniquement les `NonPublic` indicateur retournera les membres spécifiés et ne nécessite pas de tous les autres indicateurs.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MemberInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> surcharge de méthode pour collecter des informations sur tous les membres d’instance publics d’une classe spécifiée.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a specific method of the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the public method to get.</param>
        <summary>Searches for the public method with the specified name.</summary>
        <returns>An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse. La recherche inclut des méthodes d’instance publique de static et public.  
  
 Si une méthode est surchargée et a plus d’une méthode publique, la <xref:System.Type.GetMethod%28System.String%29> méthode lève une exception une <xref:System.Reflection.AmbiguousMatchException> exception. Dans l’exemple suivant, une exception est levée, car il existe plusieurs surcharges publique de la <xref:System.Int32.ToString%2A?displayProperty=nameWithType> (méthode).  Quant à eux, car le `Person.ToString` substitutions de méthode <xref:System.Object.ToString%2A?displayProperty=nameWithType> et par conséquent n’est pas surchargé, la <xref:System.Type.GetMethod%28System.String%29> (méthode) est en mesure de récupérer le <xref:System.Reflection.MethodInfo> objet.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Vous pouvez effectuer l’une des opérations suivantes pour récupérer une méthode spécifique :  
  
-   Appelez le <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> (méthode) et spécifiez un `bindingAttr` argument qui identifie de façon unique la méthode. Par exemple, si l’exception est levée, car un type a un statique et une surcharge de l’instance, vous pouvez spécifier un `bindingAttr` argument de <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.  
  
-   Appelez une surcharge de la <xref:System.Type.GetMethod%2A> méthode inclut un `types` paramètre qui définit les types de paramètres de la méthode.  
  
-   Appelez le <xref:System.Type.GetMethods> méthode pour récupérer un tableau qui contient toutes les méthodes publiques qui appartiennent à un type. Vous pouvez ensuite itérer pour identifier les méthodes dupliquées nommés `name`.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant obtient une méthode nommée `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the method to get.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <summary>Searches for the specified method, using the specified binding constraints.</summary>
        <returns>An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :  
  
-   Vous devez spécifier soit <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> afin d’obtenir un retour.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> pour inclure les méthodes publiques dans la recherche.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> pour ignorer la casse de `name`.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si une méthode est surchargée et plusieurs surcharges aux contraintes spécifiées par le `bindingAttr` argument, la méthode lève un <xref:System.Reflection.AmbiguousMatchException> exception. Dans l’exemple suivant, une exception est levée, car :  
  
-   Le `TestClass` type possède deux surcharges d’instance publique de la `DisplayValue` (méthode), `DisplayValue(String)` et `DisplayValue(String, Object[])`.  
  
-   Le `TestClass` type possède deux surcharges d’instance publique de la `Equals` méthode, un d’eux est hérité de <xref:System.Object>: `Equals(TestClass)` et `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Vous pouvez effectuer l’une des opérations suivantes pour récupérer une méthode spécifique :  
  
-   Modifiez les contraintes de liaison. Dans l’exemple précédent, tente de récupérer une instance publique `Equals` récupère de la méthode qui est déclarée par le type et pas héritée correctement `Equals(TestClass)`.  
  
-   Appelez une surcharge de la <xref:System.Type.GetMethod%2A> méthode inclut un `types` paramètre qui définit les types de paramètres de la méthode.  
  
-   Appelez le <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> méthode pour récupérer un tableau qui contient toutes les méthodes appartenant à un type dont les attributs de liaison spécifiées. Vous pouvez ensuite itérer pour identifier les méthodes dupliquées nommés `name`. Cette approche est illustrée dans le Gestionnaire de l’exemple précédent pour le <xref:System.Reflection.AmbiguousMatchException> exception.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant obtient la méthode correspondant aux indicateurs de liaison spécifiés.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and matching the specified binding constraints.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the public method to get.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.  -or-  An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</param>
        <summary>Searches for the specified public method whose parameters match the specified argument types.</summary>
        <returns>An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse. La recherche inclut des méthodes d’instance publique de static et public.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes. Vous pouvez uniquement omettre les paramètres lors de l’appel.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Le `name` paramètre ne peut pas inclure des arguments de type. Par exemple, le code c# `GetMethod("MyGenericMethod<int>")` recherche une méthode avec le nom «`MyGenericMethod<int>`», plutôt que pour une méthode nommée `MyGenericMethod` qui possède un argument générique de type `int`. Au lieu de cela, utilisez `GetMethod("MyGenericMethod")` avec le paramètre approprié dans le `types` tableau.  
  
   
  
## Examples  
 L’exemple suivant recherche des surcharges spécifiques de `MethodA`, en spécifiant une variété de types d’arguments.  
  
> [!NOTE]
>  Le [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemple nécessite la `/unsafe` option du compilateur.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 L’exemple suivant récupère <xref:System.Reflection.MethodInfo> des objets qui représentent les `Add` méthodes d’un type non générique (le <xref:System.Collections.ArrayList> classe), un type générique ouvert (le <xref:System.Collections.Generic.List%601> classe) et un type générique fermé (la `List(Of String)` type.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 L’exemple définit un `GetAddMethod` méthode qui Récupère les <xref:System.Reflection.MethodInfo> objet. Pour fournir la `types` argument pour un type générique ouvert, il appelle le <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode). Pour fournir la `types` argument pour un type générique fermé, il récupère la valeur de la <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and specified parameters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.  -or-  <paramref name="types" /> is <see langword="null" />.  -or-  One of the elements in <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the public method to get.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.  -or-  An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</param>
        <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.</param>
        <summary>Searches for the specified public method whose parameters match the specified argument types and modifiers.</summary>
        <returns>An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 La recherche de `name` respecte la casse. La recherche inclut des méthodes d’instance publique de static et public.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes. Vous pouvez uniquement omettre les paramètres lors de l’appel.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMethod("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`. Au lieu de cela, utilisez `GetMethod("MyMethod")` avec le paramètre approprié dans le `types` tableau.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and specified parameters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.  -or-  <paramref name="types" /> is <see langword="null" />.  -or-  One of the elements in <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.  -or-  <paramref name="modifiers" /> is multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the method to get.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.  -or-  An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</param>
        <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.</param>
        <summary>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</summary>
        <returns>An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les méthodes publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes. Vous pouvez uniquement omettre les paramètres lors de l’appel.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant recherche des surcharges spécifiques de `MethodA`, en spécifiant les contraintes de liaison et une variété de types d’arguments.  
  
> [!NOTE]
>  Le [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemple nécessite la `/unsafe` option du compilateur.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and matching the specified binding constraints.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.  -or-  <paramref name="types" /> is <see langword="null" />.  -or-  One of the elements in <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.  -or-  <paramref name="modifiers" /> is multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the method to get.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.  -or-  An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</param>
        <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.</param>
        <summary>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</summary>
        <returns>An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `GetXXX` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les méthodes publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes. Vous pouvez uniquement omettre les paramètres lors de l’appel.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant recherche des surcharges spécifiques de `MethodA`, en spécifiant les contraintes de liaison, les conventions d’appel et divers types d’arguments.  
  
> [!NOTE]
>  Le [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemple nécessite la `/unsafe` option du compilateur.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and matching the specified binding constraints.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.  -or-  <paramref name="types" /> is <see langword="null" />.  -or-  One of the elements in <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.  -or-  <paramref name="modifiers" /> is multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the method to get.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.  -or-  An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.  -or-  <see langword="null" />. If <c>types</c> is <see langword="null" />, arguments are not matched.</param>
        <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array. The default binder does not process this parameter.</param>
        <summary>When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</summary>
        <returns>An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Si `types` est `null`, les arguments ne correspondent pas.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les méthodes publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and matching the specified binding constraints.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.  -or-  <paramref name="modifiers" /> is multidimensional.  -or-  <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</exception>
        <exception cref="T:System.NotSupportedException">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the methods of the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns all the public methods of the current <see cref="T:System.Type" />.</summary>
        <returns>An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.  -or-  An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetMethods%2A> méthode ne retourne pas les méthodes dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les méthodes sont retournées, car cet ordre varie.  
  
 Constructeurs ne sont pas inclus dans le tableau de méthodes retourné par cet appel. Effectuer un appel séparé à `GetConstructors()` pour obtenir les méthodes de constructeur.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes. Vous pouvez uniquement omettre les paramètres lors de l’appel.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MethodInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <summary>When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
        <returns>An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.  -or-  An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetMethods%2A> méthode ne retourne pas les méthodes dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les méthodes sont retournées, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les méthodes publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche. Seuls protégés et des méthodes internes sur les classes de base sont retournés ; méthodes privées sur les classes de base ne sont pas retournés.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche des constructeurs et méthodes. Vous pouvez uniquement omettre les paramètres lors de l’appel.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MethodInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant crée une classe avec deux méthodes publiques et une méthode protégée, crée un `Type` objet correspondant à `MyTypeClass`Obtient toutes les méthodes publiques et non publiques et affiche leurs noms.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a specific type nested within the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the nested type to get.</param>
        <summary>Searches for the public nested type with the specified name.</summary>
        <returns>An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse.  
  
 Utilisez le nom simple de la classe imbriquée pour `name`. Ne la qualifiez pas avec le nom de la classe externe. Pour une classe imbriquée générique, utilisez le nom tronqué — c'est-à-dire, ajoutez un accent grave et le nombre d’arguments génériques. Par exemple, utilisez la chaîne « interne\`1 » pour obtenir le type générique de classe imbriquée `Inner<T>` (`Inner(Of T)` en Visual Basic). N’incluez pas de syntaxe spécifique au langage pour les paramètres de type.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.  
  
 Si un type imbriqué est générique, cette méthode retourne sa définition de type générique. Cela est vrai même si le type générique englobant est un type construit fermé.  
  
> [!NOTE]
>  Si le courant <xref:System.Type> représente un type générique défini en c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques. Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the nested type to get.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <summary>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</summary>
        <returns>An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le nom simple de la classe imbriquée pour `name`. Ne la qualifiez pas avec le nom de la classe externe. Pour une classe imbriquée générique, utilisez le nom tronqué — c'est-à-dire, ajoutez un accent grave et le nombre de paramètres génériques. Par exemple, utilisez la chaîne « interne\`1 » pour obtenir le type générique de classe imbriquée `Inner<T>` (`Inner(Of T)` en Visual Basic). N’incluez pas de syntaxe spécifique au langage pour les paramètres de type.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> filtre indicateurs peuvent être utilisés pour définir ce qui est imbriqué types à inclure dans la recherche :  
  
-   Vous devez spécifier soit <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour obtenir un retour.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> pour inclure les types imbriqués publics dans la recherche.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour inclure les types imbriqués non publics (autrement dit, privés, internes et protégés types imbriqués) dans la recherche.  
  
 Cette méthode retourne uniquement les types imbriqués du type actuel. Il ne recherche pas les classes de base du type actuel. Pour rechercher des types qui sont imbriqués dans les classes de base, vous devez parcourir la hiérarchie d’héritage, en appelant <xref:System.Type.GetNestedType%2A> à chaque niveau.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> sont ignorés.  
  
 Appel de cette méthode avec uniquement le <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> indicateur ou uniquement les <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> retournera types l’imbriqués spécifiés et ne nécessitent pas de tous les autres indicateurs.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.  
  
 Si un type imbriqué est générique, cette méthode retourne sa définition de type générique. Cela est vrai même si le type générique englobant est un type construit fermé.  
  
> [!NOTE]
>  Si le courant <xref:System.Type> représente un type générique défini en c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques. Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the types nested within the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the public types nested in the current <see cref="T:System.Type" />.</summary>
        <returns>An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetNestedTypes%2A> méthode ne retourne pas les types dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les types sont retournés, car cet ordre varie.  
  
 Seuls les types publics immédiatement imbriqués dans le type actuel sont retournés ; la recherche n’est pas récursive.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.  
  
 Si un type imbriqué est générique, cette méthode retourne sa définition de type générique. Cela est vrai même si le type générique englobant est un type construit fermé.  
  
> [!NOTE]
>  Si le courant <xref:System.Type> représente un type générique défini en c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques. Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 L’exemple suivant définit une classe imbriquée et un `struct` dans `MyClass`, puis il obtient les objets des types imbriqués à l’aide du type de `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <summary>When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
        <returns>An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche pour les types imbriqués n’est pas récursive.  
  
 Le <xref:System.Type.GetNestedTypes%2A> méthode ne retourne pas les types dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les types sont retournés, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> filtre indicateurs peuvent être utilisés pour définir ce qui est imbriqué types à inclure dans la recherche :  
  
-   Vous devez spécifier soit <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour obtenir un retour.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> pour inclure les types imbriqués publics dans la recherche.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour inclure les types imbriqués non publics (autrement dit, privés, internes et protégés types imbriqués) dans la recherche.  
  
 Cette méthode retourne uniquement les types imbriqués du type actuel. Il ne recherche pas les classes de base du type actuel. Pour rechercher des types qui sont imbriqués dans les classes de base, vous devez parcourir la hiérarchie d’héritage, en appelant <xref:System.Type.GetNestedTypes%2A> à chaque niveau.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> sont ignorés.  
  
 Appel de cette méthode avec uniquement le <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> indicateur ou uniquement les <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> retournera types l’imbriqués spécifiés et ne nécessitent pas de tous les autres indicateurs.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.  
  
 Si un type imbriqué est générique, cette méthode retourne sa définition de type générique. Cela est vrai même si le type générique englobant est un type construit fermé.  
  
> [!NOTE]
>  Si le courant <xref:System.Type> représente un type générique défini en c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques. Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 L’exemple suivant crée deux classes publiques imbriquées et deux classes protégées imbriquées et affiche des informations pour les classes qui correspondent aux contraintes de liaison spécifiées.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the properties of the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns all the public properties of the current <see cref="T:System.Type" />.</summary>
        <returns>An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.  -or-  An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette surcharge revient à appeler la <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> surcharge avec un `bindingAttr` argument égal à `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` en c# et `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` en Visual Basic. Il retourne tous les public propriétés d’instance et statiques, à la fois ceux définis par le type représenté par les <xref:System.Type> objet, ainsi que celles héritent à partir de ses types de base.  
  
 Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Le <xref:System.Type.GetProperties%2A> méthode ne retourne pas les propriétés dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les propriétés sont retournées, car cet ordre varie.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.PropertyInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `GetProperties`.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <summary>When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
        <returns>An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.  -or-  An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Le <xref:System.Type.GetProperties%2A> méthode ne retourne pas les propriétés dans un ordre particulier, tel qu’alphabétique ou l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les propriétés sont retournées, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> filtre indicateurs peuvent être utilisés pour définir ce qui est imbriqué types à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche. Seuls protégés et des propriétés internes sur les classes de base sont retournées ; les propriétés privées sur les classes de base ne sont pas retournées.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.PropertyInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant définit une classe nommée `PropertyClass` qui inclut six propriétés : deux sont publics, une est privée, un est protégé, l’autre est interne (`Friend` en Visual Basic), et une est protected internal (`Protected Friend` en Visual Basic). Il affiche ensuite des informations sur les propriétés de base (le nom de la propriété et le type, s’il est en lecture/écriture et la visibilité de son `get` et `set` accesseurs) pour les propriétés qui correspondent aux contraintes de liaison spécifiées.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a specific property of the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the public property to get.</param>
        <summary>Searches for the public property with the specified name.</summary>
        <returns>An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse. La recherche inclut les propriétés d’instance public de static et public.  
  
 Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
 Situations dans lesquelles <xref:System.Reflection.AmbiguousMatchException> se produit incluent les éléments suivants :  
  
-   Un type contient deux propriétés indexées qui ont le même nom mais des nombres de paramètres. Pour résoudre l’ambiguïté, utilisez une surcharge de la <xref:System.Type.GetProperty%2A> méthode qui spécifie les types de paramètres.  
  
-   Un type dérivé déclare une propriété qui masque une propriété héritée avec le même nom, à l’aide de la `new` modificateur (`Shadows` en Visual Basic). Pour résoudre l’ambiguïté, utilisez la <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> surcharge de méthode et ajoutez le <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> indicateur pour limiter la recherche aux membres qui ne sont pas hérités.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>. Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
   
  
## Examples  
 L’exemple suivant récupère la `Type` objet d’une classe définie par l’utilisateur, récupère une propriété de cette classe et affiche le nom de propriété.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 En interne, cette propriété est référencée dans les métadonnées par le nom « Item ». Toute tentative d’obtenir `PropertyInfo` à l’aide de la réflexion doit spécifier ce nom interne afin de retourner correctement le `PropertyInfo` propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the property to get.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <summary>Searches for the specified property, using the specified binding constraints.</summary>
        <returns>An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les propriétés à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
 Situations dans lesquelles <xref:System.Reflection.AmbiguousMatchException> se produit incluent les éléments suivants :  
  
-   Un type contient deux propriétés indexées qui ont le même nom mais des nombres de paramètres. Pour résoudre l’ambiguïté, utilisez une surcharge de la <xref:System.Type.GetProperty%2A> méthode qui spécifie les types de paramètres.  
  
-   Un type dérivé déclare une propriété qui masque une propriété héritée avec le même nom, à l’aide de la `new` modificateur (`Shadows` en Visual Basic). Pour résoudre l’ambiguïté, incluez <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> pour limiter la recherche aux membres qui ne sont pas hérités.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>. Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
   
  
## Examples  
 L’exemple suivant récupère le type d’une classe définie par l’utilisateur, récupère une propriété de cette classe et affiche le nom de propriété conformément aux contraintes de liaison spécifiées.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified binding constraints.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the public property to get.</param>
        <param name="returnType">The return type of the property.</param>
        <summary>Searches for the public property with the specified name and return type.</summary>
        <returns>An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 La recherche de `name` respecte la casse. La recherche inclut les propriétés d’instance public de static et public.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>. Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
   
  
## Examples  
 L’exemple suivant définit une classe avec une propriété et récupère le nom et le type de la propriété.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the public property to get.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.  -or-  An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</param>
        <summary>Searches for the specified public property whose parameters match the specified argument types.</summary>
        <returns>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 La recherche de `name` respecte la casse. La recherche inclut les propriétés d’instance public de static et public.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>. Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
   
  
## Examples  
 L’exemple suivant récupère la `Type` objet d’une classe définie par l’utilisateur, récupère la propriété de cette classe et affiche le nom de la propriété et le type de la propriété comme spécifié par les arguments passés à `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified argument types.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.  -or-  <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.</exception>
        <exception cref="T:System.NullReferenceException">An element of <paramref name="types" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the public property to get.</param>
        <param name="returnType">The return type of the property.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.  -or-  An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</param>
        <summary>Searches for the specified public property whose parameters match the specified argument types.</summary>
        <returns>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 La recherche de `name` respecte la casse. La recherche inclut les propriétés d’instance public de static et public.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>. Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified argument types.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.  -or-  <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.</exception>
        <exception cref="T:System.NullReferenceException">An element of <paramref name="types" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the public property to get.</param>
        <param name="returnType">The return type of the property.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.  -or-  An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</param>
        <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array. The default binder does not process this parameter.</param>
        <summary>Searches for the specified public property whose parameters match the specified argument types and modifiers.</summary>
        <returns>An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 La recherche de `name` respecte la casse. La recherche inclut les propriétés d’instance public de static et public.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>. Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
   
  
## Examples  
 L’exemple suivant obtient un `Type` objet correspondant à `MyPropertyClass`, et la propriété indexée de cette classe est récupérée à l’aide des arguments passés à la `GetProperty` (méthode).  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified argument types and modifiers.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.  -or-  <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.  -or-  <paramref name="modifiers" /> is multidimensional.  -or-  <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</exception>
        <exception cref="T:System.NullReferenceException">An element of <paramref name="types" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the property to get.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">The return type of the property.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.  -or-  An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</param>
        <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array. The default binder does not process this parameter.</param>
        <summary>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</summary>
        <returns>An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique de la réflexion s’il a au moins un accesseur est public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les propriétés à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classes peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe a un indexeur nommé <xref:System.String.Chars%2A>. Les propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms autres que de l’élément, également.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified binding constraints.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.  -or-  <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.  -or-  <paramref name="modifiers" /> is multidimensional.  -or-  <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</exception>
        <exception cref="T:System.NullReferenceException">An element of <paramref name="types" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the property to get.</param>
        <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.  -or-  Zero, to return <see langword="null" />.</param>
        <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">The return type of the property.</param>
        <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.  -or-  An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</param>
        <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array. The default binder does not process this parameter.</param>
        <summary>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</summary>
        <returns>An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les propriétés à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` des membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified binding constraints.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.  -or-  <paramref name="types" /> is <see langword="null" />.  -or-  One of the elements in <paramref name="types" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> is multidimensional.  -or-  <paramref name="modifiers" /> is multidimensional.  -or-  <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</exception>
        <exception cref="T:System.NotSupportedException">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a <see cref="T:System.Type" /> object that represents the specified type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the current <see cref="T:System.Type" />.</summary>
        <returns>The current <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">The assembly-qualified name of the type to get. See <see cref="P:System.Type.AssemblyQualifiedName" />. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</param>
        <summary>Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</summary>
        <returns>The type with the specified name, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Type.GetType%2A> méthode pour obtenir un <xref:System.Type> de l’objet d’un type dans un autre assembly, si vous connaissez son nom qualifié d’espace de noms. <xref:System.Type.GetType%2A> provoque le chargement de l’assembly spécifié dans `typeName`. Vous pouvez également charger un assembly à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode), puis utiliser le <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> méthodes de la <xref:System.Reflection.Assembly> classe pour laquelle obtenir <xref:System.Type> objets. Si un type est dans un assembly connu de votre programme au moment de la compilation, il est plus efficace d’utiliser en c#, <xref:System.Type.GetType%2A> en Visual Basic, ou en C++.  
  
> [!NOTE]
>  Si `typeName` ne peut pas être trouvée, l’appel à la <xref:System.Type.GetType%28System.String%29> méthode renvoie `null`. Il ne lève pas d’exception. Pour contrôler si une exception est levée, appelez une surcharge de la <xref:System.Type.GetType%2A> méthode qui a un `throwOnError` paramètre.  
  
 <xref:System.Type.GetType%2A> fonctionne uniquement sur les assemblys chargés à partir du disque. Si vous appelez <xref:System.Type.GetType%2A> pour rechercher un type défini dans un assembly dynamique défini à l’aide de la <xref:System.Reflection.Emit> services, vous pouvez obtenir un comportement incohérent. Le comportement varie selon que l’assembly dynamique est persistant, autrement dit, créé à l’aide de la `RunAndSave` ou `Save` accéder aux modes de le <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> énumération. Si l’assembly dynamique est persistant et qu’il a été écrit sur le disque avant `GetType` est appelé, le chargeur recherche l’assembly enregistré sur le disque, charge l’assembly et récupère le type de cet assembly. Si l’assembly n’a pas été enregistré sur le disque lorsque `GetType` est appelée, la méthode retourne `null`. `GetType` ne comprend pas les assemblys dynamiques transitoires ; Par conséquent, l’appel `GetType` pour récupérer un type dans un temporaire assembly dynamique retourne `null`.  
  
 Pour utiliser `GetType` sur un module dynamique, vous abonner à la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> événements et les appels `GetType` avant l’enregistrement. Sinon, vous obtiendrez deux copies de l’assembly dans la mémoire.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Les tableaux ou types COM ne sont pas recherchés, sauf si elles ont déjà été chargés dans la table des classes disponibles.  
  
 `typeName` le nom de type qualifié par son espace de noms ou un nom qualifié d’assembly qui inclut une spécification de nom d’assembly. Consultez <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Si `typeName` inclut l’espace de noms mais pas le nom de l’assembly, cette méthode recherche uniquement les assembly de l’objet appelant et dans Mscorlib.dll, dans cet ordre. Si typeName est qualifié avec le nom d’assembly partiel ou complet, cette méthode recherche dans l’assembly spécifié. Si l’assembly a un nom fort, un nom d’assembly complet est requis.  
  
 Le <xref:System.Type.AssemblyQualifiedName%2A> propriété retourne un nom de type qualifié complet, y compris les types imbriqués, le nom de l’assembly et les arguments de type générique. Tous les compilateurs qui prennent en charge le common language runtime émettront le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogé, conformément aux conventions suivantes.  
  
> [!NOTE]
>  Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly. Par exemple, « ProcessorArchitecture = msil ». Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité. Vous pouvez également charger des types en créant un <xref:System.Reflection.AssemblyName> objet et en le passant à la surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode). Vous pouvez ensuite utiliser le <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> méthode pour charger les types à partir de l’assembly. Voir aussi <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|délimiteur|Signification|  
|---------------|-------------|  
|Barre oblique inverse (\\)|Caractère d’échappement.|  
|Accent grave (')|Précède un ou plusieurs chiffres représentant le nombre de paramètres de type, à la fin du nom d’un type générique.|  
|Crochets ([])|Placez une liste d’arguments de type générique, pour un type générique construit ; dans une liste d’arguments de type, placez un type qualifié d’assembly.|  
|Virgule ()|Précède le nom de l’Assembly.|  
|Point (.)|Indique les identificateurs d’espace de noms.|  
|Signe plus (+)|Précède une classe imbriquée.|  
  
 Par exemple, le nom qualifié complet d’une classe peut ressembler à ceci :  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Si l’espace de noms ont été TopNamespace, alors que la chaîne devrait faire précéder le signe plus (+) avec un caractère d’échappement (\\) pour l’empêcher d’être interprété comme un séparateur d’imbrication. La réflexion génère cette chaîne comme suit :  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».  
  
 Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>. Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly. <xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système. <xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.  
  
 Noms de types peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau. Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.  
  
 Les espaces ne sont pertinentes dans tous les composants de nom de type, à l’exception du nom de l’assembly. Nom de l’assembly, les espaces avant le séparateur ',', mais des espaces après le séparateur ',' sont ignorées.  
  
 Le nom d’un type générique se termine par un accent grave (\`) suivi de chiffres représentant le nombre d’arguments de type générique. L’objectif de cette altération des noms est de permettre aux compilateurs prendre en charge des types génériques portant le même nom mais avec différents nombres de paramètres de type, qui se produisent dans la même portée. Par exemple, la réflexion retourne les noms tronqués `Tuple`1` and `Tuple`2` à partir des méthodes génériques `Tuple(Of T)` et `Tuple(Of T0, T1)` en Visual Basic, ou `Tuple<T>` et Tuple`\<T0, T1>` en Visual c#.  
  
 Pour les types génériques, la liste d’arguments de type est placé entre crochets et les arguments de type sont séparés par des virgules. Par exemple, un type générique <xref:System.Collections.Generic.Dictionary%602> possède deux paramètres de type. A <xref:System.Collections.Generic.Dictionary%602> de `MyType` avec des clés de type <xref:System.String> peut être représenté comme suit :  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Pour spécifier un type qualifié d’assembly dans une liste d’arguments de type, mettez le type qualifié d’assembly entre crochets. Sinon, les virgules qui séparent les parties du nom qualifié d’assembly sont interprétées comme délimitant les arguments de type supplémentaires. Par exemple, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` fromMyAssembly.dll, avec des clés de type <xref:System.String>, peut être spécifiée comme suit :  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un type qualifié d’assembly peut être placé entre crochets uniquement lorsqu’il apparaît dans une liste de paramètres de type. Les règles pour la recherche d’assemblys de types qualifiés et non qualifiés dans les listes de paramètres de type sont le même que les règles pour les types non génériques qualifiés et non qualifiés.  
  
 Les types Nullable sont un cas spécial de types génériques. Par exemple, autorisant des valeurs null <xref:System.Int32> est représenté par la chaîne « System.Nullable'1[System.Int32] ».  
  
> [!NOTE]
>  En c#, C++ et Visual Basic, vous pouvez également obtenir des types nullables à l’aide d’opérateurs de type. Par exemple, le nullable <xref:System.Boolean> type renvoyé par `typeof(Nullable<bool>)` en c#, par `Nullable<Boolean>::typeid` en C++ et par `GetType(Nullable(Of Boolean))` en Visual Basic.  
  
 Le tableau suivant montre la syntaxe à utiliser avec `GetType` pour différents types.  
  
|Pour obtenir|Utilisez|  
|------------|---------|  
|Un nullable <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Un pointeur non managé vers `MyType`|`Type.GetType("MyType*")`|  
|Un pointeur non managé vers un pointeur vers `MyType`|`Type.GetType("MyType**")`|  
|Un pointeur managé ou la référence à `MyType`|`Type.GetType("MyType&")`. Notez que contrairement aux pointeurs, les références sont limitées à un niveau.|  
|Une classe parente et une classe imbriquée|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Un tableau unidimensionnel avec une limite inférieure de 0|`Type.GetType("MyType[]")`|  
|Un tableau unidimensionnel avec une limite inférieure est inconnue|`Type.GetType("MyType[*]")`|  
|Un tableau à n dimensions|Une virgule (,) entre les crochets total de n-1 fois. Par exemple, `System.Object[,,]` représente un graphique en trois dimensions `Object` tableau.|  
|Un tableau de tableaux unidimensionnels|`Type.GetType("MyType[][]")`|  
|Un tableau rectangulaire à deux dimensions avec des limites inférieures inconnus|`Type.GetType("MyType[,]")`|  
|Un type générique avec un argument de type|`Type.GetType("MyGenericType`1[MyType]")`|  
|Un type générique avec deux arguments de type|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|Un type générique avec deux arguments de type qualifié d’assembly|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|Un type générique qualifié d’assembly avec un argument de type qualifié d’assembly|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|Un type générique dont l’argument de type est un type générique avec deux arguments de type|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 L’exemple suivant récupère le type de `System.Int32` et utilise cet objet de type pour afficher le <xref:System.Type.FullName%2A> propriété du `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.  -or-  <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.  -or-  <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.  </para>
          </block>  The assembly or one of its dependencies was found, but could not be loaded.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly or one of its dependencies is not valid.  -or-  Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">The assembly-qualified name of the type to get. See <see cref="P:System.Type.AssemblyQualifiedName" />. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</param>
        <param name="throwOnError">
          <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />. Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them. See the Exceptions section.</param>
        <summary>Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</summary>
        <returns>The type with the specified name. If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />. See the Exceptions section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Type.GetType%2A> méthode pour obtenir un <xref:System.Type> de l’objet d’un type dans un autre assembly, si vous connaissez son nom qualifié d’espace de noms. <xref:System.Type.GetType%2A> provoque le chargement de l’assembly spécifié dans `typeName`. Vous pouvez également charger un assembly à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode), puis utiliser le <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> méthodes de la <xref:System.Reflection.Assembly> classe pour laquelle obtenir <xref:System.Type> objets. Si un type est dans un assembly connu de votre programme au moment de la compilation, il est plus efficace d’utiliser `typeof` en c#, <xref:System.Type.GetType%2A> en Visual Basic, ou `typeid` en C++.  
  
 `GetType` fonctionne uniquement sur les assemblys chargés à partir du disque. Si vous appelez `GetType` pour rechercher un type défini dans un assembly dynamique défini à l’aide de la <xref:System.Reflection.Emit> services, vous pouvez obtenir un comportement incohérent. Le comportement varie selon que l’assembly dynamique est persistant, autrement dit, créé à l’aide de la `RunAndSave` ou `Save` accéder aux modes de le <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> énumération. Si l’assembly dynamique est persistant et qu’il a été écrit sur le disque avant `GetType` est appelé, le chargeur recherche l’assembly enregistré sur le disque, charge l’assembly et récupère le type de cet assembly. Si l’assembly n’a pas été enregistré sur le disque lorsque `GetType` est appelée, la méthode retourne `null`. `GetType` ne comprend pas les assemblys dynamiques transitoires ; Par conséquent, l’appel `GetType` pour récupérer un type dans un temporaire assembly dynamique retourne `null`.  
  
 Pour utiliser `GetType` sur un module dynamique, vous abonner à la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> événements et les appels `GetType` avant l’enregistrement. Sinon, vous obtiendrez deux copies de l’assembly dans la mémoire.  
  
 Le `throwOnError` paramètre spécifie que se passe-t-il lorsque le type est introuvable et supprime également certaines autres conditions d’exception, comme décrit dans la section Exceptions. Certaines exceptions sont levées, quelle que soit la valeur de `throwOnError`. Par exemple, si le type est trouvé mais ne peut pas être chargé, un <xref:System.TypeLoadException> est levée même si `throwOnError` est `false`.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Les tableaux ou types COM ne sont pas recherchés, sauf si elles ont déjà été chargés dans la table des classes disponibles.  
  
 `typeName` le nom de type qualifié par son espace de noms ou un nom qualifié d’assembly qui inclut une spécification de nom d’assembly. Consultez <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Si `typeName` inclut l’espace de noms mais pas le nom de l’assembly, cette méthode recherche uniquement les assembly de l’objet appelant et dans Mscorlib.dll, dans cet ordre. Si typeName est qualifié avec le nom d’assembly partiel ou complet, cette méthode recherche dans l’assembly spécifié. Si l’assembly a un nom fort, un nom d’assembly complet est requis.  
  
 Le <xref:System.Type.AssemblyQualifiedName%2A> propriété retourne un nom de type qualifié complet, y compris les types imbriqués, le nom de l’assembly et les arguments génériques. Tous les compilateurs qui prennent en charge le common language runtime émettront le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogé, conformément aux conventions suivantes.  
  
> [!NOTE]
>  Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly. Par exemple, « ProcessorArchitecture = msil ». Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité. Vous pouvez également charger des types en créant un <xref:System.Reflection.AssemblyName> objet et en le passant à la surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode). Vous pouvez ensuite utiliser le <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> méthode pour charger les types à partir de l’assembly. Voir aussi <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|délimiteur|Signification|  
|---------------|-------------|  
|Barre oblique inverse (\\)|Caractère d’échappement.|  
|Accent grave (')|Précède un ou plusieurs chiffres représentant le nombre de paramètres de type, à la fin du nom d’un type générique.|  
|Crochets ([])|Placez une liste d’arguments de type générique, pour un type générique construit ; dans une liste d’arguments de type, placez un type qualifié d’assembly.|  
|Virgule ()|Précède le nom de l’Assembly.|  
|Point (.)|Indique les identificateurs d’espace de noms.|  
|Signe plus (+)|Précède une classe imbriquée.|  
  
 Par exemple, le nom qualifié complet d’une classe peut ressembler à ceci :  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Si l’espace de noms ont été TopNamespace, alors que la chaîne devrait faire précéder le signe plus (+) avec un caractère d’échappement (\\) pour l’empêcher d’être interprété comme un séparateur d’imbrication. La réflexion génère cette chaîne comme suit :  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».  
  
 Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>. Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly. <xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système. <xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.  
  
 Noms de types peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau. Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.  
  
 Les espaces ne sont pertinentes dans tous les composants de nom de type, à l’exception du nom de l’assembly. Nom de l’assembly, les espaces avant le séparateur ',', mais des espaces après le séparateur ',' sont ignorées.  
  
 Le nom d’un type générique se termine par un accent grave (\`) suivi de chiffres représentant le nombre d’arguments de type générique. L’objectif de cette altération des noms est de permettre aux compilateurs prendre en charge des types génériques portant le même nom mais avec différents nombres de paramètres de type, qui se produisent dans la même portée. Par exemple, la réflexion retourne les noms tronqués `Tuple`1` and `Tuple`2` à partir des méthodes génériques `Tuple(Of T)` et `Tuple(Of T0, T1)` en Visual Basic, ou `Tuple<T>` et Tuple`\<T0, T1>` en Visual c#.  
  
 Pour les types génériques, la liste d’arguments de type est placé entre crochets et les arguments de type sont séparés par des virgules. Par exemple, un type générique <xref:System.Collections.Generic.Dictionary%602> possède deux paramètres de type. A <xref:System.Collections.Generic.Dictionary%602> de `MyType` avec des clés de type <xref:System.String> peut être représenté comme suit :  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Pour spécifier un type qualifié d’assembly dans une liste d’arguments de type, mettez le type qualifié d’assembly entre crochets. Sinon, les virgules qui séparent les parties du nom qualifié d’assembly sont interprétées comme délimitant les arguments de type supplémentaires. Par exemple, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` issu de MyAssembly.dll, avec des clés de type <xref:System.String>, peut être spécifiée comme suit :  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un type qualifié d’assembly peut être placé entre crochets uniquement lorsqu’il apparaît dans une liste de paramètres de type. Les règles pour la recherche d’assemblys de types qualifiés et non qualifiés dans les listes de paramètres de type sont le même que les règles pour les types non génériques qualifiés et non qualifiés.  
  
 Les types Nullable sont un cas spécial de types génériques. Par exemple, autorisant des valeurs null <xref:System.Int32> est représenté par la chaîne « System.Nullable'1[System.Int32] ».  
  
> [!NOTE]
>  En c#, C++ et Visual Basic, vous pouvez également obtenir des types nullables à l’aide d’opérateurs de type. Par exemple, le nullable <xref:System.Boolean> type renvoyé par `typeof(Nullable<bool>)` en c#, par `Nullable<Boolean>::typeid` en C++ et par `GetType(Nullable(Of Boolean))` en Visual Basic.  
  
 Le tableau suivant montre la syntaxe à utiliser avec `GetType` pour différents types.  
  
|Pour obtenir|Utilisez|  
|------------|---------|  
|Un nullable <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Un pointeur non managé vers `MyType`|`Type.GetType("MyType*")`|  
|Un pointeur non managé vers un pointeur vers `MyType`|`Type.GetType("MyType**")`|  
|Un pointeur managé ou la référence à `MyType`|`Type.GetType("MyType&")`. Notez que contrairement aux pointeurs, les références sont limitées à un niveau.|  
|Une classe parente et une classe imbriquée|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Un tableau unidimensionnel avec une limite inférieure de 0|`Type.GetType("MyArray[]")`|  
|Un tableau unidimensionnel avec une limite inférieure est inconnue|`Type.GetType("MyArray[*]")`|  
|Un tableau à n dimensions|Une virgule (,) entre les crochets total de n-1 fois. Par exemple, `System.Object[,,]` représente un graphique en trois dimensions `Object` tableau.|  
|Tableau d’un tableau à deux dimensions|`Type.GetType("MyArray[][]")`|  
|Un tableau rectangulaire à deux dimensions avec des limites inférieures inconnus|`Type.GetType("MyArray[,]")`|  
|Un type générique avec un argument de type|`Type.GetType("MyGenericType`1[MyType]")`|  
|Un type générique avec deux arguments de type|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|Un type générique avec deux arguments de type qualifié d’assembly|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|Un type générique qualifié d’assembly avec un argument de type qualifié d’assembly|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|Un type générique dont l’argument de type est un type générique avec deux arguments de type|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 L’exemple suivant récupère le type de `System.Int32` et utilise cet objet de type pour afficher le <xref:System.Type.FullName%2A> propriété du `System.Int32`. Si un objet de type fait référence à un assembly qui n’existe pas, cet exemple lève une exception.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.  -or-  <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax. For example, "MyType[,*,]".  -or-  <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.  -or-  <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.  -or-  <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.  </para>
          </block>  The assembly or one of its dependencies was found, but could not be loaded.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly or one of its dependencies is not valid.  -or-  Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">The assembly-qualified name of the type to get. See <see cref="P:System.Type.AssemblyQualifiedName" />. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</param>
        <param name="throwOnError">
          <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them. See the Exceptions section.</param>
        <param name="ignoreCase">
          <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</param>
        <summary>Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</summary>
        <returns>The type with the specified name. If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />. See the Exceptions section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Type.GetType%2A> méthode pour obtenir un <xref:System.Type> de l’objet d’un type dans un autre assembly, si vous connaissez son nom qualifié d’espace de noms. <xref:System.Type.GetType%2A> provoque le chargement de l’assembly spécifié dans `typeName`. Vous pouvez également charger un assembly à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode), puis utiliser le <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> méthodes de la <xref:System.Reflection.Assembly> classe pour laquelle obtenir <xref:System.Type> objets. Si un type est dans un assembly connu de votre programme au moment de la compilation, il est plus efficace d’utiliser `typeof` en c#, <xref:System.Type.GetType%2A> en Visual Basic, ou `typeid` en C++.  
  
 `GetType` fonctionne uniquement sur les assemblys chargés à partir du disque. Si vous appelez `GetType` pour rechercher un type défini dans un assembly dynamique défini à l’aide de la <xref:System.Reflection.Emit> services, vous pouvez obtenir un comportement incohérent. Le comportement varie selon que l’assembly dynamique est persistant, autrement dit, créé à l’aide de la `RunAndSave` ou `Save` accéder aux modes de le <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> énumération. Si l’assembly dynamique est persistant et qu’il a été écrit sur le disque avant `GetType` est appelé, le chargeur recherche l’assembly enregistré sur le disque, charge l’assembly et récupère le type de cet assembly. Si l’assembly n’a pas été enregistré sur le disque lorsque `GetType` est appelée, la méthode retourne `null`. `GetType` ne comprend pas les assemblys dynamiques transitoires ; Par conséquent, l’appel `GetType` pour récupérer un type dans un temporaire assembly dynamique retourne `null`.  
  
 Pour utiliser `GetType` sur un module dynamique, vous abonner à la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> événements et les appels `GetType` avant l’enregistrement. Sinon, vous obtiendrez deux copies de l’assembly dans la mémoire.  
  
 Le `throwOnError` paramètre spécifie que se passe-t-il lorsque le type est introuvable et supprime également certaines autres conditions d’exception, comme décrit dans la section Exceptions. Certaines exceptions sont levées, quelle que soit la valeur de `throwOnError`. Par exemple, si le type est trouvé mais ne peut pas être chargé, un <xref:System.TypeLoadException> est levée même si `throwOnError` est `false`.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours masquer-par-nom-et-signature.|  
|Événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuelle) peut être masquer par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Propriété|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme masquer-par-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont masquer-par-nom-et-signature. Si vous avez une propriété avec une commande get et un accesseur set de la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne pourrez pas accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Les tableaux ou types COM ne sont pas recherchés, sauf si elles ont déjà été chargés dans la table des classes disponibles.  
  
 `typeName` le nom de type qualifié par son espace de noms ou un nom qualifié d’assembly qui inclut une spécification de nom d’assembly. Consultez <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Si `typeName` inclut l’espace de noms mais pas le nom de l’assembly, cette méthode recherche uniquement les assembly de l’objet appelant et dans Mscorlib.dll, dans cet ordre. Si typeName est qualifié avec le nom d’assembly partiel ou complet, cette méthode recherche dans l’assembly spécifié. Si l’assembly a un nom fort, un nom d’assembly complet est requis.  
  
 Le <xref:System.Type.AssemblyQualifiedName%2A> propriété retourne un nom de type qualifié complet, y compris les types imbriqués, le nom de l’assembly et les arguments de type. Tous les compilateurs qui prennent en charge le common language runtime émettront le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogé, conformément aux conventions suivantes.  
  
> [!NOTE]
>  Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly. Par exemple, « ProcessorArchitecture = msil ». Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité. Vous pouvez également charger des types en créant un <xref:System.Reflection.AssemblyName> objet et en le passant à la surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode). Vous pouvez ensuite utiliser le <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> méthode pour charger les types à partir de l’assembly. Voir aussi <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|délimiteur|Signification|  
|---------------|-------------|  
|Barre oblique inverse (\\)|Caractère d’échappement.|  
|Accent grave (')|Précède un ou plusieurs chiffres représentant le nombre de paramètres de type, à la fin du nom d’un type générique.|  
|Crochets ([])|Placez une liste d’arguments de type générique, pour un type générique construit ; dans une liste d’arguments de type, placez un type qualifié d’assembly.|  
|Virgule ()|Précède le nom de l’Assembly.|  
|Point (.)|Indique les identificateurs d’espace de noms.|  
|Signe plus (+)|Précède une classe imbriquée.|  
  
 Par exemple, le nom qualifié complet d’une classe peut ressembler à ceci :  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Si l’espace de noms ont été TopNamespace, alors que la chaîne devrait faire précéder le signe plus (+) avec un caractère d’échappement (\\) pour l’empêcher d’être interprété comme un séparateur d’imbrication. La réflexion génère cette chaîne comme suit :  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».  
  
 Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>. Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly. <xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système. <xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.  
  
 Noms de types peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau. Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.  
  
 Les espaces ne sont pertinentes dans tous les composants de nom de type, à l’exception du nom de l’assembly. Nom de l’assembly, les espaces avant le séparateur ',', mais des espaces après le séparateur ',' sont ignorées.  
  
 Le nom d’un type générique se termine par un accent grave (\`) suivi de chiffres représentant le nombre d’arguments de type générique. L’objectif de cette altération des noms est de permettre aux compilateurs prendre en charge des types génériques portant le même nom mais avec différents nombres de paramètres de type, qui se produisent dans la même portée. Par exemple, la réflexion retourne les noms tronqués `Tuple`1` and `Tuple`2` à partir des méthodes génériques `Tuple(Of T)` et `Tuple(Of T0, T1)` en Visual Basic, ou `Tuple<T>` et Tuple`\<T0, T1>` en Visual c#.  
  
 Pour les types génériques, la liste d’arguments de type est placé entre crochets et les arguments de type sont séparés par des virgules. Par exemple, un type générique <xref:System.Collections.Generic.Dictionary%602> possède deux paramètres de type. A <xref:System.Collections.Generic.Dictionary%602> de `MyType` avec des clés de type <xref:System.String> peut être représenté comme suit :  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Pour spécifier un type qualifié d’assembly dans une liste d’arguments de type, mettez le type qualifié d’assembly entre crochets. Sinon, les virgules qui séparent les parties du nom qualifié d’assembly sont interprétées comme délimitant les arguments de type supplémentaires. Par exemple, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` issu de MyAssembly.dll, avec des clés de type <xref:System.String>, peut être spécifiée comme suit :  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un type qualifié d’assembly peut être placé entre crochets uniquement lorsqu’il apparaît dans une liste de paramètres de type. Les règles pour la recherche d’assemblys de types qualifiés et non qualifiés dans les listes de paramètres de type sont le même que les règles pour les types non génériques qualifiés et non qualifiés.  
  
 Les types Nullable sont un cas spécial de types génériques. Par exemple, autorisant des valeurs null <xref:System.Int32> est représenté par la chaîne « System.Nullable'1[System.Int32] ».  
  
> [!NOTE]
>  En c#, C++ et Visual Basic, vous pouvez également obtenir des types nullables à l’aide d’opérateurs de type. Par exemple, le nullable <xref:System.Boolean> type renvoyé par `typeof(Nullable<bool>)` en c#, par `Nullable<Boolean>::typeid` en C++ et par `GetType(Nullable(Of Boolean))` en Visual Basic.  
  
 Le tableau suivant montre la syntaxe à utiliser avec `GetType` pour différents types.  
  
|Pour obtenir|Utilisez|  
|------------|---------|  
|Un nullable <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Un pointeur non managé vers `MyType`|`Type.GetType("MyType*")`|  
|Un pointeur non managé vers un pointeur vers `MyType`|`Type.GetType("MyType**")`|  
|Un pointeur managé ou la référence à `MyType`|`Type.GetType("MyType&")`. Notez que contrairement aux pointeurs, les références sont limitées à un niveau.|  
|Une classe parente et une classe imbriquée|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Un tableau unidimensionnel avec une limite inférieure de 0|`Type.GetType("MyArray[]")`|  
|Un tableau unidimensionnel avec une limite inférieure est inconnue|`Type.GetType("MyArray[*]")`|  
|Un tableau à n dimensions|Une virgule (,) entre les crochets total de n-1 fois. Par exemple, `System.Object[,,]` représente un graphique en trois dimensions `Object` tableau.|  
|Tableau d’un tableau à deux dimensions|`Type.GetType("MyArray[][]")`|  
|Un tableau rectangulaire à deux dimensions avec des limites inférieures inconnus|`Type.GetType("MyArray[,]")`|  
|Un type générique avec un argument de type|`Type.GetType("MyGenericType`1[MyType]")`|  
|Un type générique avec deux arguments de type|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|Un type générique avec deux arguments de type qualifié d’assembly|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|Un type générique qualifié d’assembly avec un argument de type qualifié d’assembly|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|Un type générique dont l’argument de type est un type générique avec deux arguments de type|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.  -or-  <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax. For example, "MyType[,*,]".  -or-  <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.  -or-  <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.  -or-  <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</exception>
        <exception cref="T:System.IO.FileLoadException">The assembly or one of its dependencies was found, but could not be loaded.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly or one of its dependencies is not valid.  -or-  Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">The name of the type to get. If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving. If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</param>
        <param name="assemblyResolver">A method that locates and returns the assembly that is specified in <c>typeName</c>. The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object. If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called. If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.  Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.</param>
        <param name="typeResolver">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution. If no assembly is provided, the <c>typeResolver</c> method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.  Caution   Do not pass methods from unknown or untrusted callers.</param>
        <summary>Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</summary>
        <returns>The type with the specified name, or <see langword="null" /> if the type is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scénarios d’utilisation pour cette méthode et les détails de la `assemblyResolver` et `typeResolver` paramètres peuvent être trouvés dans le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode.  
  
> [!NOTE]
>  Si `typeName` ne peut pas être trouvée, l’appel à la <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> méthode renvoie `null`. Il ne lève pas d’exception. Pour contrôler si une exception est levée, appelez une surcharge de la <xref:System.Type.GetType%2A> méthode qui a un `throwOnError` paramètre.  
  
 Appel de cette surcharge de méthode est le même que d’appeler le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode et en spécifiant `false` pour le `throwOnError` et `ignoreCase` paramètres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
        <exception cref="T:System.ArgumentException">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  -or-  <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.  -or-  <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.  -or-  <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">The assembly or one of its dependencies was found, but could not be loaded.  -or-  <paramref name="typeName" /> contains an invalid assembly name.  -or-  <paramref name="typeName" /> is a valid assembly name without a type name.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly or one of its dependencies is not valid.  -or-  The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">The name of the type to get. If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving. If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</param>
        <param name="assemblyResolver">A method that locates and returns the assembly that is specified in <c>typeName</c>. The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object. If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called. If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.  Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.</param>
        <param name="typeResolver">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.  Caution   Do not pass methods from unknown or untrusted callers.</param>
        <param name="throwOnError">
          <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />. Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them. See the Exceptions section.</param>
        <summary>Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</summary>
        <returns>The type with the specified name. If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />. See the Exceptions section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scénarios d’utilisation pour cette méthode et les détails de la `assemblyResolver` et `typeResolver` paramètres peuvent être trouvés dans le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode.  
  
 Appel de cette surcharge de méthode est le même que d’appeler le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode et en spécifiant `false` pour la `ignoreCase` paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.  -or-  <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,*,]").  -or-  <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.  -or-  <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.  -or-  <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.  -or-  <paramref name="typeName" /> contains an invalid assembly name.  -or-  <paramref name="typeName" /> is a valid assembly name without a type name.</exception>
        <exception cref="T:System.IO.FileLoadException">The assembly or one of its dependencies was found, but could not be loaded.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly or one of its dependencies is not valid.  -or-  The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">The name of the type to get. If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving. If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</param>
        <param name="assemblyResolver">A method that locates and returns the assembly that is specified in <c>typeName</c>. The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object. If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called. If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.  Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.</param>
        <param name="typeResolver">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <c>ignoreCase</c> is passed to that parameter.  Caution   Do not pass methods from unknown or untrusted callers.</param>
        <param name="throwOnError">
          <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />. Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them. See the Exceptions section.</param>
        <param name="ignoreCase">
          <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</param>
        <summary>Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</summary>
        <returns>The type with the specified name. If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />. See the Exceptions section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge de méthode et ses surcharges associées (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> et <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) pour remplacer l’implémentation par défaut de la <xref:System.Type.GetType%2A> méthode avec des implémentations plus flexibles. En fournissant vos propres méthodes pour résoudre les noms de type et les noms des assemblys qui contiennent les, vous pouvez procédez comme suit :  
  
-   Contrôler la version d’un assembly d’un type est chargé à partir de.  
  
-   Fournissez un autre emplacement pour rechercher un nom de type qui n’inclut pas un nom d’assembly.  
  
-   Charger des assemblys à l’aide des noms d’assemblys partiels.  
  
-   Retournez les sous-classes de <xref:System.Type?displayProperty=nameWithType> qui ne sont pas créés par le common language runtime (CLR).  
  
 Par exemple, sérialisation avec tolérance de version de cette méthode vous permet de rechercher un assembly « ajustement optimal » à l’aide d’un nom partiel. D’autres surcharges de la <xref:System.Type.GetType%2A> méthode requiert un nom de type qualifié d’assembly, qui inclut le numéro de version.  
  
 Les implémentations alternatives du système de type devra peut-être retourner des sous-classes de <xref:System.Type?displayProperty=nameWithType> qui ne sont pas créés par le CLR ; tous les types qui sont retournées par les autres surcharges de la <xref:System.Type.GetType%2A> méthode sont des types de runtime.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Notes d’utilisation  
 Cette surcharge de méthode et ses surcharges associées analysent `typeName` dans le nom d’un type et le nom d’un assembly, puis pour résoudre les noms. Résolution du nom de l’assembly se produit avant la résolution du nom de type, car un nom de type doit être résolu dans le contexte d’un assembly.  
  
> [!NOTE]
>  Si vous n’êtes pas familiarisé avec le concept de noms de type qualifié d’assembly, consultez la <xref:System.Type.AssemblyQualifiedName%2A> propriété.  
  
 Si `typeName` n’est pas un nom qualifié d’assembly et résolution de l’assembly est ignorée. Les noms de type non qualifiés peuvent être résolus dans le contexte de Mscorlib.dll ou l’assembly en cours d’exécution, ou vous pouvez éventuellement fournir un assembly dans le `typeResolver` paramètre. Les effets d’inclure ou d’omettre le nom de l’assembly pour différents types de résolution de noms sont affichés sous la forme d’une table dans le [résolution des noms mixtes](#mixed_name_resolution) section.  
  
 Remarques d’utilisation générales :  
  
-   Ne passez pas de méthodes à `assemblyResolver` ou `typeResolver` si elles proviennent d’appelants inconnus ou non approuvés. Utilisez uniquement les méthodes que vous fournissez ou avec lesquelles vous êtes familiarisé.  
  
    > [!CAUTION]
    >  À l’aide de méthodes provenant d’appelants inconnus ou non fiables peut entraîner une élévation de privilèges pour le code malveillant.  
  
-   Si vous omettez le `assemblyResolver` et/ou `typeResolver` paramètres, la valeur de le `throwOnError` paramètre est passé aux méthodes qui effectuent la résolution par défaut.  
  
-   Si `throwOnError` est `true`, cette méthode lève un <xref:System.TypeLoadException> lorsque `typeResolver` retourne `null`et un <xref:System.IO.FileNotFoundException> lorsque `assemblyResolver` retourne `null`.  
  
-   Cette méthode n’intercepte pas les exceptions levées par `assemblyResolver` et `typeResolver`. Vous êtes responsable de toutes les exceptions levées par les méthodes de résolution.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Résolution d’assemblys  
 Le `assemblyResolver` méthode reçoit un <xref:System.Reflection.AssemblyName> objet, qui est généré en analysant le nom d’assembly de chaîne qui est inclus dans `typeName`. Si `typeName` ne contient pas de nom d’assembly, `assemblyResolver` n’est pas appelée et `null` est passé à `typeResolver`.  
  
 Si `assemblyResolver` n’est pas fourni, standard assembly détection permet de localiser l’assembly. Si `assemblyResolver` est fourni, le <xref:System.Type.GetType%2A> méthode n’effectue pas la détection standard ; dans ce cas vous devez vous assurer que votre `assemblyResolver` peut gérer tous les assemblys que vous passez à celui-ci.  
  
 Le `assemblyResolver` méthode doit retourner `null` si l’assembly ne peut pas être résolu. Si `assemblyResolver` retourne `null`, `typeResolver` n’est pas appelée et qu’aucun traitement supplémentaire se produit ; en outre, si `throwOnError` est `true`, un <xref:System.IO.FileNotFoundException> est levée.  
  
 Si le <xref:System.Reflection.AssemblyName> qui est passé à `assemblyResolver` est un partiel nom, un ou plusieurs de ses parties sont `null`. Par exemple, si elle dispose d’une version sans le <xref:System.Reflection.AssemblyName.Version%2A> propriété est `null`. Si le <xref:System.Reflection.AssemblyName.Version%2A> propriété, le <xref:System.Reflection.AssemblyName.CultureInfo%2A> propriété et le <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> tout retour de la méthode `null`, alors seulement le nom simple de l’assembly a été fourni. Le `assemblyResolver` méthode peut utiliser ou ignorer toutes les parties du nom de l’assembly.  
  
 Les effets des options de résolution d’assembly différents sont affichés sous la forme d’une table dans le [résolution des noms mixtes](#mixed_name_resolution) section, pour les noms de types simples et qualifiés d’assembly.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Résolution de Types  
 Si `typeName` ne spécifie pas de nom d’assembly, `typeResolver` est toujours appelée. Si `typeName` Spécifie le nom d’assembly, `typeResolver` est appelée uniquement lorsque le nom de l’assembly est résolu avec succès. Si `assemblyResolver` ou retourne de détection d’assembly standard `null`, `typeResolver` n’est pas appelée.  
  
 Le `typeResolver` méthode reçoit les trois arguments :  
  
-   L’assembly à rechercher ou `null` si `typeName` ne contient pas un nom d’assembly.  
  
-   Nom du type simple. Dans le cas d’un type imbriqué, il s’agit du type conteneur extérieur. Dans le cas d’un type générique, il s’agit du nom simple du type générique.  
  
-   Valeur booléenne qui est `true` si la casse des noms de type doit être ignoré.  
  
 L’implémentation de détermine la manière dont ces arguments sont utilisées. Le `typeResolver` méthode doit retourner `null` si elle ne peut pas résoudre le type. Si `typeResolver` retourne `null` et `throwOnError` est `true`, cette surcharge de <xref:System.Type.GetType%2A> lève une <xref:System.TypeLoadException>.  
  
 Les effets des options de résolution de type différent sont affichés sous la forme d’une table dans le [résolution des noms mixtes](#mixed_name_resolution) section, pour les noms de types simples et qualifiés d’assembly.  
  
#### <a name="resolving-nested-types"></a>Résolution de Types imbriqués  
 Si `typeName` est un type imbriqué, seul le nom de l’extérieur qui contient le type est passé à `typeResolver`. Lorsque `typeResolver` retourne ce type, le <xref:System.Type.GetNestedType%2A> méthode est appelée de manière récursive jusqu'à ce que le plus profond type imbriqué a été résolu.  
  
#### <a name="resolving-generic-types"></a>Résolution de Types génériques  
 Le <xref:System.Type.GetType%2A> est appelée de manière récursive pour résoudre les types génériques : pour résoudre le type générique lui-même, puis pour résoudre ses arguments de type. Si un argument de type est générique, <xref:System.Type.GetType%2A> est appelée de manière récursive pour résoudre ses arguments de type et ainsi de suite.  
  
 La combinaison de `assemblyResolver` et `typeResolver` que vous fournissez doit être capable de résoudre tous les niveaux de cette récursivité. Par exemple, supposez que vous fournissez un `assemblyResolver` qui contrôle le chargement de `MyAssembly`. Supposons que vous souhaitez résoudre le type générique `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` en Visual Basic). Vous pouvez passer le nom de type générique suivant :  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Notez que `MyType` est l’argument de type qualifié d’assembly uniquement. Les noms de la <xref:System.Collections.Generic.Dictionary%602> et <xref:System.String> classes ne sont pas qualifiés d’assembly. Votre `typeResolver` doit être en mesure de gérer un assembly ou `null`, car il recevra `null` pour <xref:System.Collections.Generic.Dictionary%602> et <xref:System.String>. Il peut gérer ce cas en appelant une surcharge de la <xref:System.Type.GetType%2A> méthode qui prend une chaîne, car les deux noms de type non qualifiés sont dans Mscorlib.dll :  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 Le `assemblyResolver` méthode n’est pas appelée pour le type de dictionnaire et le type de chaîne, car ces noms de types ne sont pas qualifiés d’assembly.  
  
 Supposons maintenant qu’au lieu de `System.String`, le premier type d’argument générique est `YourType`, à partir de `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Étant donné que cet assembly n’est ni Mscorlib.dll, ni l’assembly en cours d’exécution, vous ne peut pas résoudre `YourType` sans un nom qualifié d’assembly. Étant donné que votre `assemblyResolve` sera appelé de manière récursive, il doit être en mesure de gérer ce cas. Au lieu de retourner `null` pour les assemblys autres que `MyAssembly`, elle s’exécute maintenant le chargement d’un assembly à l’aide de l’élément <xref:System.Reflection.AssemblyName> objet.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Retour au [Notes d’utilisation](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Résolution de noms de Type avec des caractères spéciaux  
 Certains caractères ont une signification particulière dans les noms qualifiés d’assembly. Si un nom de type simple contient ces caractères, les caractères provoquent des erreurs d’analyse lorsque le nom simple fait partie d’un nom qualifié d’assembly. Pour éviter les erreurs d’analyse, vous devez isoler les caractères spéciaux par une barre oblique inverse avant de pouvoir passer le nom qualifié d’assembly pour le <xref:System.Type.GetType%2A> (méthode). Par exemple, si un type est nommé `Strange]Type`, le caractère d’échappement doit être ajouté avant les crochets comme suit : `Strange\]Type`.  
  
> [!NOTE]
>  Les noms de ces caractères spéciaux ne peut pas être créés en Visual Basic ou c#, mais peuvent être créés à l’aide du langage intermédiaire Microsoft (MSIL) ou par l’émission d’assemblys dynamiques.  
  
 Le tableau suivant présente les caractères spéciaux pour les noms de type.  
  
|Caractère|Signification|  
|---------------|-------------|  
|`,` (virgule)|Délimiteur pour les noms qualifiés d’assembly.|  
|`[]` (les crochets)|En tant que suffixe paire, indique un type de tableau ; comme une paire de séparateurs, englobe les listes d’arguments génériques et les noms qualifiés d’assembly.|  
|`&` (et commercial)|En guise de suffixe, indique qu’un type est un type référence.|  
|`*` (astérisque)|En guise de suffixe, indique qu’un type est un type pointeur.|  
|`+` (plus)|Délimiteur pour les types imbriqués.|  
|`\` (barre oblique inverse)|Caractère d’échappement.|  
  
 Propriétés, telles que <xref:System.Type.AssemblyQualifiedName%2A> retour correctement d’échappement de chaînes. Vous devez passer des chaînes correctement échappées à le <xref:System.Type.GetType%2A> (méthode). À son tour, le <xref:System.Type.GetType%2A> méthode passe les noms correctement échappées à `typeResolver` et aux méthodes de résolution de type par défaut. Si vous devez comparer un nom à un nom sans séquence d’échappement dans `typeResolver`, vous devez supprimer les caractères d’échappement.  
  
 Retour au [Notes d’utilisation](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Résolution de noms mixtes  
 Le tableau suivant récapitule les interactions entre `assemblyResolver`, `typeResolver`et la résolution de noms par défaut, pour toutes les combinaisons de nom de type et le nom de l’assembly dans `typeName`:  
  
|Contenu du nom de type|Méthode de programme de résolution d’assembly|Méthode de programme de résolution de type|Résultat|  
|---------------------------|------------------------------|--------------------------|------------|  
|type, l’assembly|null|null|Équivalent à l’appel du <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de méthode.|  
|type, l’assembly|fourni|null|`assemblyResolver` Retourne l’assembly ou `null` si elle ne peut pas résoudre l’assembly. Si l’assembly est résolu, le <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de méthode est utilisée pour charger le type à partir de l’assembly ; sinon, il n’existe aucune tentative de résoudre le type.|  
|type, l’assembly|null|fourni|Équivalent à la conversion du nom de l’assembly à un <xref:System.Reflection.AssemblyName> objet et en appelant le <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> surcharge de méthode pour obtenir l’assembly. Si l’assembly est résolu, il est passé à `typeResolver`; sinon, `typeResolver` n’est pas appelée et il n’existe aucune autre tentative de résoudre le type.|  
|type, l’assembly|fourni|fourni|`assemblyResolver` Retourne l’assembly ou `null` si elle ne peut pas résoudre l’assembly. Si l’assembly est résolu, il est passé à `typeResolver`; sinon, `typeResolver` n’est pas appelée et il n’existe aucune autre tentative de résoudre le type.|  
|type|NULL, fourni|null|Équivalent à l’appel du <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de méthode. Étant donné que le nom de l’assembly n’est pas fourni, Mscorlib.dll et l’assembly en cours d’exécution sont recherchés. Si `assemblyResolver` est fourni, il est ignoré.|  
|type|NULL, fourni|fourni|`typeResolver` est appelée, et `null` est passé pour l’assembly. `typeResolver` peut de fournir un type à partir de n’importe quel assembly, y compris les assemblys qu’il charge à cet effet. Si `assemblyResolver` est fourni, il est ignoré.|  
|assembly|NULL, fourni|NULL, fourni|A <xref:System.IO.FileLoadException> est levée, car le nom de l’assembly est analysé comme s’il s’agissait d’un nom de type qualifié d’assembly. Cela entraîne un nom d’assembly non valide.|  
  
 À : [Notes d’utilisation](#usage_notes), [résolution d’assemblys](#resolving_assemblies), [résoudre les Types](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.  -or-  <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  -or-  <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,*,]").  -or-  <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.  -or-  <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.  -or-  <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</exception>
        <exception cref="T:System.IO.FileLoadException">The assembly or one of its dependencies was found, but could not be loaded.  -or-  <paramref name="typeName" /> contains an invalid assembly name.  -or-  <paramref name="typeName" /> is a valid assembly name without a type name.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly or one of its dependencies is not valid.  -or-  The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">An array of objects whose types to determine.</param>
        <summary>Gets the types of the objects in the specified array.</summary>
        <returns>An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment utiliser la <xref:System.Type.GetTypeArray%2A> méthode pour répertorier les types des éléments du tableau.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> is <see langword="null" />.  -or-  One or more of the elements in <paramref name="args" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The class initializers are invoked and at least one throws an exception.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">The type whose underlying type code to get.</param>
        <summary>Gets the underlying type code of the specified <see cref="T:System.Type" />.</summary>
        <returns>The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous héritez de <xref:System.Type>, vous pouvez modifier le comportement de cette méthode en substituant le <xref:System.Type.GetTypeCodeImpl%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment la <xref:System.TypeCode> énumération peut être utilisée. Dans un bloc de décision le `WriteObjectInfo` (méthode), la <xref:System.TypeCode> d’un <xref:System.Object> paramètre est examiné, et un message approprié est écrit dans la console.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the underlying type code of this <see cref="T:System.Type" /> instance.</summary>
        <returns>The type code of the underlying type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit l’implémentation pour la `static` (en c#) ou `Shared` (en Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> (méthode). Lorsque vous héritez de <xref:System.Type>, vous pouvez substituer cette méthode pour fournir votre propre implémentation de <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the type associated with the specified class identifier (CLSID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">The CLSID of the type to get.</param>
        <summary>Gets the type associated with the specified class identifier (CLSID).</summary>
        <returns>
          <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).  L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre. Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété pour déterminer si le type retourné par cette méthode est un objet COM.  
  
> [!TIP]
>  Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.  
  
 Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :  
  
1.  Obtenir un <xref:System.Type> objet qui représente le`__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).  
  
2.  Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).  
  
 Consultez l’exemple pour obtenir une illustration.  
  
 Le <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> surcharge ignore toute exception qui peut se produire lorsque vous instanciez un <xref:System.Type> objet basé sur le `clsid` argument. Notez qu’aucune exception n’est levée si `clsid` est introuvable dans le Registre.  
  
   
  
## Examples  
 L’exemple suivant utilise le CLSID de le Microsoft Word [objet Application](http://msdn.microsoft.com/library/office/ff838565.aspx) pour récupérer un type COM qui représente l’application Microsoft Word. Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et le ferme en appelant le [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (méthode).  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework. Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leurs <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété. Bien que la méthode retourne un <see cref="T:System.Type" /> objets d’objet qui correspond au GUID du .NET Framework, vous ne pouvez pas utiliser <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme le montre l’exemple suivant.  [ ! code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [ ! code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">The CLSID of the type to get.</param>
        <param name="throwOnError">
          <see langword="true" /> to throw any exception that occurs.  -or-  <see langword="false" /> to ignore any exception that occurs.</param>
        <summary>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</summary>
        <returns>
          <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).  L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre. Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété pour déterminer si le type retourné par cette méthode est un objet COM.  
  
> [!TIP]
>  Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.  
  
 Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :  
  
1.  Obtenir un <xref:System.Type> objet qui représente le `__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).  
  
2.  Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).  
  
 Consultez l’exemple pour obtenir une illustration.  
  
 Exceptions telles que <xref:System.OutOfMemoryException> sera levée lors de la spécification `true` pour `throwOnError`, mais non inscrits CLSID n’échouera pas.  
  
   
  
## Examples  
 L’exemple suivant utilise le CLSID de le Microsoft Word [objet Application](http://msdn.microsoft.com/library/office/ff838565.aspx) pour récupérer un type COM qui représente l’application Microsoft Word. Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et le ferme en appelant le [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (méthode). Une exception est levée si une erreur se produit pendant le chargement du type.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework. Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leurs <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété. Bien que la méthode retourne un <see cref="T:System.Type" /> objets d’objet qui correspond au GUID du .NET Framework, vous ne pouvez pas utiliser <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme le montre l’exemple suivant.  [ ! code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [ ! code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">The CLSID of the type to get.</param>
        <param name="server">The server from which to load the type. If the server name is <see langword="null" />, this method automatically reverts to the local machine.</param>
        <summary>Gets the type associated with the specified class identifier (CLSID) from the specified server.</summary>
        <returns>
          <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).  L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre. Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété pour déterminer si le type retourné par cette méthode est un objet COM.  
  
> [!TIP]
>  Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.  
  
 Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :  
  
1.  Obtenir un <xref:System.Type> objet qui représente le `__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).  
  
2.  Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise le CLSID de le Microsoft Word [objet Application](http://msdn.microsoft.com/library/office/ff838565.aspx) pour récupérer un type COM qui représente l’application Microsoft Word à partir d’un serveur nommé computer17.central.contoso.com. Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et le ferme en appelant le [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (méthode).  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework. Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leurs <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété. Bien que la méthode retourne un <see cref="T:System.Type" /> objets d’objet qui correspond au GUID du .NET Framework, vous ne pouvez pas utiliser <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme le montre l’exemple suivant.  [ ! code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [ ! code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">The CLSID of the type to get.</param>
        <param name="server">The server from which to load the type. If the server name is <see langword="null" />, this method automatically reverts to the local machine.</param>
        <param name="throwOnError">
          <see langword="true" /> to throw any exception that occurs.  -or-  <see langword="false" /> to ignore any exception that occurs.</param>
        <summary>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</summary>
        <returns>
          <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).  L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre. Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété pour déterminer si le type retourné par cette méthode est un objet COM.  
  
> [!TIP]
>  Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.  
  
 Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :  
  
1.  Obtenir un <xref:System.Type> objet qui représente le `__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).  
  
2.  Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).  
  
 Exceptions telles que <xref:System.OutOfMemoryException> sera levée lors de la spécification `true` pour `throwOnError`, mais non inscrits CLSID n’échouera pas.  
  
   
  
## Examples  
 L’exemple suivant utilise le CLSID de le Microsoft Word [objet Application](http://msdn.microsoft.com/library/office/ff838565.aspx) pour récupérer un type COM qui représente l’application Microsoft Word à partir d’un serveur nommé computer17.central.contoso.com. Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et le ferme en appelant le [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (méthode). Une exception est levée si une erreur se produit pendant le chargement du type.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework. Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leurs <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété. Bien que le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> méthode retourne un <see cref="T:System.Type" /> objet qui correspond au GUID d’un objet managé particulier, vous ne pouvez pas utiliser <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme l’exemple suivant montre.  [ ! code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [ ! code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">The object that refers to the type.</param>
        <summary>Gets the type referenced by the specified type handle.</summary>
        <returns>The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les poignées sont valides uniquement dans le domaine d’application dans lequel ils ont été obtenus.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Type.GetTypeFromHandle%2A> méthode pour obtenir un <xref:System.Type> à partir de l’objet un <xref:System.RuntimeTypeHandle> fournie par le <xref:System.Type.GetTypeHandle%2A> (méthode).  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the type associated with the specified program identifier (ProgID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">The ProgID of the type to get.</param>
        <summary>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</summary>
        <returns>The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour la prise en charge COM. ProgID ne sont pas utilisés dans le Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">The ProgID of the type to get.</param>
        <param name="throwOnError">
          <see langword="true" /> to throw any exception that occurs.  -or-  <see langword="false" /> to ignore any exception that occurs.</param>
        <summary>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</summary>
        <returns>The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour la prise en charge COM. ID de programme ne sont pas utilisés dans Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.  
  
   
  
## Examples  
 L’exemple suivant récupère un type en passant un ProgID, indiquant s’il faut lever une exception si le ProgID n’est pas valide. L’exemple affiche ensuite le ClassID associé au ProgID, ainsi que tout message d’exception approprié.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">The specified ProgID is not registered.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">The progID of the type to get.</param>
        <param name="server">The server from which to load the type. If the server name is <see langword="null" />, this method automatically reverts to the local machine.</param>
        <summary>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</summary>
        <returns>The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour la prise en charge COM. ID de programme ne sont pas utilisés dans Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.  
  
   
  
## Examples  
 L’exemple suivant récupère un type en passant un ProgID et nom de serveur. L’exemple puis affiche le ClassID associé au ProgID, ou lève une exception si le ProgID ou le nom du serveur n’est pas valide.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">The progID of the <see cref="T:System.Type" /> to get.</param>
        <param name="server">The server from which to load the type. If the server name is <see langword="null" />, this method automatically reverts to the local machine.</param>
        <param name="throwOnError">
          <see langword="true" /> to throw any exception that occurs.  -or-  <see langword="false" /> to ignore any exception that occurs.</param>
        <summary>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</summary>
        <returns>The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour la prise en charge COM. ID de programme ne sont pas utilisés dans Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.  
  
   
  
## Examples  
 L’exemple suivant récupère un type en passant un ProgID et nom de serveur. L’exemple affiche ensuite le ClassID associé au ProgID, en spécifiant s’il faut lever une exception si le ProgID ou le nom du serveur n’est pas valide.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">The specified progID is not registered.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">The object for which to get the type handle.</param>
        <summary>Gets the handle for the <see cref="T:System.Type" /> of a specified object.</summary>
        <returns>The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les poignées sont valides uniquement dans le domaine d’application dans lequel ils ont été obtenus.  
  
   
  
## Examples  
 L’exemple suivant définit la classe `MyClass1`, obtient une instance de celui-ci et récupère le handle de runtime de l’objet.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the GUID associated with the <see cref="T:System.Type" />.</summary>
        <value>GUID associé à <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un GUID est associé à un type à l’aide de la <xref:System.Runtime.InteropServices.GuidAttribute> attribut.  
  
   
  
## Examples  
 L’exemple suivant crée la classe `MyClass1` avec une méthode publique, crée un `Type` objet correspondant à `MyClass1`et obtient le <xref:System.Guid> à l’aide de la structure du `GUID` propriété de la `Type` classe.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> est un tableau ou un pointeur ou encore s'il est passé par référence ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, Type.GetType("Int32[]"). HasElementType retourne `true`, mais Type.GetType("Int32"). HasElementType retourne `false`. HasElementType retourne également `true` pour « Int32 * » et « Int32 & ».  
  
 Si le courant <xref:System.Type> représente un type générique ou un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant renvoie `true` ou `false` selon ou non l’objet est un tableau, un type référence ou un pointeur.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, Type.GetType("Int32[]"). HasElementTypeImpl retourne `true`, mais Type.GetType("Int32"). HasElementTypeImpl retourne `false`. HasElementTypeImpl retourne également `true` pour « Int32 * » et « Int32 & ».  
  
   
  
## Examples  
 L’exemple suivant définit la classe `MyTypeDelegator`, qui remplace le `HasElementTypeImpl` (méthode). La classe principale vérifie la `HasElementType` propriété et affiche le type d’élément.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invokes a specific member of the current <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the constructor, method, property, or field member to invoke.  -or-  An empty string ("") to invoke the default member.  -or-  For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</param>
        <param name="invokeAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted. The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</param>
        <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />. Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</param>
        <param name="target">The object on which to invoke the specified member.</param>
        <param name="args">An array containing the arguments to pass to the member to invoke.</param>
        <summary>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</summary>
        <returns>An object representing the return value of the invoked member.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser <xref:System.Type.InvokeMember%2A> pour appeler une méthode générique.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` pour inclure les membres statiques dans la hiérarchie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> indicateurs d’appel peuvent être utilisés pour désigner l’action à effectuer sur le membre :  
  
-   `CreateInstance` pour appeler un constructeur. `name` est ignoré. Non valide avec d’autres indicateurs d’appel.  
  
-   `InvokeMethod` pour appeler une méthode, mais pas sur un constructeur ou un initialiseur de type. Non valide avec `SetField` ou `SetProperty`. Si `InvokeMethod` est spécifié par lui-même, `BindingFlags.Public`, `BindingFlags.Instance`, et `BindingFlags.Static` sont automatiquement inclus.  
  
-   `GetField` Pour obtenir la valeur d’un champ. Non valide avec `SetField`.  
  
-   `SetField` Pour définir la valeur d’un champ. Non valide avec `GetField`.  
  
-   `GetProperty` Pour obtenir une propriété. Non valide avec `SetProperty`.  
  
-   `SetProperty` Pour définir une propriété. Non valide avec `GetProperty`.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Une méthode est appelée si les deux conditions suivantes sont remplies :  
  
-   Le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans le `args` tableau (à moins que les arguments par défaut sont définis sur le membre et `BindingFlags.OptionalParamBinding` est spécifié).  
  
-   Le type de chaque argument peut être converti par le binder pour le type du paramètre.  
  
 Le binder va trouver toutes les méthodes correspondantes. Ces méthodes sont recherchées en fonction du type de liaison demandé (<xref:System.Reflection.BindingFlags> valeurs `InvokeMethod`, `GetProperty`, et ainsi de suite). L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un ensemble de modificateurs de recherche définis dans le classeur.  
  
 Une fois que la méthode est sélectionnée, elle est appelée. Accessibilité est vérifiée à ce stade. La recherche peut contrôler quel ensemble de méthodes est analysé en fonction de l’attribut d’accessibilité associé à la méthode. Le <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> méthode de la <xref:System.Reflection.Binder> classe est chargée de sélectionner la méthode à appeler. Le binder par défaut sélectionne la correspondance la plus spécifique.  
  
 Restrictions d’accès sont ignorées pour le code de confiance totale ; Autrement dit, propriétés, méthodes, champs et constructeurs privés peuvent être accessibles et appelées par la <xref:System.Reflection> chaque fois que le code est entièrement fiable.  
  
 Vous pouvez utiliser `Type.InvokeMember` pour définir un champ à une valeur particulière, en spécifiant <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Par exemple, si vous souhaitez définir un champ d’instance public nommé F sur la classe C et F est un `String`, vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Si F est un `String[]`, vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 ce qui initialisera le champ F à ce nouveau tableau. Vous pouvez également utiliser `Type.InvokeMember` pour définir une position dans un tableau en fournissant l’index de la valeur, puis la valeur suivante en utilisant le code suivant :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Cela modifie la chaîne « z » dans le tableau F conserve la chaîne « b ».  
  
 Quand vous appelez un `IDispatch` membre, vous pouvez spécifier le DispID au lieu du nom de membre, à l’aide du format de chaîne « [DispID = ##] ». Par exemple, si le DispID de MyComMethod est 3, vous pouvez spécifier la chaîne « [DispID = 3] » au lieu de « MyComMethod ». L’appel d’un membre par DispID est plus rapide que la recherche d’un membre par nom. Dans les scénarios d’agrégation complexes, le DispID est parfois la seule façon d’appeler le membre souhaité.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple suivant utilise `InvokeMember` pour accéder aux membres d’un type.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.  -or-  <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.  -or-  <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.  -or-  This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.  -or-  One of the named parameter arrays contains a string that is <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">The specified member is a class initializer.</exception>
        <exception cref="T:System.MissingFieldException">The field or property cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">No method can be found that matches the arguments in <paramref name="args" />.  -or-  The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">The specified member cannot be invoked on <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matches the binding criteria.</exception>
        <exception cref="T:System.NotSupportedException">The .NET Compact Framework does not currently support this method.</exception>
        <exception cref="T:System.InvalidOperationException">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters. That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres non publics, quelle que soit leur allocation définie. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the constructor, method, property, or field member to invoke.  -or-  An empty string ("") to invoke the default member.  -or-  For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</param>
        <param name="invokeAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted. The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</param>
        <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />. Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</param>
        <param name="target">The object on which to invoke the specified member.</param>
        <param name="args">An array containing the arguments to pass to the member to invoke.</param>
        <param name="culture">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</param>
        <summary>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</summary>
        <returns>An object representing the return value of the invoked member.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Globalization.CultureInfo> (le `culture` paramètre), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `culture`.  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser <xref:System.Type.InvokeMember%2A> pour appeler une méthode générique.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` pour inclure les membres statiques dans la hiérarchie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> indicateurs d’appel peuvent être utilisés pour désigner l’action à effectuer sur le membre :  
  
-   `CreateInstance` pour appeler un constructeur. `name` est ignoré. Non valide avec d’autres indicateurs d’appel.  
  
-   `InvokeMethod` pour appeler une méthode, mais pas sur un constructeur ou un initialiseur de type. Non valide avec `SetField` ou `SetProperty`. Si `InvokeMethod` est spécifié par lui-même, `BindingFlags.Public`, `BindingFlags.Instance`, et `BindingFlags.Static` sont automatiquement inclus.  
  
-   `GetField` Pour obtenir la valeur d’un champ. Non valide avec `SetField`.  
  
-   `SetField` Pour définir la valeur d’un champ. Non valide avec `GetField`.  
  
-   `GetProperty` Pour obtenir une propriété. Non valide avec `SetProperty`.  
  
-   `SetProperty` Pour définir une propriété. Non valide avec `GetProperty`.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Une méthode est appelée si les deux conditions suivantes sont remplies :  
  
-   Le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans le `args` tableau (à moins que les arguments par défaut sont définis sur le membre et `BindingFlags.OptionalParamBinding` est spécifié).  
  
-   Le type de chaque argument peut être converti par le binder pour le type du paramètre.  
  
 Le binder va trouver toutes les méthodes correspondantes. Ces méthodes sont recherchées en fonction du type de liaison demandé (<xref:System.Reflection.BindingFlags> valeurs `InvokeMethod`, `GetProperty`, et ainsi de suite). L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un ensemble de modificateurs de recherche définis dans le classeur.  
  
 Une fois que la méthode est sélectionnée, elle est appelée. Accessibilité est vérifiée à ce stade. La recherche peut contrôler quel ensemble de méthodes est analysé en fonction de l’attribut d’accessibilité associé à la méthode. Le <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> méthode de la <xref:System.Reflection.Binder> classe est chargée de sélectionner la méthode à appeler. Le binder par défaut sélectionne la correspondance la plus spécifique.  
  
 Restrictions d’accès sont ignorées pour le code de confiance totale ; Autrement dit, les propriétés, méthodes, champs et constructeurs privés sont accessibles et peuvent être appelées par réflexion, chaque fois que le code est entièrement fiable.  
  
 Vous pouvez utiliser `Type.InvokeMember` pour définir un champ à une valeur particulière, en spécifiant <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Par exemple, si vous souhaitez définir un champ d’instance public nommé F sur la classe C et F est un `String` vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Si F est un `String[]`, vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 ce qui initialisera le champ F à ce nouveau tableau. Vous pouvez également utiliser `Type.InvokeMember` pour définir une position dans un tableau en fournissant l’index de la valeur, puis la valeur suivante en utilisant le code suivant :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Cela modifie la chaîne « z » dans le tableau F conserve la chaîne « b ».  
  
 Quand vous appelez un `IDispatch` membre que vous pouvez spécifier le DispID à la place du nom de membre en utilisant le format de chaîne « [DispID = ##] ». Par exemple, si le DispID de MyComMethod est 3, vous pouvez spécifier la chaîne « [DispID = 3] » au lieu de « MyComMethod ». L’appel d’un membre par DispID est plus rapide que la recherche d’un membre par nom. Dans les scénarios d’agrégation complexes, le DispID est parfois la seule façon d’appeler le membre souhaité.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.  -or-  <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.  -or-  <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.  -or-  This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.  -or-  One of the named parameter arrays contains a string that is <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">The specified member is a class initializer.</exception>
        <exception cref="T:System.MissingFieldException">The field or property cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">No method can be found that matches the arguments in <paramref name="args" />.  -or-  The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">The specified member cannot be invoked on <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matches the binding criteria.</exception>
        <exception cref="T:System.InvalidOperationException">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters. That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres non publics, quelle que soit leur allocation définie. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">The string containing the name of the constructor, method, property, or field member to invoke.  -or-  An empty string ("") to invoke the default member.  -or-  For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</param>
        <param name="invokeAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted. The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</param>
        <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  -or-  A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />. Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</param>
        <param name="target">The object on which to invoke the specified member.</param>
        <param name="args">An array containing the arguments to pass to the member to invoke.</param>
        <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>args</c> array. A parameter's associated attributes are stored in the member's signature.  The default binder processes this parameter only when calling a COM component.</param>
        <param name="culture">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="namedParameters">An array containing the names of the parameters to which the values in the <c>args</c> array are passed.</param>
        <summary>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</summary>
        <returns>An object representing the return value of the invoked member.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` appelle un membre de constructeur ou un membre de méthode, obtient ou définit une propriété de membre, obtient ou définit un membre de champ de données, ou obtient ou définit un élément d’un membre de tableau.  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser <xref:System.Type.InvokeMember%2A> pour appeler une méthode générique.  
  
 Quand vous appelez un `IDispatch` membre que vous pouvez spécifier le DispID à la place du nom de membre en utilisant le format de chaîne « [DispID = ##] ». Par exemple, si le DispID de MyComMethod est 3, vous pouvez spécifier la chaîne « [DispID = 3] » au lieu de « MyComMethod ». L’appel d’un membre par DispID est plus rapide que la recherche d’un membre par nom. Dans les scénarios d’agrégation complexes, le DispID est parfois la seule façon d’appeler le membre souhaité.  
  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> ou <xref:System.Globalization.CultureInfo> (le `modifiers` et `culture` paramètres), vous pouvez utiliser le résumé <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers` et `culture`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Chaque paramètre dans le `namedParameters` tableau Obtient la valeur de l’élément correspondant dans le `args` tableau. Si la longueur de `args` est supérieure à la longueur de `namedParameters`, les valeurs d’argument restantes sont passées dans l’ordre.  
  
 Le `namedParameters` tableau peut être utilisé pour modifier l’ordre des arguments dans un tableau d’entrée. Par exemple, étant donné la méthode `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` en Visual Basic) et le tableau d’entrée `{ 42, "x" }`, le tableau d’entrée peut être passé sans modification à `args` si le tableau `{ "b", "a" }` est fourni pour `namedParameters`.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` pour inclure les membres statiques dans la hiérarchie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> indicateurs d’appel peuvent être utilisés pour désigner l’action à effectuer sur le membre :  
  
-   `CreateInstance` pour appeler un constructeur. `name` est ignoré. Non valide avec d’autres indicateurs d’appel.  
  
-   `InvokeMethod` pour appeler une méthode, mais pas sur un constructeur ou un initialiseur de type. Non valide avec `SetField` ou `SetProperty`. Si `InvokeMethod` est spécifié par lui-même, `BindingFlags.Public`, `BindingFlags.Instance`, et `BindingFlags.Static` sont automatiquement inclus.  
  
-   `GetField` Pour obtenir la valeur d’un champ. Non valide avec `SetField`.  
  
-   `SetField` Pour définir la valeur d’un champ. Non valide avec `GetField`.  
  
-   `GetProperty` Pour obtenir une propriété. Non valide avec `SetProperty`.  
  
-   `SetProperty` Pour définir une propriété. Non valide avec `GetProperty`.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Une méthode est appelée si les deux conditions suivantes sont remplies :  
  
-   Le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans le `args` tableau (à moins que les arguments par défaut sont définis sur le membre et `BindingFlags.OptionalParamBinding` est spécifié).  
  
-   Le type de chaque argument peut être converti par le binder pour le type du paramètre.  
  
 Le binder va trouver toutes les méthodes correspondantes. Ces méthodes sont recherchées en fonction du type de liaison demandé (<xref:System.Reflection.BindingFlags> valeurs `InvokeMethod`, `GetProperty`, et ainsi de suite). L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un ensemble de modificateurs de recherche définis dans le classeur.  
  
 Une fois que la méthode est sélectionnée, elle est appelée. Accessibilité est vérifiée à ce stade. La recherche peut contrôler quel ensemble de méthodes est analysé en fonction de l’attribut d’accessibilité associé à la méthode. Le <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> méthode de la <xref:System.Reflection.Binder> classe est chargée de sélectionner la méthode à appeler. Le binder par défaut sélectionne la correspondance la plus spécifique.  
  
 `InvokeMember` peut être utilisé pour appeler des méthodes avec des paramètres qui ont des valeurs par défaut. Pour lier ces méthodes, Reflection requiert <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> être spécifié. Pour un paramètre qui a une valeur par défaut, vous pouvez fournir une valeur différente, ou fournir <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> pour utiliser la valeur par défaut.  
  
 Par exemple, considérez une méthode telle que MyMethod (int x, float y = 2.0). Pour appeler cette méthode avec uniquement le premier argument en tant que MyMethod (4), passez un des indicateurs de liaisons ci-dessus, puis passez deux arguments, à savoir 4 pour le premier argument et `Missing.Value` pour le deuxième argument. Sauf si vous utilisez `Missing.Value`, vous ne pouvez pas omettre les paramètres facultatifs avec le `Invoke` (méthode). Si vous devez le faire, utilisez `InvokeMember` à la place.  
  
 Restrictions d’accès sont ignorées pour le code de confiance totale ; Autrement dit, propriétés, méthodes, champs et constructeurs privés peuvent être accessibles et appelées par la <xref:System.Reflection> chaque fois que le code est entièrement fiable.  
  
 Vous pouvez utiliser `Type.InvokeMember` pour définir un champ à une valeur particulière, en spécifiant <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Par exemple, si vous souhaitez définir un champ d’instance public nommé F sur la classe C et F est un `String`, vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Si F est un `String[]`, vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 ce qui initialisera le champ F à ce nouveau tableau. Vous pouvez également utiliser `Type.InvokeMember` pour définir une position dans un tableau en fournissant l’index de la valeur, puis la valeur suivante en utilisant le code suivant :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Cela modifie la chaîne « z » dans le tableau F conserve la chaîne « b ».  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant de l’accorder le jeu, ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.  -or-  <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.  -or-  <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.  -or-  <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.  -or-  <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.  -or-  The named parameter array is larger than the argument array.  -or-  This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.  -or-  One of the named parameter arrays contains a string that is <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">The specified member is a class initializer.</exception>
        <exception cref="T:System.MissingFieldException">The field or property cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">No method can be found that matches the arguments in <paramref name="args" />.  -or-  No member can be found that has the argument names supplied in <paramref name="namedParameters" />.  -or-  The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">The specified member cannot be invoked on <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matches the binding criteria.</exception>
        <exception cref="T:System.InvalidOperationException">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters. That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres non publics, quelle que soit leur allocation définie. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> est abstrait ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsAbstract%2A> propriété renvoie `true` dans les cas suivants :  
  
-   Le type actuel est abstrait ; Autrement dit, il ne peut pas être instanciée, mais peut servir uniquement à la classe de base pour les classes dérivées. En c#, classes abstraites sont marquées avec le [abstraite](~/docs/csharp/language-reference/keywords/abstract.md) (mot clé) ; en Visual Basic, elles sont marquées avec le [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) (mot clé).  
  
-   Le type actuel est une interface.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de <xref:System.Type> objets qui représentent les types suivants : contient des retours de type `true` si l’objet spécifié est `abstract`; sinon, elle retourne `false`.  
  
-   `AbstractClass`, une classe abstraite (une classe marquée en tant que `abstract` en c# et `MustInherit` en Visual Basic).  
  
-   `DerivedClass`, une classe qui hérite de `AbstractClass`.  
  
-   `SingleClass`, une classe non héritable. Il est défini en tant que `sealed` en c# et `NotInheritable` en Visual Basic.  
  
-   `ITypeInfo`, une interface.  
  
-   `ImplementingClass`, une classe qui implémente le `ITypeInfo` interface.  
  
 La méthode retourne `true` uniquement pour `AbstractClass`, la classe abstraite, et `ITypeInfo`, l’interface.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> si l'attribut de format de chaîne <see langword="AnsiClass" /> est sélectionné pour le <see cref="T:System.Type" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.TypeAttributes.StringFormatMask> sélectionne les attributs de format de chaîne. Les attributs de format de chaîne améliorent l’interopérabilité en définissant la manière dont les chaînes doivent être interprétées.  
  
 Si le courant <xref:System.Type> représente un type générique, cette propriété se rapporte à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant obtient les informations de champ et vérifie le `AnsiClass` attribut.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the type is an array.</summary>
        <value>
          <see langword="true" /> si le type actuel est un tableau ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsArray%2A> propriété renvoie `false` pour la <xref:System.Array> classe. Il renvoie également `false` si l’instance actuelle est un <xref:System.Type> objet qui représente un type de collection ou d’une interface conçue pour fonctionner avec les collections, telles que <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Pour vérifier si un tableau, utilisez le code tel que :  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Si le type actuel représente un type générique ou un paramètre de type dans la définition d’un type générique ou de méthode générique, cette propriété retourne toujours `false`.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Type.IsArray%2A> propriété.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance de la <xref:System.Array> classe doit retourner `false` , car il s’agit d’un objet, pas un tableau.  
  
   
  
## Examples  
 L’exemple suivant substitue la `IsArrayImpl` méthode dans la `MyTypeDelegator` classe, vérifie si une variable est un tableau et affiche le résultat.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">The type to compare with the current type.</param>
        <summary>Determines whether an instance of a specified type can be assigned to an instance of the current type.</summary>
        <returns>
          <see langword="true" /> if any of the following conditions is true:  -   <paramref name="c" /> and the current instance represent the same type.  
  
-   <paramref name="c" /> is derived either directly or indirectly from the current instance. <paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.  -   The current instance is an interface that <paramref name="c" /> implements.  
  
-   <paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.  In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class. <c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />. Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.  [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  -   <paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).  
  
 <see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsAssignableFrom%2A> méthode peut être utilisée pour déterminer si une instance de `c` peut être affectée à une instance du type actuel, la méthode est particulièrement utile lorsque vous gérez les objets dont les types ne sont pas connus au moment du design et permet de conditionnelle l’attribution, comme l’exemple suivant s’affiche.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Cette méthode qui garantit ainsi une ligne de code comme celui-ci s’exécute lors de l’exécution sans lever une <xref:System.InvalidCastException> exception ou une exception semblable :  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Cette méthode peut être substituée par une classe dérivée.  
  
> [!NOTE]
>  Une définition de type générique n’est pas attribuable à partir d’un type construit fermé. Autrement dit, vous ne pouvez pas affecter le type construit fermé `MyGenericList<int>` (`MyGenericList(Of Integer)` en Visual Basic) à une variable de type `MyGenericList<T>`.  
  
 Si le `c` paramètre est de type <xref:System.Reflection.Emit.TypeBuilder>, le résultat est basé sur le type doit être créé. L’exemple de code suivant illustre cela : à l’aide d’un type construit nommé `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant illustre la `IsAssignableFrom` à l’aide de la méthode définie par les classes, des tableaux d’entiers et des génériques.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> si l'attribut de format de chaîne <see langword="AutoClass" /> est sélectionné pour le <see cref="T:System.Type" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.TypeAttributes.StringFormatMask> sélectionne les attributs de format de chaîne. Les attributs de format de chaîne améliorent l’interopérabilité en définissant la manière dont les chaînes doivent être interprétées.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</summary>
        <value>
          <see langword="true" /> si la propriété <see cref="P:System.Type.Attributes" /> du type actuel comprend <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est fournie pour des raisons pratiques. Vous pouvez également utiliser le <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valeur d’énumération pour sélectionner les attributs de mise en page de type, puis effectuer des tests de si <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> est défini. Le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, et <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valeurs d’énumération indiquent la façon des champs du type sont disposés en mémoire.  
  
 Pour les types dynamiques, vous pouvez spécifier <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> lorsque vous créez le type. Dans le code, vous devez appliquer le <xref:System.Runtime.InteropServices.StructLayoutAttribute> d’attribut avec le <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> valeur d’énumération pour le type, pour permettre au runtime de déterminer la méthode appropriée pour disposer de la classe.  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> méthode pour déterminer si le <xref:System.Runtime.InteropServices.StructLayoutAttribute> a été appliqué à un type.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>.`  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant crée une instance du type et affiche le <xref:System.Type.IsAutoLayout%2A> propriété.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> est passé par référence ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir le type réel, supprimez la référence le type a été passé par référence, puis appelez <xref:System.Type.GetElementType%2A> sur ce type.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de la `IsByRef` propriété pour vérifier si un type spécifié est passé par référence. L’exemple définit la classe `MyTypeDelegator`, qui remplace le `HasElementTypeImpl` (méthode). La classe principale vérifie la `HasElementType` propriété et affiche le type d’élément.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> est une classe ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne `true` pour les classes, ainsi que les délégués. Elle retourne `false` pour les types valeur (pour les structures et les énumérations) même si elles sont boxed.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `true`. Si le courant <xref:System.Type> représente un type générique construit, cette propriété retourne `true` si la définition de type générique est une définition de classe ; autrement dit, il ne définit pas une interface ou un type valeur.  
  
> [!NOTE]
>  Cette propriété retourne `true` pour `Type` instances qui représentent le <xref:System.Enum> et <xref:System.ValueType> classes. Ces deux classes sont les types de base pour les énumérations et les types valeur, respectivement, mais ils ne sont pas des énumérations ou des types valeur eux-mêmes. Pour plus d’informations, consultez la <xref:System.Type.IsValueType%2A> et <xref:System.Type.IsEnum%2A> propriétés.  
  
 Le <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valeur d’énumération distingue une déclaration de type en tant que classe ou interface. Toutefois, les classes et les types valeur sont marqués avec le <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribut. Si vous récupérez la valeur de propriété des attributs et l’utilisation d’un type la <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valeur pour déterminer si un type est une classe au lieu d’un type valeur, vous devez également appeler le <xref:System.Type.IsValueType%2A> propriété. L’exemple de la <xref:System.Reflection.TypeAttributes> énumération contient des informations supplémentaires ainsi qu’Unexemple.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant crée une instance d’un type et indique si le type est une classe.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> est un objet COM ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne `false` pour les interfaces COM, car ils ne sont pas des objets. Interfaces COM peuvent être implémentées par des objets Microsoft .NET Framework.  
  
 Vous pouvez également charger une classe COM et obtenir un `Type` objet pour cette classe COM à l’aide de la [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) outil.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int`> (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne `false` pour les interfaces COM, car ils ne sont pas des objets. Interfaces COM peuvent être implémentées par des objets Microsoft .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether this object represents a constructed generic type. You can create instances of a constructed generic type.</summary>
        <value>
          <see langword="true" /> si cet objet représente un type générique construit ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un type générique construit a été fournies pour tous ses paramètres de type générique de types explicites. Il est également appelé un type générique fermé.  
  
 Lorsque cette propriété est `true`, vous pouvez créer des instances du type actuel ; lorsqu’il est `false`, vous ne pouvez pas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> peut être hébergé dans un contexte ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contexte intercepte les appels aux membres de la classe et applique les stratégies sont appliquées à la classe, telles que la synchronisation. Pour plus d’informations sur les contextes de communication à distance, consultez <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant illustre la `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, et <xref:System.Type.IsPrimitive%2A> propriétés de la <xref:System.Type> classe. Il vérifie si le type donné peut être hébergé dans le contexte, si elle peut être marshalée par référence, et si le type est un type de données primitif.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Un contexte intercepte les appels aux membres de la classe et appliquer des stratégies qui sont appliquées à la classe, telles que la synchronisation.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de la `IsContextfulImpl` (méthode).  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> actuel représente une énumération ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne `true` pour une énumération, mais pas pour le <xref:System.Enum> type lui-même.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le `IsEnum` propriété.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to be tested.</param>
        <summary>Returns a value that indicates whether the specified value exists in the current enumeration type.</summary>
        <returns>
          <see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The current type is not an enumeration.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">The COM type that is tested for equivalence with the current type.</param>
        <summary>Determines whether two COM types have the same identity and are eligible for type equivalence.</summary>
        <returns>
          <see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />. This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le common language runtime prend en charge l’incorporation des informations de type pour les types COM directement dans des assemblys managés, au lieu de demander les assemblys managés obtenir des informations de type pour les types COM à partir de l’interopérabilité assemblys. Étant donné que les informations de type incorporées incluent uniquement les types et les membres qui sont réellement utilisés par un assembly managé, deux assemblys managés peuvent présenter des affichages très différents du même type COM. Chaque assembly managé a un objet <xref:System.Type> différent pour représenter son affichage du type COM. Le Common Language Runtime prend en charge l’équivalence des types entre ces différents affichages pour les interfaces, les structures, les énumérations et les délégués.  
  
 Avec l’équivalence des types, un objet COM qui est passé d’un assembly managé à un autre peut être casté en type managé approprié dans l’assembly de réception. Le <xref:System.Type.IsEquivalentTo%2A> méthode permet à un assembly de déterminer qu’un objet COM obtenu à partir d’un autre assembly a la même identité COM en tant qu’un des types interop du premier assembly incorporé et peut donc être casté en ce type.  
  
 Pour plus d’informations, consultez [équivalence des types et Types Interop incorporés](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</summary>
        <value>
          <see langword="true" /> si la propriété <see cref="P:System.Type.Attributes" /> du type actuel comprend <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est fournie pour des raisons pratiques. Vous pouvez également utiliser le <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valeur d’énumération pour sélectionner les attributs de mise en page de type, puis effectuer des tests de si <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> est défini. Le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, et <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valeurs d’énumération indiquent la façon des champs du type sont disposés en mémoire.  
  
 Pour les types dynamiques, vous pouvez spécifier <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> lorsque vous créez le type. Dans le code, vous devez appliquer le <xref:System.Runtime.InteropServices.StructLayoutAttribute> d’attribut avec le <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> valeur d’énumération pour le type, pour spécifier que les décalages à laquelle démarrer les champs sont spécifiés explicitement.  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> méthode pour déterminer si le <xref:System.Runtime.InteropServices.StructLayoutAttribute> a été appliqué à un type.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant crée une instance d’un type et affiche la valeur de son <xref:System.Type.IsExplicitLayout%2A> propriété. Elle utilise le `MySystemTime` (classe), qui est également dans l’exemple de code <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</summary>
        <value>
          <see langword="true" /> si l'objet <see cref="T:System.Type" /> représente un paramètre de type d'une définition de type générique ou de méthode générique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> objets qui représentent les paramètres de type générique peuvent être obtenus en appelant le <xref:System.Type.GetGenericArguments%2A> méthode d’un <xref:System.Type> objet qui représente une définition de type générique, ou la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> méthode d’un <xref:System.Reflection.MethodInfo> objet qui représente une méthode générique définition.  
  
-   Pour un type générique ou la définition de méthode, le <xref:System.Type.IsGenericParameter%2A> propriété renvoie `true` pour chaque élément du tableau résultant.  
  
-   Pour un type construit fermé ou une méthode, le <xref:System.Type.IsGenericParameter%2A> propriété renvoie `false` pour chaque élément du tableau retourné par la <xref:System.Type.GetGenericArguments%2A> (méthode).  
  
-   Pour une méthode ou un type construit ouvert, certains éléments du tableau peuvent être des types spécifiques et d’autres peuvent être des paramètres de type. <xref:System.Type.IsGenericParameter%2A> Retourne `false` pour les types et `true` pour les paramètres de type. L’exemple de code pour le <xref:System.Type.ContainsGenericParameters%2A> propriété montre une classe générique avec un mélange de types et les paramètres de type.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Type.IsGenericParameter%2A> propriété pour tester les paramètres de type générique dans un type générique.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current type is a generic type.</summary>
        <value>
          <see langword="true" /> Si le type actuel est un type générique ; dans le cas contraire, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Type.IsGenericType%2A> propriété pour déterminer si un <xref:System.Type> objet représente un type générique. Utilisez le <xref:System.Type.ContainsGenericParameters%2A> propriété pour déterminer si un <xref:System.Type> objet représente un type construit ouvert ou un type construit fermé.  
  
> [!NOTE]
>  Le <xref:System.Type.IsGenericType%2A> propriété renvoie `false` si le type immédiat n’est pas générique. Par exemple, un tableau dont les éléments sont de type `A<int>` (`A(Of Integer)` en Visual Basic) n’est pas lui-même un type générique.  
  
 Le tableau suivant résume les conditions invariantes pour les termes couramment utilisés dans la réflexion générique.  
  
|Terme|Invariant|  
|----------|---------------|  
|définition de type générique|La propriété <xref:System.Type.IsGenericTypeDefinition%2A> a la valeur `true`.<br /><br /> Définit un type générique. Un type construit est créé en appelant le <xref:System.Type.MakeGenericType%2A> méthode sur un <xref:System.Type> de l’objet qui représente une définition de type générique et en spécifiant un tableau d’arguments de type.<br /><br /> <xref:System.Type.MakeGenericType%2A> peut être appelée uniquement sur les définitions de type générique.<br /><br /> Toute définition de type générique est un type générique (la <xref:System.Type.IsGenericType%2A> propriété est `true`), mais l’inverse n’est pas vrai.|  
|type générique|La propriété <xref:System.Type.IsGenericType%2A> a la valeur `true`.<br /><br /> Peut être une définition de type générique, un type construit ouvert ou un type construit fermé.<br /><br /> Notez qu’un type tableau dont le type d’élément est générique n’est pas lui-même un type générique. Est de même d’une <xref:System.Type> objet représentant un pointeur vers un type générique.|  
|type construit ouvert|La propriété <xref:System.Type.ContainsGenericParameters%2A> a la valeur `true`.<br /><br /> Les exemples sont un type générique qui a des paramètres de type non assignés, un type qui est imbriqué dans une définition de type générique ou dans un type construit ouvert ou un type générique qui a un argument de type pour lequel le <xref:System.Type.ContainsGenericParameters%2A> propriété est `true`.<br /><br /> Il n’est pas possible de créer une instance d’un type construit ouvert.<br /><br /> Notez que les types construits ouverts pas génériques. Par exemple, un tableau dont le type d’élément est une définition de type générique n’est pas générique, et un pointeur vers un type construit ouvert n’est pas générique.|  
|type construit fermé|La propriété <xref:System.Type.ContainsGenericParameters%2A> a la valeur `false`.<br /><br /> Lorsque examinées de manière récursive, le type n’a aucun paramètre générique non assignés.|  
|paramètre de type générique|La propriété <xref:System.Type.IsGenericParameter%2A> a la valeur `true`.<br /><br /> La propriété <xref:System.Type.ContainsGenericParameters%2A> a la valeur `true`.<br /><br /> Dans une définition de type générique, un espace réservé pour un type qui sera assigné ultérieurement.|  
|argument de type générique|Peut être n’importe quel type, y compris un paramètre de type générique.<br /><br /> Arguments de type sont spécifiés sous forme de tableau de <xref:System.Type> objets passés à la <xref:System.Type.MakeGenericType%2A> méthode lors de la création d’un type générique construit. Si les instances du type résultant doivent être créés, le <xref:System.Type.ContainsGenericParameters%2A> propriété doit être `false` pour tous les arguments de type.|  
  
 L’exemple de code et le tableau suivants illustrent certaines de ces termes et invariants. La `Derived` classe présente un intérêt particulier, car son type de base est un type construit qui possède un mélange de types et les paramètres de type dans sa liste d’arguments de type.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 Le tableau suivant montre des exemples qui utilisent et générer des classes `Base`, `Derived`, et `G`. Lorsque le code C++ et c# est la même, une seule entrée est indiquée.  
  
|Exemple|Invariants|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Pour ce type :<br /><br /> <xref:System.Type.IsGenericType%2A> a la valeur `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> a la valeur `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> a la valeur `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Pour ce type :<br /><br /> <xref:System.Type.IsGenericType%2A> a la valeur `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> a la valeur `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> a la valeur `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Pour le type de variable `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> est `false` car `d` est un tableau.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> a la valeur `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> a la valeur `false`.|  
|`T`, `U`, et `V` (partout où ils apparaissent)|<xref:System.Type.IsGenericParameter%2A> a la valeur `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> est `false` , car il n’existe aucun moyen de contraindre un paramètre de type aux types génériques.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> a la valeur `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> est `true` car `T`, `U`, et `V` sont elles-mêmes des paramètres de type générique. Cela ne signifie pas rien sur les arguments de type qui leur sont assignés ultérieurement.|  
|Le type de champ `F`|<xref:System.Type.IsGenericType%2A> a la valeur `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> est `false` , car un type a été affecté au paramètre de type de `G`. Notez que cela équivaut à appeler le <xref:System.Type.MakeGenericType%2A> (méthode).<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> est `true` , car le type du champ `F` a un argument de type est un type construit ouvert. Le type construit est ouvert, car son argument de type (c'est-à-dire, `Base`) est une définition de type générique. Cet exemple illustre la nature récursive de la <xref:System.Type.IsGenericType%2A> propriété.|  
|La classe imbriquée `Nested`|<xref:System.Type.IsGenericType%2A> est `true`, même si la `Nested` classe n’a aucun paramètre de type générique de son propre, car elle est imbriquée dans un type générique.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> a la valeur `true`. Autrement dit, vous pouvez appeler la <xref:System.Type.MakeGenericType%2A> méthode et fournir le paramètre de type du type englobant, `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> est `true` , car le type englobant, `Derived`, a des paramètres de type générique. Cet exemple illustre la nature récursive de la <xref:System.Type.ContainsGenericParameters%2A> propriété.|  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur de la <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, et <xref:System.Type.ContainsGenericParameters%2A> propriétés pour les types décrits dans la section Notes. Pour obtenir des explications des valeurs de propriété, consultez le tableau joint dans la section Notes.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</summary>
        <value>
          <see langword="true" /> si l'objet <see cref="T:System.Type" /> représente une définition de type générique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une définition de type générique est un modèle à partir de laquelle d’autres types peuvent être construits. Par exemple, à partir de la définition de type générique `G<T>` (exprimé en syntaxe c# ; `G(Of T)` en Visual Basic ou `generic <typename T> ref class G` en C++) vous pouvez construire et instancier le type `G<int>` (`G(Of Integer)` en Visual Basic), en appelant le <xref:System.Type.MakeGenericType%2A> méthode avec une liste d’arguments génériques contenant le <xref:System.Int32> type. Étant donné un <xref:System.Type> objet représentant ce type construit, le <xref:System.Type.GetGenericTypeDefinition%2A> méthode récupère la définition de type générique à nouveau.  
  
 Utilisez le <xref:System.Type.IsGenericTypeDefinition%2A> propriété pour déterminer si vous pouvez créer de nouveaux types à partir du type actuel. Si le <xref:System.Type.IsGenericTypeDefinition%2A> propriété renvoie `true`, vous pouvez appeler la <xref:System.Type.MakeGenericType%2A> méthode pour créer des types génériques.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple suivant affiche des informations sur un type, notamment si elle est une définition de type générique ou non. Informations s’affichent pour un type construit, pour sa définition de type générique et un type ordinaire.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>.`  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">The object to compare with the current type.</param>
        <summary>Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</summary>
        <returns>
          <see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements. <see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
> [!NOTE]
>  Un type construit n’est pas une instance de sa définition de type générique. Autrement dit, `MyGenericList<int>` (`MyGenericList(Of Integer)` en Visual Basic) n’est pas une instance de `MyGenericList<T>` (`MyGenericList(Of T)` en Visual Basic).  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `IsInstanceOfType`.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> est une interface ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distingue une déclaration de type en tant que classe, interface ou un type valeur.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant crée une interface, vérifie le type d’interface et indique si une classe possède le `IsInterface` jeu de propriétés.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</summary>
        <value>
          <see langword="true" /> si la propriété <see cref="P:System.Type.Attributes" /> du type actuel comprend <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est fournie pour des raisons pratiques. Vous pouvez également utiliser le <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valeur d’énumération pour sélectionner les attributs de mise en page de type, puis effectuer des tests de si <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> est défini. Le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, et <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valeurs d’énumération indiquent la façon des champs du type sont disposés en mémoire.  
  
 Pour les types dynamiques, vous pouvez spécifier <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> lorsque vous créez le type. Dans le code, vous devez appliquer le <xref:System.Runtime.InteropServices.StructLayoutAttribute> d’attribut avec le <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valeur d’énumération pour le type, pour spécifier que la disposition est séquentielle.  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> méthode pour déterminer si le <xref:System.Runtime.InteropServices.StructLayoutAttribute> a été appliqué à un type.  
  
 Pour plus d’informations, consultez la section 9.1.2 de la spécification de la documentation du Common Language Infrastructure (CLI), « Partition II : Metadata Definition et Semantics ». La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant crée une instance d’une classe pour laquelle le <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valeur d’énumération dans le <xref:System.Runtime.InteropServices.StructLayoutAttribute> classe a été défini, les contrôles pour le <xref:System.Type.IsLayoutSequential%2A> propriété et affiche le résultat.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> est marshalé par référence ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre la `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, et <xref:System.Type.IsPrimitive%2A> propriétés de la <xref:System.Type> classe. Il vérifie si le type donné peut être hébergé dans le contexte, si elle peut être marshalée par référence, et si le type est un type de données primitif.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
   
  
## Examples  
 L’exemple suivant détermine si le type donné est marshalé par référence et affiche le résultat.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué dans un autre type ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsNested%2A> propriété renvoie `true` pour tous les types imbriqués, quelle que soit la visibilité. Pour tester l’imbrication et la visibilité en même temps, utilisez les propriétés connexes <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, ou <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  Le <xref:System.Reflection.TypeAttributes.VisibilityMask> membre de l’énumération sélectionne les attributs de visibilité pour un type.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement dans son propre assembly ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement par rapport aux classes qui appartiennent à la fois à sa propre famille et à son propre assembly ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
> [!NOTE]
>  Les langages c# et Visual Basic n’incluent pas de sémantique qui vous permettent de définir un type imbriqué qui est visible uniquement pour les types protégés dans son propre assembly. `protected internal` visibilité en c# et `Protected Friend` visibilité en Visual Basic définissent un type imbriqué qui est visible pour les types protégés et les types dans le même assembly.  
  
 A <xref:System.Type> famille de l’objet est défini en tant que tous les objets du même <xref:System.Type> et de ses sous-types.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement dans sa propre famille ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
 A <xref:System.Type> famille de l’objet est défini en tant que tous les objets de la même <xref:System.Type> et de ses sous-types.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement par rapport aux classes qui appartiennent à sa propre famille ou à son propre assembly ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la visibilité d’un type est `protected internal` en c# ou `Protected Friend` en Visual Basic, le <xref:System.Type.IsNestedFamORAssem%2A> propriété renvoie `true`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
 A <xref:System.Type> famille de l’objet est défini en tant que tous les objets de la même <xref:System.Type> et de ses sous-types.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et déclaré privé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether a class is nested and declared public.</summary>
        <value>
          <see langword="true" /> si la classe est imbriquée et déclarée publique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont des types différents de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> n'est pas déclaré public et n'est pas un type imbriqué ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’utilisez pas cette propriété avec les types imbriqués ; Utilisez le <xref:System.Type.IsNestedPublic%2A> propriété à la place.  
  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne `false`.  
  
   
  
## Examples  
 Cet exemple montre comment l’option `IsNotPublic` pour obtenir la visibilité du type de propriété.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 L’exemple de code suivant montre pourquoi vous ne pouvez pas utiliser `IsPublic` et `IsNotPublic` pour les classes imbriquées.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Pour les classes imbriquées, ignorez les résultats de `IsPublic` et `IsNotPublic` et uniquement pour les résultats d’une attention `IsNestedPublic` et `IsNestedPrivate`. La sortie de la réflexion pour ce fragment de code se présente comme suit :  
  
|Classe|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|false|true|false|false|  
|B|false|false|true|false|  
|C|false|FALSE|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> est un pointeur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le courant <xref:System.Type> représente un type générique ou un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de la `IsPointer` propriété.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> est l'un des types primitifs ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types primitifs sont <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, et <xref:System.Single>.  
  
 Si le courant <xref:System.Type> représente un type générique ou un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant illustre la `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, et <xref:System.Type.IsPrimitive%2A> propriétés de la <xref:System.Type> classe. Il vérifie si le type donné peut être hébergé dans le contexte, si elle peut être marshalée par référence, et si le type est un type de données primitif.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types primitifs sont <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, et <xref:System.Single>.  
  
   
  
## Examples  
 L’exemple suivant détermine si le type donné est un type primitif et affiche le résultat.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> est déclaré public et n'est pas un type imbriqué ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’utilisez pas avec les types imbriqués ; Utilisez <xref:System.Type.IsNestedPublic%2A> à la place.  
  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne `true`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
   
  
## Examples  
 L’exemple suivant crée une instance de `MyTestClass`, vérifie le `IsPublic` propriété et affiche le résultat.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Pour les classes imbriquées, ignorez les résultats de `IsPublic` et `IsNotPublic` et uniquement pour les résultats d’une attention <xref:System.Type.IsNestedPublic%2A> et <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> est déclaré sealed ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le courant <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `true`.  
  
   
  
## Examples  
 L’exemple suivant crée une instance d’un `sealed` classe vérifie le `IsSealed` propriété et affiche le résultat.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</summary>
        <value>
          <see langword="true" /> si le type actuel est critique de sécurité ou critique sécurisé au niveau de confiance actuel ; <see langword="false" /> s'il est transparent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, et <xref:System.Type.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR). Les combinaisons de ces propriétés sont répertoriées dans le tableau suivant :  
  
|Niveau de sécurité|EstCritiqueDeSécurité|EstCritiqueSécurisé|EstTransparentDeSécurité|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critique|`true`|`false`|`false`|  
|Critique sécurisé|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
> [!IMPORTANT]
>  Pour les assemblys de confiance partielle, la valeur de cette propriété dépend du niveau de confiance actuel de l’assembly. Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly. L’assembly et tous ses types sont traités comme étant transparent. Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau). En revanche, un assembly fiable (autrement dit, un assembly avec nom fort est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quelle que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable. Vous pouvez déterminer les niveaux de confiance actuels des assemblys et des domaines d’application à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.  
  
 Pour plus d’informations sur la réflexion et transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</summary>
        <value>
          <see langword="true" /> si le type actuel est critique sécurisé au niveau de confiance actuel ; <see langword="false" /> s'il est critique de sécurité ou transparent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, et <xref:System.Type.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR). Les combinaisons de ces propriétés sont répertoriées dans le tableau suivant :  
  
|Niveau de sécurité|EstCritiqueDeSécurité|EstCritiqueSécurisé|EstTransparentDeSécurité|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critique|`true`|`false`|`false`|  
|Critique sécurisé|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
> [!IMPORTANT]
>  Pour les assemblys de confiance partielle, la valeur de cette propriété dépend du niveau de confiance actuel de l’assembly. Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly. L’assembly et tous ses types sont traités comme étant transparent. Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau). En revanche, un assembly fiable (autrement dit, un assembly avec nom fort est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quelle que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable. Vous pouvez déterminer les niveaux de confiance actuels des assemblys et des domaines d’application à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.  
  
 Pour plus d’informations sur la réflexion et transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</summary>
        <value>
          <see langword="true" /> si le type est transparent de sécurité au niveau de confiance actuel ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété retourne `true`, le <xref:System.Type.IsSecurityCritical%2A> et <xref:System.Type.IsSecuritySafeCritical%2A> propriétés retour `false`.  
  
 Le <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, et <xref:System.Type.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR). L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
> [!IMPORTANT]
>  Pour les assemblys de confiance partielle, la valeur de cette propriété dépend du niveau de confiance actuel de l’assembly. Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly. L’assembly et tous ses types sont traités comme étant transparent. Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau). En revanche, un assembly fiable (autrement dit, un assembly avec nom fort est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quelle que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable. Vous pouvez déterminer les niveaux de confiance actuels des assemblys et des domaines d’application à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.  
  
 Pour plus d’informations sur la réflexion et transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> est sérialisable ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Les types qui sont définis dans le .NET Standard ne sont pas marqués avec <xref:System.SerializableAttribute>. Au lieu de cela, chaque implémentation .NET détermine si un type est sérialisable. Au moment de l’exécution, vous pouvez utiliser la <xref:System.Type.IsSerializable%2A> pour déterminer si cette implémentation prend en charge la sérialisation d’une instance du type de propriété. Pour plus d’informations et obtenir un exemple, consultez [comment déterminer si un objet .NET Standard est sérialisable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant crée une instance de `MyTestClass` (classe), définit l’attribut [Serializable] et vérifie le `IsSerializable` propriété `true` ou `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the type has a name that requires special handling.</summary>
        <value>
          <see langword="true" /> si le type a un nom qui nécessite un traitement spécial ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les noms commencent par ou un caractère de soulignement (_), les accesseurs de propriété et les méthodes de surcharge d’opérateur sont des exemples de types qui peuvent nécessiter un traitement spécial par certains compilateurs.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">The type to compare with the current type.</param>
        <summary>Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</summary>
        <returns>
          <see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />. This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez appeler la <xref:System.Type.IsSubclassOf%2A> méthode pour déterminer les éléments suivants :  
  
-   Si une classe dérive d’un autre.  
  
-   Si un type dérive de <xref:System.ValueType>. Toutefois, le <xref:System.Type.IsValueType%2A> est un moyen plus efficace pour déterminer si un type est un type valeur.  
  
-   Si un type dérive de <xref:System.Enum>. Toutefois, le <xref:System.Type.IsEnum%2A> méthode est un moyen plus efficace pour déterminer si un type est une énumération.  
  
-   Si un type est un délégué, autrement dit, si elle dérive <xref:System.Delegate> ou <xref:System.MulticastDelegate>.  
  
 Le <xref:System.Type.IsSubclassOf%2A> méthode ne peut pas être utilisée pour déterminer si une interface dérive d’une autre interface, ou si une classe implémente une interface. Utilisez le <xref:System.Type.IsAssignableFrom%2A> (méthode) à cette fin, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, il dérive de sa contrainte de classe ou de <xref:System.Object?displayProperty=nameWithType> si elle ne possède aucune contrainte de classe.  
  
> [!NOTE]
>  Sauf lorsqu’il est utilisé avec les interfaces, <xref:System.Type.IsSubclassOf%2A> est l’inverse de <xref:System.Type.IsAssignableFrom%2A>. Autrement dit, si `t1.IsSubclassOf(t2)` est `true`, puis `t2.IsAssignableFrom(t1)` est également `true`.  
  
 Cette méthode peut être substituée par une classe dérivée.  
  
   
  
## Examples  
 L’exemple suivant crée une classe nommée `Class1` et une classe dérivée nommée `DerivedC1`. Il appelle le <xref:System.Type.IsSubclassOf%2A> méthode pour indiquer que `DerivedC1` est une sous-classe de `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> si l'attribut de format de chaîne <see langword="UnicodeClass" /> est sélectionné pour le <see cref="T:System.Type" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.TypeAttributes.StringFormatMask> est utilisé pour sélectionner les attributs de format de chaîne. Les attributs de format de chaîne améliorent l’interopérabilité en définissant la manière dont les chaînes doivent être interprétées.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> est un type valeur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types valeur sont des types qui sont représentés sous forme de séquences de bits ; types valeur ne sont pas des classes ou des interfaces. Types valeur sont appelés « structs » dans certains langages de programmation. Les énumérations sont un cas spécial de types valeur.  
  
 Cette propriété retourne `false` pour le <xref:System.ValueType> classe, car <xref:System.ValueType> n’est pas lui-même un type valeur. Il s’agit de la classe de base pour tous les types valeur et par conséquent n’importe quel type de valeur peut être affectée à celui-ci. Cela ne serait pas possible si <xref:System.ValueType> lui-même était un type valeur. Types valeur sont boxed lorsqu’ils sont attribués à un champ de type <xref:System.ValueType>.  
  
 Cette propriété retourne `true` pour les énumérations, mais pas pour le <xref:System.Enum> type lui-même. Pour obtenir un exemple qui illustre ce comportement, consultez <xref:System.Type.IsEnum%2A>.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant crée une variable de type `MyEnum`, vérifie le `IsValueType` propriété et affiche le résultat.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour activer l’implémentation d’autres systèmes de type. En règle générale, il n’est pas utilisé dans le code d’application.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Type" /> actuel est un type public ou un type imbriqué public rendant publics tous les types englobants ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour déterminer si un type fait partie de l’interface publique d’un assembly de composant.  
  
   
  
## Examples  
 L’exemple de code suivant teste deux classes, un seul d'entre eux est visible en dehors de l’assembly.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</summary>
        <returns>A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.MakeArrayType%2A> méthode fournit un moyen de générer des types tableau dont les types d’élément sont calculées au moment de l’exécution.  
  
 **Remarque** le common language runtime établit une distinction entre les vecteurs (autrement dit, les tableaux unidimensionnels qui sont toujours de base zéro) et les tableaux multidimensionnels. Un vecteur, qui a toujours une seule dimension, n’est pas un tableau multidimensionnel qui n’a qu’une seule dimension. Cette surcharge de méthode peut uniquement être utilisée pour créer des types de vecteurs, et elle est la seule façon de créer un type de vecteur. Utilisez le <xref:System.Type.MakeArrayType%28System.Int32%29> surcharge de méthode pour créer des types de tableaux multidimensionnels.  
  
   
  
## Examples  
 L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour la `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class. Derived classes must provide an implementation.</exception>
        <exception cref="T:System.TypeLoadException">The current type is <see cref="T:System.TypedReference" />.  -or-  The current type is a <see langword="ByRef" /> type. That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">The number of dimensions for the array. This number must be less than or equal to 32.</param>
        <summary>Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</summary>
        <returns>An object representing an array of the current type, with the specified number of dimensions.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.MakeArrayType%2A> méthode fournit un moyen de générer des types tableau dont les types d’élément sont calculées au moment de l’exécution.  
  
> [!NOTE]
>  Le common language runtime établit une distinction entre les vecteurs (autrement dit, les tableaux unidimensionnels qui sont toujours de base zéro) et les tableaux multidimensionnels. Un vecteur, qui a toujours une seule dimension, n’est pas un tableau multidimensionnel qui n’a qu’une seule dimension. Vous ne pouvez pas utiliser cette surcharge de méthode pour créer un type vectoriel ; Si `rank` est 1, cette surcharge de méthode retourne un type de tableau multidimensionnel qui possède une seule dimension. Utilisez le <xref:System.Type.MakeArrayType> surcharge de méthode pour créer des types vectoriels.  
  
   
  
## Examples  
 L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour la `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> is invalid. For example, 0 or negative.</exception>
        <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class.</exception>
        <exception cref="T:System.TypeLoadException">The current type is <see cref="T:System.TypedReference" />.  -or-  The current type is a <see langword="ByRef" /> type. That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.  -or-  <paramref name="rank" /> is greater than 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</summary>
        <returns>A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.MakeByRefType%2A> méthode fournit un moyen de générer `ref` types (`ByRef` en Visual Basic) pour le paramètre répertorie.  
  
 À l’aide de la syntaxe de langage intermédiaire Microsoft (MSIL), si actuel <xref:System.Type> représente l’objet <xref:System.Int32>, cette méthode retourne un <xref:System.Type> objet représentant `Int32&`.  
  
   
  
## Examples  
 L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour la `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class.</exception>
        <exception cref="T:System.TypeLoadException">The current type is <see cref="T:System.TypedReference" />.  -or-  The current type is a <see langword="ByRef" /> type. That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">An array of types to be substituted for the type parameters of the current generic type.</param>
        <summary>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</summary>
        <returns>A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.MakeGenericType%2A> méthode vous permet d’écrire du code qui assigne des types spécifiques aux paramètres de type d’une définition de type générique, créant ainsi un <xref:System.Type> objet qui représente un type construit particulier. Vous pouvez utiliser cette <xref:System.Type> objet à créer des instances d’exécution du type construit.  
  
 Types construits avec <xref:System.Type.MakeGenericType%2A> peut être ouvert, autrement dit, certains de leurs arguments de type peuvent être de placer des méthodes génériques ou les types des paramètres de type. Vous pouvez utiliser ces types construits ouverts lorsque vous émettez des assemblys dynamiques. Par exemple, considérez les classes `Base` et `Derived` dans le code suivant.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Pour générer `Derived` dans un assembly dynamique, il est nécessaire de construire son type de base. Pour ce faire, appelez le <xref:System.Type.MakeGenericType%2A> méthode sur un <xref:System.Type> objet représentant la classe `Base`, à l’aide des arguments de type générique <xref:System.Int32> et le paramètre de type `V` de `Derived`. Étant donné que les types et les paramètres de type générique sont représentés par <xref:System.Type> des objets, un tableau contenant les deux peut être passé à la <xref:System.Type.MakeGenericType%2A> (méthode).  
  
> [!NOTE]
>  Un type construit comme `Base<int, V>` est utile lorsque l’émission de code, mais vous ne pouvez pas appeler la <xref:System.Type.MakeGenericType%2A> méthode sur ce type, car il n’est pas une définition de type générique. Pour créer un type construit fermé qui peut être instancié, appelez d’abord la <xref:System.Type.GetGenericTypeDefinition%2A> méthode pour obtenir un <xref:System.Type> de l’objet qui représente la définition de type générique, puis appelez <xref:System.Type.MakeGenericType%2A> avec les arguments de type souhaité.  
  
 Le <xref:System.Type> objet retourné par <xref:System.Type.MakeGenericType%2A> est le même que le <xref:System.Type> obtenu en appelant le <xref:System.Object.GetType%2A> méthode des résultats de type construit, ou le <xref:System.Object.GetType%2A> méthode de n’importe quel construite de type qui a été créé à partir de la même générique définition du type à l’aide des mêmes arguments de type.  
  
> [!NOTE]
>  Un tableau de types génériques n’est pas lui-même un type générique. Vous ne pouvez pas appeler <xref:System.Type.MakeGenericType%2A> sur un type tableau tel que `C<T>[]` (`Dim ac() As C(Of T)` en Visual Basic). Pour construire un type générique fermé de `C<T>[]`, appelez <xref:System.Type.GetElementType%2A> pour obtenir la définition de type générique `C<T>`; appeler <xref:System.Type.MakeGenericType%2A> sur la définition de type générique pour créer le type construit ; enfin appeler la <xref:System.Type.MakeArrayType%2A> méthode sur le type construit pour créer le type de tableau. Est de même des types pointeur et `ref` types (`ByRef` en Visual Basic).  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
## <a name="nested-types"></a>Types imbriqués  
 Si un type générique est défini à l’aide de c#, C++ ou Visual Basic, ses types imbriqués sont tous génériques. Cela est vrai même si les types imbriqués n’ont leurs propres, aucun paramètre de type, car les trois langages incluent les paramètres de type de types englobants dans les listes de paramètres de type de types imbriqués. Considérez les classes suivantes :  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 La liste de paramètres de type de la classe imbriquée `Inner` possède deux paramètres de type, `T` et `U`, le premier est le paramètre de type de sa classe englobante. De même, la liste de paramètres de type de la classe imbriquée `Innermost1` a trois paramètres de type, `T`, `U`, et `V`, avec `T` et `U` en provenance de ses classes englobantes. La classe imbriquée `Innermost2` possède deux paramètres de type, `T` et `U`, provenant de ses classes englobantes.  
  
 Si la liste des paramètres du type englobant comporte plusieurs paramètres de type, tous les paramètres de type dans l’ordre sont inclus dans la liste de paramètres de type du type imbriqué.  
  
 Pour construire un type générique de la définition de type générique pour un type imbriqué, appelez le <xref:System.Type.MakeGenericType%2A> méthode avec le tableau formé en concaténant les tableaux d’argument de type de tous les types englobants, commençant par le type générique à l’extérieur et se terminant par le type de tableau d’arguments du type imbriqué lui-même, s’il possède des paramètres de type de son propre. Pour créer une instance de `Innermost1`, appelez le <xref:System.Type.MakeGenericType%2A> méthode avec un tableau contenant trois types à assigner à T, U et V. Pour créer une instance de `Innermost2`, appelez le <xref:System.Type.MakeGenericType%2A> méthode avec un tableau contenant deux types à assigner à T, U.  
  
 Les langages propagent les paramètres de type des types englobants de cette façon afin de pouvoir utiliser les paramètres de type d’un type englobant pour définir des champs de types imbriqués. Dans le cas contraire, les paramètres de type ne serait pas dans la portée au sein des instances des types imbriqués. Il est possible de définir des types imbriqués sans propager les paramètres de type de types englobants, en émettant le code dans des assemblys dynamiques ou en utilisant le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Prenons le code suivant pour l’assembleur MSIL :  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 Dans cet exemple, il n’est pas possible de définir un champ de type `T` ou `U` dans la classe `Innermost`, car ces paramètres de type ne sont pas dans la portée. Le code assembleur suivant définit les classes imbriquées qui se comportent comme si elles étaient définies en C++, Visual Basic et c# :  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner les classes imbriquées définies dans les langages de niveau supérieur et observer ce schéma d’affectation de noms.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Type.MakeGenericType%2A> méthode pour créer un type construit à partir de la définition de type générique pour le <xref:System.Collections.Generic.Dictionary%602> type. Le type construit représente un <xref:System.Collections.Generic.Dictionary%602> de `Test` objets avec des clés de chaîne.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The current type does not represent a generic type definition. That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> is <see langword="null" />.  -or-  Any element of <paramref name="typeArguments" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.  -or-  Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.  -or-  <paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class. Derived classes must provide an implementation.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</summary>
        <returns>A <see cref="T:System.Type" /> object that represents a pointer to the current type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.MakePointerType%2A> méthode fournit un moyen de générer des types pointeur pour les listes de paramètres.  
  
 À l’aide de la syntaxe de langage intermédiaire Microsoft (MSIL), si actuel <xref:System.Type> représente l’objet <xref:System.Int32>, cette méthode retourne un <xref:System.Type> objet représentant `Int32*`.  
  
   
  
## Examples  
 L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour la `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class.</exception>
        <exception cref="T:System.TypeLoadException">The current type is <see cref="T:System.TypedReference" />.  -or-  The current type is a <see langword="ByRef" /> type. That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</summary>
        <value>Valeur <see cref="T:System.Reflection.MemberTypes" /> qui indique que ce membre est un type ou un type imbriqué.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété substitue <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Par conséquent, lorsque vous examinez un ensemble de <xref:System.Reflection.MemberInfo> objets — par exemple, le tableau retourné par <xref:System.Type.GetMembers%2A>: le <xref:System.Reflection.MemberInfo.MemberType%2A> propriété renvoie <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> quand un membre donné est un type imbriqué.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si le courant <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Ce qui suit montre l’exemple de code la `MemberType` champ en tant que paramètre à la `GetMember` méthode :  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents a missing value in the <see cref="T:System.Type" /> information. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `Missing` field pour un appel par la réflexion pour obtenir la valeur par défaut d’un paramètre. Si le `Missing` champ est passé pour une valeur de paramètre et il n’existe aucune valeur par défaut pour ce paramètre, un <xref:System.ArgumentException> est levée.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la `Missing` champ à appeler une méthode avec ses arguments par défaut.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Ce code génère la sortie suivante :  
  
 un = 10 b = 55.3 c = 12  
  
 un = 10 b = 1.3 c = 1  
  
 un = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</summary>
        <value>Module dans lequel le <see cref="T:System.Type" /> actuel est défini.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété retourne le module dans lequel la définition de type générique a été définie. Par exemple, si vous créez une instance de `MyGenericStack<int>`, le <xref:System.Type.Module%2A> propriété pour le type construit retourne le module dans lequel `MyGenericStack<T>` est défini.  
  
 De même, si le courant <xref:System.Type> représente un paramètre générique `T`, cette propriété retourne l’assembly qui contient le type générique qui définit `T`.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de la <xref:System.Type.Namespace%2A> et `Module` propriétés et le <xref:System.Type.ToString%2A> méthode <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the namespace of the <see cref="T:System.Type" />.</summary>
        <value>Espace de noms du <see cref="T:System.Type" /> ; <see langword="null" /> si l'instance actuelle n'a pas d'espace de noms ou représente un paramètre générique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un espace de noms est une logique au moment du design d’affectation des noms plus de commodité, principalement utilisé pour définir l’étendue d’une application et organiser des classes et autres types dans une structure hiérarchique unique. Du point de vue de l’exécution, il n’existe aucun espace de noms.  
  
 Si le courant <xref:System.Type> représente un type générique construit, cette propriété retourne l’espace de noms qui contient la définition de type générique. De même, si le courant <xref:System.Type> représente un paramètre générique `T`, cette propriété retourne l’espace de noms qui contient la définition de type générique qui définit `T`.  
  
 Si le courant <xref:System.Type> objet représente un paramètre générique, cette propriété retourne `null`.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de la `Namespace` et <xref:System.Type.Module%2A> propriétés et le <xref:System.Type.ToString%2A> méthode <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">The first object to compare.</param>
        <param name="right">The second object to compare.</param>
        <summary>Indicates whether two <see cref="T:System.Type" /> objects are equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">The first object to compare.</param>
        <param name="right">The second object to compare.</param>
        <summary>Indicates whether two <see cref="T:System.Type" /> objects are not equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the class object that was used to obtain this member.</summary>
        <value>Objet <see langword="Type" /> via lequel cet objet <see cref="T:System.Type" /> a été obtenu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour <xref:System.Type> des objets, la valeur de cette propriété est toujours identique à la valeur de la <xref:System.Type.DeclaringType%2A> propriété.  
  
   
  
## Examples  
 Cet exemple affiche le type réfléchi d’une classe imbriquée.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</param>
        <param name="throwIfNotFound">
          <see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found. Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them. See the Exceptions section.</param>
        <param name="ignoreCase">
          <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>; <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</param>
        <summary>Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found. The type is loaded for reflection only, not for execution.</summary>
        <returns>The type with the specified name, if found; otherwise, <see langword="null" />. If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />. See the Exceptions section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’assembly contenant le type n’est pas déjà chargé dans le contexte de réflexion uniquement, à l’aide du <xref:System.Type.ReflectionOnlyGetType%2A> méthode est équivalent au premier chargement de l’assembly pour la réflexion uniquement, à l’aide de la <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> (méthode), puis le chargement du type en appelant le l’assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> (méthode). Pour plus d’informations sur les noms qualifiés d’assembly, consultez la <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> propriété. Pour plus d’informations sur la spécification des noms de types, consultez le <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode.  
  
 Si l’assembly est déjà chargé pour l’exécution, une autre copie est chargée dans le contexte de réflexion uniquement.  
  
 Le `throwIfNotFound` paramètre spécifie que se passe-t-il lorsque le type est introuvable et supprime également certaines autres conditions d’exception, comme décrit dans la section Exceptions. Certaines exceptions sont levées, quelle que soit la valeur de `throwIfNotFound`. Par exemple, si l’assembly n’est pas valide, un <xref:System.BadImageFormatException> est levée même si `throwIfNotFound` est `false`.  
  
 Pour plus d’informations sur le contexte de réflexion uniquement, consultez [Comment : charger des assemblys dans le contexte de Reflection](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.  -or-  <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.  -or-  <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.  -or-  <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.  -or-  <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> does not include the assembly name.  -or-  <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,*,]".  -or-  <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.  -or-  <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.  -or-  <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</exception>
        <exception cref="T:System.IO.FileLoadException">The assembly or one of its dependencies was found, but could not be loaded.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly or one of its dependencies is not valid.  -or-  The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</summary>
        <value>Obtient un <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> qui décrit les fonctions de disposition brutes du type actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> n’est pas retournée par le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> (méthode). Au lieu de cela, utilisez cette propriété pour l’obtenir.  
  
   
  
## Examples  
 L’exemple de code suivant définit tout d’abord une classe, une structure et une structure avec des attributs de disposition spéciaux (les structures sont imbriquées dans la classe). L’exemple utilise ensuite la <xref:System.Type.StructLayoutAttribute%2A> propriété pour obtenir un <xref:System.Runtime.InteropServices.StructLayoutAttribute> pour chaque type et affiche les propriétés des attributs.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="rgszNames">Passed-in array of names to be mapped.</param>
        <param name="cNames">Count of the names to be mapped.</param>
        <param name="lcid">The locale context in which to interpret the names.</param>
        <param name="rgDispId">Caller-allocated array which receives the IDs corresponding to the names.</param>
        <summary>Maps a set of names to a corresponding set of dispatch identifiers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">The type information to return.</param>
        <param name="lcid">The locale identifier for the type information.</param>
        <param name="ppTInfo">A pointer to the requested type information object.</param>
        <summary>Retrieves the type information for an object, which can then be used to get the type information for an interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Points to a location that receives the number of type information interfaces provided by the object.</param>
        <summary>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifies the member.</param>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="lcid">The locale context in which to interpret arguments.</param>
        <param name="wFlags">Flags describing the context of the call.</param>
        <param name="pDispParams">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</param>
        <param name="pVarResult">Pointer to the location where the result is to be stored.</param>
        <param name="pExcepInfo">Pointer to a structure that contains exception information.</param>
        <param name="puArgErr">The index of the first argument that has an error.</param>
        <summary>Provides access to properties and methods exposed by an object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</summary>
        <returns>A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne le common language runtime espace de noms complet et le nom de tous les types primitifs. Par exemple, l’instruction c# `(long)0.Type().ToString()` retourne « System.Int64 » au lieu de simplement « Int64 ».  
  
 Si le courant <xref:System.Type> représente un type générique, le type et ses arguments de type sont qualifiés par espace de noms et par un type imbriqué, mais pas par un assembly. Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode retourne le nom non qualifié du paramètre de type.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de la <xref:System.Type.Namespace%2A> et <xref:System.Type.Module%2A> propriétés et le `ToString` méthode <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 L’exemple suivant compare les chaînes retournées par la <xref:System.Type.ToString%2A> (méthode) et le `Name`, <xref:System.Type.FullName%2A>, et <xref:System.Type.AssemblyQualifiedName%2A> propriétés.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the handle for the current <see cref="T:System.Type" />.</summary>
        <value>Handle pour le <see cref="T:System.Type" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` encapsule un pointeur vers une structure de données interne qui représente le type. Ce handle est unique pendant la durée de vie du processus. Le handle est valide uniquement dans le domaine d’application dans lequel il a été obtenu.  
  
   
  
## Examples  
 L’exemple suivant retourne le handle du type correspondant et passe le handle à une méthode qui obtient le type à partir du handle et l’affiche.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The .NET Compact Framework does not currently support this property.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the initializer for the type.</summary>
        <value>Objet contenant le nom du constructeur de classe pour <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les initialiseurs de classe sont également disponibles via le <xref:System.Type.FindMembers%2A> (méthode), ou via les surcharges de la <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, et <xref:System.Type.GetConstructors%2A> méthodes qui prennent des <xref:System.Reflection.BindingFlags> en tant que paramètre.  
  
 Si le courant <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates the type provided by the common language runtime that represents this type.</summary>
        <value>Type de système sous-jacent pour <see cref="T:System.Type" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>