<Type Name="Exception" FullName="System.Exception">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4dc37d06070017412e2ccd0e886f62a2b70f6949" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48595306" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente les erreurs qui se produisent lors de l'exécution de l'application.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe est la classe de base pour toutes les exceptions. Lorsqu’une erreur se produit, le système ou l’application en cours d’exécution la signale en levant une exception qui contient des informations sur l’erreur. Après qu’une exception est levée, elle est gérée par l’application ou par le Gestionnaire d’exceptions par défaut.  
  
 Dans cette section :  
  
 [Erreurs et exceptions](#Errors)   
 [Blocs try/catch](#TryCatch)   
 [Fonctionnalités de type d’exception](#Features)   
 [Propriétés de classe d’exception](#Properties)   
 [Considérations relatives aux performances](#Performance)   
 [Lever à nouveau une exception](#Rethrow)   
 [Choix d’exceptions standard](#Standard)   
 [Implémentation d’exceptions personnalisées](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>Erreurs et exceptions  
 Erreurs d’exécution peuvent se produire pour diverses raisons. Toutefois, pas toutes les erreurs doivent être traités comme des exceptions dans votre code. Voici certaines catégories d’erreurs qui peuvent se produire au moment de l’exécution et les méthodes appropriées pour y répondre.  
  
-   **Erreurs d’utilisation.** Une erreur d’utilisation représente une erreur dans la logique de programme qui peut entraîner une exception. Toutefois, l’erreur doit être traité, non par le biais de la gestion des exceptions, mais en modifiant le code défectueux. Par exemple, la substitution de la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode dans l’exemple suivant suppose que le `obj` argument doit toujours être non null.  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     Le <xref:System.NullReferenceException> exception qui résulte lorsque `obj` est `null` peuvent être éliminées en modifiant le code source pour tester explicitement les valeurs null avant d’appeler le <xref:System.Object.Equals%2A?displayProperty=nameWithType> override et puis recompilation. L’exemple suivant contient le code source corrigé qui gère un `null` argument.  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     Au lieu d’utiliser la gestion des exceptions pour les erreurs d’utilisation, vous pouvez utiliser la <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> méthode pour identifier les erreurs d’utilisation dans les versions debug et le <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> génère de méthode pour identifier les erreurs de l’utilisation de debug et release. Pour plus d’informations, consultez [Assertions dans du Code managé](/visualstudio/debugger/assertions-in-managed-code).  
  
-   **Erreurs du programme.** Une erreur de programme est une erreur d’exécution qui ne peut pas nécessairement être évitée en écrivant du code exempte de bogues.  
  
     Dans certains cas, une erreur de programme peut refléter une condition d’erreur attendu ou de routine. Dans ce cas, vous souhaiterez éviter à l’aide de la gestion des exceptions à traiter l’erreur de programme et à la place une nouvelle tentative. Par exemple, si l’utilisateur doit entrer une date dans un format particulier, vous pouvez analyser la chaîne de date en appelant le <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> (méthode), qui retourne un <xref:System.Boolean> valeur qui indique si l’opération d’analyse a réussi, au lieu d’utiliser le <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>(méthode), qui lève une <xref:System.FormatException> exception si la chaîne de date ne peut pas être convertie en un <xref:System.DateTime> valeur. De même, si un utilisateur tente d’ouvrir un fichier qui n’existe pas, vous pouvez tout d’abord appeler la <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> méthode permettant de vérifier si le fichier existe et, le cas contraire, invite l’utilisateur si il souhaite créer.  
  
     Dans d’autres cas, une erreur de programme reflète une condition d’erreur inattendue qui peut être gérée dans votre code. Par exemple, même si vous avez vérifié pour garantir qu’un fichier existe, il peut être supprimé avant que vous pouvez l’ouvrir, ou il peut être endommagé. Dans ce cas, essayez d’ouvrir le fichier en instanciant un <xref:System.IO.StreamReader> objet ou en appelant le <xref:System.IO.File.Open%2A> méthode peut lever une <xref:System.IO.FileNotFoundException> exception. Dans ce cas, vous devez utiliser des exceptions pour récupérer à partir de l’erreur.  
  
-   **Défaillances du système.** Une défaillance du système est une erreur d’exécution qui ne peuvent pas être gérée par programmation de manière explicite. Par exemple, n’importe quelle méthode peut lever une <xref:System.OutOfMemoryException> exception si le common language runtime ne peut pas allouer de mémoire supplémentaire. En règle générale, les défaillances du système ne sont pas gérées à l’aide de la gestion des exceptions. Au lieu de cela, vous pourrez peut-être utiliser un événement tel que <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> et appelez le <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> méthode pour enregistrer des informations d’exception et informer l’utilisateur de l’échec avant que l’application se termine.  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Blocs try/catch  
 Le common language runtime fournit un modèle de gestion des exceptions est basé sur la représentation des exceptions sous forme d’objets et la séparation de code de programme et des exceptions de code dans `try` blocs et `catch` blocs. Il peut y avoir un ou plusieurs `catch` bloque, chacun étant conçu pour gérer un type particulier d’exception, ou un seul bloc conçu pour intercepter une exception plus spécifique qu’un autre bloc.  
  
 Si une application gère les exceptions qui se produisent pendant l’exécution d’un bloc de code d’application, le code doit être placé dans un `try` instruction et est appelé un `try` bloc. Code d’application qui gère les exceptions levées par un `try` bloc est placé dans un `catch` instruction et est appelé un `catch` bloc. Zéro ou plusieurs `catch` blocs sont associés un `try` bloc et chaque `catch` bloc inclut un filtre de type qui détermine les types d’exceptions à gérer.  
  
 Si une exception se produit dans un `try` bloc, le système recherche associé `catch` blocs dans l’ordre d’apparition dans le code d’application, jusqu'à ce qu’il trouve un `catch` bloc qui gère l’exception. Un `catch` bloc gère une exception de type `T` si le filtre de type du bloc catch spécifie `T` ou tout type pouvant `T` dérive. Le système arrête la recherche après avoir trouvé le premier `catch` bloc qui gère l’exception. Pour cette raison, dans le code d’application, un `catch` bloc qui gère un type doit être spécifié avant un `catch` bloc qui gère ses types de base, comme illustré dans l’exemple qui suit cette section. Un bloc catch qui gère `System.Exception` est spécifiée en dernier.  
  
 Si aucun de la `catch` blocs associés actuel `try` bloc gérer l’exception et en cours `try` bloc est imbriqué dans d’autres `try` bloque dans l’appel actuel, le `catch` blocs associés à la suivante englobant `try` bloc sont recherchés. Si aucun `catch` bloc pour l’exception est trouvé, le système recherche les niveaux d’imbrication précédents dans l’appel actuel. Si aucun `catch` bloquer pour l’exception se trouve dans l’appel en cours, l’exception remonte la pile des appels, et le frame de pile précédent est recherché une `catch` bloc qui gère l’exception. La recherche de la pile des appels se poursuit jusqu'à ce que l’exception est gérée ou jusqu'à ce que des frames sont présents sur la pile des appels. Si le haut de la pile des appels est atteint sans recherche un `catch` bloc qui gère l’exception, le Gestionnaire d’exceptions par défaut et l’application s’arrête.  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>Fonctionnalités de type d’exception  
 Types d’exceptions prennent en charge les fonctionnalités suivantes :  
  
-   Texte contrôlable de visu qui décrit l’erreur. Lorsqu’une exception se produit, le runtime établit un SMS disponible pour informer l’utilisateur de la nature de l’erreur et de suggérer d’action pour résoudre le problème. Ce message textuel est contenu dans le <xref:System.Exception.Message%2A> propriété de l’objet exception. Lors de la création de l’objet exception, vous pouvez passer une chaîne de texte au constructeur pour décrire les détails de cette exception particulière. Si aucun argument de message d’erreur est fourni au constructeur, le message d’erreur par défaut est utilisé. Pour plus d'informations, consultez la propriété <xref:System.Exception.Message%2A>.  
  
-   L’état de la pile des appels lorsque l’exception a été levée. Le <xref:System.Exception.StackTrace%2A> propriété conserve une trace de pile qui peut être utilisée pour déterminer où l’erreur se produit dans le code. La trace de pile répertorie toutes les méthodes appelées et les numéros de ligne dans le fichier source où les appels sont effectués.  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>Propriétés de classe d’exception  
 Le <xref:System.Exception> classe inclut un nombre de propriétés qui permettent d’identifier l’emplacement du code, le type, le fichier d’aide et la raison de l’exception : <xref:System.Exception.StackTrace%2A>, <xref:System.Exception.InnerException%2A>, <xref:System.Exception.Message%2A>, <xref:System.Exception.HelpLink%2A>, <xref:System.Exception.HResult%2A>, <xref:System.Exception.Source%2A>, <xref:System.Exception.TargetSite%2A>, et <xref:System.Exception.Data%2A>.  
  
 Lors de l’existence d’une relation existe entre deux ou plusieurs exceptions, la <xref:System.Exception.InnerException%2A> propriété conserve ces informations. L’exception externe levée en réponse à cette exception interne. Le code qui gère l’exception externe peut utiliser les informations de l’exception interne précédemment pour gérer l’erreur plus convenablement. Informations supplémentaires sur l’exception peuvent être stockées comme une collection de paires clé/valeur dans le <xref:System.Exception.Data%2A> propriété.  
  
 La chaîne de message d’erreur qui est passée au constructeur lors de la création de l’objet exception doit être localisée et peuvent être fournie à partir d’un fichier de ressources à l’aide de la <xref:System.Resources.ResourceManager> classe. Pour plus d’informations sur les ressources localisées, consultez le [création d’assemblys satellites](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) et [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) rubriques.  
  
 Pour fournir l’utilisateur avec des informations détaillées sur la raison pour laquelle l’exception s’est produite, le <xref:System.Exception.HelpLink%2A> propriété peut contenir une URL (ou URN) vers un fichier d’aide.  
  
 Le <xref:System.Exception> classe utilise HRESULT COR_E_EXCEPTION, dont la valeur est 0 x 80131500.  
  
 Pour obtenir la liste des valeurs initiales des propriétés d’une instance de la <xref:System.Exception> de classe, consultez le <xref:System.Exception.%23ctor%2A> constructeurs.  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>Considérations sur les performances  
 Lancer ou de gestion d’une exception consomme une quantité importante de ressources système et la durée d’exécution. Lever des exceptions uniquement pour gérer des conditions vraiment extraordinaires, pas pour gérer les événements prévisibles ou de contrôle de flux. Par exemple, dans certains cas, notamment lorsque vous développez une bibliothèque de classes, il est raisonnable de lever une exception si un argument de méthode n’est pas valide, car vous attendez que votre méthode d’être appelée avec des paramètres valides. Un argument de méthode non valide, si elle n’est pas le résultat d’une erreur d’utilisation, signifie que quelque chose d’anormal s’est produite. Inversement, ne levez pas d’exception si l’entrée d’utilisateur n’est pas valide, car vous pouvez vous attendre les utilisateurs entrent parfois des données non valides. Au lieu de cela, fournissent un mécanisme de nouvelle tentative pour permettre aux utilisateurs d’entrer une entrée valide. Ni doit utiliser des exceptions pour gérer les erreurs d’utilisation. Au lieu de cela, utilisez [assertions](/visualstudio/debugger/assertions-in-managed-code) pour identifier et corriger les erreurs d’utilisation.  
  
 En outre, ne levez pas d’exception lorsqu’un code de retour est suffisant ; ne pas convertir un code de retour à une exception ; n’interceptez pas régulièrement une exception, l’ignorer et continuer le traitement.  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>Génération répétée d’une exception  
 Dans de nombreux cas, un gestionnaire d’exceptions veut simplement passer l’exception à l’appelant. Ceci se produit souvent dans :  
  
-   Une bibliothèque de classes qui à son tour encapsule les appels aux méthodes dans la bibliothèque de classes .NET Framework ou d’autres bibliothèques de classes.  
  
-   Une application ou une bibliothèque qui rencontre une erreur fatale. Le Gestionnaire d’exceptions peut consigner l’exception et lever à nouveau l’exception.  
  
 La méthode recommandée pour lever à nouveau une exception consiste à utiliser simplement le [lever](~/docs/csharp/language-reference/keywords/throw.md) instruction en langage c# et le [lever](~/docs/visual-basic/language-reference/statements/throw-statement.md) instruction en Visual Basic sans inclure une expression. Cela garantit la préservation de toutes les informations de pile des appels lorsque l’exception est propagée à l’appelant. L'exemple suivant illustre ce comportement. Une méthode d’extension de chaîne, `FindOccurrences`, encapsule un ou plusieurs appels à <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> sans valider au préalable de ses arguments.  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 Un appelant appelle ensuite `FindOccurrences` à deux reprises. Dans le deuxième appel à `FindOccurrences`, l’appelant passe un `null` comme chaîne de recherche, les cas de la <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> méthode lève un <xref:System.ArgumentNullException> exception. Cette exception est gérée par le `FindOccurrences` (méthode) et renvoyée à l’appelant. Étant donné que l’instruction throw est utilisée sans expression, la sortie de l’exemple montre que la pile des appels est conservée.  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 En revanche, si l’exception est levée à nouveau à l’aide de la  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 instruction, la pile des appels complète n’est pas conservée, et l’exemple génère la sortie suivante :  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 Une alternative légèrement plus lourde consiste à lever une exception et pour conserver les informations de pile des appels de l’exception d’origine dans une exception interne. L’appelant peut utiliser ensuite la nouvelle exception <xref:System.Exception.InnerException%2A> propriété à récupérer le frame de pile et d’autres informations relatives à l’exception d’origine. Dans ce cas, l’instruction throw est :  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 Le code utilisateur qui gère l’exception doit savoir si le <xref:System.Exception.InnerException%2A> propriété contient des informations sur l’exception d’origine, comme l’illustre le Gestionnaire d’exceptions.  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>Choix d’exceptions standard  
 Lorsque vous devez lever une exception, vous pouvez souvent utiliser un type d’exception existant dans le .NET Framework au lieu d’implémenter une exception personnalisée. Vous devez utiliser un type d’exception standard dans ces deux conditions :  
  
-   Vous lèvent une exception provoquée par une erreur d’utilisation (autrement dit, par une erreur dans la logique de programme effectuée par le développeur qui appelle votre méthode). En règle générale, vous lèverait une exception comme <xref:System.ArgumentException>, <xref:System.ArgumentNullException>, <xref:System.InvalidOperationException>, ou <xref:System.NotSupportedException>. La chaîne que vous fournissez au constructeur de l’objet exception lors de l’instanciation de l’objet exception doit décrire l’erreur afin que le développeur peut résoudre le problème. Pour plus d'informations, consultez la propriété <xref:System.Exception.Message%2A>.  
  
-   Vous gérez une erreur qui peut être communiquée à l’appelant avec une exception .NET Framework existante. Vous devez lever l’exception la plus dérivée possible. Par exemple, si une méthode requiert un argument d’être un membre valide d’un type énumération, vous devez lever une <xref:System.ComponentModel.InvalidEnumArgumentException> (la classe dérivée le meilleur) plutôt qu’un <xref:System.ArgumentException>.  
  
 Le tableau suivant répertorie les types d’exceptions courantes et les conditions sous lesquelles vous les lèverait.  
  
|Exception|Condition|  
|---------------|---------------|  
|<xref:System.ArgumentException>|Un argument non null qui est passé à une méthode n’est pas valide.|  
|<xref:System.ArgumentNullException>|Est un argument qui est passé à une méthode `null`.|  
|<xref:System.ArgumentOutOfRangeException>|Un argument est en dehors de la plage de valeurs valides.|  
|<xref:System.IO.DirectoryNotFoundException>|Partie d’un chemin de répertoire n’est pas valide.|  
|<xref:System.DivideByZeroException>|Le dénominateur dans un entier ou <xref:System.Decimal> opération de division est zéro.|  
|<xref:System.IO.DriveNotFoundException>|Un lecteur n’est pas disponible ou n’existe pas.|  
|<xref:System.IO.FileNotFoundException>|Un fichier n’existe pas.|  
|<xref:System.FormatException>|Une valeur n’est pas dans un format approprié à convertir à partir d’une chaîne par une méthode de conversion comme `Parse`.|  
|<xref:System.IndexOutOfRangeException>|Un index est en dehors des limites d’un tableau ou une collection.|  
|<xref:System.InvalidOperationException>|Un appel de méthode n’est pas valide dans l’état actuel d’un objet.|  
|<xref:System.Collections.Generic.KeyNotFoundException>|Impossible de trouver la clé spécifiée pour l’accès à un membre dans une collection.|  
|<xref:System.NotImplementedException>|Une méthode ou l’opération n’est pas implémentée.|  
|<xref:System.NotSupportedException>|Une méthode ou l’opération n’est pas pris en charge.|  
|<xref:System.ObjectDisposedException>|Une opération est effectuée sur un objet qui a été supprimé.|  
|<xref:System.OverflowException>|Une opération arithmétique, de casting ou de conversion engendre un dépassement de capacité.|  
|<xref:System.IO.PathTooLongException>|Un chemin d’accès ou nom de fichier dépasse la longueur maximale définie par le système.|  
|<xref:System.PlatformNotSupportedException>|L’opération n’est pas pris en charge sur la plateforme actuelle.|  
|<xref:System.RankException>|Un tableau ayant un nombre incorrect de dimensions est passé à une méthode.|  
|<xref:System.TimeoutException>|L’intervalle de temps alloué à une opération a expiré.|  
|<xref:System.UriFormatException>|Un non valide identificateur URI (Uniform Resource) est utilisé.|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>Implémentation d’exceptions personnalisées  
 Dans les cas suivants, à l’aide d’une exception .NET Framework existante pour gérer une condition d’erreur n’est pas suffisante :  
  
-   Lorsque l’exception reflète une erreur de programme unique qui ne peut pas être mappée à une exception .NET Framework existante.  
  
-   Lorsque l’exception nécessite que la gestion est différente de la gestion qui convient à une exception .NET Framework existante, ou l’exception doit éviter toute ambiguïté à partir d’une exception semblable. Par exemple, si vous levez une <xref:System.ArgumentOutOfRangeException> exception lors de l’analyse de la représentation numérique d’une chaîne qui est en dehors de la plage du type intégral cible, vous souhaitez pas utiliser la même exception pour une erreur qui résulte de l’appelant ne fournissant ne pas le valeurs de contrainte appropriées lors de l’appel de la méthode.  
  
 Le <xref:System.Exception> est la classe de base de toutes les exceptions dans le .NET Framework. De nombreuses classes dérivées s’appuient sur le comportement hérité des membres de la <xref:System.Exception> classe ; ils ne remplacent pas les membres de <xref:System.Exception>, ni de faire tous les membres uniques.  
  
 Pour définir votre propre classe d’exception :  
  
1.  Définissez une classe qui hérite de <xref:System.Exception>. Si nécessaire, définissez tous les membres uniques requis par votre classe pour fournir des informations supplémentaires relatives à l’exception. Par exemple, le <xref:System.ArgumentException> classe inclut un <xref:System.ArgumentException.ParamName%2A> propriété qui spécifie le nom du paramètre dont l’argument a provoqué l’exception, et le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> propriété inclut un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> propriété qui indique l’intervalle de délai d’attente.  
  
2.  Si nécessaire, substituer des membres hérités dont vous souhaitez modifier ou de modifier les fonctionnalités. Notez qu’existant de la plupart des classes dérivées de <xref:System.Exception> ne remplacent pas le comportement des membres hérités.  
  
3.  Déterminer si votre objet d’exception personnalisé est sérialisable. Sérialisation vous permet d’enregistrer des informations sur l’exception et autorise les informations sur les exceptions à être partagés entre un serveur et un proxy client dans un contexte de communication à distance. Pour rendre l’objet exception sérialisable, marquez-le avec le <xref:System.SerializableAttribute> attribut.  
  
4.  Définir les constructeurs de votre classe d’exception. En règle générale, les classes d’exceptions ont un ou plusieurs des constructeurs suivants :  
  
    -   <xref:System.Exception.%23ctor>, qui utilise les valeurs par défaut pour initialiser les propriétés d’un nouvel objet d’exception.  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>, qui initialise un nouvel objet d’exception avec un message d’erreur spécifié.  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, qui initialise un nouvel objet d’exception avec une erreur spécifiée message et l’exception interne.  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, qui est un `protected` constructeur qui initialise un nouvel objet d’exception à partir des données sérialisées. Vous devez implémenter ce constructeur si vous avez choisi de rendre votre objet d’exception sérialisable.  
  
 L’exemple suivant illustre l’utilisation d’une classe d’exception personnalisée. Il définit un `NotPrimeException` exception levée lorsqu’un client tente de récupérer une séquence de nombres premiers en spécifiant un numéro de départ n’est pas privilégiée. L’exception définit une nouvelle propriété, `NonPrime`, qui retourne le non-nombre premier l’ayant provoqué l’exception. Outre l’implémentation d’un constructeur sans paramètre protégé et un constructeur avec <xref:System.Runtime.Serialization.SerializationInfo> et <xref:System.Runtime.Serialization.StreamingContext> paramètres pour la sérialisation, le `NotPrimeException` classe définit trois constructeurs supplémentaires pour prendre en charge le `NonPrime` propriété.  Chaque constructeur appelle un constructeur de classe de base en plus de la préservation de la valeur du nombre premier. Le `NotPrimeException` est également marquée avec le <xref:System.SerializableAttribute> attribut.  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 Le `PrimeNumberGenerator` classe illustrée dans l’exemple suivant utilise le crible d’Ératosthène pour calculer la séquence de nombres premiers de 2 à une limite spécifiée par le client dans l’appel à son constructeur de classe. Le `GetPrimesFrom` méthode retourne tous les nombres premiers qui sont supérieurs ou égaux à une limite inférieure spécifiée, mais lève une `NotPrimeException` si cette limite inférieure n’est pas un nombre premier.  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 L’exemple suivant effectue deux appels à la `GetPrimesFrom` méthode avec des nombres non premiers, un qui dépasse les limites du domaine d’application. Dans les deux cas, l’exception est levée et gérée correctement dans le code client.  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows Runtime et [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 Dans [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] pour [!INCLUDE[win8](~/includes/win8-md.md)], certaines informations sur l’exception sont généralement perdues lorsqu’une exception est propagée par le biais des frames de pile non .NET Framework. En commençant par le [!INCLUDE[net_v451](~/includes/net-v451-md.md)] et [!INCLUDE[win81](~/includes/win81-md.md)], le common language runtime continue d’utiliser la version d’origine <xref:System.Exception> objet qui a été levée, sauf si cette exception a été modifiée dans un frame de pile non .NET Framework.  
  
   
  
## Examples  
 L’exemple suivant montre un `catch` bloc qui est défini pour gérer <xref:System.ArithmeticException> erreurs. Cela `catch` bloquer également les captures <xref:System.DivideByZeroException> erreurs, car <xref:System.DivideByZeroException> dérive <xref:System.ArithmeticException> et qu’il existe aucune `catch` bloc défini explicitement pour <xref:System.DivideByZeroException> erreurs.  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">Gestion et levée des exceptions</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetage et déploiement de ressources dans des applications de bureau</related>
    <related type="Article" href="http://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">Assertions dans du code managé</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Exception" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Exception" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise la propriété <xref:System.Exception.Message%2A> de la nouvelle instance en lui assignant un message système qui décrit l'erreur et prend en compte la culture du système en cours.  
  
 Toutes les classes dérivées doivent fournir ce constructeur par défaut. Le tableau suivant montre les valeurs initiales des propriétés d'une instance de <xref:System.Exception>.  
  
|Property|Value|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Référence Null (`Nothing` en Visual Basic).|  
|<xref:System.Exception.Message%2A>|Description localisée fournie par le système.|  
  
   
  
## Examples  
 L’exemple de code suivant dérive un `Exception` qui utilise un message prédéfini. Le code illustre l’utilisation du constructeur sans paramètre pour la classe dérivée et la base de `Exception` classe.  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message décrivant l'erreur.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Exception" /> avec un message d'erreur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise la <xref:System.Exception.Message%2A> propriété de la nouvelle instance à l’aide de le `message` paramètre. Si le `message` paramètre est `null`, ceci est le même que si vous appelez le <xref:System.Exception.%23ctor%2A> constructeur.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d'une instance de <xref:System.Exception>.  
  
|Property|Value|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Référence Null (`Nothing` en Visual Basic).|  
|<xref:System.Exception.Message%2A>|Chaîne du message d'erreur.|  
  
   
  
## Examples  
 L’exemple de code suivant dérive un `Exception` pour une condition spécifique. Le code illustre l’utilisation du constructeur qui prend un message spécifié par l’appelant en tant que paramètre, pour la classe dérivée et la base de `Exception` classe.  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les données d'objet sérialisées concernant l'exception levée.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient des informations contextuelles relatives à la source ou à la destination.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Exception" /> avec des données sérialisées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est appelé lors de la désérialisation pour reconstituer l’objet exception transmis sur un flux. Pour plus d’informations, consultez [sérialisation XML et SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
   
  
## Examples  
 L’exemple de code suivant définit une dérivée sérialisable `Exception` classe. Le code impose une erreur de division par 0, puis crée une instance de l’exception dérivée à l’aide du (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) constructeur. Le code sérialise l’instance dans un fichier, désérialise le fichier dans une nouvelle exception, elle lève, puis intercepte et affiche les données de l’exception.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="info" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Le nom de la classe est <see langword="null" /> ou <see cref="P:System.Exception.HResult" /> est zéro (0).</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Sérialisation XML et SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Message d'erreur qui explique la raison de l'exception.</param>
        <param name="innerException">Exception à l'origine de l'exception actuelle, ou une référence null (<see langword="Nothing" /> en Visual Basic) si aucune exception interne n'est spécifiée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Exception" /> avec un message d'erreur spécifié et une référence à l'exception interne ayant provoqué cette exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une exception levée en conséquence directe d'une exception précédente doit contenir une référence à celle-ci dans la propriété <xref:System.Exception.InnerException%2A>. La propriété <xref:System.Exception.InnerException%2A> retourne la même valeur que celle qui a été passée dans le constructeur ou une référence Null (`Nothing` en Visual Basic), si la propriété <xref:System.Exception.InnerException%2A> ne fournit pas la valeur de l'exception interne au constructeur.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d'une instance de <xref:System.Exception>.  
  
|Property|Value|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|La référence à l'exception interne.|  
|<xref:System.Exception.Message%2A>|Chaîne du message d'erreur.|  
  
   
  
## Examples  
 L’exemple de code suivant dérive un `Exception` pour une condition spécifique. Le code illustre l’utilisation du constructeur qui prend un message et une exception interne comme paramètres pour la classe dérivée et la base de `Exception` classe.  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de paires clé/valeur qui fournissent des informations supplémentaires définies par l’utilisateur sur l’exception.</summary>
        <value>Objet qui implémente l'interface <see cref="T:System.Collections.IDictionary" /> et contient une collection de paires clé/valeur définies par l'utilisateur. La valeur par défaut est une collection vide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Collections.IDictionary?displayProperty=nameWithType> objet retourné par la <xref:System.Exception.Data%2A> propriété pour stocker et récupérer des informations supplémentaires concernant l’exception. Les informations sont sous la forme d’un nombre arbitraire de paires clé/valeur définies par l’utilisateur. Le composant clé de chaque paire clé/valeur est généralement une chaîne d’identification, tandis que le composant de valeur de la paire peut être tout type d’objet.  
  
## <a name="keyvalue-pair-security"></a>Sécurité de paire clé/valeur  
 Les paires clé/valeur stockées dans la collection retournée par la <xref:System.Exception.Data%2A> propriété ne sont pas sécurisés. Si votre application appelle une série imbriquée de routines et que chaque routine contient des gestionnaires d’exceptions, la pile des appels qui en résulte contient une hiérarchie de ces gestionnaires d’exceptions. Si une routine de niveau inférieur lève une exception, tout gestionnaire d’exceptions de niveau supérieur dans la hiérarchie de la pile des appels peut lire et/ou modifier les paires clé/valeur stockées dans la collection par n’importe quel autre gestionnaire d’exceptions. Cela signifie que vous devez vous assurer que les informations contenues dans les paires clé/valeur ne sont pas confidentielles et que votre application fonctionnera correctement si les informations contenues dans les paires clé/valeur sont endommagés.  
  
## <a name="key-conflicts"></a>Conflits de clés  
 Un conflit de clés se produit lorsque les gestionnaires d’exceptions différents spécifient la même clé pour accéder à une paire clé/valeur. Soyez prudent lorsque vous développez votre application, car la conséquence d’un conflit de clés est que les gestionnaires d’exceptions de niveau inférieur peuvent communiquer par inadvertance avec des gestionnaires d’exceptions, et cette communication peut provoquer des erreurs de programmation subtiles. Toutefois, si vous êtes prudent, vous pouvez utiliser les conflits de clé pour améliorer votre application.  
  
## <a name="avoiding-key-conflicts"></a>Prévention des conflits de clé  
 Éviter les conflits de clés en adoptant une convention d’affectation de noms pour générer des clés uniques pour les paires clé/valeur. Par exemple, une convention d’affectation de noms peut générer une clé qui se compose du nom séparé de votre application, la méthode qui fournit des informations supplémentaires pour la paire et un identificateur unique.  
  
 Supposons que deux applications, nommées produits et fournisseurs, chacune possède une méthode nommée Sales. La méthode ventes dans l’application produits fournit le numéro d’identification (le stock de stockage ou CDs) d’un produit. La méthode de ventes dans l’application fournisseurs fournit le numéro d’identification, ou SID, d’un fournisseur. Par conséquent, la convention d’affectation de noms pour cet exemple génère les clés, « Produits.ventes.CDs » et « Fournisseurs.ventes.SID ».  
  
## <a name="exploiting-key-conflicts"></a>Exploitant les conflits de clés  
 Exploiter les conflits de clés à l’aide de la présence d’une ou plusieurs clés spéciales et préétablies pour contrôler le traitement. Supposons que, dans un scénario, le Gestionnaire d’exceptions de niveau le plus élevé dans la hiérarchie de la pile des appels intercepte toutes les exceptions levées par les gestionnaires d’exceptions de niveau inférieur. Si une paire clé/valeur avec une clé spéciale existe, le Gestionnaire d’exceptions de haut niveau met en forme les paires clé/valeur restantes dans le <xref:System.Collections.IDictionary> objet d’une certaine façon non standard ; sinon, les paires clé/valeur restants sont mis en forme de façon normale.  
  
 Supposons à présent, dans un autre scénario, que le Gestionnaire d’exceptions à chaque niveau de la hiérarchie de la pile des appels intercepte l’exception levée par le Gestionnaire d’exceptions de niveau inférieur suivant. De plus, chaque gestionnaire d’exceptions sait que la collection retournée par la <xref:System.Exception.Data%2A> propriété contient un ensemble de paires clé/valeur qui est accessible avec un ensemble préétablie de clés.  
  
 Chaque gestionnaire d’exceptions utilise l’ensemble préétablie de clés pour mettre à jour le composant de valeur de la paire clé/valeur correspondante avec des informations propres à ce gestionnaire d’exceptions. Une fois le processus de mise à jour terminé, le Gestionnaire d’exceptions lève l’exception au gestionnaire d’exceptions de niveau supérieur suivant. Enfin, le Gestionnaire d’exceptions de niveau le plus élevé accède aux paires clé/valeur et affiche les informations de mise à jour consolidé à partir de tous les gestionnaires d’exceptions de niveau inférieur.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter et récupérer des informations à l’aide du <xref:System.Exception.Data%2A> propriété.  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, retourne la <see cref="T:System.Exception" /> qui est à l'origine d'une ou de plusieurs exceptions ultérieures.</summary>
        <returns>Première exception levée dans une chaîne d'exceptions. Si la propriété <see cref="P:System.Exception.InnerException" /> de l'exception actuelle est une référence null (<see langword="Nothing" /> en Visual Basic), cette propriété retourne l'exception actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une chaîne d’exceptions se compose d’un ensemble d’exceptions où chaque exception de la chaîne a été levée en conséquence directe de l’exception référencée dans sa `InnerException` propriété. Pour une chaîne donnée, il peut y avoir exactement une exception qui est la cause racine de toutes les autres exceptions dans la chaîne. Cette exception est appelée à l’exception de base et ses `InnerException` propriété contient toujours une référence null.  
  
 Pour toutes les exceptions dans une chaîne d’exceptions, la `GetBaseException` méthode doit retourner le même objet (l’exception de base).  
  
 Utilisez le `GetBaseException` méthode lorsque vous souhaitez trouver la cause d’une exception mais que vous n’avez pas besoin d’informations sur les exceptions qui se sont produites entre l’exception actuelle et la première exception.  
  
   
  
## Examples  
 L’exemple de code suivant définit deux dérivés `Exception` classes. Il force une exception et lève à nouveau avec chacune des classes dérivées. Le code illustre l’utilisation de la `GetBaseException` méthode pour récupérer l’exception d’origine.  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Le <see langword="GetBaseException" /> méthode est substituée dans les classes qui requièrent un contrôle le format ou le contenu de l’exception.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les données d'objet sérialisées concernant l'exception levée.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient des informations contextuelles relatives à la source ou à la destination.</param>
        <summary>En cas de substitution dans une classe dérivée, définit <see cref="T:System.Runtime.Serialization.SerializationInfo" /> avec des informations sur l'exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` définit <xref:System.Runtime.Serialization.SerializationInfo> avec toutes les données de l'objet exception ciblées en vue d'une sérialisation. Au cours de la désérialisation, l'exception est reconstituée à partir de l'`SerializationInfo` transmises sur le flux.  
  
   
  
## Examples  
 L’exemple de code suivant définit une dérivée sérialisable `Exception` classe qui implémente `GetObjectData`, qui apporte des modifications mineures à deux propriétés, et puis appelle la classe de base pour effectuer la sérialisation. L’exemple impose une erreur de division par 0, puis crée une instance de l’exception dérivée. Le code sérialise l’instance dans un fichier, désérialise le fichier dans une nouvelle exception, elle lève, puis intercepte et affiche les données de l’exception.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="info" /> est une référence null (<see langword="Nothing" /> en Visual Basic).</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le type au moment de l'exécution de l'instance actuelle.</summary>
        <returns>Objet <see cref="T:System.Type" /> qui représente le type exact au moment de l'exécution de l'instance actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Exception.GetType%2A> méthode existe pour prendre en charge l’infrastructure .NET Framework et appelle en interne la méthode fondamentale, <xref:System.Object.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un lien vers le fichier d'aide associé à cette exception.</summary>
        <value>URN (Uniform Resource Name) ou URL (Uniform Resource Locator).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de retour, qui représente un fichier d'aide, est une adresse URN ou URL. Par exemple, le `HelpLink` valeur pourrait être :  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 Le code suivant exemple lève une `Exception` qui définit le `HelpLink` propriété dans son constructeur, puis intercepte l’exception et l’affiche `HelpLink`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit HRESULT, valeur numérique codée qui est assignée à une exception spécifique.</summary>
        <value>Valeur HRESULT.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT est une valeur 32 bits, divisée en trois champs : un code de gravité, un code de service et un code d’erreur. Le code de gravité indique si la valeur de retour représente les informations, avertissement ou erreur. Le code de service identifie la zone du système responsable de l’erreur. Le code d’erreur est un nombre unique affecté pour représenter une exception. Chaque exception est mappée à une valeur HRESULT distincte. Lorsque le code managé lève une exception, le runtime passe la valeur HRESULT au client COM. Lorsque le code non managé retourne une erreur, le HRESULT est converti en une exception, qui est ensuite levée par le runtime. Pour plus d’informations sur les valeurs HRESULT et les exceptions de .NET Framework correspondantes, consultez [Comment : Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md). Consultez [valeurs HRESULT courantes](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) dans la documentation de Windows pour obtenir la liste des valeurs que vous êtes plus susceptible de rencontrer.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], le <xref:System.Exception.HResult%2A> accesseur Set de la propriété est protégé, tandis que sa méthode getter est public.  Dans les versions précédentes du .NET Framework, les méthodes getter et setter sont protégées.  
  
   
  
## Examples  
 L’exemple de code suivant définit une dérivée `Exception` classe qui définit le `HResult` propriété à une valeur personnalisée dans son constructeur.  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">Comment : mapper des HRESULT et des exceptions</related>
        <related type="ExternalDocumentation" href="http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">Valeurs HRESULT courantes</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'instance <see cref="T:System.Exception" /> qui a provoqué l'exception actuelle.</summary>
        <value>Objet décrivant l'erreur qui a provoqué l'exception actuelle. La propriété <see cref="P:System.Exception.InnerException" /> retourne la même valeur que celle transmise au constructeur <see cref="M:System.Exception.#ctor(System.String,System.Exception)" />, ou <see langword="null" /> si la valeur de l'exception interne n'a pas été fournie au constructeur. Cette propriété est en lecture seule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’une exception `X` est levée en conséquence directe d’une exception précédente `Y`, le <xref:System.Exception.InnerException%2A> propriété du `X` doit contenir une référence à `Y`.  
  
 Utilisez la propriété <xref:System.Exception.InnerException%2A> pour obtenir l'ensemble d'exceptions ayant provoqué l'exception en cours.  
  
 Vous pouvez créer une nouvelle exception qui intercepte une exception antérieure. Le code qui gère la deuxième exception peut utiliser les informations supplémentaires à partir de l’exception antérieure pour gérer l’erreur plus convenablement.  
  
 Supposons qu’une fonction qui lit un fichier et met en forme les données à partir de ce fichier. Dans cet exemple, en tant que le code essaie de lire le fichier, un <xref:System.IO.IOException> est levée. La fonction intercepte la <xref:System.IO.IOException> et lève un <xref:System.IO.FileNotFoundException>. Le <xref:System.IO.IOException> peut être enregistré dans le <xref:System.Exception.InnerException%2A> propriété de la <xref:System.IO.FileNotFoundException>, permettre au code qui intercepte la <xref:System.IO.FileNotFoundException> pour examiner la cause de l’erreur initiale.  
  
 Le <xref:System.Exception.InnerException%2A> propriété, qui contient une référence à l’exception interne, est définie lors de l’initialisation de l’objet exception.  
  
   
  
## Examples  
 L’exemple suivant illustre la levée et l’interception d’une exception qui fait référence à une exception interne.  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un message qui décrit l'exception actuelle.</summary>
        <value>Message d'erreur qui explique la raison de l'exception ou bien chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Messages d’erreur ciblent le développeur qui gère l’exception. Le texte de la <xref:System.Exception.Message%2A> propriété doit décrire complètement l’erreur et, dans la mesure du possible, doit également comment corriger l’erreur. Gestionnaires d’exceptions de niveau supérieur peuvent afficher le message aux utilisateurs finaux, afin de vous assurer qu’il est grammaticalement correct et que chaque phrase du message se termine par un point. N’utilisez pas de points d’interrogation ou des points d’exclamation. Si votre application utilise des messages d’exception localisé, vous devez vous assurer qu’elles sont traduites correctement.  
  
> [!IMPORTANT]
>  Ne pas divulguer des informations sensibles dans les messages d’exception sans vérifier les autorisations appropriées.  
  
 La valeur de la <xref:System.Exception.Message%2A> propriété est incluse dans les informations retournées par <xref:System.Exception.ToString%2A>. Le <xref:System.Exception.Message%2A> propriété est définie uniquement lorsque vous créez un <xref:System.Exception>. Si aucun message n’a été fourni au constructeur pour l’instance actuelle, le système fournit un message par défaut qui est mis en forme à l’aide de la culture système actuelle.  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows Runtime et [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 En commençant par le [!INCLUDE[net_v451](~/includes/net-v451-md.md)] et [!INCLUDE[win81](~/includes/win81-md.md)], la fidélité des messages d’erreur à partir d’exceptions qui sont propagés à partir des types Windows Runtime et les membres qui ne font pas partie du .NET Framework est améliorée. En particulier, messages d’exception à partir des extensions de composant Visual C++ (C++ / c++ / CX) sont maintenant propagées dans .NET Framework <xref:System.Exception> objets.  
  
   
  
## Examples  
 L’exemple de code suivant lève, puis intercepte un <xref:System.Exception> exception et affiche le texte de l’exception message en utilisant le <xref:System.Exception.Message%2A> propriété.
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si vous levez une exception à partir d’une propriété, et que vous avez besoin faire référence dans le texte de <see cref="P:System.Exception.Message" /> à l’argument de propriété que vous définissez ou obtenez, utilisez « valeur » en tant que le nom de l’argument de la propriété.</para>
        </block>
        <block subset="none" type="overrides">
          <para>Le <see cref="P:System.Exception.Message" /> est substituée dans les classes qui requièrent un contrôle de contenu de message ou le format. Code de l’application accède généralement à cette propriété lorsqu’il a besoin pour afficher des informations sur une exception qui a été interceptée.  
  
Le message d’erreur doit être localisé.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand une exception est sérialisée pour créer un objet d'état d'exception qui contient des données sérialisées concernant l'exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet d’état exception implémente le <xref:System.Runtime.Serialization.ISafeSerializationData> interface.  
  
 Lorsque le <xref:System.Exception.SerializeObjectState> est abonné à l’événement, l’exception est désérialisée et créée en tant qu’une exception vide. Le constructeur d’exception n’est pas exécuté, et l’état d’exception est également désérialisé. Le <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> méthode de rappel de l’objet exception d’état est ensuite notifié afin qu’il puisse pousser les données désérialisées dans l’exception vide.  
  
 Le <xref:System.Exception.SerializeObjectState> événement permet aux types d’exception transparents sérialiser et désérialiser des données d’exception. Le code transparent peut exécuter des commandes dans les limites du jeu d’autorisations qu’il fonctionne, mais ne peut pas exécuter, appeler, dériver à partir d’ou contenir du code critique.  
  
 Si le <xref:System.Exception.SerializeObjectState> n'est pas abonné à l’événement, la désérialisation se produit comme d’habitude à l’aide de la <xref:System.Exception.%23ctor%2A> constructeur.  
  
 En règle générale, un gestionnaire pour le <xref:System.Exception.SerializeObjectState> événement est ajouté dans le constructeur d’exception à fournir pour sa sérialisation. Mais étant donné que le constructeur n’est pas exécuté lorsque le <xref:System.Exception.SerializeObjectState> Gestionnaire d’événements s’exécute, la sérialisation d’une exception désérialisée peut lever une <xref:System.Runtime.Serialization.SerializationException> exception lorsque vous tentez de désérialiser l’exception. Pour éviter ce problème, vous devez également ajouter le gestionnaire pour le <xref:System.Exception.SerializeObjectState> événement dans le <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> (méthode). Consultez la section exemples pour obtenir une illustration.  
  
   
  
## Examples  
 L’exemple suivant définit un `BadDivisionException` qui gère la <xref:System.Exception.SerializeObjectState> événement. Il contient également un objet d’état, qui est imbriquée structure nommée `BadDivisionExceptionState` qui implémente le <xref:System.Runtime.Serialization.ISafeSerializationData> interface.  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 Le `BadDivisionException` exception est levée lorsqu’une division à virgule flottante par zéro se produit. Lors de la première division par zéro, l’exemple instancie un `BadDivisionException` objet, il sérialise et lève l’exception. Lorsque des divisions suivantes par zéro se produisent, l’exemple désérialise l’objet précédemment sérialisé resérialise il et lève l’exception. Pour fournir à la sérialisation des objets, la désérialisation, resérialisation et la désérialisation, l’exemple ajoute le <xref:System.Exception.SerializeObjectState> Gestionnaire d’événements à la fois dans le `BadDivisionException` constructeur de classe et dans le <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> implémentation.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si cet événement est abonné à et utilisé, tous les types dérivés qui se suivent dans la hiérarchie d’héritage doivent implémenter le même mécanisme de sérialisation.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de l'application ou de l'objet qui est à l'origine de l'erreur.</summary>
        <value>Nom de l'application ou de l'objet qui est à l'origine de l'erreur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Exception.Source%2A> propriété n’est pas définie explicitement, le runtime définit automatiquement le nom de l’assembly d'où provient l’exception.  
  
   
  
## Examples  
 L’exemple suivant lève une `Exception` qui définit le `Source` propriété dans son constructeur, puis intercepte l’exception et l’affiche `Source`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’objet doit être un objet <see cref="N:System.Reflection" /> d’exécution.</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une représentation sous forme de chaîne des frames immédiats sur la pile des appels.</summary>
        <value>Chaîne qui décrit les frames immédiates de la pile des appels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La pile d'exécution assure le suivi de toutes les méthodes qui sont en cours d'exécution à un moment donné. La trace des appels de méthodes s'appelle la trace de la pile. La liste de trace de pile fournit un moyen de suivre la pile des appels au numéro de ligne dans la méthode où l’exception se produit.  
  
 Le <xref:System.Exception.StackTrace%2A> propriété retourne les frames de la pile des appels qui proviennent de l’emplacement où l’exception a été levée. Vous pouvez obtenir des informations sur les frames supplémentaires dans la pile des appels en créant une nouvelle instance de la <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> classe et à l’aide de son <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> (méthode).  
  
 Le common language runtime (CLR) met à jour la trace de pile chaque fois qu’une exception est levée dans le code d’application (à l’aide de la `throw` mot clé). Si l’exception est levée à nouveau dans une méthode qui est différente de celle de la méthode où elle a été levée à l’origine, la trace de pile contient l’emplacement dans la méthode où l’exception a été levée initialement et l’emplacement dans la méthode où l’exception a été à nouveau levée. Si l’exception est levée et levée ensuite à nouveau dans la même méthode, la trace de pile contient uniquement l’emplacement où l’exception a été levée et n’inclut pas l’emplacement où l’exception a été levée initialement.  
  
 Le <xref:System.Exception.StackTrace%2A> propriété peut ne pas signale autant d’appels de méthode comme prévu en raison des transformations de code, tel qu’incorporation, qui se produisent pendant l’optimisation.  
  
   
  
## Examples  
 Le code suivant exemple lève une `Exception` intercepte et affiche une trace de pile à l’aide de la `StackTrace` propriété.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Le <see langword="StackTrace" /> est substituée dans les classes qui requièrent un contrôle le format ou le contenu de trace de pile.  
  
Par défaut, la trace de pile est capturée immédiatement avant qu’un objet d’exception soit levé. Utilisez <see cref="P:System.Environment.StackTrace" /> pour obtenir des informations de trace de pile quand aucune exception n’est levée.</para>
        </block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la méthode qui lève l'exception actuelle.</summary>
        <value>
          <see cref="T:System.Reflection.MethodBase" /> qui a levé l'exception actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la méthode qui lève cette exception n’est pas disponible et la trace de pile n’est pas une référence null (`Nothing` en Visual Basic), <xref:System.Exception.TargetSite%2A> Obtient la méthode à partir de la trace de pile. Si la trace de la pile est une référence nulle, <xref:System.Exception.TargetSite%2A> retourne également une référence nulle.  
  
> [!NOTE]
>  Le <xref:System.Exception.TargetSite%2A> propriété ne peut pas signaler correctement le nom de la méthode dans laquelle une exception a été levée si le Gestionnaire d’exceptions gère une exception sur les limites du domaine d’application.  
  
   
  
## Examples  
 Le code suivant exemple lève une `Exception` intercepte et affiche la méthode d’origine à l’aide du `TargetSite` propriété.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée et retourne une chaîne représentant l'exception actuelle.</summary>
        <returns>Représentation sous forme de chaîne de l'exception actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> Retourne une représentation de l’exception actuelle est destinée à être compréhensible par les utilisateurs. Lorsque l’exception contient des données de la culture, la représentation sous forme de chaîne retournée par `ToString` est requise pour prendre en compte la culture système actuelle. Bien qu’il n’existe aucune configuration requise exacte pour le format de la chaîne retournée, il doit tenter de refléter la valeur de l’objet en tant que perçue par l’utilisateur.  
  
 L’implémentation par défaut de <xref:System.Exception.ToString%2A> Obtient le nom de la classe qui a levé l’exception actuelle, le message, le résultat de l’appel <xref:System.Exception.ToString%2A> sur l’exception interne et le résultat de l’appel <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>. Si un de ces membres est `null`, sa valeur n’est pas incluse dans la chaîne retournée.  
  
 S’il n’existe aucun message d’erreur ou s’il s’agit d’une chaîne vide (" »), aucun message d’erreur est retournée. Le nom de l’exception interne et la trace de pile sont retournés uniquement s’ils ne sont pas `null`.  
  
 Cette méthode se substitue à <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant provoque une exception et affiche le résultat de l’appel <xref:System.Exception.ToString%2A> sur cette exception. Notez que le <xref:System.Exception.ToString%2A?displayProperty=nameWithType> méthode est appelée implicitement lorsque l’instance de classe d’Exception s’affiche dans la liste d’arguments de la <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>