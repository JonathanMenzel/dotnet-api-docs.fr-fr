<Type Name="String" FullName="System.String">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7bf2d0223b77d7a3205fcbcc0fc27d643d2e78a8" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36432027" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente le texte en tant que séquence d’unités de code UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Une chaîne est une collection séquentielle de caractères qui est utilisée pour représenter du texte. A <xref:System.String> objet est une collection séquentielle de <xref:System.Char?displayProperty=nameWithType> des objets qui représentent une chaîne, un <xref:System.Char?displayProperty=nameWithType> objet correspond à une unité de code UTF-16. La valeur de la <xref:System.String> objet est le contenu de la collection séquentielle de <xref:System.Char?displayProperty=nameWithType> objets, et que la valeur est immuable (autrement dit, il est en lecture seule). Pour plus d’informations sur l’immuabilité des chaînes, consultez le [immuabilité et la classe StringBuilder](#Immutability) section plus loin dans cette rubrique. La taille maximale d’un <xref:System.String> objet en mémoire est de 2 Go ou environ 1 milliard de caractères.  
  
 Dans cette section :  
  
 [Instanciation d’un objet de chaîne](#Instantiation)   
 [Objets char et caractères Unicode](#Characters)   
 [Chaînes et la norme Unicode](#Unicode)   
 [Chaînes et caractères null incorporés](#EmbeddedNulls)   
 [Chaînes et des index](#Indexes)   
 [Chaînes null et les chaînes vides](#Nulls)   
 [Immuabilité et la classe StringBuilder](#Immutability)   
 [Ordinal et les opérations dépendantes de la culture](#CultureSensitive)   
 [Normalisation](#Normalization)   
 [Opérations de chaîne par catégorie](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Instanciation d’un objet de chaîne  
 Vous pouvez instancier un <xref:System.String> objet comme suit :  
  
-   En assignant un littéral de chaîne en un <xref:System.String> variable. Il s’agit de la méthode la plus couramment utilisée pour la création d’une chaîne. L’exemple suivant utilise l’attribution à créer plusieurs chaînes. Notez que dans c#, étant donné que la barre oblique inverse (\\) est un caractère d’échappement, des barres obliques inverses littérales dans une chaîne doivent être échappés ou la chaîne entière doit être @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   En appelant un <xref:System.String> constructeur de classe. L’exemple suivant instancie des chaînes en appelant plusieurs constructeurs de classe. Notez que certains constructeurs incluent des pointeurs vers des tableaux de caractères ou des tableaux d’octets signés en tant que paramètres. Visual Basic ne prend pas en charge les appels à ces constructeurs. Pour plus d’informations sur les <xref:System.String> constructeurs, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   À l’aide de l’opérateur de concaténation (+ en c# et & ou + en Visual Basic) pour créer une chaîne unique à partir de n’importe quelle combinaison de <xref:System.String> instances et les littéraux de chaîne. L’exemple suivant illustre l’utilisation de l’opérateur de concaténation de chaîne.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   En extrayant une propriété ou en appelant une méthode qui retourne une chaîne. L’exemple suivant utilise les méthodes de la <xref:System.String> classe pour extraire une sous-chaîne d’une chaîne plus grande.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   En appelant une méthode de mise en forme pour convertir une valeur ou un objet en sa représentation sous forme de chaîne. L’exemple suivant utilise le [mise en forme composite](~/docs/standard/base-types/composite-formatting.md) fonctionnalité pour incorporer la représentation sous forme de chaîne de deux objets dans une chaîne.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Objets char et caractères Unicode  
 Chaque caractère dans une chaîne est défini par une valeur scalaire Unicode, également appelée point de code Unicode ou la valeur ordinale (numérique) du caractère Unicode. Chaque point de code est encodé à l’aide de l’encodage UTF-16 et la valeur numérique de chaque élément de l’encodage est représentée par un <xref:System.Char> objet.  
  
> [!NOTE]
>  Notez que, car un <xref:System.String> instance se compose d’une collection séquentielle d’unités de code UTF-16, il est possible de créer un <xref:System.String> objet qui n’est pas une chaîne Unicode bien formée. Par exemple, il est possible de créer une chaîne qui possède un substitut faible sans un substitut correspondant. Bien que certaines méthodes, telles que les méthodes de codage et décodage d’objets dans le <xref:System.Text> espace de noms peut effectue des vérifications pour vous assurer que les chaînes sont bien formées, <xref:System.String> membres de classe ne garantissent pas qu’une chaîne est bien formée.  
  
 Un seul <xref:System.Char> objet représente généralement un seul point de code, autrement dit, la valeur numérique de la <xref:System.Char> est égale au point de code. Par exemple, le point de code pour le caractère « a » est U + 0061. Toutefois, un point de code peut nécessiter plusieurs éléments encodés (plusieurs <xref:System.Char> objet). La norme Unicode définit deux types de caractères qui correspondent à plusieurs <xref:System.Char> objets : graphèmes et les points de code supplémentaires Unicode qui correspondent aux caractères dans les plans supplémentaires Unicode.  
  
-   Un groupes de graphèmes est représenté par un caractère de base suivi par un ou plusieurs caractères d’association. Par exemple, le caractère « ä » est représenté par un <xref:System.Char> objet dont le point de code est U + 0061, suivi par un <xref:System.Char> objet dont le point de code est U + 0308. Ce caractère peut également être défini par un seul <xref:System.Char> objet qui a un point de code de U + 00E4. Comme le montre l’exemple suivant, une comparaison dépendante de la culture d’égalité indique que ces deux représentations sont égales, même si n’est pas le cas d’une comparaison ordinale ordinaire. Toutefois, si les deux chaînes sont normalisées, une comparaison ordinale indique également qu’ils sont égaux. (Pour plus d’informations sur la normalisation de chaînes, consultez le [normalisation](#Normalization) section.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode point de code supplémentaire (une paire de substitution) est représenté par un <xref:System.Char> objet dont le point de code est un substitut étendu suivi par un <xref:System.Char> objet dont le point de code est un substitut faible. Les unités de code de substituts haute comprise entre U + D800 et U + DBFF. Les unités de code de substitut faible comprise entre U + DC00 et U + DFFF. Les paires de substitution sont utilisés pour représenter des caractères dans les plans supplémentaires Unicode 16. L’exemple suivant crée un caractère de substitution et passe à la <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> méthode pour déterminer s’il s’agit d’une paire de substitution.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Chaînes et la norme Unicode  
 Caractères dans une chaîne sont représentés par des unités de code encodée en UTF-16, qui correspondent aux <xref:System.Char> valeurs.  
  
 Chaque caractère d’une chaîne a une catégorie de caractères Unicode associée, qui est représentée dans le .NET Framework par la <xref:System.Globalization.UnicodeCategory> énumération. La catégorie d’un caractère ou une paire de substitution peut être déterminée en appelant le <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> (méthode).  
  
 .NET gère sa propre table des caractères et leurs catégories correspondants, ce qui garantit qu’une version spécifique d’une implémentation .NET en cours d’exécution sur différentes plateformes retourne des informations de catégorie de caractères identiques. Le tableau suivant répertorie les versions du .NET et les versions de la norme Unicode sur lesquelles reposent les catégories de caractères.  
  
|Version du .NET Framework|Version de la norme Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[La norme Unicode, Version 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|Le .NET Framework 2.0|[La norme Unicode, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[La norme Unicode, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[La norme Unicode, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]|[La norme Unicode, Version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/includes/net-v451-md.md)]|[La norme Unicode, Version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/includes/net-v452-md.md)]|[La norme Unicode, Version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/includes/net-v46-md.md)]|[La norme Unicode, Version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/includes/net-v461-md.md)]|[La norme Unicode, Version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/includes/net-v462-md.md)]|[La norme Unicode, Version 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/)|  
|.NET core (toutes versions)|[La norme Unicode, Version 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/)|
  
 En outre, le .NET Framework prend en charge la comparaison de chaînes et le tri basé sur la norme Unicode. Dans les versions du .NET Framework via le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le .NET Framework gère sa propre table des données de chaîne. Cela vaut également pour des versions du .NET Framework en commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] s’exécutant sur Windows 7. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] en cours d’exécution sur Windows 8 et versions ultérieures du système d’exploitation Windows, les délégués de l’exécution de chaîne comparaison et tri des opérations du système d’exploitation. Le tableau suivant répertorie les versions du .NET Framework et les versions de la norme Unicode sur le caractère de comparaison et tri sont basées.  
  
|Version du .NET Framework|Version de la norme Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[La norme Unicode, Version 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|Le .NET Framework 2.0|[La norme Unicode, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[La norme Unicode, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[La norme Unicode, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] et versions ultérieures de Windows 7|[La norme Unicode, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] et versions ultérieures de Windows 8 et ultérieures|[La norme Unicode, Version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  

Dans le .NET Core, les opérations de tri et de comparaison sont basées sur [Version8.0.0 de la norme Unicode](https://www.unicode.org/versions/Unicode8.0.0/).

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Chaînes et caractères null incorporés  
 Dans le .NET Framework, un <xref:System.String> objet peut inclure des caractères null incorporés, qui comptent dans la longueur de chaîne. Toutefois, dans certains langages tels que C et C++, un caractère null indique la fin d’une chaîne ; il n’est pas considéré comme une partie de la chaîne et n’est pas compté dans le cadre de la longueur de chaîne. Cela signifie que les hypothèses courantes suivantes, les programmeurs C et C++ ou écrites en C ou C++ qui peuvent être sur les chaînes ne sont pas nécessairement valides lorsqu’il est appliqué à <xref:System.String> objets :  
  
-   La valeur retournée par la `strlen` ou `wcslen` fonctions n’est pas nécessairement égal <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   La chaîne créée par le `strcpy_s` ou `wcscpy_s` fonctions n’est pas nécessairement identique à la chaîne créée par le <xref:System.String.Copy%2A?displayProperty=nameWithType> (méthode).  
  
 Vous devez vous assurer que code C et C++ natif qui instancie <xref:System.String> objets et le code qui est passé <xref:System.String> objets via la plateforme de code non managé, ne supposez pas qu’un caractère null incorporé marque la fin de la chaîne.  
  
 Les caractères null incorporés dans une chaîne sont également traités différemment lorsqu’une chaîne est triée (ou comparée) et lorsqu’une chaîne de recherche est effectuée. Les caractères null sont ignorés lors de l’exécution de comparaisons dépendantes de la culture entre deux chaînes, notamment des comparaisons à l’aide de la culture dite indifférente. Elles sont considérées comme uniquement pour les comparaisons ordinales ordinales ou non la casse. En revanche, les caractères null incorporés sont toujours considérées comme lors de la recherche d’une chaîne avec des méthodes telles que <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, et <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Chaînes et des index  
 Un index est la position d’un <xref:System.Char> objet (pas un caractère Unicode) dans un <xref:System.String>. Un index est un nombre non négatif de base zéro qui commence à partir de la première position dans la chaîne, qui est la position d’index zéro. Un nombre de méthodes de recherche, tels que <xref:System.String.IndexOf%2A> et <xref:System.String.LastIndexOf%2A>, retourner l’index d’un caractère ou d’une sous-chaîne dans l’instance de chaîne.  
  
 Le <xref:System.String.Chars%2A> propriété vous permet d’accéder à des <xref:System.Char> les objets par leur position d’index dans la chaîne. Étant donné que la <xref:System.String.Chars%2A> propriété est la propriété par défaut (en Visual Basic) ou l’indexeur (en c#), vous pouvez accéder à la personne <xref:System.Char> objets dans une chaîne en utilisant le code suivant. Ce code recherche des espaces blancs ou des caractères de ponctuation dans une chaîne pour déterminer la chaîne contient le nombre de mots.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Car le <xref:System.String> la classe implémente la <xref:System.Collections.IEnumerable> interface, vous pouvez également itérer la <xref:System.Char> objets dans une chaîne à l’aide un `foreach` construction, comme le montre l’exemple suivant.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Valeurs d’index consécutives ne peuvent pas correspondre à des caractères Unicode consécutifs, car un caractère peut être encodé en Unicode de plusieurs <xref:System.Char> objet. En particulier, une chaîne peut contenir plusieurs caractères unités de texte qui sont formées par un caractère de base suivi par un ou plusieurs caractères d’association ou par les paires de substitution. Pour travailler avec des caractères Unicode à la place de <xref:System.Char> objets, utilisez la <xref:System.Globalization.StringInfo?displayProperty=nameWithType> et <xref:System.Globalization.TextElementEnumerator> classes. L’exemple suivant illustre la différence entre le code qui fonctionne avec <xref:System.Char> objets et du code qui fonctionne avec des caractères Unicode. Il compare le nombre de caractères ou des éléments de texte de chaque mot d’une phrase. La chaîne inclut deux séquences d’un caractère de base suivi par un caractère d’association.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 Cet exemple fonctionne avec les éléments de texte à l’aide de la <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> (méthode) et la <xref:System.Globalization.TextElementEnumerator> classe pour énumérer tous les éléments de texte dans une chaîne. Vous pouvez également récupérer un tableau qui contient l’index de début de chaque élément de texte en appelant le <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur l’utilisation des unités de texte plutôt que personne <xref:System.Char> valeurs, consultez la <xref:System.Globalization.StringInfo> classe.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Chaînes null et les chaînes vides  
 Une chaîne qui a été déclarée mais n’a pas été attribuée une valeur est `null`. Toute tentative d’appel de méthodes sur cette chaîne lève un <xref:System.NullReferenceException>. Une chaîne null est différente d’une chaîne vide, qui est une chaîne dont la valeur est « » ou <xref:System.String.Empty?displayProperty=nameWithType>. Dans certains cas, en passant une chaîne null ou une chaîne vide en tant qu’argument dans un appel de méthode lève une exception. Par exemple, en passant une chaîne null pour le <xref:System.Int32.Parse%2A?displayProperty=nameWithType> méthode lève une exception une <xref:System.ArgumentNullException>et en passant une chaîne vide lève une <xref:System.FormatException>. Dans d’autres cas, un argument de méthode peut être une chaîne null ou une chaîne vide. Par exemple, si vous fournissez un <xref:System.IFormattable> implémentation pour une classe, doivent correspondre à la fois une chaîne null et une chaîne vide avec le spécificateur de format général (« G »).  
  
 Le <xref:System.String> classe inclut les deux méthodes pratiques suivantes qui vous permettent de tester si une chaîne est `null` ou vide :  
  
-   <xref:System.String.IsNullOrEmpty%2A>, qui indique si une chaîne est `null` ou égale à <xref:System.String.Empty?displayProperty=nameWithType>. Cette méthode élimine le besoin d’utiliser du code semblable au suivant :  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, qui indique si une chaîne est `null`, est égal à <xref:System.String.Empty?displayProperty=nameWithType>, ou est composé exclusivement d’espaces blancs. Cette méthode élimine le besoin d’utiliser du code semblable au suivant :  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 L’exemple suivant utilise le <xref:System.String.IsNullOrEmpty%2A> méthode dans le <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implémentation de personnalisé `Temperature` classe. La méthode prend en charge les chaînes de format « G », « C », « F » et « K ». Si une chaîne de format vide ou un format de chaîne dont la valeur est `null` est passé à la méthode, sa valeur est remplacée par la chaîne de format « G ».  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Immuabilité et la classe StringBuilder  
 A <xref:System.String> objet est appelé immuable (lecture seule), car sa valeur ne peut pas être modifiée une fois qu’elle a été créée. Les méthodes qui semblent modifier un <xref:System.String> objet réellement retournent un nouvel <xref:System.String> objet qui contient la modification.  
  
 Étant donné que les chaînes sont immuables, les routines de manipulation de chaîne qui effectuent des répété ajouts ou suppressions à ce qui semble être qu'une chaîne unique peut peser une baisse significative des performances. Par exemple, le code suivant utilise un générateur de nombres aléatoires pour créer une chaîne avec 1 000 caractères dans la plage 0 x 0001 à 0x052F. Bien que le code s’affiche à la concaténation de chaînes permet d’ajouter un nouveau caractère à la chaîne existante nommée `str`, elle crée un nouveau <xref:System.String> objet pour chaque opération de concaténation.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Vous pouvez utiliser la <xref:System.Text.StringBuilder> classe au lieu du <xref:System.String> classe pour les opérations qui apportent plusieurs modifications à la valeur d’une chaîne. Contrairement aux instances de la <xref:System.String> (classe), <xref:System.Text.StringBuilder> objets sont mutables ; lorsque vous concaténez, ajoutez ou supprimez des sous-chaînes d’une chaîne, les opérations sont effectuées sur une seule chaîne. Lorsque vous avez terminé de modifier la valeur d’un <xref:System.Text.StringBuilder> de l’objet, vous pouvez appeler son <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> méthode pour le convertir en une chaîne. L’exemple suivant remplace le <xref:System.String> utilisé dans l’exemple précédent pour concaténer les 1000 de caractères aléatoires dans la plage de 0 x 0001 à 0x052F avec un <xref:System.Text.StringBuilder> objet.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Ordinal et les opérations dépendantes de la culture  
 Membres de la <xref:System.String> classe opérations ordinales ou dépendantes de la culture (linguistique) sur un <xref:System.String> objet. Une opération ordinale agit sur la valeur numérique de chaque <xref:System.Char> objet. A lieu une opération dépendante de la culture de la valeur de la <xref:System.String> objet et prend la casse spécifiques à la culture, le tri, de mise en forme et règles d’analyse en compte. Les opérations dépendantes de la culture s’exécutent dans le contexte d’une culture déclarée de manière explicite ou de la culture en cours implicite. Les deux types d’opérations peuvent produire des résultats très différents lorsqu’ils sont exécutés sur la même chaîne.  
  
 Le .NET Framework prend également en charge les opérations de chaînes linguistique indépendante de la culture à l’aide de la culture dite indifférente (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), qui est faiblement basé sur les paramètres de culture de la langue anglaise indépendante de la région. Contrairement à d’autres <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> sont garanti que les paramètres, les paramètres de la culture dite indifférente restent cohérentes sur un seul ordinateur, à partir du système au système et entre les versions du .NET Framework. La culture dite indifférente peut être considéré comme étant un type de zone noire qui garantit la stabilité des comparaisons de chaînes et de tri dans toutes les cultures.  
  
> [!IMPORTANT]
>  Si votre application prend une décision de sécurité sur un identificateur symbolique tel qu’un nom de fichier ou canal nommé, ou des données rendues persistantes telles que les données textuelles dans un fichier XML, l’opération doit utiliser une comparaison ordinale au lieu d’une comparaison dépendante de la culture. Il s’agit, car une comparaison dépendante de la culture peut produire des résultats différents selon la culture en vigueur, tandis qu’une comparaison ordinale dépend uniquement de la valeur binaire des caractères comparés.  
  
> [!IMPORTANT]
>  La plupart des méthodes qui effectuent des opérations de chaîne incluent une surcharge qui a un paramètre de type <xref:System.StringComparison>, ce qui vous permet de spécifier si la méthode effectue une opération ordinale ou dépendante de la culture. En règle générale, vous devez appeler cette surcharge pour appeler l’intention de votre méthode clear. Pour les meilleures pratiques et les instructions d’utilisation des ordinale et dépendante de la culture des opérations sur les chaînes, consultez [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 Opérations pour [casse](#casing), [l’analyse et de mise en forme](#parsing), [comparaison et tri](#comparison), et [test d’égalité](#equality) peut être soit ordinal ou sensible à la culture. Les sections suivantes décrivent chaque catégorie d’opération.  
  
> [!TIP]
>  Vous devez toujours appeler une surcharge de méthode qui appelle l’intention de votre méthode clear. Par exemple, au lieu d’appeler le <xref:System.String.Compare%28System.String%2CSystem.String%29> méthode pour effectuer une comparaison dépendante de la culture de deux chaînes en utilisant les conventions de la culture actuelle, vous devez appeler la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> méthode avec la valeur <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> pour la `comparisonType` argument. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
<a name="casing"></a>   
### <a name="casing"></a>Casse  
 Règles de casse déterminent comment modifier la mise en majuscules d’un caractère Unicode ; par exemple, de minuscules en majuscules. Souvent, une opération de casse est exécutée avant une comparaison de chaînes. Par exemple, une chaîne peut être convertie en majuscules afin qu’elle peut être comparée avec une autre chaîne en majuscules. Vous pouvez convertir les caractères dans une chaîne en minuscules en appelant le <xref:System.String.ToLower%2A> ou <xref:System.String.ToLowerInvariant%2A> (méthode) et que vous pouvez convertir en majuscules en appelant le <xref:System.String.ToUpper%2A> ou <xref:System.String.ToUpperInvariant%2A> (méthode). En outre, vous pouvez utiliser la <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> méthode pour convertir une chaîne en majuscule.  
  
 Opérations de la casse peuvent reposer sur les règles de la culture actuelle, une culture spécifiée ou la culture dite indifférente. Étant donné que les mappages de casse peuvent varier en fonction de la culture utilisée, le résultat des opérations de casse peut varier en fonction de la culture. Il existe trois types de différences réelles de la casse :  
  
-   Les différences dans le mappage de casse de lettre majuscule de LATIN I (U + 0049), LATIN petite lettre I (U + 0069), LATIN lettre majuscule I avec point en chef (U + 0130) et LATIN petite lettre sans point I (U + 0131). Dans le tr-TR (turc (Turquie)) et cultures de az-Latn-AZ (Azerbaïdjan, Latin) et dans les tr, az et az-Latn les cultures neutres, l’équivalent en minuscule de lettre majuscule latine I est LATIN petite lettre sans point I, et est de l’équivalent en majuscule latine de petite lettre i LETTRE MAJUSCULE LATINE I POINT CI-DESSUS. Dans tous les autres cultures, y compris la culture dite indifférente, LATIN petite lettre I et MAJUSCULE LATIN I sont équivalents majuscules et minuscules.  
  
     L’exemple suivant montre comment une comparaison de chaînes conçue pour empêcher l’accès au système de fichiers peut échouer si elle s’appuie sur une comparaison dépendante de la culture la casse. (Les conventions de casse de la culture dite indifférente doivent avoir été utilisées.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Différences dans les mappages de casse entre tous les autres cultures et de la culture dite indifférente. Dans ce cas, à l’aide des règles de casse de la culture dite indifférente pour modifier un caractère en majuscules ou minuscules retourne le même caractère. Pour toutes les autres cultures, il retourne un caractère différent. Certains caractères concernés sont répertoriés dans le tableau suivant.  
  
    |Caractère|Si vous en|Returns (Retours)|  
    |---------------|-------------------|-------------|  
    |TECHNIQUE SIGNE (U + 00B5)|Majuscules|LETTRE MAJUSCULE GRECQUE MU (U +-39C)|  
    |LETTRE MAJUSCULE LATINE I POINT CI-DESSUS (U + 0130)|Minuscules|LETTRE MINUSCULE LATINE I (U + 0069)|  
    |LETTRE MINUSCULE LATINE SANS POINT I (U + 0131)|Majuscules|LETTRE MAJUSCULE LATINE I (U + 0049)|  
    |LETTRE MINUSCULE LATINE LONG S (U + 017F)|Majuscules|LETTRE MAJUSCULE LATINE S (U + 0053)|  
    |LETTRE MAJUSCULE LATINE D Z LETTRE MINUSCULE AVEC CARON (U + 01C 5)|Minuscules|LETTRE MINUSCULE LATINE DZ CARON (U + 01C 6)|  
    |COMBINAISON GREC IOTA SOUSCRIT (U + 0345)|Majuscules|LETTRE MAJUSCULE GRECQUE IOTA (U + 0399)|  
  
-   Différences dans les mappages de casse de paires de casse mixte de deux lettres dans la plage de caractères ASCII. Dans la plupart des cultures, une paire de casse mixte de deux lettres est égale à la paire de caractères majuscule ou minuscule équivalente à deux lettres. Cela n’est pas vrai pour les paires de deux lettres suivantes dans les cultures suivantes, car dans chaque cas, elles sont comparées à un digramme :  
  
    -   « lJ » et « nJ » dans la culture hr-HR (croate (Croatie)).  
  
    -   « cH » dans cs-CZ (tchèque (République tchèque)) et cultures de sk-SK (slovaque (Slovaquie)).  
  
    -   « aA » dans la culture da-DK (Danois (Danemark)).  
  
    -   « cS », « dZ », « dZS », « nY », « sZ », « réessayer » et « zS » dans la culture hu-HU (hongrois (Hongrie)).  
  
    -   « cH » et « lL » dans la culture es-ES_tradnl (espagnol (Espagne, traditionnel)).  
  
    -   « cH », « gI », « kH », « nG », « nH », « pH », « qU », « tH » et « tR » dans la culture vi-VN (vietnamien (Vietnam)).  
  
     Toutefois, il est rare de rencontrer une situation dans laquelle une comparaison dépendante de la culture de ces paires crée des problèmes, étant donné que ces paires sont rares dans les identificateurs ni les chaînes fixes.  
  
 L’exemple suivant illustre certaines des différences dans les règles de casse entre les cultures lors de la conversion de chaînes en majuscules.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>L’analyse et mise en forme  
 Mise en forme et l’analyse sont des opérations inverses. Règles de mise en forme déterminent comment convertir une valeur, comme une date et d’heure ou d’un nombre, en sa représentation sous forme de chaîne, tandis que les règles d’analyse déterminent comment convertir une représentation sous forme de chaîne en une valeur telle qu’une date et une heure. Mise en forme et de règles d’analyse sont dépendantes des conventions culturelles. L’exemple suivant illustre l’ambiguïté qui peut survenir lors de l’interprétation d’une chaîne de date spécifique à la culture. Sans connaître les conventions de la culture utilisée pour générer une chaîne de date, il n’est pas possible de savoir si 03/01/2011, 3/1/2011 et 01/03/2011 représentent le 3 janvier 2011 ou le 1er mars 2011.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 De même, comme le montre l’exemple suivant, une chaîne unique peut produire des dates différentes selon la culture dont les conventions sont utilisées dans l’opération d’analyse.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Comparaison de chaînes et de tri  
 Conventions pour comparer et trier des chaînes varient d’une culture. Par exemple, l’ordre de tri peut être basé sur phonétique ou sur la représentation visuelle de caractères. Dans les langues d'Asie orientale, les caractères sont classés en fonction du trait et de la clé des idéogrammes. Le tri peut aussi varier en fonction de l'ordre fondamental utilisé par la langue ou la culture pour l'alphabet. Par exemple, la langue danoise emploie un caractère "Æ" qu'elle place après "Z" dans l'alphabet. En outre, les comparaisons peuvent respecter la casse, et dans certains cas, les règles de casse diffèrent également selon la culture. Comparaison ordinale, utilise en revanche, les points de code Unicode des caractères dans une chaîne lors de la comparaison et tri des chaînes.  
  
 Les règles de tri déterminent que l’ordre alphabétique des caractères Unicode et la manière dont deux chaînes comparent. Par exemple, le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> méthode compare deux chaînes selon les <xref:System.StringComparison> paramètre. Si la valeur du paramètre est <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, la méthode effectue une comparaison linguistique qui utilise les conventions de la culture actuelle ; si la valeur du paramètre est <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, la méthode effectue une comparaison ordinale. Par conséquent, comme le montre l’exemple suivant, si la culture actuelle est anglais Anglais, le premier appel à la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> (méthode) (à l’aide de la comparaison dépendante de la culture) considère « a » inférieur à « A », mais le deuxième appel à la même méthode (à l’aide de la comparaison ordinale) considère « a » comme supérieur à « A ».  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 Le .NET Framework prend en charge les mots, des chaînes et des règles de tri ordinal :  
  
-   Un tri word effectue une comparaison dépendante de la culture de chaînes dans lequel certains caractères Unicode non alphanumériques peut-être spéciales poids affectés pour les. Par exemple, le trait d’union (-) peut avoir une très petite pondération affectée à ce dernier afin que « coop » et « op » s’affichent en regard de l’autre dans une liste triée. Pour obtenir la liste de la <xref:System.String> les méthodes qui permettent de comparer deux chaînes à l’aide des règles de tri de word, consultez le [opérations de chaîne par catégorie](#ByCategory) section.  
  
-   Un tri de chaîne effectue également une comparaison dépendante de la culture. Il est similaire à un tri par mot, sauf qu’il n’y a aucun cas particulier et tous les symboles non alphanumériques sont avant tous les caractères Unicode alphanumériques. Deux chaînes peuvent être comparées à l’aide des règles de tri de chaîne en appelant le <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> des surcharges de méthode qui ont un `options` paramètre est fourni une valeur de <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>. Notez qu’il s’agit de la seule méthode que le .NET Framework fournit pour comparer deux chaînes à l’aide des règles de tri de chaîne.  
  
-   Un tri ordinal compare des chaînes en fonction de la valeur numérique de chaque <xref:System.Char> objet dans la chaîne. Une comparaison ordinale est automatiquement la casse, car les versions minuscules et majuscules d’un caractère ont des points de code différents. Toutefois, si la casse n’est pas importante, vous pouvez spécifier une comparaison ordinale qui ignore la casse. Cela équivaut à convertir la chaîne en majuscules à l’aide de la culture dite indifférente et effectuer une comparaison ordinale du résultat. Pour obtenir la liste de la <xref:System.String> les méthodes qui permettent de comparer deux chaînes à l’aide des règles de tri ordinal, consultez la [opérations de chaîne par catégorie](#ByCategory) section.  
  
 Une comparaison dépendante de la culture est une comparaison qui utilise explicitement ou implicitement un <xref:System.Globalization.CultureInfo> objet, y compris la culture dite indifférente est spécifiée par le <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> propriété. La culture implicite est la culture actuelle, qui est spécifiée par le <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> et <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriétés. Il existe des variations considérables dans l’ordre de tri des caractères alphabétiques (autrement dit, les caractères dont la <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> propriété renvoie `true`) dans toutes les cultures. Vous pouvez spécifier une comparaison dépendante de la culture qui utilise les conventions d’une culture spécifique en fournissant un <xref:System.Globalization.CultureInfo> d’objet à une méthode de comparaison de chaîne comme <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. Vous pouvez spécifier une comparaison dépendante de la culture qui utilise les conventions de la culture actuelle, vous devez fournir <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, ou un membre de la <xref:System.Globalization.CompareOptions> énumération autre que <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> ou <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> à appropriée surcharge de la <xref:System.String.Compare%2A> (méthode). Une comparaison dépendante de la culture est en général appropriée au tri tandis qu’une comparaison ordinale ne l’est pas. Une comparaison ordinale est généralement appropriée pour déterminer si deux chaînes sont égales (autrement dit, pour déterminer l’identité) alors qu’une comparaison dépendante de la culture n’est pas.  
  
 L’exemple suivant illustre la différence entre une comparaison dépendante de la culture et ordinale. L’exemple renvoie trois chaînes « Apple », « Æble » et « AEble », à l’aide de la comparaison ordinale et les conventions des cultures da-DK et en-US (chacun d’eux est la culture par défaut au moment où la <xref:System.String.Compare%2A> méthode est appelée). Étant donné que la langue danoise traite le caractère « Æ » comme une seule lettre et elle place après « Z » dans l’alphabet, la chaîne « Æble » est supérieure à « Apple ». Toutefois, « Æble » n’est pas considéré équivalent à « AEble », « Æble » est également supérieure à « AEble ». La culture en-US n’inclut pas la lettre « Æ », mais la traite comme étant équivalent à « AE », qui explique pourquoi « Æble » est inférieure à « Apple » mais égal à « AEble ». Comparaison ordinale, en revanche, prend en compte que le « Apple » est inférieure à « Æble » et « Æble » est supérieure à « AEble ».  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Pour choisir une méthode de comparaison de tri ou de chaîne appropriée, utilisez les indications suivantes :  
  
-   Si vous souhaitez que les chaînes pour être classés en fonction de la culture de l’utilisateur, vous devez classer les selon les conventions de la culture actuelle. Si la culture change, l’ordre des chaînes de tri modifiera également en conséquence. Par exemple, une application de dictionnaire des synonymes doit toujours trier les mots en fonction de la culture de l’utilisateur.  
  
-   Si vous souhaitez que les chaînes pour être classés selon les conventions d’une culture spécifique, vous devez les classer en fournissant un <xref:System.Globalization.CultureInfo> objet qui représente cette culture à une méthode de comparaison. Par exemple, dans une application conçue pour apprendre les étudiants une langue particulière, vous souhaitez les chaînes pour être classés selon les conventions de l’un des cultures qui lit cette langue.  
  
-   Si vous souhaitez que l’ordre des chaînes à restent inchangés dans toutes les cultures, dans l’ordre selon les conventions de la culture dite indifférente ou si vous utilisez une comparaison ordinale. Par exemple, vous utiliseriez un tri ordinal pour organiser les noms de fichiers, les processus, les mutex, ou les canaux nommés.  
  
-   Pour une comparaison qui implique une décision de sécurité (par exemple, si un nom d’utilisateur est valide), vous devez toujours réaliser un test ordinal pour l’égalité en appelant une surcharge de la <xref:System.String.Equals%2A> (méthode).  
  
> [!NOTE]
>  Le tri de dépendante de la culture et les règles de casse utilisées dans la comparaison de chaînes dépendent de la version du .NET Framework. Dans le .NET Framework [!INCLUDE[net_v45](~/includes/net-v45-md.md)] en cours d’exécution le [!INCLUDE[win8](~/includes/win8-md.md)] système d’exploitation, de tri, casse, normalisation et informations sur les caractères Unicode est conforme à la norme Unicode 6.0. Sur les autres systèmes d’exploitation, il est conforme à la norme Unicode 5.0.  
  
 Pour plus d’informations sur les mots, des chaînes et des règles de tri ordinal, consultez la <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> rubrique. Pour des recommandations supplémentaires quand utiliser chaque règle, consultez [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 En règle générale, vous n’appelez pas chaîne telles que les méthodes de comparaison <xref:System.String.Compare%2A> directement pour déterminer l’ordre de tri de chaînes. Au lieu de cela, les méthodes de comparaison sont appelées par les méthodes de tri telles que <xref:System.Array.Sort%2A?displayProperty=nameWithType> ou <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. L’exemple suivant effectue les quatre opérations de tri différentes (tri des mots à l’aide de la culture actuelle, le tri de word à l’aide de la culture dite indifférente, le tri ordinal et le tri des chaînes à l’aide de la culture dite indifférente) sans appeler explicitement une méthode de comparaison de chaînes Bien qu’ils spécifient le type de comparaison à utiliser. Notez que chaque type de tri produit un classement unique de chaînes dans son tableau.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  En interne,.NET Framework utilise des clés de tri pour prendre en charge la comparaison de chaînes culturallysensitive. Chaque caractère d'une chaîne se voit attribuer plusieurs pondérations de tri, notamment les pondérations alphabétiques, de casse et diacritiques. Une clé de tri, représenté par le <xref:System.Globalization.SortKey> de classe, fournit un référentiel de ces pondérations pour une chaîne particulière. Si votre application effectue un grand nombre d’opérations sur le même ensemble de chaînes de tri ou de recherche, vous pouvez améliorer ses performances en générant et en stockant des clés de tri pour toutes les chaînes qu’il utilise. Lorsqu’une opération de tri ou de comparaison est requise, vous utilisez les clés de tri plutôt que les chaînes. Pour plus d'informations, consultez la classe <xref:System.Globalization.SortKey>.  
  
 Si vous ne spécifiez pas une convention de comparaison de chaîne, les méthodes de tri telles que <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> effectuer un tri dépendantes de la culture, la casse sur les chaînes. L’exemple suivant illustre comment la modification de la culture actuelle affecte l’ordre des chaînes de tri dans un tableau. Il crée un tableau de trois chaînes. D'abord, cela définit la propriété `System.Threading.Thread.CurrentThread.CurrentCulture` sur la valeur en-US, et appelle la méthode <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>. L’ordre de tri qui en résulte est basée sur le tri des conventions pour la culture anglais (États-Unis). Ensuite, l'exemple définit la propriété `System.Threading.Thread.CurrentThread.CurrentCulture` sur da-DK et appelle à nouveau la méthode <xref:System.Array.Sort%2A?displayProperty=nameWithType>. Notez la façon dont l'utilisation des conventions de tri définies pour la culture danoise (Danemark) aboutit à un ordre de tri différent de celui obtenu pour la culture en-US.  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Si votre objectif principal de la comparaison de chaînes consiste à déterminer si elles sont égales, vous devez appeler la <xref:System.String.Equals%2A?displayProperty=nameWithType> (méthode). En règle générale, vous devez utiliser <xref:System.String.Equals%2A> pour effectuer une comparaison ordinale. Le <xref:System.String.Compare%2A?displayProperty=nameWithType> méthode est conçue essentiellement pour trier les chaînes.  
  
 Chaîne des méthodes de recherche, telles que <xref:System.String.StartsWith%2A?displayProperty=nameWithType> et <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, vous pouvez également exécuter des comparaisons de chaînes dépendantes de la culture ou ordinales. L’exemple suivant illustre les différences entre les comparaisons ordinales et dépendantes de la culture à l’aide du <xref:System.String.IndexOf%2A> (méthode). Une recherche dépendante de la culture dans laquelle la culture actuelle est anglais (États-Unis) considère que la sous-chaîne « oe » pour faire correspondre le digramme soudé « section ». Un trait d’union (U + 00AD) étant un caractère de largeur nulle, la recherche traite le trait d’union comme équivalent à <xref:System.String.Empty> et trouve une correspondance au début de la chaîne. Une recherche ordinale, quant à eux, ne trouve pas de correspondance dans les deux cas.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Recherche de chaînes  
 Chaîne des méthodes de recherche, telles que <xref:System.String.StartsWith%2A?displayProperty=nameWithType> et <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, vous pouvez également exécuter dépendante de la culture ou des comparaisons de chaînes ordinales pour déterminer si un caractère ou une sous-chaîne est trouvé dans une chaîne spécifiée.  
  
 Les méthodes de recherche dans les <xref:System.String> classe rechercher un caractère individuel, tel que le <xref:System.String.IndexOf%2A> méthode ou un jeu de caractères, tels que le <xref:System.String.IndexOfAny%2A> (méthode), tous effectuent une recherche ordinale. Pour effectuer une recherche dépendante de la culture d’un caractère, vous devez appeler un <xref:System.Globalization.CompareInfo> méthode telle que <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> ou <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Notez que les résultats de recherche d’un caractère à l’aide de la comparaison ordinale et dépendante de la culture peuvent être très différentes. Par exemple, une recherche d’un caractère Unicode précomposé telles que le digramme soudé « Æ » (U + 00 C 6) peut correspondre à toute occurrence de ses composants dans l’ordre approprié, tel que « AE » (U + 041U + 0045), en fonction de la culture. L’exemple suivant illustre la différence entre la <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> et <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> méthodes lorsque vous recherchez un caractère individuel. Le digramme soudé « æ » (U + 00E6) se trouve dans la chaîne « aérien » lorsque vous utilisez les conventions de la culture en-US, mais ne pas lorsque vous utilisez les conventions de la culture da-DK ou lorsque vous effectuez une comparaison ordinale.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 En revanche, <xref:System.String> les méthodes de recherche de chaîne plutôt qu’un caractère effectuer une recherche dépendante de la culture si les options de recherche ne sont pas explicitement spécifiées par un paramètre de type de la classe <xref:System.StringComparison>. La seule exception est <xref:System.String.Contains%2A>, qui effectue une recherche ordinale.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Test d’égalité  
 Utilisez la <xref:System.String.Compare%2A?displayProperty=nameWithType> méthode pour déterminer la relation entre deux chaînes dans l’ordre de tri. En règle générale, il s’agit d’une opération dépendante de la culture. En revanche, appelez le <xref:System.String.Equals%2A?displayProperty=nameWithType> méthode pour tester l’égalité. Le test d’égalité compare habituellement les entrées d’utilisateur avec une chaîne connue, comme un nom d’utilisateur valide, un mot de passe ou un chemin d’accès de système de fichiers, il est généralement une opération ordinale.  
  
> [!WARNING]
>  Il est possible de tester l’égalité en appelant le <xref:System.String.Compare%2A?displayProperty=nameWithType> (méthode) et déterminer si la valeur de retour est zéro. Toutefois, cette pratique n’est pas recommandée. Pour déterminer si deux chaînes sont égales, vous devez appeler une des surcharges de la <xref:System.String.Equals%2A?displayProperty=nameWithType> (méthode). La surcharge par défaut à appeler est l’instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> méthode ou la méthode statique <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> (méthode), car les deux méthodes incluent un <xref:System.StringComparison?displayProperty=nameWithType> paramètre qui spécifie explicitement le type de comparaison.  
  
 L’exemple suivant illustre le risque d’effectuer une comparaison dépendante de la culture pour l’égalité lorsqu’un nombre ordinal une doit être utilisée à la place. Dans ce cas, l’objectif du code est d’interdire l’accès au système de fichiers à partir de l’URL qui commencent par « FILE:// » ou « file:// » en effectuant une comparaison respectant la casse du début d’une URL avec la chaîne « FILE:// ». Toutefois, si une comparaison dépendante de la culture est effectuée à l’aide de la culture turc (Turquie) sur une URL qui commence par « file:// », la comparaison d’égalité échoue, car le turc équivalent en majuscule de « i » minuscule est « » au lieu de « I ». Par conséquent, les accès au système de fichiers est autorisée par inadvertance. En revanche, si une comparaison ordinale est effectuée, la comparaison d’égalité réussit et accès au système de fichiers est refusé.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalisation  
 Certains caractères Unicode ont plusieurs représentations. Par exemple, un des points de code suivant peut représenter la lettre « ắ » :  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 Plusieurs représentations pour un seul caractère compliquent la recherche, le tri, la mise en correspondance et les autres opérations de chaînes.  
  
 La norme Unicode définit un processus appelé normalisation qui retourne une représentation binaire d’un caractère Unicode pour toutes ses représentations binaires équivalentes. La normalisation peut utiliser plusieurs algorithmes, appelés formulaires de normalisation, qui suivent des règles différentes. Le .NET Framework prend en charge les formulaires de normalisation Unicode C, D, KC et KD. Lorsque les chaînes ont été normalisées selon le même formulaire de normalisation, elles peuvent être comparées à l’aide d’une comparaison ordinale.  
  
 Une comparaison ordinale est une comparaison binaire de la valeur scalaire Unicode correspondant <xref:System.Char> objets dans chaque chaîne. La <xref:System.String> classe inclut un nombre de méthodes qui peuvent effectuer une comparaison ordinale, notamment les suivantes :  
  
-   Aucune surcharge de la <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, et <xref:System.String.LastIndexOf%2A> méthodes qui inclut un <xref:System.StringComparison> paramètre. La méthode effectue une comparaison ordinale, si vous fournissez une valeur de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase> pour ce paramètre.  
  
-   Les surcharges de la <xref:System.String.CompareOrdinal%2A> (méthode).  
  
-   Les méthodes qui utilisent une comparaison ordinale par défaut, tels que <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, et <xref:System.String.Split%2A>.  
  
-   Les méthodes qui recherchent un <xref:System.Char> valeur ou pour les éléments dans un <xref:System.Char> tableau dans une instance de chaîne. Ces méthodes incluent <xref:System.String.IndexOf%28System.Char%29> et <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Vous pouvez déterminer si une chaîne est normalisée à un formulaire de normalisation C en appelant le <xref:System.String.IsNormalized?displayProperty=nameWithType> (méthode), ou vous pouvez appeler la <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> méthode pour déterminer si une chaîne est normalisée à un formulaire de normalisation spécifié. Vous pouvez également appeler le <xref:System.String.Normalize?displayProperty=nameWithType> méthode pour convertir une chaîne en un formulaire de normalisation C, ou vous pouvez appeler la <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> méthode pour convertir une chaîne à un formulaire de normalisation spécifié. Pour obtenir des informations détaillées sur la normalisation et la comparaison de chaînes, consultez le <xref:System.String.Normalize> et <xref:System.String.Normalize%28System.Text.NormalizationForm%29> méthodes.  
  
 L’exemple simple suivant illustre la normalisation des chaînes. Il définit la lettre « ố » de trois façons différentes dans trois chaînes différentes et utilise une comparaison ordinale pour l’égalité afin de déterminer que chaque chaîne diffère des deux autres chaînes. Il convertit ensuite chaque chaîne pour les formulaires de normalisation pris en charge et effectue une comparaison ordinale de chaque chaîne de nouveau dans un formulaire de normalisation spécifié. Dans chaque cas, le deuxième test d’égalité indique que les chaînes sont égales.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Pour plus d’informations sur la normalisation et les formulaires de normalisation, consultez <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, ainsi que [Unicode annexe 15 de la norme : formulaires de normalisation Unicode](https://unicode.org/reports/tr15/) et [FAQ de normalisation](https://www.unicode.org/faq/normalization.html) sur le site Web de Unicode.org.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Opérations de chaîne par catégorie  
 Le <xref:System.String> classe fournit des membres pour comparer des chaînes, les chaînes sont égales, la recherche de caractères ou des sous-chaînes dans une chaîne, la modification d’une chaîne, extraire des sous-chaînes d’une chaîne, la combinaison de chaînes, de mise en forme de valeurs, la copie d’une chaîne, de test et normalisation d’une chaîne.  
  
### <a name="comparing-strings"></a>Comparaison de chaînes  
 Vous pouvez comparer des chaînes pour déterminer leur position relative dans l’ordre de tri en utilisant le <xref:System.String> méthodes :  
  
-   <xref:System.String.Compare%2A> Retourne un entier qui indique la relation entre une chaîne et une deuxième chaîne dans l’ordre de tri.  
  
-   <xref:System.String.CompareOrdinal%2A> Retourne un entier qui indique la relation entre une chaîne et une deuxième chaîne basée sur une comparaison de leurs points de code.  
  
-   <xref:System.String.CompareTo%2A> Retourne un entier qui indique la relation de l’instance actuelle de la chaîne et une deuxième chaîne dans l’ordre de tri. Le <xref:System.String.CompareTo%28System.String%29> méthode fournit le <xref:System.IComparable> et <xref:System.IComparable%601> implémentations pour les <xref:System.String> classe.  
  
### <a name="testing-strings-for-equality"></a>Test d’égalité de chaînes  
 Vous appelez le <xref:System.String.Equals%2A> méthode pour déterminer si deux chaînes sont égales. L’instance <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> et statiques <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> surcharges vous permettent de spécifier si la comparaison est dépendante de la culture ou ordinale, et si la casse est considérée comme ou ignorée. La plupart des tests d’égalité sont ordinales et les comparaisons d’égalité qui déterminent l’accès à une ressource système (par exemple, un objet de système de fichiers) doivent toujours être un nombre ordinales.  
  
### <a name="finding-characters-in-a-string"></a>Recherche de caractères dans une chaîne  
 La <xref:System.String> classe inclut deux types de méthodes de recherche :  
  
-   Les méthodes qui retournent un <xref:System.Boolean> valeur pour indiquer si une sous-chaîne particulière est présente dans une instance de chaîne. Celles-ci incluent la <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, et <xref:System.String.StartsWith%2A> méthodes.  
  
-   Méthodes qui indiquent la position de départ d’une sous-chaîne dans une instance de chaîne. Celles-ci incluent la <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, et <xref:System.String.LastIndexOfAny%2A> méthodes.  
  
> [!WARNING]
>  Si vous souhaitez rechercher une chaîne pour un modèle particulier plutôt que d’une sous-chaîne spécifique, vous devez utiliser des expressions régulières. Pour plus d’informations, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Modification d’une chaîne  
 La <xref:System.String> classe comprend les méthodes suivantes qui semblent modifier la valeur d’une chaîne :  
  
-   <xref:System.String.Insert%2A> Insère une chaîne dans la zone actuelle <xref:System.String> instance.  
  
-   <xref:System.String.PadLeft%2A> Insère une ou plusieurs occurrences d’un caractère spécifié au début d’une chaîne.  
  
-   <xref:System.String.PadRight%2A> Insère une ou plusieurs occurrences d’un caractère spécifié à la fin d’une chaîne.  
  
-   <xref:System.String.Remove%2A> Supprime une sous-chaîne actuel <xref:System.String> instance.  
  
-   <xref:System.String.Replace%2A> remplace une sous-chaîne par une autre sous-chaîne en cours <xref:System.String> instance.  
  
-   <xref:System.String.ToLower%2A> et <xref:System.String.ToLowerInvariant%2A> convertit tous les caractères dans une chaîne en minuscules.  
  
-   <xref:System.String.ToUpper%2A> et <xref:System.String.ToUpperInvariant%2A> convertit tous les caractères dans une chaîne en majuscules.  
  
-   <xref:System.String.Trim%2A> Supprime toutes les occurrences d’un caractère de début et à la fin d’une chaîne.  
  
-   <xref:System.String.TrimEnd%2A> Supprime toutes les occurrences d’un caractère de la fin d’une chaîne.  
  
-   <xref:System.String.TrimStart%2A> Supprime toutes les occurrences d’un caractère de début d’une chaîne.  
  
> [!IMPORTANT]
>  Toutes les méthodes de modification de chaîne retournent un nouvel <xref:System.String> objet. Ils ne modifient pas la valeur de l’instance actuelle.  
  
### <a name="extracting-substrings-from-a-string"></a>Extraire des sous-chaînes d’une chaîne  
 Le <xref:System.String.Split%2A?displayProperty=nameWithType> méthode divise une chaîne unique en plusieurs chaînes. Les surcharges de la méthode permettent de spécifier plusieurs délimiteurs, pour déterminer le nombre maximal de sous-chaînes que la méthode extrait et pour déterminer si les chaînes vides (qui se produisent lorsque les délimiteurs sont adjacents) sont inclus dans les chaînes retournées.  
  
### <a name="combining-strings"></a>Combinaison des chaînes  
 Les éléments suivants <xref:System.String> méthodes peuvent être utilisées pour la concaténation de chaîne :  
  
-   <xref:System.String.Concat%2A> associe un ou plusieurs sous-chaînes dans une chaîne unique.  
  
-   <xref:System.String.Join%2A> Concatène une ou plusieurs sous-chaînes dans un élément unique et ajoute un séparateur entre chaque sous-chaîne.  
  
### <a name="formatting-values"></a>Mise en forme de valeurs  
 Le <xref:System.String.Format%2A?displayProperty=nameWithType> méthode utilise la fonctionnalité de mise en forme composite pour remplacer un ou plusieurs des espaces réservés dans une chaîne avec la représentation sous forme de chaîne de l’objet ou valeur. Le <xref:System.String.Format%2A> méthode est souvent utilisée pour effectuer les opérations suivantes :  
  
-   Pour incorporer la représentation sous forme de chaîne d’une valeur numérique dans une chaîne.  
  
-   Pour incorporer la représentation sous forme de chaîne d’une valeur de date et d’heure dans une chaîne.  
  
-   Pour incorporer la représentation sous forme de chaîne d’une valeur d’énumération d’une chaîne.  
  
-   Pour incorporer la représentation sous forme de chaîne d’un objet qui prend en charge la <xref:System.IFormattable> interface dans une chaîne.  
  
-   À droite ou à gauche une sous-chaîne dans un champ au sein d’une chaîne plus grande.  
  
 Pour plus d’informations sur la mise en forme des opérations et des exemples, consultez la <xref:System.String.Format%2A> résumé de surcharge.  
  
### <a name="copying-a-string"></a>Copie d’une chaîne  
 Vous pouvez appeler la <xref:System.String> méthodes pour effectuer une copie d’une chaîne :  
  
-   <xref:System.String.Clone%2A> Retourne une référence à un fichier <xref:System.String> objet.  
  
-   <xref:System.String.Copy%2A> Crée une copie d’une chaîne existante.  
  
-   <xref:System.String.CopyTo%2A> copie une partie d’une chaîne dans un tableau de caractères.  
  
### <a name="normalizing-a-string"></a>Normalisation d’une chaîne  
 Au format Unicode, un caractère unique peut avoir plusieurs points de code. La normalisation convertit ces caractères équivalents dans la même représentation binaire. Le <xref:System.String.Normalize%2A?displayProperty=nameWithType> méthode exécute la normalisation et le <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> méthode détermine si une chaîne est normalisée.  
  
 Pour plus d’informations et obtenir un exemple, consultez la [normalisation](#Normalization) plus haut dans cette rubrique.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans cette section :  
  
 [Syntaxe de constructeur surchargé](#Syntax)   
 [Paramètres](#Params)   
 [Exceptions](#Exceptions)   
 [Quelle méthode appeler ?](#Tasks)   
 [Création de chaînes](#Creating_Strings)   
 [La gestion des chaînes répétitives](#Repetitive)   
 Exemples de chaînes d’instanciation :   
 [Utilisation de l’attribution de chaîne](#Ctor1_Example)  
 [À l’aide d’un tableau de caractères](#Ctor2_Example)  
 [À l’aide d’une partie d’un tableau de caractères et la répétition d’un caractère unique](#Ctor3_Example)  
 [À l’aide d’un pointeur vers un tableau de caractères](#Ctor4_Example)  
 [À l’aide d’un pointeur et une plage d’un tableau](#Ctor5_Example)  
 [À l’aide d’un pointeur vers un tableau d’octets signés](#Ctor6_Example)  
[Informations de version](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Syntaxe de constructeur surchargé  
 Constructeurs de la chaîne se répartissent en deux catégories : ceux sans paramètres de pointeur et ceux avec des paramètres de pointeur. Les constructeurs qui utilisent des pointeurs ne sont pas conformes CLS. En outre, Visual Basic ne prend pas en charge l’utilisation des pointeurs et c# nécessite que du code qui utilise des pointeurs pour s’exécuter dans un contexte unsafe. Pour plus d’informations, consultez [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Pour plus d’informations sur le choix d’une surcharge, consultez [sur lequel la méthode appelez ?](#Tasks)  
  
 `String(Char[] value)`  
 Initialise la nouvelle instance à la valeur indiquée par un tableau de caractères Unicode. Ce constructeur copie les caractères Unicode ([exemple](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Initialise la nouvelle instance à la valeur indiquée par un tableau de caractères Unicode, une position de caractère de départ dans ce tableau et une longueur ([exemple](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Initialise la nouvelle instance de la valeur indiquée par un caractère Unicode spécifié répété un certain nombre de fois ([exemple](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Pas conforme CLS) ** Initialise la nouvelle instance à la valeur indiquée par un pointeur vers un tableau de caractères Unicode terminée par un caractère null (U + 0000 ou « \0 »). ([exemple](#Ctor4_Example)).  
  
 Autorisation : <xref:System.Security.SecurityCriticalAttribute>, requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Pas conforme CLS) ** Initialise la nouvelle instance à la valeur indiquée par un pointeur vers un tableau de caractères Unicode, une position de caractère de départ dans ce tableau et une longueur. Le constructeur de copie les caractères Unicode à partir de `value` en commençant à l’index `startIndex` et se termine à l’index `startIndex`  +  `length` – 1 ([exemple](#Ctor5_Example)).  
  
 Autorisation : <xref:System.Security.SecurityCriticalAttribute>, requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.  
  
 `String(SByte* value)`  
 **(Pas conforme CLS) ** Initialise la nouvelle instance à la valeur indiquée par un pointeur vers un tableau d’entiers signés 8 bits. Le tableau est censé pour représenter une chaîne encodée à l’aide de la page de codes système actuelle (autrement dit, l’encodage spécifié par <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Le constructeur traite les caractères de `value` à partir de l’emplacement spécifié par le pointeur jusqu'à ce qu’un caractère null (0 x 00) est atteint ([exemple](#Ctor6_Example)).  
  
 Autorisation : <xref:System.Security.SecurityCriticalAttribute>, requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Pas conforme CLS) ** Initialise la nouvelle instance à la valeur indiquée par un pointeur vers un tableau d’entiers signés 8 bits, une position de départ dans ce tableau et une longueur.  Le tableau est censé pour représenter une chaîne encodée à l’aide de la page de codes système actuelle (autrement dit, l’encodage spécifié par <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Le constructeur traite les caractères à partir de la valeur en commençant à `startIndex` et se terminant à `startIndex`  +  `length` – 1 ([exemple](#Ctor6_Example)).  
  
 Autorisation : <xref:System.Security.SecurityCriticalAttribute>, requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Pas conforme CLS) ** Initialise la nouvelle instance à la valeur indiquée par un pointeur vers un tableau d’entiers signés 8 bits, une position de départ dans ce tableau, une longueur et un <xref:System.Text.Encoding> objet.  
  
 Autorisation : <xref:System.Security.SecurityCriticalAttribute>, requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Paramètres  
 Voici une liste complète des paramètres utilisés par <xref:System.String> constructeurs qui n’incluent pas un paramètre de pointeur. Pour les paramètres utilisés par chaque surcharge, consultez la syntaxe de la surcharge.  
  
|Paramètre|Type|Description |  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Tableau de caractères Unicode.|  
|`c`|<xref:System.Char>|Caractère Unicode.|  
|`startIndex`|<xref:System.Int32>|Position de départ dans `value` du premier caractère dans la nouvelle chaîne.<br /><br /> Valeur par défaut : 0|  
|`length`|<xref:System.Int32>|Le nombre de caractères dans `value` à inclure dans la nouvelle chaîne.<br /><br /> Valeur par défaut : <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Le nombre de fois où le caractère `c` est répétée dans la nouvelle chaîne. Si `count` est égal à zéro, la valeur du nouvel objet est <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Voici une liste complète des paramètres utilisés par <xref:System.String> constructeurs qui incluent un paramètre de pointeur. Pour les paramètres utilisés par chaque surcharge, consultez la syntaxe de la surcharge.  
  
|Paramètre|Type|Description |  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> - ou -<br /><br /> <xref:System.SByte>\*|Un pointeur en tableau de caractères Unicode se terminant par null ou en un tableau d’entiers signés 8 bits. Si `value` est `null` ou un tableau vide, la valeur de la nouvelle chaîne est <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|Index de l’élément de tableau qui définit le premier caractère dans la nouvelle chaîne.<br /><br /> Valeur par défaut : 0|  
|`length`|<xref:System.Int32>|Le nombre d’éléments de tableau à utiliser pour créer la nouvelle chaîne. Si la longueur est égale à zéro, le constructeur crée une chaîne dont la valeur est <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Valeur par défaut : <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Un objet qui spécifie comment la `value` est encodé.<br /><br /> Valeur par défaut : <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, ou la page de codes ANSI actuelle du système|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Exceptions  
 Voici une liste d’exceptions levées par les constructeurs qui n’incluent pas les paramètres de pointeur.  
  
|Exception|Condition|Levée par|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` est `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, ou `count` est inférieur à zéro.<br /><br /> - ou -<br /><br /> La somme de `startIndex` et `length` est supérieure au nombre d'éléments figurant dans `value`.<br /><br /> - ou -<br /><br /> `count` est inférieur à zéro.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Voici une liste d’exceptions levées par les constructeurs qui incluent des paramètres de pointeur.  
  
|Exception|Condition|Levée par|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` Spécifie un tableau qui contient un caractère Unicode non valide.<br /><br /> - ou -<br /><br /> `value` ou `value`  +  `startIndex` spécifie une adresse qui est inférieure à 64 Ko.<br /><br /> - ou -<br /><br /> Un nouveau <xref:System.String> instance n’a pas pu être initialisée à partir de la `value` tableau d’octets, car `value` n’utilise pas l’encodage de page de code par défaut.|Tous les constructeurs avec des pointeurs.|  
|<xref:System.ArgumentNullException>|`value` a la valeur null.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Le processus actuel n’a pas d’accès en lecture à tous les caractères adressés.<br /><br /> - ou -<br /><br /> `startIndex` ou `length` est inférieur à zéro, `value` + `startIndex` entraîne un dépassement de capacité de pointeur ou le processus en cours n’a pas accès en lecture à tous les caractères identifiés par l’adresse.<br /><br /> - ou -<br /><br /> La longueur de la nouvelle chaîne est trop grande à allouer.|Tous les constructeurs avec des pointeurs.|  
|<xref:System.AccessViolationException>|`value`, ou `value`  +  `startIndex`  +  `length` – 1, spécifie une adresse non valide.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Quelle méthode appeler ?  
  
|À|Appel ou l’utilisation|  
|--------|-----------------|  
|Créer une chaîne.|Assignation d’un littéral de chaîne ou une chaîne existante ([exemple](#Ctor1_Example))|  
|Créer une chaîne à partir d’un tableau de caractères entière.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([exemple](#Ctor2_Example))|  
|Chaîne de cette méthode crée à partir d’une partie d’un tableau de caractères.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([exemple](#Ctor3_Example))|  
|Créer une chaîne qui se répète le même caractère plusieurs fois.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([exemple](#Ctor3_Example))|  
|Créer une chaîne à partir d’un pointeur vers une Unicode ou un tableau de caractères larges.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Créer une chaîne à partir d’une partie d’un tableau de caractères larges ou d’Unicode en utilisant son pointeur.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Créer une chaîne à partir de C++ `char` tableau.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> - ou -<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Créer une chaîne de caractères ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Création de chaînes  
 Les plus couramment utilisées technique pour la création par programme des chaînes est une assignation simple, comme illustré dans [cet exemple](#Ctor1_Example). La <xref:System.String> classe inclut également les quatre types de surcharges de constructeur qui vous permettent de créer des chaînes à partir des valeurs suivantes :  
  
-   À partir d’un tableau de caractères (il s’agit d’un tableau de caractères d’encodée en UTF-16). Vous pouvez créer un nouveau <xref:System.String> objet à partir des caractères dans le tableau entier ou une partie de celui-ci. Le <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructeur copie tous les caractères dans le tableau à la nouvelle chaîne. Le <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructeur copie les caractères à partir de l’index `startIndex` index `startIndex`  +  `length` – 1 pour la nouvelle chaîne. Si `length` est égal à zéro, la valeur de la nouvelle chaîne est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Si votre code instancie à plusieurs reprises les chaînes qui ont la même valeur, vous pouvez améliorer les performances de l’application à l’aide d’un autre moyen de la création de chaînes. Pour plus d’informations, consultez [la gestion des chaînes répétitives](#Repetitive).  
  
-   À partir d’un seul caractère dupliqué égal à zéro, une ou plusieurs fois, à l’aide de la <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> constructeur. Si `count` est égal à zéro, la valeur de la nouvelle chaîne est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   À partir d’un pointeur vers un tableau de caractères terminée par null, en utilisant le <xref:System.String.%23ctor%28System.Char%2A%29> ou <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructeur. L’intégralité du tableau ou une plage spécifiée peut être utilisée pour initialiser la chaîne. Le constructeur de copie d’une séquence de caractères Unicode commençant à partir du pointeur spécifié ou à partir du pointeur spécifié plu `startIndex` et en continuant à la fin du tableau ou pour `length` caractères. Si `value` est un pointeur null ou `length` est égal à zéro, le constructeur crée une chaîne dont la valeur est <xref:System.String.Empty?displayProperty=nameWithType>. Si l’opération de copie continue jusqu'à la fin du tableau et le tableau n’est pas terminée par null, le comportement du constructeur dépend du système. Cette condition peut entraîner une violation d’accès.  
  
     Si le tableau contient des caractères null incorporés (U + 0000 ou « \0 ») et le <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> surcharge est appelée, l’instance de chaîne contient `length` caractères, y compris ceux incorporé les valeurs NULL. L’exemple suivant montre ce qui se passe quand un pointeur vers un tableau de 10 éléments qui inclut les deux caractères null est passé à la <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> (méthode). Étant donné que l’adresse est le début du tableau, et tous les éléments du tableau doivent être ajoutés à la chaîne, le constructeur instancie une chaîne de 10 caractères, y compris les deux valeurs null incorporées. En revanche, si le même tableau est passé à la <xref:System.String.%23ctor%28System.Char%2A%29> constructeur, le résultat est une chaîne de quatre caractères qui n’inclut pas le premier caractère null.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     Le tableau doit contenir des caractères Unicode. En C++, cela signifie que le tableau de caractères doit être défini comme managé <xref:System.Char>type [] ou non managé`wchar_t`type [].  
  
     Si le <xref:System.String.%23ctor%28System.Char%2A%29> surcharge est appelée et le tableau n’est pas terminée par null, ou si le <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> surcharge est appelée et `startIndex`  +  `length`-1 inclut une plage qui elle en dehors de la mémoire allouée à la séquence de caractères, le comportement du constructeur est dépendante du système, et une violation d’accès peut se produire. En outre, sur le processeur Intel Itanium, les appels à la <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructeur peut lever un <xref:System.DataMisalignedException> exception. Si cela se produit, appelez le <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> à la place.  
  
-   À partir d’un pointeur vers un tableau d’octets signés. L’intégralité du tableau ou une plage spécifiée peut être utilisée pour initialiser la chaîne. La séquence d’octets peut être interprétée à l’aide de la page de codes par défaut de codage ou un codage peut être spécifié dans l’appel de constructeur. Si le constructeur essaie d’instancier une chaîne à partir d’un tableau entier qui n’est pas terminée par null, ou si la plage du tableau à partir de `value`  +  `startIndex` à `value`  +  `startIndex`  +  `length` -1 est en dehors de la mémoire allouée pour le tableau, le comportement de ce constructeur est dépendante du système, et une violation d’accès peut se produire.  
  
     Les trois constructeurs qui incluent un tableau d’octets signés en tant que paramètre sont conçus principalement pour convertir un C++ `char` tableau vers une chaîne, comme illustré dans cet exemple :  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Si le tableau contient des caractères null ('\0') ou des octets dont la valeur est 0 et la <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> surcharge est appelée, l’instance de chaîne contient `length` caractères, y compris ceux incorporé les valeurs NULL. L’exemple suivant montre ce qui se passe quand un pointeur vers un tableau de 10 éléments qui inclut les deux caractères null est passé à la <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> (méthode). Étant donné que l’adresse est le début du tableau, et tous les éléments du tableau doivent être ajoutés à la chaîne, le constructeur instancie une chaîne de 10 caractères, y compris les deux valeurs null incorporées. En revanche, si le même tableau est passé à la <xref:System.String.%23ctor%28System.SByte%2A%29> constructeur, le résultat est une chaîne de quatre caractères qui n’inclut pas le premier caractère null.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Étant donné que la <xref:System.String.%23ctor%28System.SByte%2A%29> et <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> constructeurs interprètent `value` à l’aide de la page de codes ANSI par défaut, ces constructeurs avec des tableaux d’octets identiques peuvent créer des chaînes qui ont des valeurs différentes sur des systèmes différents.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>La gestion des chaînes répétitives  
 Les applications qui analysent ou décodent le flux de texte souvent utiliser le <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructeur ou la <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour convertir des séquences de caractères en une chaîne. Création à plusieurs reprises de nouvelles chaînes ayant la même valeur au lieu de la création et la réutilisation d’une seule chaîne gaspille de la mémoire. Si vous êtes susceptible de créer la même valeur de chaîne à plusieurs reprises en appelant le <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructeur, même si vous ne connaissez pas dans ce que ces valeurs de chaîne identiques peuvent être d’avance, vous pouvez utiliser une table de correspondance à la place.  
  
 Par exemple, lire et analyser un flux de caractères à partir d’un fichier qui contient des balises et attributs XML. Lorsque vous analysez le flux de données, vous rencontrez à plusieurs reprises certains jetons (autrement dit, les séquences de caractères qui ont une signification symbolique). Les jetons équivalents aux chaînes « 0 », « 1 », « true » et « false » sont susceptibles de se produire fréquemment dans un flux XML.  
  
 Au lieu de convertir chaque jeton dans une nouvelle chaîne, vous pouvez créer un <xref:System.Xml.NameTable?displayProperty=nameWithType> objet pour contenir les chaînes courantes. Le <xref:System.Xml.NameTable> objet améliore les performances, car il récupère les chaînes stockées sans allouer de mémoire temporaire. Lorsque vous rencontrez un jeton, utilisez le <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> pour récupérer le jeton de la table. Si le jeton existe, la méthode retourne la chaîne correspondante. Si le jeton n’existe pas, utilisez le <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour insérer le jeton dans la table et pour obtenir la chaîne correspondante.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Exemple 1 : Utiliser l’affectation de la chaîne  
 L’exemple suivant crée une nouvelle chaîne en lui assignant un littéral de chaîne. Il crée une deuxième chaîne en lui assignant la valeur de la première chaîne. Voici les deux méthodes les plus courantes pour instancier un nouvel <xref:System.String> objet.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Exemple 2 : Utilisation d’un tableau de caractères  
 L’exemple suivant montre comment créer un nouveau <xref:System.String> objet à partir d’un tableau de caractères.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Exemple 3 : À l’aide d’une partie d’un tableau de caractères et en répétant un caractère unique  
 L’exemple suivant montre comment créer un nouveau <xref:System.String> objet à partir d’une partie d’un tableau de caractères et comment créer un nouveau <xref:System.String> objet qui contient plusieurs occurrences d’un seul caractère.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Exemple 4 : Utilisation d’un pointeur vers un tableau de caractères  
 L’exemple suivant montre comment créer un nouveau <xref:System.String> objet à partir d’un pointeur vers un tableau de caractères. L’exemple c# doit être compilée à l’aide de la `/unsafe` commutateur du compilateur.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Exemple 5 : L’instanciation d’une chaîne à partir d’un pointeur et une plage d’un tableau  
 L’exemple suivant examine les éléments d’un tableau de caractères pour une période ou un point d’exclamation. S’il existe, il instancie une chaîne à partir des caractères dans le tableau qui précèdent le symbole de ponctuation. Si ce n’est pas le cas, il instancie une chaîne avec le contenu entier du tableau. L’exemple c# doit être compilée à l’aide de la `/unsafe` commutateur du compilateur.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Exemple 6 : L’instanciation d’une chaîne à partir d’un pointeur vers un tableau d’octets signés  
 L’exemple suivant montre comment vous pouvez créer une instance de la <xref:System.String> classe avec le <xref:System.String.%23ctor%28System.SByte%2A%29> constructeur.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Informations de version  
 .NET Framework  
 Toutes les surcharges sont pris en charge dans : 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Toutes les surcharges sont pris en charge dans : 4, 3.5 SP1  
  
 Bibliothèque de classes portable  
 Toutes les surcharges sans un <xref:System.SByte> `*` paramètre sont pris en charge.  
  
 .NET pour les applications du Windows Store  
 Toutes les surcharges sans un <xref:System.SByte> `*` paramètre sont pris en charge dans : Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau de caractères Unicode terminé par un caractère null.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un pointeur spécifié vers un tableau de caractères Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour des exemples et complète de l’utilisation des informations sur cette modification et autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le processus actuel n’a pas d’accès en lecture à tous les caractères adressés.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> spécifie un tableau qui contient un caractère Unicode non valide ou <paramref name="value" /> spécifie une adresse inférieure à 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Tableau de caractères Unicode.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un tableau de caractères Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour des exemples et complète de l’utilisation des informations sur cette modification et autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau d'entiers signés 8 bits terminé par le caractère null. Les entiers sont interprétés à l’aide de l’encodage de page de codes système actuel (autrement dit, l’encodage spécifié par <see cref="P:System.Text.Encoding.Default" />).</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un pointeur vers un tableau d'entiers signés 8 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour des exemples et complète de l’utilisation des informations sur cette modification et autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Une nouvelle instance de <see cref="T:System.String" /> n’a pas pu être initialisée à l’aide de <paramref name="value" />, en supposant que <paramref name="value" /> est encodé au format ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longueur de la nouvelle chaîne à initialiser, déterminée par le caractère de fin Null de <paramref name="value" />, est trop grande à allouer.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> spécifie une adresse non valide.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Caractère Unicode.</param>
        <param name="count">Nombre d’occurrences de <c>c</c>.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un caractère Unicode spécifié et répété un certain nombre de fois.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour des exemples et complète de l’utilisation des informations sur cette modification et autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau de caractères Unicode.</param>
        <param name="startIndex">Position de départ dans <c>value</c>.</param>
        <param name="length">Nombre de caractères dans <c>value</c> à utiliser.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un pointeur spécifié vers un tableau de caractères Unicode, un point de départ pour le caractère dans ce tableau et une longueur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour des exemples et complète de l’utilisation des informations sur cette modification et autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro, <paramref name="value" /> + <paramref name="startIndex" /> entraîne un dépassement de capacité de pointeur ou le processus en cours n’a pas accès en lecture à tous les caractères identifiés par l’adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> spécifie un tableau qui contient un caractère Unicode non valide ou <paramref name="value" /> + <paramref name="startIndex" /> spécifie une adresse inférieure à 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Tableau de caractères Unicode.</param>
        <param name="startIndex">Position de départ dans <c>value</c>.</param>
        <param name="length">Nombre de caractères dans <c>value</c> à utiliser.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un tableau de caractères Unicode, une position de départ pour le caractère dans ce tableau et une longueur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour des exemples et complète de l’utilisation des informations sur cette modification et autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro.  -ou- La somme de <paramref name="startIndex" /> et <paramref name="length" /> est supérieure au nombre d’éléments de <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau d'entiers signés 8 bits. Les entiers sont interprétés à l’aide de l’encodage de page de codes système actuel (autrement dit, l’encodage spécifié par <see cref="P:System.Text.Encoding.Default" />).</param>
        <param name="startIndex">Position de départ dans <c>value</c>.</param>
        <param name="length">Nombre de caractères dans <c>value</c> à utiliser.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un pointeur spécifié vers un tableau d'entiers signés 8 bits, une position de départ dans ce tableau et une longueur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour des exemples et complète de l’utilisation des informations sur cette modification et autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro.  -ou- L’adresse spécifiée par <paramref name="value" /> + <paramref name="startIndex" /> est trop grande pour la plateforme actuelle ; autrement dit, le calcul d’adresse a été l’objet d’un dépassement de capacité.  -ou- La longueur de la nouvelle chaîne à initialiser est trop grande à allouer.</exception>
        <exception cref="T:System.ArgumentException">L’adresse spécifiée par <paramref name="value" /> + <paramref name="startIndex" /> est inférieure à 64 Ko.  -ou- Une nouvelle instance de <see cref="T:System.String" /> n’a pas pu être initialisée à l’aide de <paramref name="value" />, en supposant que <paramref name="value" /> est encodé au format ANSI.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> et <paramref name="length" /> spécifient collectivement une adresse non valide.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau d'entiers signés 8 bits.</param>
        <param name="startIndex">Position de départ dans <c>value</c>.</param>
        <param name="length">Nombre de caractères dans <c>value</c> à utiliser.</param>
        <param name="enc">Objet qui spécifie la façon dont le tableau référencé par <c>value</c> est encodé. Si <c>enc</c> est <see langword="null" />, l’encodage ANSI est utilisé par défaut.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un pointeur spécifié vers un tableau d'entiers signés 8 bits, une position de départ dans ce tableau, une longueur et un objet <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour des exemples et complète de l’utilisation des informations sur cette modification et autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro.  -ou- L’adresse spécifiée par <paramref name="value" /> + <paramref name="startIndex" /> est trop grande pour la plateforme actuelle ; autrement dit, le calcul d’adresse a été l’objet d’un dépassement de capacité.  -ou- La longueur de la nouvelle chaîne à initialiser est trop grande à allouer.</exception>
        <exception cref="T:System.ArgumentException">L’adresse spécifiée par <paramref name="value" /> + <paramref name="startIndex" /> est inférieure à 64 Ko.  -ou- Nous n’avons pas pu initialiser une nouvelle instance de <see cref="T:System.String" /> à l’aide de <paramref name="value" />, en supposant que <paramref name="value" /> est encodé comme indiqué par <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> et <paramref name="length" /> spécifient collectivement une adresse non valide.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Position dans la chaîne actuelle.</param>
        <summary>Obtient l'objet <see cref="T:System.Char" /> à une position de caractère spécifiée dans l'objet <see cref="T:System.String" /> actuel.</summary>
        <value>Objet à la position <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `index` paramètre est de base zéro.  
  
 Cette propriété retourne le <xref:System.Char> objet à la position spécifiée par la `index` paramètre. Toutefois, un caractère Unicode peut être représenté par plusieurs <xref:System.Char>. Utilisez le <xref:System.Globalization.StringInfo?displayProperty=nameWithType> classe fonctionne avec Unicode des caractères à la place de <xref:System.Char> objets. Pour plus d’informations, consultez la section « Objets Char et caractères Unicode » dans le <xref:System.String> vue d’ensemble de la classe.  
  
 En c#, le <xref:System.String.Chars%2A> propriété est un indexeur. En Visual Basic, il s’agit de la propriété par défaut de la <xref:System.String> classe. Chaque <xref:System.Char> objet dans la chaîne est accessible à l’aide de code suivant.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant montre comment vous pouvez utiliser cet indexeur dans une routine de valider une chaîne.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> est supérieur ou égal à la longueur de cet objet ou inférieur à zéro.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une référence à cette instance de <see cref="T:System.String" />.</summary>
        <returns>Instance de <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de retour n’est pas une copie indépendante de cette instance ; Il est simplement une autre vue des mêmes données. Utilisez le <xref:System.String.Copy%2A> ou <xref:System.String.CopyTo%2A> méthode pour créer un distinct <xref:System.String> objet ayant la même valeur que cette instance.  
  
 Étant donné que la <xref:System.String.Clone%2A> méthode retourne simplement l’instance existante de la chaîne, il est recommandé d’appeler directement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Toutes les surcharges de la méthode <xref:System.String.Compare%2A> retournent un entier signé sur 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
|Value|Condition|  
|-----------|---------------|  
|Inférieure à zéro|La première sous-chaîne précède la deuxième sous-chaîne dans l’ordre de tri.|  
|Zéro|Les sous-chaînes ont la même position dans l’ordre de tri, ou `length` a pour valeur zéro.|  
|Supérieure à zéro|La première sous-chaîne suit la deuxième sous-chaîne dans l’ordre de tri.|  
  
> [!WARNING]
>  Chaque fois que possible, vous devez appeler une surcharge de la <xref:System.String.Compare%2A> méthode inclut un <xref:System.StringComparison> paramètre. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro </term><description><paramref name="strA" /> précède <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Zéro </term><description><paramref name="strA" /> se produit à la même position que <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Supérieur à zéro </term><description><paramref name="strA" /> suit <paramref name="strB" /> dans l’ordre de tri. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparaison utilise la culture en cours pour obtenir des informations spécifiques à la culture telles que les règles de casse et l’ordre alphabétique de caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une manière particulière, ou que les caractères qui précèdent dépend de l’ordre de tri d’un caractère ou cliquer dessus.  
  
 La comparaison est effectuée à l’aide des règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Comparaison de chaînes, vous devez appeler la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> (méthode), ce qui nécessite que vous spécifiez explicitement le type de comparaison de chaînes qui utilise de la méthode. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (« »), est supérieure à une référence null ; et deux références null sont égales.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux chaînes comparées. Toutefois, si les deux chaînes sont égales à la fin d’une chaîne et l’autre chaîne comporte des caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, dans la langue turque, l’exemple suivant donne des résultats erronés car le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Voici le code correct pour ce faire :  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.String.Compare%28System.String%2CSystem.String%29> méthode pour comparer les trois ensembles de chaînes.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 Dans l’exemple suivant, la `ReverseStringComparer` classe montre comment vous pouvez évaluer les deux chaînes avec le <xref:System.String.Compare%2A> (méthode).  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.String)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Par exemple, si le code suivant est exécuté sur le [ ! Include[netfx40_short](~/Includes/netfx40-short-MD.MD)] ou une version ultérieure, une comparaison dépendante de la culture de « préféré » avec « ani Outlook » (à l’aide d’un trait d’union, ou U + 00AD) indique que les deux chaînes sont équivalentes.  [ ! csharp de code [System.String.Compare#21] (~/samples/snippets/csharp/VS_Snippets_CLR_System/système. String.Compare/cs/compare21.cs#21)] [ !-code vb [System.String.Compare#21] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/système. String.Compare/vb/compare21.vb#21)] pour reconnaître les caractères ignorables dans une comparaison de chaînes, appel de la <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> méthode et fournir une valeur <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour le paramètre 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés, en ignorant ou en respectant leur casse, et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro </term><description><paramref name="strA" /> précède <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Zéro </term><description><paramref name="strA" /> se produit à la même position que <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Supérieur à zéro </term><description><paramref name="strA" /> suit <paramref name="strB" /> dans l’ordre de tri. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparaison utilise la culture en cours pour obtenir des informations spécifiques à la culture telles que les règles de casse et l’ordre alphabétique de caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une manière particulière, ou que les caractères qui précèdent dépend de l’ordre de tri d’un caractère ou cliquer dessus.  
  
 La comparaison est effectuée à l’aide des règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Comparaison de chaînes, vous devez appeler la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> (méthode), ce qui nécessite que vous spécifiez explicitement le type de comparaison de chaînes qui utilise de la méthode. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (« »), est supérieure à une référence null ; et deux références null sont égales.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux chaînes comparées. Toutefois, si les deux chaînes sont égales à la fin d’une chaîne et l’autre chaîne comporte des caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, dans la langue turque, l’exemple suivant donne des résultats erronés car le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Voici le code correct pour ce faire :  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 L’exemple suivant montre que le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> méthode est équivalente à l’aide <xref:System.String.ToUpper%2A> ou <xref:System.String.ToLower%2A> lors de la comparaison de chaînes.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Par exemple, si le code suivant est exécuté sur le [ ! Include[netfx40_short](~/Includes/netfx40-short-MD.MD)] ou une version ultérieure, une comparaison dépendante de la culture, la casse de « préféré » avec « Ani Outlook » (à l’aide d’un trait d’union, ou U + 00AD) indique que les deux chaînes sont équivalentes.  [ ! csharp de code [System.String.Compare#22] (~/samples/snippets/csharp/VS_Snippets_CLR_System/système. String.Compare/cs/compare22.cs#22)] [ !-code vb [System.String.Compare#22] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/système. String.Compare/vb/compare22.vb#22)] pour reconnaître les caractères ignorables dans une comparaison de chaînes, appel de la <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> méthode et fournir une valeur <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour la <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <param name="comparisonType">Une des valeurs d'énumération qui spécifie les règles à utiliser dans la comparaison.</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés à l'aide des règles désignées et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro </term><description><paramref name="strA" /> précède <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Zéro  </term><description><paramref name="strA" /> est dans la même position que <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Supérieur à zéro </term><description><paramref name="strA" /> suit <paramref name="strB" /> dans l’ordre de tri. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `comparisonType` paramètre indique si la comparaison doit utiliser la culture actuelle ou indifférente, respecter ou ignorer la casse des comparateurs ou utiliser word (dépendante de la culture) ou des règles de tri basé sur ordinale (indépendante de la culture).  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (« »), est supérieure à une référence null ; et deux références null sont égales.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux chaînes comparées. Toutefois, si les deux chaînes sont égales à la fin d’une chaîne et l’autre chaîne comporte des caractères restants, la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, dans la langue turque, l’exemple suivant donne des résultats erronés car le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Voici le code correct pour ce faire :  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 L’exemple suivant compare les trois versions de la lettre « I ». Les résultats sont affectés par le choix de la culture, si la casse est ignorée et indique si une comparaison ordinale est effectuée.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" /> n'est pas pris en charge.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Pour qu’il reconnaisse les caractères ignorables dans votre comparaison, fournissez une valeur de <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> pour la <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <param name="culture">Objet qui fournit des informations de comparaison propres à la culture.</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés, en ignorant ou en respectant leur casse et en utilisant les informations propres à la culture pour influencer la comparaison, et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro </term><description><paramref name="strA" /> précède <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Zéro </term><description><paramref name="strA" /> se produit à la même position que <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Supérieur à zéro </term><description><paramref name="strA" /> suit <paramref name="strB" /> dans l’ordre de tri. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparaison utilise le `culture` paramètre pour obtenir des informations spécifiques à la culture telles que les règles de casse et l’ordre alphabétique de caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une manière particulière, ou que les caractères qui précèdent dépend de l’ordre de tri d’un caractère ou cliquer dessus.  
  
 La comparaison est effectuée à l’aide des règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (« »), est supérieure à une référence null ; et deux références null sont égales.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux chaînes comparées. Toutefois, si les deux chaînes sont égales à la fin d’une chaîne et l’autre chaîne comporte des caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, dans la langue turque, l’exemple suivant donne des résultats erronés car le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Voici le code correct pour ce faire :  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 L’exemple suivant montre comment la culture peut affecter une comparaison. Tchèque - culture de la République tchèque, « ch » est un caractère unique qui est supérieur à « d ». Toutefois, en anglais - États-Unis culture, « ch » se compose de deux caractères, et « c » est inférieure à « d ».  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Par exemple, si le code suivant est exécuté sur le [ ! Include[netfx40_short](~/Includes/netfx40-short-MD.MD)] ou une version ultérieure, une comparaison respectant la casse de « préféré » avec « Ani Outlook » (à l’aide d’un trait d’union, ou U + 00AD) en utilisant le nom invariant culture indique que les deux chaînes sont équivalentes.  [ ! csharp de code [System.String.Compare#23] (~/samples/snippets/csharp/VS_Snippets_CLR_System/système. String.Compare/cs/compare23.cs#23)] [ !-code vb [System.String.Compare#23] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/système. String.Compare/vb/compare23.vb#23)] pour reconnaître les caractères ignorables dans une comparaison de chaînes, appel de la <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> méthode et fournir une valeur <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour la <paramref name="options" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <param name="culture">Culture qui fournit les informations de comparaison propres à la culture.</param>
        <param name="options">Options à utiliser pour effectuer la comparaison (par exemple, ignorer la casse ou les symboles).</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés en utilisant les options de comparaison spécifiées et les informations propres à la culture pour influencer la comparaison, et retourne un entier qui indique la relation entre ces deux chaînes dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre <paramref name="strA" /> et <paramref name="strB" />, comme indiqué dans le tableau suivant <list type="table"><listheader><term> Valeur </term><description> Condition </description></listheader><item><term> Inférieur à zéro </term><description><paramref name="strA" /> précède <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Zéro  </term><description><paramref name="strA" /> se produit à la même position que <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Supérieur à zéro </term><description><paramref name="strA" /> suit <paramref name="strB" /> dans l’ordre de tri. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparaison utilise le `culture` paramètre pour obtenir des informations spécifiques à la culture, tels que les règles de casse et l’ordre alphabétique de caractères individuels. Par exemple, une culture particulière peut spécifier que certaines combinaisons de caractères considérée comme un caractère unique, de comparer les caractères majuscules et minuscules d’une manière particulière, ou que les caractères dépend de l’ordre de tri d’un caractère qui Faites précéder ou suivre.  
  
> [!CAUTION]
>  Le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> méthode est conçue essentiellement pour une utilisation dans de tri ou de tri alphabétique des opérations. Il ne doit pas être utilisé lorsque l’objectif principal de l’appel de méthode est de déterminer si deux chaînes sont équivalentes (autrement dit, lorsque l’objectif de l’appel de méthode est de tester une valeur de retour de zéro). Pour déterminer si deux chaînes sont équivalentes, appelez le <xref:System.String.Equals%2A> (méthode).  
  
 La comparaison peut être spécifiée ultérieurement par le `options` paramètre, qui se compose d’un ou plusieurs membres de la <xref:System.Globalization.CompareOptions> énumération. Toutefois, étant donné que l’objectif de cette méthode est d’effectuer une comparaison de chaînes sensible à la culture, le <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> et <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valeurs n’ont aucun effet.  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris <xref:System.String.Empty?displayProperty=nameWithType>, est supérieure à une référence null et deux références null sont égales entre elles.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux chaînes comparées. Toutefois, si les deux chaînes sont égales à la fin d’une chaîne et l’autre chaîne comporte des caractères restants, la chaîne avec les autres caractères est considéré comme supérieure.  
  
   
  
## Examples  
 L’exemple suivant compare deux chaînes de trois façons différentes : à l’aide de la comparaison linguistique pour la culture en-US ; à l’aide d’une comparaison respectant la casse linguistique pour la culture en-US ; et, à l’aide d’une comparaison ordinale. Il illustre la façon dont les trois méthodes de comparaison produisent trois résultats différents.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> n’est pas une valeur <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas pris en compte lorsque vous effectuez une comparaison linguistique ou dépendante de la culture. Le <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Pour qu’il reconnaisse les caractères ignorables dans votre comparaison, fournissez une valeur de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour la <paramref name="options" /> paramètre.</para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Position de la sous-chaîne dans <c>strA</c>.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Position de la sous-chaîne dans <c>strB</c>.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <summary>Compare les sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> précède la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Zéro  </term><description> Les sous-chaînes se produisent à la même position dans l’ordre de tri ou <paramref name="length" /> est zéro.  </description></item><item><term> Supérieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> suit la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les sous-chaînes à comparer commencent `strA` à `indexA` et dans `strB` à `indexB`. Les deux `indexA` et `indexB` sont de base zéro, c'est-à-dire le premier caractère dans `strA` et `strB` est à la position zéro. La longueur de la première sous-chaîne est égale à la longueur de `strA` moins `indexA` plus un. La longueur de la deuxième sous-chaîne est égale à la longueur de `strB` moins `indexB` plus un.  
  
 Le nombre de caractères à comparer est le plus petit des longueurs des deux sous-chaînes, et `length`. Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 La comparaison utilise la culture en cours pour obtenir des informations spécifiques à la culture telles que les règles de casse et l’ordre alphabétique de caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une manière particulière, ou que les caractères qui précèdent dépend de l’ordre de tri d’un caractère ou cliquer dessus.  
  
 La comparaison est effectuée à l’aide des règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Comparaison de chaînes, vous devez appeler la <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> (méthode), ce qui nécessite que vous spécifiez explicitement le type de comparaison de chaînes qui utilise de la méthode. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (« »), est supérieure à une référence null ; et deux références null sont égales.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux sous-chaînes ont été comparés. Toutefois, si les deux chaînes sont égales à la fin d’une chaîne et l’autre chaîne comporte des caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, dans la langue turque, l’exemple suivant donne des résultats erronés car le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Voici le code correct pour ce faire :  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 L’exemple suivant compare les sous-chaînes de deux.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see cref="P:System.String.Length" />.  -ou- <paramref name="indexB" /> est supérieur à <paramref name="strB" />.<see cref="P:System.String.Length" />.  -ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est négatif.  -ou- <paramref name="indexA" /> ou <paramref name="indexB" /> est <see langword="null" />, et <paramref name="length" /> est supérieur à zéro.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison linguistique ou dépendante de la culture. Pour reconnaître les caractères ignorables dans votre comparaison, appelez le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode et fournir une valeur de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour la <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Position de la sous-chaîne dans <c>strA</c>.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Position de la sous-chaîne dans <c>strB</c>.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <summary>Compare les sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés, en ignorant ou en respectant leur casse, et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> précède la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Zéro  </term><description> Les sous-chaînes se produisent à la même position dans l’ordre de tri ou <paramref name="length" /> est zéro.  </description></item><item><term> Supérieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> suit la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les sous-chaînes à comparer commencent `strA` à `indexA`et dans `strB` à `indexB`. Les deux `indexA` et `indexB` sont de base zéro, c'est-à-dire le premier caractère dans `strA` et `strB` est à la position zéro. La longueur de la première sous-chaîne est égale à la longueur de `strA` moins `indexA` plus un. La longueur de la deuxième sous-chaîne est égale à la longueur de `strB` moins `indexB` plus un.  
  
 Le nombre de caractères à comparer est le plus petit des longueurs des deux sous-chaînes, et `length`. Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 La comparaison utilise la culture en cours pour obtenir des informations spécifiques à la culture telles que les règles de casse et l’ordre alphabétique de caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une manière particulière, ou que les caractères qui précèdent dépend de l’ordre de tri d’un caractère ou cliquer dessus.  
  
 La comparaison est effectuée à l’aide des règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Comparaison de chaînes, vous devez appeler la <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> (méthode), ce qui nécessite que vous spécifiez explicitement le type de comparaison de chaînes qui utilise de la méthode. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (« »), est supérieure à une référence null ; et deux références null sont égales.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux sous-chaînes ont été comparés. Toutefois, si les deux chaînes sont égales à la fin d’une chaîne et l’autre chaîne comporte des caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, dans la langue turque, l’exemple suivant donne des résultats erronés car le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Le nom de chemin d’accès doit être comparée d’une manière invariante. Voici le code correct pour ce faire.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 L’exemple suivant effectue deux comparaisons de deux sous-chaînes qui ne diffèrent que par la casse. La première comparaison ignore la casse et la deuxième prend en compte.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see cref="P:System.String.Length" />.  -ou- <paramref name="indexB" /> est supérieur à <paramref name="strB" />.<see cref="P:System.String.Length" />.  -ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est négatif.  -ou- <paramref name="indexA" /> ou <paramref name="indexB" /> est <see langword="null" />, et <paramref name="length" /> est supérieur à zéro.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison linguistique ou dépendante de la culture. Pour reconnaître les caractères ignorables dans votre comparaison, appelez le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode et fournir une valeur de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour la <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Position de la sous-chaîne dans <c>strA</c>.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Position de la sous-chaîne dans <c>strB</c>.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <param name="comparisonType">Une des valeurs d'énumération qui spécifie les règles à utiliser dans la comparaison.</param>
        <summary>Compare les sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés à l'aide des règles désignées et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> précède la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Zéro </term><description> Les sous-chaînes se produisent à la même position dans l’ordre de tri ou le paramètre <paramref name="length" /> est zéro.  </description></item><item><term> Supérieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> suit la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les sous-chaînes à comparer commencent `strA` à `indexA` et dans `strB` à `indexB`. Les deux `indexA` et `indexB` sont de base zéro, c'est-à-dire le premier caractère dans `strA` et `strB` est à la position zéro, ne placez pas un. La longueur de la première sous-chaîne est égale à la longueur de `strA` moins `indexA` plus un. La longueur de la deuxième sous-chaîne est égale à la longueur de `strB` moins `indexB` plus un.  
  
 Le nombre de caractères à comparer est le plus petit des longueurs des deux sous-chaînes, et `length`. Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 Le `comparisonType` paramètre indique si la comparaison doit utiliser la culture actuelle ou indifférente, respecter ou ignorer la casse des comparateurs ou utiliser word (dépendante de la culture) ou des règles de tri basé sur ordinale (indépendante de la culture).  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (« »), est supérieure à une référence null ; et deux références null sont égales.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux sous-chaînes ont été comparés. Toutefois, si les deux chaînes sont égales à la fin d’une chaîne et l’autre chaîne comporte des caractères restants, la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, dans la langue turque, l’exemple suivant donne des résultats erronés car le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Voici le code correct pour ce faire :  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 L’exemple suivant compare les sous-chaînes de deux.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see cref="P:System.String.Length" />.  -ou- <paramref name="indexB" /> est supérieur à <paramref name="strB" />.<see cref="P:System.String.Length" />.  -ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est négatif.  -ou- <paramref name="indexA" /> ou <paramref name="indexB" /> est <see langword="null" />, et <paramref name="length" /> est supérieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison linguistique ou dépendante de la culture. Pour qu’il reconnaisse les caractères ignorables dans votre comparaison, fournissez une valeur de <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> pour la <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Position de la sous-chaîne dans <c>strA</c>.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Position de la sous-chaîne dans <c>strB</c>.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <param name="culture">Objet qui fournit des informations de comparaison propres à la culture.</param>
        <summary>Compare les sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés, en ignorant ou en respectant leur casse et en utilisant les informations propres à la culture pour influencer la comparaison, et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> précède la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Zéro  </term><description> Les sous-chaînes se produisent à la même position dans l’ordre de tri ou <paramref name="length" /> est zéro.  </description></item><item><term> Supérieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> suit la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les sous-chaînes à comparer commencent `strA` à `indexA`et dans `strB` à `indexB`. Les deux `indexA` et `indexB` sont de base zéro, c'est-à-dire le premier caractère dans `strA` et `strB` est à la position zéro, ne placez pas un. La longueur de la première sous-chaîne est égale à la longueur de `strA` moins `indexA` plus un. La longueur de la deuxième sous-chaîne est égale à la longueur de `strB` moins `indexB` plus un.  
  
 Le nombre de caractères à comparer est le plus petit des longueurs des deux sous-chaînes, et `length`. Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 La comparaison utilise le `culture` paramètre pour obtenir des informations spécifiques à la culture telles que les règles de casse et l’ordre alphabétique de caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une manière particulière, ou que les caractères qui précèdent dépend de l’ordre de tri d’un caractère ou cliquer dessus.  
  
 La comparaison est effectuée à l’aide des règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (« »), est supérieure à une référence null ; et deux références null sont égales.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux sous-chaînes ont été comparés. Toutefois, si les deux chaînes sont égales à la fin d’une chaîne et l’autre chaîne comporte des caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, dans la langue turque, l’exemple suivant donne des résultats erronés car le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Voici le code correct pour ce faire :  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 L’exemple suivant compare deux sous-chaînes utilisant des cultures différentes et ignorer la casse des sous-chaînes. Le choix de culture affecte la façon dont la lettre « I » est comparé.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see cref="P:System.String.Length" />.  -ou- <paramref name="indexB" /> est supérieur à <paramref name="strB" />.<see cref="P:System.String.Length" />.  -ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est négatif.  -ou- <paramref name="strA" /> ou <paramref name="strB" /> est <see langword="null" />, et <paramref name="length" /> est supérieur à zéro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison linguistique ou dépendante de la culture. Pour reconnaître les caractères ignorables dans votre comparaison, appelez le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> méthode et fournir une valeur de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour la <paramref name="options" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Position de départ de la sous-chaîne dans <c>strA</c>.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Position de départ de la sous-chaîne dans <c>strB</c>.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <param name="culture">Objet qui fournit des informations de comparaison propres à la culture.</param>
        <param name="options">Options à utiliser pour effectuer la comparaison (par exemple, ignorer la casse ou les symboles).</param>
        <summary>Compare des sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés en utilisant les options de comparaison spécifiées et les informations propres à la culture pour influencer la comparaison, et retourne un entier qui indique la relation entre ces deux sous-chaînes dans l'ordre de tri.</summary>
        <returns>Entier qui indique la relation lexicale entre les deux sous-chaînes, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> précède la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Zéro  </term><description> Les sous-chaînes se produisent à la même position dans l’ordre de tri ou <paramref name="length" /> est zéro.  </description></item><item><term> Supérieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> suit la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les sous-chaînes à comparer commencent `strA` à la position `indexA` et dans `strB` à la position `indexB`. La longueur de la première sous-chaîne est la longueur de `strA` moins `indexA`. La longueur de la deuxième sous-chaîne est la longueur de `strB` moins `indexB`.  
  
 Le nombre de caractères à comparer est le plus petit des longueurs des deux sous-chaînes, et `length`. Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 La comparaison utilise le `culture` paramètre pour obtenir des informations spécifiques à la culture, tels que les règles de casse et l’ordre alphabétique de caractères individuels. Par exemple, une culture particulière peut spécifier que certaines combinaisons de caractères considérée comme un caractère unique, de comparer les caractères majuscules et minuscules d’une manière particulière, ou que les caractères dépend de l’ordre de tri d’un caractère qui Faites précéder ou suivre.  
  
> [!CAUTION]
>  Le <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> méthode est conçue essentiellement pour une utilisation dans de tri ou de tri alphabétique des opérations. Il ne doit pas être utilisé lorsque l’objectif principal de l’appel de méthode est de déterminer si les deux sous-chaînes sont équivalentes (autrement dit, lorsque l’objectif de l’appel de méthode est de tester une valeur de retour de zéro). Pour déterminer si deux chaînes sont équivalentes, appelez le <xref:System.String.Equals%2A> (méthode).  
  
 Une ou les deux `strA` et `strB` peut être `null`. Par définition, toute chaîne, y compris <xref:System.String.Empty?displayProperty=nameWithType>, est supérieure à une référence null et deux références null sont égales entre elles.  
  
 La comparaison peut être spécifiée ultérieurement par le `options` paramètre, qui se compose d’un ou plusieurs membres de la <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> énumération. Toutefois, étant donné que l’objectif de cette méthode est d’effectuer une comparaison de chaînes sensible à la culture, le <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> et <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valeurs n’ont aucun effet.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux sous-chaînes ont été comparés. Toutefois, si les deux chaînes sont égales à la fin d’une chaîne et l’autre chaîne comporte des caractères restants, la chaîne avec les autres caractères est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> méthode pour comparer les noms de deux personnes. Elle les affiche ensuite dans l’ordre alphabétique.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> n’est pas une valeur <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see langword=".Length" />.  -ou- <paramref name="indexB" /> est supérieur à <paramref name="strB" /><see langword=".Length" />.  -ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est négatif.  -ou- <paramref name="strA" /> ou <paramref name="strB" /> est <see langword="null" />, et <paramref name="length" /> est supérieur à zéro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison linguistique ou dépendante de la culture. Pour qu’il reconnaisse les caractères ignorables dans votre comparaison, fournissez une valeur de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour la <paramref name="options" /> paramètre.</para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compare deux objets <see cref="T:System.String" /> en évaluant les valeurs numériques des objets <see cref="T:System.Char" /> correspondants dans chaque chaîne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés en évaluant les valeurs numériques des objets <see cref="T:System.Char" /> correspondants dans chaque chaîne.</summary>
        <returns>Entier qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro  </term><description><paramref name="strA" /> est inférieur à <paramref name="strB" />.  </description></item><item><term> Zéro  </term><description><paramref name="strA" /> et <paramref name="strB" /> sont égaux.  </description></item><item><term> Supérieur à zéro  </term><description><paramref name="strA" /> est supérieur à <paramref name="strB" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison respectant la casse à l’aide des règles de tri ordinal. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Pour effectuer une comparaison respectant la casse à l’aide des règles de tri ordinal, appelez le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> méthode avec la `comparisonType` affectée à l’argument <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Étant donné que <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> est une méthode statique, `strA` et `strB` peut être `null`. Si les deux valeurs sont `null`, la méthode retourne 0 (zéro), ce qui indique que `strA` et `strB` sont égales. Si seule une des valeurs est `null`, la méthode considère que la valeur non null est supérieure.  
  
   
  
## Examples  
 L’exemple suivant effectue et la comparaison ordinale de deux chaînes qui diffèrent uniquement par la casse.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Index de départ de la sous-chaîne dans <c>strA</c>.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Index de départ de la sous-chaîne dans <c>strB</c>.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <summary>Compare les sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés en évaluant les valeurs numériques des objets <see cref="T:System.Char" /> correspondants de chaque sous-chaîne.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> est inférieure à la sous-chaîne de <paramref name="strB" />.  </description></item><item><term> Zéro </term><description> Les sous-chaînes sont égales ou <paramref name="length" /> est égal à zéro.  </description></item><item><term> Supérieur à zéro </term><description> La sous-chaîne de <paramref name="strA" /> est supérieure à la sous-chaîne de <paramref name="strB" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 Le nombre de caractères comparés est le plus petit de la longueur de `strA` moins `indexA`, la longueur de `strB` moins `indexB`, et `length`.  
  
 Cette méthode effectue une comparaison respectant la casse à l’aide des règles de tri ordinal. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Pour effectuer une comparaison respectant la casse à l’aide des règles de tri ordinal, appelez le <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> méthode avec la `comparisonType` affectée à l’argument <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Étant donné que <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> est une méthode statique, `strA` et `strB` peut être `null`. Si les deux valeurs sont `null`, la méthode retourne 0 (zéro), ce qui indique que `strA` et `strB` sont égales. Si seule une des valeurs est `null`, la méthode considère que la valeur non null est supérieure.  
  
   
  
## Examples  
 L’exemple suivant montre que <xref:System.String.CompareOrdinal%2A> et <xref:System.String.Compare%2A> utilisent différents ordres de tri.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" /> n’est pas <see langword="null" /> et <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see cref="P:System.String.Length" />.  -ou- <paramref name="strB" /> n’est pas <see langword="null" /> et <paramref name="indexB" /> est supérieur à <paramref name="strB" />.<see cref="P:System.String.Length" />.  -ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est négatif.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compare cette instance à un objet spécifié ou <see cref="T:System.String" /> et retourne un entier qui indique si cette instance précède, suit ou apparaît à la même position dans l'ordre de tri que l'objet spécifié ou <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les deux surcharges de la <xref:System.String.CompareTo%2A> méthode effectuer une comparaison dépendante de la culture et respecte la casse. Vous ne pouvez pas utiliser cette méthode pour effectuer des comparaisons indépendantes de la culture ou ordinales. Pour la clarté du code, nous vous recommandons d’éviter le <xref:System.String.CompareTo%2A> (méthode) et appelez le <xref:System.String.Compare%2A> (méthode) à la place.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet qui prend pour valeur <see cref="T:System.String" />.</param>
        <summary>Compare cette instance avec un <see cref="T:System.Object" /> spécifié et indique si cette instance précède, suit ou apparaît à la même position dans l'ordre de tri que le <see cref="T:System.Object" /> spécifié.</summary>
        <returns>Entier signé 32 bits qui indique si cette instance précède, suit ou apparaît dans la même position dans l'ordre de tri que le paramètre <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro  </term><description> Cette instance précède <paramref name="value" />.  </description></item><item><term> Zéro  </term><description> Cette instance a la même position que <paramref name="value" /> dans l’ordre de tri.  </description></item><item><term> Supérieur à zéro  </term><description> Cette instance suit <paramref name="value" />. -ou- <paramref name="value" /> est <see langword="null" />. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` doit être un <xref:System.String> objet.  
  
> [!CAUTION]
>  Le <xref:System.String.CompareTo%2A> méthode a été conçue pour être utilisée dans le tri ou le tri alphabétique des opérations. Il ne doit pas être utilisé lorsque l’objectif principal de l’appel de méthode est de déterminer si deux chaînes sont équivalentes. Pour déterminer si deux chaînes sont équivalentes, appelez le <xref:System.String.Equals%2A> (méthode).  
  
 Cette méthode effectue une comparaison de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Pour plus d’informations sur le comportement de cette méthode, consultez la section Notes de la <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.String.CompareTo%2A> méthode avec un <xref:System.Object>. Car elle tente de comparer un <xref:System.String> de l’instance à un `TestClass` de l’objet, la méthode lève un <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> n'est pas un <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.CompareTo(System.Object)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Par exemple, si le code suivant est exécuté sur le [ ! Include[netfx40_short](~/Includes/netfx40-short-MD.MD)] ou une version ultérieure, une comparaison de « préféré » avec « ani Outlook » (à l’aide d’un trait d’union, ou U + 00AD) indique que les deux chaînes sont équivalentes.  [ ! code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [ ! code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  Pour qu’il reconnaisse les caractères ignorables dans une comparaison de chaînes, appeler le <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> (méthode).</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Chaîne à comparer à cette instance.</param>
        <summary>Compare cette instance avec un objet <see cref="T:System.String" /> spécifié et indique si cette instance précède, suit ou apparaît à la même position dans l'ordre de tri que la chaîne spécifiée.</summary>
        <returns>Entier signé 32 bits qui indique si cette instance précède, suit ou apparaît dans la même position dans l'ordre de tri que le paramètre <paramref name="strB" />.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro  </term><description> Cette instance précède <paramref name="strB" />.  </description></item><item><term> Zéro  </term><description> Cette instance a la même position que <paramref name="strB" /> dans l’ordre de tri.  </description></item><item><term> Supérieur à zéro  </term><description> Cette instance suit <paramref name="strB" />. -ou- <paramref name="strB" /> est <see langword="null" />. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Le <xref:System.String.CompareTo%2A> méthode a été conçue pour être utilisée dans le tri ou le tri alphabétique des opérations. Il ne doit pas être utilisé lorsque l’objectif principal de l’appel de méthode est de déterminer si deux chaînes sont équivalentes. Pour déterminer si deux chaînes sont équivalentes, appelez le <xref:System.String.Equals%2A> (méthode).  
  
 Pour plus d’informations sur le comportement de cette méthode, consultez la section Notes de la <xref:System.String.Compare%28System.String%2CSystem.String%29> (méthode).  
  
 Cette méthode implémente la <xref:System.IComparable%601?displayProperty=nameWithType> interface et effectue légèrement meilleures que les <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> (méthode), car il n’a pas déterminer si le `strB` argument est un type valeur mutable qui doit être convertie (boxed), et il n’a pas d’effectuer un cast son paramètre d’une <xref:System.Object> à un <xref:System.String>.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.String.CompareTo%2A> méthode compare l’instance de chaîne actuelle par une autre chaîne.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 L’exemple suivant montre les versions génériques et non générique de la méthode CompareTo pour plusieurs types valeur et référence.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.CompareTo(System.String)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Par exemple, si le code suivant est exécuté sur le [ ! Include[netfx40_short](~/Includes/netfx40-short-MD.MD)] ou une version ultérieure, une comparaison de « préféré » avec « ani Outlook » (à l’aide d’un trait d’union, ou U + 00AD) indique que les deux chaînes sont équivalentes.  [ ! code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [ ! code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  Pour qu’il reconnaisse les caractères ignorables dans une comparaison de chaînes, appeler le <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> (méthode).</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatène une ou plusieurs instances de <see cref="T:System.String" /> ou les représentations <see cref="T:System.String" /> des valeurs d'une ou de plusieurs instances de <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">Collection d'objets qui implémente <see cref="T:System.Collections.Generic.IEnumerable`1" /> et dont l'argument de type générique est <see cref="T:System.String" />.</param>
        <summary>Concatène les membres d'une collection <see cref="T:System.Collections.Generic.IEnumerable`1" /> construite de type <see cref="T:System.String" />.</summary>
        <returns>Chaînes concaténées dans <paramref name="values" /> ou <see cref="F:System.String.Empty" /> si <paramref name="values" /> est un <see langword="IEnumerable(Of String)" /> vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène chaque objet dans `values`; il n’ajoute pas de délimiteurs. Pour spécifier un délimiteur entre chaque membre de `values`, appelez le <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> (méthode).  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place d’un élément null de `values`.  
  
 Si `values` est vide `IEnumerable(Of String)`, la méthode retourne <xref:System.String.Empty?displayProperty=nameWithType>. Si `values` est `null`, la méthode lève un <xref:System.ArgumentNullException> exception.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> est une méthode pratique qui vous permet de concaténer chaque élément dans un `IEnumerable(Of String)` collection sans avoir à convertir les éléments dans un tableau de chaînes. Il est particulièrement utile avec les expressions de requête Language-Integrated Query (LINQ). L’exemple suivant passe un `List(Of String)` objet contenant les lettres majuscules ou minuscules de l’alphabet à une expression lambda qui sélectionne des lettres qui sont égales ou supérieures à une lettre particulière (c'est-à-dire, dans l’exemple, « M »). Le `IEnumerable(Of String)` collection qui est retournée par le <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> est passé à la méthode le <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> méthode pour afficher le résultat sous forme de chaîne unique.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 L’exemple suivant utilise le crible d’Ératosthène pour calculer les nombres premiers qui sont inférieurs ou égaux à 100. Il assigne le résultat à un <xref:System.Collections.Generic.List%601> objet de type <xref:System.String>, qu’il passe ensuite à la <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> (méthode).  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Objet à représenter, ou <see langword="null" />.</param>
        <summary>Crée la représentation sous forme de chaîne d'un objet spécifié.</summary>
        <returns>Représentation sous forme de chaîne de la valeur de <paramref name="arg0" />, ou <see cref="F:System.String.Empty" /> si <paramref name="arg0" /> est <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.Concat%28System.Object%29> méthode représente `arg0` sous forme de chaîne en appelant sa `ToString` (méthode).  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.Concat%2A> (méthode).  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Tableau d'objets qui contient les éléments à concaténer.</param>
        <summary>Concatène les représentations sous forme de chaîne des éléments dans un tableau <see cref="T:System.Object" /> spécifié.</summary>
        <returns>Représentations sous forme de chaînes concaténées des valeurs des éléments dans <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène chaque objet dans `args` en appelant sans paramètre `ToString` méthode de cet objet ; il n’ajoute pas de délimiteurs.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> est utilisé à la place de tout objet null dans le tableau.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.String.Concat%2A> méthode avec un <xref:System.Object> tableau.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> est <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Mémoire insuffisante.</exception>
        <block subset="none" type="usage">
          <para>Cette méthode n’est pas appelée par du code C++. Le compilateur C++ résout les appels à <see cref="Overload:System.String.Concat" /> qui ont des paramètres d’objet de quatre ou plus comme un appel à <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Tableau d'instances de chaîne.</param>
        <summary>Concatène les éléments d'un tableau <see cref="T:System.String" /> spécifié.</summary>
        <returns>Éléments concaténés de <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène chaque objet dans `values`; il n’ajoute pas de délimiteurs.  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place de tout objet null dans le tableau.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.String.Concat%2A> méthode avec un <xref:System.String> tableau.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> est <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Mémoire insuffisante.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Premier objet à concaténer.</param>
        <param name="arg1">Second objet à concaténer.</param>
        <summary>Concatène les représentations sous forme de chaîne de deux objets spécifiés.</summary>
        <returns>Représentations sous forme de chaîne concaténées des valeurs des paramètres <paramref name="arg0" /> et <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène `arg0` et `arg1` en appelant sans paramètre `ToString` méthode `arg0` et `arg1`; il n’ajoute pas de délimiteurs.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> est utilisé à la place de tout argument null.  
  
 Si un des arguments est une référence de tableau, la méthode concatène une chaîne qui représente ce tableau, au lieu de ses membres (par exemple, « System.String[]").  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.Concat%2A> (méthode).  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Première chaîne à concaténer.</param>
        <param name="str1">Seconde chaîne à concaténer.</param>
        <summary>Concatène deux instances spécifiées de <see cref="T:System.String" />.</summary>
        <returns>Concaténation de <paramref name="str0" /> et <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène `str0` et `str1`; il n’ajoute pas de délimiteurs.  
  
> [!NOTE]
>  Vous pouvez également utiliser d’opérateur de concaténation de chaîne de votre langage, tel que `+` en c#, ou `&` et `+` en Visual Basic)  
>   
>  , pour concaténer des chaînes.  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place de tout argument null.  
  
   
  
## Examples  
 L’exemple suivant concatène le prénom, intermédiaire et le nom d’une personne.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Premier objet à concaténer.</param>
        <param name="arg1">Second objet à concaténer.</param>
        <param name="arg2">Troisième objet à concaténer.</param>
        <summary>Concatène les représentations sous forme de chaîne de trois objets spécifiés.</summary>
        <returns>Représentations sous forme de chaîne concaténées des valeurs des paramètres <paramref name="arg0" />, <paramref name="arg1" /> et <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène `arg0`, `arg1`, et `arg2` en appelant sans paramètre `ToString` méthode de chaque objet ; il n’ajoute pas de délimiteurs.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> est utilisé à la place de tout argument null.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.Concat%2A> (méthode).  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Première chaîne à concaténer.</param>
        <param name="str1">Seconde chaîne à concaténer.</param>
        <param name="str2">Troisième chaîne à concaténer.</param>
        <summary>Concatène trois instances spécifiées de <see cref="T:System.String" />.</summary>
        <returns>Concaténation de <paramref name="str0" />, <paramref name="str1" /> et <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène `str0`, `str1`, et `str2`; il n’ajoute pas de délimiteurs.  
  
> [!NOTE]
>  Vous pouvez également utiliser d’opérateur de concaténation de chaîne de votre langage, tel que `+` en c#, ou `&` et `+` en Visual Basic)  
>   
>  , pour concaténer des chaînes.  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place de tout argument null.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.String.Concat%2A> méthode pour concaténer trois chaînes et affiche le résultat.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Premier objet à concaténer.</param>
        <param name="arg1">Second objet à concaténer.</param>
        <param name="arg2">Troisième objet à concaténer.</param>
        <param name="arg3">Quatrième objet à concaténer.</param>
        <summary>Concatène les représentations sous forme de chaîne de quatre objets spécifiés et de tous les objets spécifiés dans une liste facultative de paramètres de longueur variable.</summary>
        <returns>Représentation sous forme de chaîne concaténée de chaque valeur de la liste de paramètres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette API n'est pas conforme CLS. L’alternative conforme CLS est <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Les compilateurs c# et Visual Basic résoudre automatiquement un appel à cette méthode comme un appel à <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 La méthode concatène chaque objet dans la liste de paramètres en appelant sa `ToString` méthode ; il n’ajoute pas de délimiteurs.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> est utilisé à la place de tout argument null.  
  
> [!NOTE]
>  Le dernier paramètre de la <xref:System.String.Concat%2A> méthode est une liste facultative délimitée par des virgules d’un ou plusieurs objets supplémentaires à concaténer.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> méthode pour concaténer une liste de paramètres de variables. Dans ce cas, la méthode est appelée avec neuf paramètres.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Cette méthode est marquée avec le <see langword="vararg" /> (mot clé), ce qui signifie qu’il prend en charge un nombre variable de paramètres. La méthode peut être appelée à partir de Visual C++, mais il ne peut pas être appelé à partir de code c# ou Visual Basic. Les compilateurs c# et Visual Basic résolvent les appels à <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> comme des appels à <see cref="M:System.String.Concat(System.Object[])" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Première chaîne à concaténer.</param>
        <param name="str1">Seconde chaîne à concaténer.</param>
        <param name="str2">Troisième chaîne à concaténer.</param>
        <param name="str3">Quatrième chaîne à concaténer.</param>
        <summary>Concatène quatre instances spécifiées de <see cref="T:System.String" />.</summary>
        <returns>Concaténation de <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> et <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène `str0`, `str1`, `str2`, et `str3`; il n’ajoute pas de délimiteurs.  
  
> [!NOTE]
>  Vous pouvez également utiliser d’opérateur de concaténation de chaîne de votre langage, tel que `+` en c#, ou `&` et `+` en Visual Basic)  
>   
>  , pour concaténer des chaînes.  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place de tout objet null dans le tableau.  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de quatre – lettre mots et stocke leurs lettres individuelles dans un tableau de chaînes pour les mélanger. Il appelle ensuite la <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> méthode pour réassembler les mots mélangés.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Le type des membres de <c>valeurs</c>.</typeparam>
        <param name="values">Objet de collection qui implémente l'interface <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Concatène les membres d'une implémentation <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Membres concaténés dans <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène chaque objet dans `values`; il n’ajoute pas de délimiteurs.  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place de tout argument null.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> est une méthode pratique qui vous permet de concaténer chaque élément dans un <xref:System.Collections.Generic.IEnumerable%601> collection sans avoir à convertir les éléments en chaînes. Il est particulièrement utile avec les expressions de requête Language-Integrated Query (LINQ), comme l’illustre l’exemple. La représentation sous forme de chaîne de chaque objet dans le <xref:System.Collections.Generic.IEnumerable%601> collection est dérivée en appelant l’objet `ToString` (méthode).  
  
   
  
## Examples  
 L’exemple suivant définit un très simple `Animal` classe qui contient le nom d’un animal et l’ordre auquel il appartient. Il définit ensuite une <xref:System.Collections.Generic.List%601> objet peuvent contenir un nombre de `Animal` objets. Le <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> méthode d’extension est appelée pour extraire le `Animal` objets dont `Order` propriété est égale à « Rongeurs ». Le résultat est passé à la <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> méthode et affichée dans la console.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <summary>Retourne une valeur qui indique si la sous-chaîne spécifiée apparaît dans cette chaîne.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> apparaît dans cette chaîne, ou si <paramref name="value" /> est la chaîne vide ("") ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison d’ordinale (respectant la casse et indépendantes de la culture). La recherche commence à la première position de caractère de cette chaîne et continue jusqu'à la dernière position de caractère.  
  
 Pour déterminer si une chaîne contient une sous-chaîne spécifiée à l’aide d’autre chose qu’une comparaison ordinale (par exemple, la comparaison dépendante de la culture ou ordinale comparaison respectant la casse), vous pouvez créer une méthode personnalisée. L’exemple suivant illustre une telle approche. Il définit un <xref:System.String> méthode d’extension qui inclut un <xref:System.StringComparison> paramètre qui indique si une chaîne contient une sous-chaîne lors de l’utilisation de la forme spécifiée de la comparaison de chaînes.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 L’exemple suivant appelle ensuite la `Contains` méthode d’extension pour déterminer si une sous-chaîne a été trouvée dans une chaîne lors de l’utilisation de la comparaison ordinale et la comparaison ordinale respectant la casse.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Si vous êtes intéressé par la position de la sous-chaîne `value` dans l’instance actuelle, vous pouvez appeler la <xref:System.String.IndexOf%2A> méthode pour obtenir la position de départ de sa première occurrence, ou vous pouvez appeler la <xref:System.String.LastIndexOf%2A> position de la méthode à obtenir le démarrage de son dernière occurrence. L’exemple inclut un appel à la <xref:System.String.IndexOf%28System.String%29> méthode si une sous-chaîne est trouvée dans une instance de chaîne.  
  
   
  
## Examples  
 L’exemple suivant détermine si la chaîne « fox » est une sous-chaîne d’une citation connue. Si « renard » dans la chaîne est trouvée, elle affiche également sa position de départ.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Chaîne à copier.</param>
        <summary>Crée une instance de <see cref="T:System.String" /> ayant la même valeur qu'un <see cref="T:System.String" /> spécifié.</summary>
        <returns>Nouvelle chaîne ayant la même valeur que <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.Copy%2A> méthode retourne un <xref:System.String> objet qui a la même valeur que la chaîne d’origine, mais représente une référence d’objet différent. Il diffère d’une opération d’assignation, qui assigne une référence de chaîne existante à une variable objet supplémentaires. L’exemple illustre la différence.  
  
   
  
## Examples  
 L’exemple suivant crée deux objets string avec des valeurs différentes. Lorsqu’il appelle le <xref:System.String.Copy%2A> méthode pour attribuer la première valeur à la deuxième chaîne, la sortie indique que les chaînes représentent des références d’objet différentes bien que leurs valeurs sont maintenant égales. En revanche, lorsque la première chaîne est assignée à la deuxième chaîne, les deux chaînes ont des valeurs identiques, car elles représentent la même référence d’objet.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Index du premier caractère de cette instance à copier.</param>
        <param name="destination">Tableau de caractères Unicode dans lequel les caractères de cette instance sont copiés.</param>
        <param name="destinationIndex">Index de <c>destination</c> au niveau duquel commence l’opération de copie.</param>
        <param name="count">Nombre de caractères dans cette instance à copier vers <c>destination</c>.</param>
        <summary>Copie un nombre spécifié de caractères à partir d'une position spécifiée dans cette instance vers une position spécifiée dans un tableau de caractères Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie `count` caractères à partir de la `sourceIndex` position de cette instance à la `destinationIndex` position de `destination` tableau de caractères. Cette méthode n’est pas redimensionné le `destination` tableau de caractères ; il doit avoir un nombre suffisant d’éléments à prendre en charge les caractères copiés ou la méthode lève un <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` et `destinationIndex` sont de base zéro.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.CopyTo%2A> (méthode).  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> ou <paramref name="count" /> est négatif -ou- <paramref name="sourceIndex" /> n’identifie pas de position dans l’instance actuelle.  -ou- <paramref name="destinationIndex" /> n’identifie pas d’index valide dans le tableau <paramref name="destination" />.  -ou- <paramref name="count" /> est supérieur à la longueur de la sous-chaîne entre <paramref name="sourceIndex" /> et la fin de cette instance -ou- <paramref name="count" /> est supérieur à la longueur du sous-tableau entre <paramref name="destinationIndex" /> et la fin du tableau <paramref name="destination" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la chaîne vide. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de ce champ est la chaîne de longueur nulle, « ».  
  
 Dans le code d’application, ce champ est couramment utilisé dans les attributions d’initialiser une variable de chaîne en une chaîne vide. Pour tester si la valeur d’une chaîne est `null` ou <xref:System.String.Empty?displayProperty=nameWithType>, utilisez le <xref:System.String.IsNullOrEmpty%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si la fin de cette instance de chaîne correspond à une chaîne spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer à la sous-chaîne à la fin de cette instance.</param>
        <summary>Détermine si la fin de cette instance de chaîne correspond à la chaîne spécifiée.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> correspond à la fin de cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode compare `value` à la sous-chaîne à la fin de cette instance est la même longueur que `value`et retourne une indication si elles sont égales. Pour être égale, `value` doit être une référence à cette même instance ou correspondre à la fin de cette instance.  
  
 Cette méthode effectue une comparaison de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle.  
  
   
  
## Examples  
 L’exemple suivant indique si chaque chaîne dans un tableau se termine par un point («. »).  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 L’exemple suivant définit un `StripEndTags` méthode qui utilise le <xref:System.String.EndsWith%28System.String%29> méthode pour supprimer les balises de fin HTML à partir de la fin d’une ligne. Notez que le `StripEndTags` méthode est appelée pour vous assurer que plusieurs balises de fin HTML à la fin de la ligne sont supprimés de manière récursive.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [Best Practices for à l’aide de Strings](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent les méthodes qui requièrent des paramètres pour être explicitement spécifié. Pour déterminer si une chaîne se termine par une sous-chaîne particulière en utilisant les règles de comparaison de la culture actuelle, appelez la <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> avec une valeur de la surcharge de méthode <see cref="F:System.StringComparison.CurrentCulture" /> pour son <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer à la sous-chaîne à la fin de cette instance.</param>
        <param name="comparisonType">Une des valeurs d’énumération qui détermine le mode de comparaison entre cette chaîne et <c>value</c>.</param>
        <summary>Détermine si la fin de cette instance de chaîne correspond à la chaîne spécifiée quand elle est comparée à l'aide de l'option spécifiée.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> correspond à la fin de cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.EndsWith%2A> méthode compare la `value` paramètre à la sous-chaîne à la fin de cette chaîne et retourne une valeur qui indique s’ils sont égaux. Pour être égale, `value` doit être une référence à cette même chaîne, doit être une chaîne vide (« »), ou doit correspondre à la fin de cette chaîne. Le type de comparaison effectuée par le <xref:System.String.EndsWith%2A> méthode dépend de la valeur de le `comparisonType` paramètre.  
  
   
  
## Examples  
 L’exemple suivant détermine si une chaîne se termine par une sous-chaîne particulière. Les résultats sont affectés par le choix de la culture, si la casse est ignorée et indique si une comparaison ordinale est effectuée.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer à la sous-chaîne à la fin de cette instance.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <param name="culture">Informations culturelles qui déterminent le mode de comparaison entre cette instance et <c>value</c>. Si <c>culture</c> est <see langword="null" />, la culture actuelle est utilisée.</param>
        <summary>Détermine si la fin de cette instance de chaîne correspond à la chaîne spécifiée quand elle est comparée à l'aide de la culture spécifiée.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> correspond à la fin de cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode compare la `value` paramètre à la sous-chaîne à la fin de cette chaîne est la même longueur que `value`et retourne une valeur qui indique s’ils sont égaux. Pour être égale, `value` doit être une référence à cette même instance ou correspondre à la fin de cette chaîne.  
  
 Cette méthode effectue une comparaison de (dépendante de la culture) de word à l’aide de la casse spécifiée et la culture.  
  
   
  
## Examples  
 L’exemple suivant détermine si une chaîne se produit à la fin d’une autre chaîne. Le <xref:System.String.EndsWith%2A> méthode est appelée plusieurs fois avec respect de la casse, non-respect de la casse et différentes cultures qui influencent les résultats de la recherche.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si deux objets <see cref="T:System.String" /> ont la même valeur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Chaîne à comparer à cette instance.</param>
        <summary>Détermine si cette instance et un objet spécifié, qui doit aussi être un objet <see cref="T:System.String" />, ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si <paramref name="obj" /> est <see cref="T:System.String" /> et possède la même valeur que cette instance ; sinon, <see langword="false" />.  Si <paramref name="obj" /> est <see langword="null" />, la méthode retourne <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison d’ordinale (respectant la casse et indépendantes de la culture).  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.Equals%2A> (méthode).  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer à cette instance.</param>
        <summary>Détermine si cette instance et un autre objet <see cref="T:System.String" /> spécifié ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si la valeur du paramètre <paramref name="value" /> est la même que celle de cette instance ; sinon, <see langword="false" />. Si <paramref name="value" /> est <see langword="null" />, la méthode retourne <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison d’ordinale (respectant la casse et indépendantes de la culture).  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.Equals%2A> (méthode). Il compare le mot de casse de titre « Fichier » avec un mot équivalent, son équivalent en minuscules, son équivalent en majuscule et un mot qui contient des caractères latins petite lettre sans point I (U + 0131) au lieu de LATIN petite lettre I (U + 0069). Étant donné que la <xref:System.String.Equals%28System.String%29> méthode effectue une comparaison ordinale, uniquement la comparaison avec un mot identiques retourne `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Première chaîne à comparer ou <see langword="null" />.</param>
        <param name="b">Seconde chaîne à comparer ou <see langword="null" />.</param>
        <summary>Détermine si deux objets <see cref="T:System.String" /> spécifiés ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si la valeur de <paramref name="a" /> est égale à la valeur de <paramref name="b" /> ; sinon <see langword="false" />. Si <paramref name="a" /> et <paramref name="b" /> ont la valeur <see langword="null" />, la méthode retourne <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison d’ordinale (respectant la casse et indépendantes de la culture).  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.Equals%2A> (méthode).  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer à cette instance.</param>
        <param name="comparisonType">Une des valeurs d'énumération qui spécifie le mode de comparaison des chaînes.</param>
        <summary>Détermine si cette chaîne et un objet <see cref="T:System.String" /> spécifié ont la même valeur. Un paramètre spécifie la culture, la casse et les règles de tri utilisées dans la comparaison.</summary>
        <returns>
          <see langword="true" /> si la valeur du paramètre <paramref name="value" /> est la même que cette chaîne ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `comparisonType` paramètre indique si la comparaison doit utiliser la culture actuelle ou indifférente, respecter ou ignorer la casse des deux chaînes comparées ou utiliser word ou des règles de tri ordinal.  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de chaînes qui se compose d’une majuscule « I », un caractère minuscule « i » et un « ı » sans point. Il appelle ensuite la <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> méthode permet de les comparer à l’aide de chaque possible <xref:System.StringComparison> valeur d’énumération.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 L’exemple suivant compare les quatre jeux de mots à l’aide de chaque membre de la <xref:System.StringComparison> énumération.  Les comparaisons utilisent les conventions de l’anglais (États-Unis) et cultures de Sami (Suède supérieur). Notez que les chaînes « encyclopædia » et « Encyclopédie » sont considérés comme équivalents dans la culture en-US, mais pas dans la culture Sami (Suède du Nord).  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">Première chaîne à comparer ou <see langword="null" />.</param>
        <param name="b">Seconde chaîne à comparer ou <see langword="null" />.</param>
        <param name="comparisonType">Une des valeurs d'énumération qui spécifie les règles de la comparaison.</param>
        <summary>Détermine si deux objets <see cref="T:System.String" /> spécifiés ont la même valeur. Un paramètre spécifie la culture, la casse et les règles de tri utilisées dans la comparaison.</summary>
        <returns>
          <see langword="true" /> si la valeur du paramètre <paramref name="a" /> est égale à la valeur du paramètre <paramref name="b" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `comparisonType` paramètre indique si la comparaison doit utiliser la culture actuelle ou indifférente, respecter ou ignorer la casse des deux chaînes comparées ou utiliser word ou des règles de tri ordinal.  
  
   
  
## Examples  
 L’exemple suivant compare les quatre jeux de mots à l’aide de chaque membre de la <xref:System.StringComparison> énumération.  Les comparaisons utilisent les conventions de l’anglais (États-Unis) et cultures de Sami (Suède supérieur). Notez que les chaînes « encyclopædia » et « Encyclopédie » sont considérés comme équivalents dans la culture en-US, mais pas dans la culture Sami (Suède du Nord).  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la valeur des objets en chaînes selon les formats spécifiés et les insère dans une autre chaîne.  Si vous découvrez la méthode `String.Format`, consultez la section [Bien démarrer avec la méthode String.Format](#Starting) pour avoir une rapide vue d’ensemble.  Consultez la section [Remarque](#remarks-top) pour de la documentation générale sur la méthode `String.Format`.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 Dans cette section :  
  
 [Prise en main la méthode String.Format](#Starting)   
 [Quelle méthode appeler ?](#FTaskList)   
 [La méthode Format en bref](#Format_Brief)   
 [L’élément de Format](#FormatItem)   
 [Comment les arguments sont mis en forme](#HowFormatted)   
 [Éléments de format qui ont le même index](#SameIndex)   
 [Mise en forme et à la culture](#Format_Culture)   
 [Opérations de mise en forme personnalisée](#Format_Custom)   
 [String.Format Q & r](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Prise en main la méthode String.Format  
 Utilisez <xref:System.String.Format%2A?displayProperty=nameWithType> si vous devez insérer la valeur d’un objet, une variable ou une expression dans une autre chaîne. Par exemple, vous pouvez insérer la valeur d’un <xref:System.Decimal> valeur en une chaîne pour l’afficher à l’utilisateur sous forme de chaîne unique :  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 Et vous pouvez contrôler la mise en forme de cette valeur :  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Outre la mise en forme, vous pouvez également contrôler alignement et l’espacement.  
  
 ### <a name="inserting-a-string"></a>Insertion d’une chaîne  

 <xref:System.String.Format%2A?displayProperty=nameWithType> commence par une chaîne de format, suivie d’un ou plusieurs objets ou des expressions qui seront converties en chaînes et insérées à un emplacement spécifié dans la chaîne de format. Exemple :  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 Le `{0}` dans le format de chaîne est un élément de format. `0` est l’index de l’objet dont la valeur de chaîne doit être insérée à cette position. (Les index commencent à 0.) Si l’objet à insérer n’est pas une chaîne, son `ToString` méthode est appelée pour convertir un avant de l’insérer dans la chaîne de résultat.  
  
 Voici un autre exemple qui utilise les deux éléments de format et de deux objets dans la liste d’objets :  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Vous pouvez avoir autant d’éléments format et qu’un grand nombre d’objets dans la liste d’objets que vous souhaitez, tant que l’index de chaque élément de format a un objet correspondant dans la liste d’objets. Vous n’avez à vous soucier sur quelle surcharge, vous appelez ; le compilateur sélectionne celui qui convient à votre place.  
  
 ### <a name="controlling-formatting"></a>Contrôle de la mise en forme  
 Vous pouvez suivre l’index dans un élément de format avec une chaîne de format pour contrôler la façon dont un objet est mis en forme. Par exemple, `{0:d}` s’applique la chaîne de format « d » pour le premier objet dans la liste d’objets. Voici un exemple avec un seul objet et deux éléments de format :  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Un numéro de prise en charge des types de chaînes de format, y compris tous les types numériques (les deux [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) et [personnalisé](~/docs/standard/base-types/custom-numeric-format-strings.md) chaînes de format), toutes les dates et heures (les deux [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [personnalisé](~/docs/standard/base-types/custom-date-and-time-format-strings.md) chaînes de format) et les intervalles de temps (à la fois [standard](~/docs/standard/base-types/standard-timespan-format-strings.md) et [personnalisé](~/docs/standard/base-types/custom-timespan-format-strings.md) chaînes de format), tous les types énumération [types énumération ](~/docs/standard/base-types/enumeration-format-strings.md), et [GUID](https://msdn.microsoft.com/library/97af8hh4.aspx). Vous pouvez également ajouter la prise en charge des chaînes de format pour vos propres types.  
  
 ### <a name="controlling-spacing"></a>Contrôle de l’espacement  
 Vous pouvez définir la largeur de la chaîne qui est insérée dans la chaîne de résultat à l’aide de syntaxe comme `{0,12}`, qui insère une chaîne de 12 caractères. Dans ce cas, la représentation sous forme de chaîne du premier objet est aligné à droite dans le champ de 12 caractères.  (Si la représentation sous forme de chaîne du premier objet est plus de 12 caractères, toutefois, la largeur préférée du champ est ignorée et la chaîne entière est insérée dans la chaîne de résultat.)  
  
 L’exemple suivant définit un champ de 6 caractères pour contenir la chaîne « Année » et certaines chaînes de l’année, ainsi un champ de 15 caractères pour contenir la chaîne « Remplissage » et des données de la population. Notez que les caractères sont alignés à droite du champ.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Contrôle de l’alignement  
 Par défaut, les chaînes sont alignés à droite dans leur champ si vous spécifiez une largeur de champ. Pour aligner à gauche les chaînes dans un champ, vous faites précéder la largeur de champ avec un signe négatif, tel que `{0,-12}` pour définir un champ alignée à droite de 12 caractères.  
  
 L’exemple suivant est similaire au précédent, à ceci près qu’il aligne à gauche les étiquettes et les données.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> utilise la fonctionnalité de mise en forme composite. Pour plus d’informations, consultez [Mise en forme composite](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Quelle méthode appeler ?  
  
|À|Call|  
|--------|----------|  
|Mettre en forme un ou plusieurs objets en utilisant les conventions de la culture actuelle.|À l’exception des surcharges qui incluent un `provider` paramètre, les autres <xref:System.String.Format%2A> surcharges incluent un <xref:System.String> paramètre suivie d’un ou plusieurs paramètres de l’objet. Pour cette raison, il est inutile déterminer quelle <xref:System.String.Format%2A> surcharge que vous voulez appeler. Le compilateur de langage sélectionne la surcharge appropriée parmi les surcharges qui n’ont pas un `provider` paramètre, en fonction de votre liste d’arguments. Par exemple, si votre liste d’arguments possède cinq arguments, le compilateur appelle le <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> (méthode).|  
|Mettre en forme un ou plusieurs objets en utilisant les conventions d’une culture spécifique.|Chaque <xref:System.String.Format%2A> surcharge qui commence par un `provider` paramètre est suivi d’un <xref:System.String> paramètre et la valeur d’un ou plusieurs paramètres de l’objet. Pour cette raison, vous n’êtes pas obligé de déterminer quelles <xref:System.String.Format%2A> surcharge que vous voulez appeler. Le compilateur de langage sélectionne la surcharge appropriée parmi les surcharges qui ont un `provider` paramètre, en fonction de votre liste d’arguments. Par exemple, si votre liste d’arguments possède cinq arguments, le compilateur appelle le <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> (méthode).|  
|Effectuer une opération de mise en forme personnalisée avec un <xref:System.ICustomFormatter> implémentation ou un <xref:System.IFormattable> mise en œuvre.|Un des quatre surcharges avec un `provider` paramètre. Le compilateur sélectionne la surcharge appropriée parmi les surcharges qui ont un `provider` paramètre, en fonction de votre liste d’arguments.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>La méthode Format en bref 

 Chaque surcharge de la <xref:System.String.Format%2A> utilise le [la fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) à inclure de base zéro des espaces réservés indexés, appelés *mettre en forme les éléments*, dans la chaîne de format composite. Au moment de l’exécution, chaque élément de format est remplacé par la représentation sous forme de chaîne de l’argument correspondant dans une liste de paramètres. Si la valeur de l’argument est `null`, l’élément de format est remplacé par <xref:System.String.Empty?displayProperty=nameWithType>. Par exemple, l’appel suivant à la <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> méthode inclut une chaîne de format avec trois éléments de format, {0}, {1}, et {2}et une liste d’arguments avec trois éléments.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>L’élément de format  
 Un élément de format a cette syntaxe :  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Crochets indiquent des éléments facultatifs. Les accolades ouvrantes et fermantes sont requises. (Pour inclure un littéral ouvrante ou fermante dans la chaîne de format, consultez la [accolades d’échappement](~/docs/standard/base-types/composite-formatting.md#escaping-braces) section dans le [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md) article.)  
  
 Par exemple, un élément de format pour mettre en forme une valeur de devise peut apparaître comme suit :  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Un élément de format comporte les éléments suivants :  
  
 *index*  
 Index de base zéro de l’argument dont la représentation chaîne doit être inclus dans cette position dans la chaîne. Si cet argument est `null`, une chaîne vide sera incluse dans cette position dans la chaîne.  
  
 *alignement*  
 Optionnel. Entier signé qui indique la longueur totale du champ dans lequel l’argument est inséré et si elle est alignée à droite (un entier positif) ou aligné à gauche (un entier négatif). Si vous omettez *alignement*, la représentation sous forme de chaîne de l’argument correspondant est insérée dans un champ sans espaces de début ou de fin.  
  
 Si la valeur de *alignement* est inférieure à la longueur de l’argument doit être inséré, *alignement* est ignoré et la longueur de la représentation sous forme de chaîne de l’argument est utilisée comme largeur de champ.  
  
 *FormatString*  
 Optionnel. Chaîne qui spécifie le format de chaîne de résultat de l’argument correspondant. Si vous omettez *formatString*, sans paramètre de l’argument correspondant `ToString` méthode est appelée pour produire sa représentation sous forme de chaîne. Si vous spécifiez *formatString*, l’argument référencé par l’élément de format doit implémenter la <xref:System.IFormattable> interface. Les types qui prennent en charge les chaînes de format sont les suivantes :  
  
-   Tous les types intégraux et à virgule flottante. (Consultez [les chaînes de Format numériques Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   Voir <xref:System.DateTime> et <xref:System.DateTimeOffset>. (Consultez [chaînes de Format de Date et heure Standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [chaînes de Format de Date et heure](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Tous les types énumération. (Consultez [chaînes de Format d’énumération](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   des valeurs <xref:System.TimeSpan>. (Consultez [chaînes de Format TimeSpan Standard](~/docs/standard/base-types/standard-timespan-format-strings.md) et [les chaînes de Format TimeSpan personnalisées](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUID. (Consultez la <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> méthode.)  
  
 Toutefois, notez que n’importe quel type personnalisé peut implémenter <xref:System.IFormattable> ou étendre un type existant <xref:System.IFormattable> implémentation.  
  
 L’exemple suivant utilise le `alignment` et `formatString` arguments pour produire le résultat mis en forme.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Comment les arguments sont mis en forme  
 Éléments de format sont traités de façon séquentielle à partir du début de la chaîne. Chaque élément de format a un index qui correspond à un objet dans la liste d’arguments de la méthode. Le <xref:System.String.Format%2A> extrait l’argument de méthode et sa représentation sous forme de chaîne est dérivée comme suit :  
  
-   Si l’argument est `null`, la méthode insère <xref:System.String.Empty?displayProperty=nameWithType> dans la chaîne de résultat. Vous n’êtes pas obligé de se préoccuper de la gestion d’un <xref:System.NullReferenceException> pour les arguments null. 
  
-   Si vous appelez le <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> de surcharge et la `provider` l’objet <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implémentation retourne une valeur non null <xref:System.ICustomFormatter> mise en œuvre, l’argument est passé à son <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode). Si l’élément de format contient un *formatString* argument, il est passé comme premier argument à la méthode. Si le <xref:System.ICustomFormatter> implémentation est disponible et produit une chaîne non null, cette chaîne est retournée comme la représentation sous forme de chaîne de l’argument ; sinon, l’étape suivante s’exécute.  
  
-   Si l’argument implémente la <xref:System.IFormattable> interface, son <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implémentation est appelée.  
  
-   L’argument de sans paramètre `ToString` (méthode), qui remplace ou hérite d’une implémentation de classe de base, est appelée.  
  
 Pour obtenir un exemple qui intercepte les appels à la <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> (méthode) et vous permet de voir les informations le <xref:System.String.Format%2A> méthode passe à une méthode de mise en forme pour chaque élément de format de chaîne de format composite, consultez [exemple : un fournisseur d’interception et Chiffre romain formateur](#Format7_Example).  

 Pour plus d’informations, consultez la [l’ordre de traitement](~/docs/standard/base-types/composite-formatting.md##processing-order) section dans le [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md) l’article.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Éléments de format qui ont le même index  
 Le <xref:System.String.Format%2A> méthode lève une exception un <xref:System.FormatException> exception si l’index d’un élément de l’index est supérieur ou égal au nombre d’arguments dans la liste d’arguments. Toutefois, `format` peut inclure plusieurs éléments de format qu’il existe des arguments tant que plusieurs éléments de format ont le même index. Dans l’appel à la <xref:System.String.Format%28System.String%2CSystem.Object%29> méthode dans l’exemple suivant, la liste d’arguments possède un seul argument, mais la chaîne de format inclut deux éléments de format : une affiche la valeur décimale d’un nombre, et l’autre affiche sa valeur hexadécimale.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Mise en forme et à la culture  
 En règle générale, les objets dans la liste d’arguments sont convertis en représentations sous forme de chaîne en utilisant les conventions de la culture actuelle, qui est retourné par la <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriété. Vous pouvez contrôler ce comportement en appelant une des surcharges de <xref:System.String.Format%2A> qui inclut un `provider` paramètre. Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation qui fournit des informations de mise en forme personnalisées et spécifiques à la culture qui servant à contrôler la mise en forme propres à traiter.  
  
 Le <xref:System.IFormatProvider> interface comprend un seul membre, <xref:System.IFormatProvider.GetFormat%2A>, qui est chargé de retourner l’objet qui fournit des informations de mise en forme. Le .NET Framework propose trois <xref:System.IFormatProvider> implémentations qui fournissent la mise en forme propres à la culture :  
  
-   <xref:System.Globalization.CultureInfo>. Son <xref:System.Globalization.CultureInfo.GetFormat%2A> méthode retourne une culture spécifique <xref:System.Globalization.NumberFormatInfo> objet pour mettre en forme des valeurs numériques et spécifiques à la culture <xref:System.Globalization.DateTimeFormatInfo> objet pour mettre en forme des valeurs de date et d’heure.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, qui est utilisé pour de mise en forme propres à la culture des valeurs de date et d’heure. Son <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> méthode est retournée.  
  
-   <xref:System.Globalization.NumberFormatInfo>, qui est utilisé pour la mise en forme propres à la culture des valeurs numériques. Son <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> propriété renvoie elle-même. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Opérations de mise en forme personnalisée  
 Vous pouvez également appeler l’une des surcharges de la <xref:System.String.Format%2A> méthode ayant un `provider` paramètre de type <xref:System.IFormatProvider> pour effectuer des opérations de mise en forme personnalisées. Par exemple, vous pourriez mettre en forme un nombre entier comme un numéro d’identification ou un numéro de téléphone. Pour effectuer une mise en forme personnalisée, votre `provider` argument doit implémenter les deux le <xref:System.IFormatProvider> et <xref:System.ICustomFormatter> interfaces. Lorsque le <xref:System.String.Format%2A> méthode est passée une <xref:System.ICustomFormatter> mise en œuvre en tant que le `provider` argument, la <xref:System.String.Format%2A> appels de méthode son <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implémentation et demande un objet de type <xref:System.ICustomFormatter>. Il appelle ensuite retourné <xref:System.ICustomFormatter> l’objet <xref:System.ICustomFormatter.Format%2A> méthode pour mettre en forme chaque élément de format dans la chaîne composite qui lui sont passés.  
  
 Pour plus d’informations sur les solutions de mise en forme personnalisées, consultez [Comment : définir et fournisseurs de Format numérique personnalisée utilisation](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) et <xref:System.ICustomFormatter>. Pour obtenir un exemple qui convertit des entiers en nombres personnalisé mis en forme, consultez [exemple : une opération de mise en forme personnalisée](#Format6_Example). Pour obtenir un exemple qui convertit les chiffres romains en octets non signés, consultez [exemple : un fournisseur de l’ordonnée à l’origine et d’un chiffre romain formateur](#Format7_Example).  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a>Exemple : Une opération mise en forme personnalisée  
 Cet exemple définit un fournisseur de format qui met en forme une valeur entière en tant qu’un numéro de compte client au format x-xxxxx-xx.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Exemple : Un fournisseur d’interception et chiffre romain formateur  
 Cet exemple définit un fournisseur de format personnalisé qui implémente le <xref:System.ICustomFormatter> et <xref:System.IFormatProvider> interfaces faire deux choses :  
  
-   Il affiche les paramètres passés à son <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implémentation. Cela permet de voir quels paramètres le <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> méthode passe à l’implémentation de la mise en forme personnalisée pour chaque objet qu’il tente de mettre en forme. Cela peut être utile lorsque vous déboguez votre application.  
  
-   Si l’objet à mettre en forme est une valeur d’octet non signé qui doit être mise en forme à l’aide de la chaîne de format standard « R », le formateur personnalisé met en forme la valeur numérique en tant qu’un chiffre romain.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format Q & r  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Pourquoi vous recommandez interpolation de chaîne sur les appels à la `String.Format` méthode ?

Interpolation de chaîne est la suivante :

- Plus flexible. Il peut être utilisé dans n’importe quelle chaîne sans nécessiter un appel à une méthode qui prend en charge la mise en forme composite. Dans le cas contraire, vous devez appeler la <xref:System.String.Format%2A> méthode ou une autre méthode qui prend en charge la mise en forme composite, telles que <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Plus lisible. Étant donné que l’expression à insérer dans une chaîne apparaît dans l’expression interpolée plutôt que dans une liste d’arguments, chaînes interpolées sont beaucoup plus faciles au code et à lire. En raison de leur lisibilité supérieure, chaînes interpolées peuvent remplacer non seulement les appels aux méthodes de mise en forme composite, mais ils peuvent également les opérations de concaténation de chaîne pour produire un code plus concis et plus clair. 

Une comparaison ci-dessous deux exemples de code illustre la supériorité de chaînes interpolées sur la concaténation de chaînes et les appels aux méthodes de mise en forme composite. L’utilisation de plusieurs opérations de concaténation de chaînes dans l’exemple suivant génère du code détaillé et difficile à lire.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

En revanche, l’utilisation de chaînes interpolées dans l’exemple suivant produire du code beaucoup plus clair, plus concis que l’instruction de concaténation de chaîne et l’appel à la <xref:System.String.Format%2A> méthode dans l’exemple précédent.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Où puis-je trouver une liste des chaînes de format prédéfinis qui peuvent être utilisés avec les éléments de format ?  
  
-   Pour tous les types intégraux et à virgule flottante, consultez [des chaînes de Format numériques Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour les valeurs de date et d’heure, consultez [Standard de Date et heure des chaînes de Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [les chaînes de Format de temps et de Date personnalisée](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour les valeurs d’énumération, consultez [chaînes de Format d’énumération](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour <xref:System.TimeSpan> valeurs, consultez [des chaînes de Format TimeSpan Standard](~/docs/standard/base-types/standard-timespan-format-strings.md) et [chaînes de Format TimeSpan personnalisées](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Pour <xref:System.Guid> valeurs, consultez la section Notes de la <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> page de référence.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Comment pour contrôler l’alignement des chaînes de résultat qui remplacent les éléments de format ?  
 La syntaxe générale d’un élément de format est :  
  
```  
{index[,alignment][: formatString]}  
```  
  
 où *alignement* est un entier signé qui définit la largeur du champ. Si cette valeur est négative, le texte dans le champ est alignées à gauche. S’il est positif, texte est aligné à droite.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Comment contrôler le nombre de chiffres après le séparateur décimal ?  
 Tous les [les chaînes de format numériques standard](~/docs/standard/base-types/standard-numeric-format-strings.md) à l’exception de « D » (qui est utilisée avec des entiers uniquement), « G », « R » et « X » autorise un spécificateur de précision qui définit le nombre de chiffres décimaux dans la chaîne de résultat. L’exemple suivant utilise des chaînes de format numériques standard pour contrôler le nombre de chiffres décimaux dans la chaîne de résultat.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Si vous utilisez un [chaîne de format numérique personnalisée](~/docs/standard/base-types/custom-numeric-format-strings.md), utilisez le spécificateur de format « 0 » pour contrôler le nombre de chiffres décimaux dans la chaîne de résultat, comme le montre l’exemple suivant.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Comment contrôler le nombre de chiffres intégraux ?  
 Par défaut, les opérations de mise en forme affichent uniquement les chiffres intégraux différente de zéro. Si vous mettez en forme des nombres entiers, vous pouvez utiliser un spécificateur de précision avec le « D » et « X » de chaînes de format standard pour contrôler le nombre de chiffres.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Vous pouvez remplir un entier ou un nombre à virgule flottante avec des zéros non significatifs pour produire une chaîne de résultat avec un nombre spécifié de chiffres intégraux à l’aide de la « 0 » [spécificateur de format numérique personnalisée](~/docs/standard/base-types/custom-numeric-format-strings.md), comme le montre l’exemple suivant.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Combien d’éléments puis-je inclure dans la liste format ?  
 Il n’existe aucune limite pratique. Le deuxième paramètre de la <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> méthode est marquée avec la <xref:System.ParamArrayAttribute> attribut, qui vous permet d’inclure une liste délimitée ou un tableau d’objets en tant que votre liste de format.  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Comment inclure les accolades littéral (« { » et «} ») dans la chaîne de résultat ?  
 Par exemple, comment empêcher l’appel de méthode suivants de lever une <xref:System.FormatException> exception ?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Une seule accolade ouvrante ou fermante est toujours interprétée comme le début ou la fin d’un élément de format. Pour être interprété littéralement, celui-ci doit être échappé. Vous échapper une accolade en ajoutant un autre accolade (« {{ » et «}} » au lieu de » { » et «} »), comme dans l’appel de méthode suivant :  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Toutefois, les accolades même séquence d’échappement sont facilement mal interprétés. Nous recommandons que vous incluez des accolades dans la liste de format et utilisez des éléments de format pour les insérer dans la chaîne de résultat, comme le montre l’exemple suivant.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Pourquoi mon appel à la méthode String.Format lève une exception FormatException ?  
 La cause la plus courante de l’exception est que l’index d’un élément de format ne correspond pas à un objet dans la liste de format. Cela indique généralement que vous avez misnumbered les index des éléments de format ou si vous avez oublié d’inclure un objet dans la liste de format. Tentative d’ajout d’une accolade gauche ou droite sans séquence d’échappement de caractères également lève une <xref:System.FormatException>. Parfois, l’exception est le résultat d’une faute de frappe ; par exemple, une erreur classique consiste à une faute de frappe » [« (le crochet gauche) au lieu de « { » (l’accolade gauche).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Si la méthode Format(System.IFormatProvider,System.String,System.Object[]) prend en charge les tableaux de paramètres, pourquoi mon code lève une exception lorsque j’utilise un tableau ?  
 Par exemple, le code suivant lève une <xref:System.FormatException> exception :  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Il s’agit d’un problème de résolution de surcharge du compilateur. Étant donné que le compilateur ne peut pas convertir un tableau d’entiers en un tableau d’objets, il traite le tableau d’entiers en tant qu’un seul argument, afin qu’elle appelle la <xref:System.String.Format%28System.String%2CSystem.Object%29> (méthode). L’exception est levée, car il existe quatre éléments de format, mais un seul élément dans la liste de format.  
  
 Étant donné que Visual Basic ni c# peut convertir un tableau d’entiers à un tableau d’objets, vous devez effectuer la conversion avant d’appeler le <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> (méthode). L’exemple suivant fournit une implémentation.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Nombreux exemples qui appellent le <xref:System.String.Format%2A> méthode sont mélangées via la [notes](#remarks) section de cet article.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

Vous pouvez également télécharger un ensemble complet de `String.Format` obtenir des exemples, qui sont inclus un [projet .NET Core 2.0 pour c#](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip) et un [projet .NET Core 2.0 pour Visual Basic](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip), à partir de la [dotnet/docs Référentiel GitHub](https://github.com/dotnet/docs).

Voici des exemples inclus dans l’article :

### <a name="create-a-format-string"></a>Créer une chaîne de format

[Insertion d’une chaîne](#inserting-a-string)  
[L’élément de format](#the-format-item)  
[Éléments de format qui ont le même index](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Contrôler la sortie mise en forme

[Contrôle de la mise en forme](#controlling-formatting)  
[Contrôle de l’espacement](#controlling-spacing)  
[Contrôle de l’alignement](#controlling-alignment)  
[Contrôle du nombre de chiffres intégraux](#how-do-i-control-the-number-of-integral-digits)  
[Contrôle le nombre de chiffres après le séparateur décimal](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[Y compris les accolades littéral dans une chaîne de résultat](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Vérifiez les chaînes de format dépendante de la culture

[La mise en forme dépendante de la culture](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Personnaliser l’opération de mise en forme

[Une opération de mise en forme personnalisée](#example-a-custom-formatting-operation)  
[Un fournisseur de l’ordonnée à l’origine et d’un chiffre romain formateur](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Objet à mettre en forme.</param>
        <summary>Remplace un ou plusieurs éléments de mise en forme d’une chaîne par la représentation sous forme de chaîne d’un objet spécifié.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle tous les éléments de mise en forme sont remplacés par la représentation sous forme de chaîne de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise le [la fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir la valeur d’une expression en sa représentation sous forme de chaîne et pour incorporer cette représentation dans une chaîne. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Exemple : Mise en forme d’un seul argument  
 
 L’exemple suivant utilise la <xref:System.String.Format%28System.String%2CSystem.Object%29> méthode pour incorporer l’âge d’un individu au milieu d’une chaîne.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">L'élément de mise en forme dans <paramref name="format" /> n'est pas valide.  -ou- L’index d’un élément de format n’est pas zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Tableau d'objets contenant aucun ou plusieurs objets à mettre en forme.</param>
        <summary>Remplace l'élément de mise en forme d'une chaîne spécifiée par la représentation sous forme de chaîne d'un objet correspondant dans un tableau spécifié.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme ont été remplacés par la représentation sous forme de chaîne des objets correspondants dans <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise le [la fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir la valeur des expressions de quatre ou plus en leurs représentations sous forme de chaîne et incorporer ces représentations dans une chaîne. Étant donné que la `args` paramètre est marqué avec la <xref:System.ParamArrayAttribute?displayProperty=nameWithType> attribut, vous pouvez passer les objets à la méthode en tant qu’arguments individuels ou un <xref:System.Object> tableau. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Exemple : Mise en forme de plus de trois arguments  
 
 Cet exemple crée une chaîne qui contient des données sur la température haute et basse à une date particulière. La chaîne de format composite a cinq éléments de format dans l’exemple c# et six dans l’exemple Visual Basic. Deux des éléments de format de définir la largeur de la représentation sous forme de chaîne de leur valeur correspondante, et le premier élément de format inclut également une date standard et la chaîne de format d’heure.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Vous pouvez également passer les objets à mettre en forme en tant que tableau plutôt qu’une liste d’arguments.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="args" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  -ou- L’index d’un élément de format est inférieur à zéro, ou supérieur ou égal à la longueur du tableau <paramref name="args" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Objet à mettre en forme.</param>
        <summary>Remplace le ou les éléments de mise en forme d'une chaîne spécifiée par la représentation sous forme de chaîne de l'objet correspondant. Un paramètre fournit des informations de mise en forme propres à la culture.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle le ou les éléments de mise en forme sont remplacés par la représentation sous forme de chaîne de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise le [la fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir la valeur d’une expression en sa représentation sous forme de chaîne et pour incorporer cette représentation dans une chaîne. Lors de la conversion, la méthode utilise un formateur personnalisé ou la mise en forme dépendante de la culture. La méthode convertit `arg0` à sa représentation sous forme de chaîne en appelant sa **ToString (IFormatProvider)** (méthode) ou, si correspondant de l’objet d’élément de format inclut une chaîne de format, en appelant ses **ToString () String, IFormatProvider)** (méthode). Si ces méthodes n’existent pas, elle appelle l’objet sans paramètre **ToString** (méthode).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  -ou- L’index d’un élément de format n’est pas zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Tableau d'objets contenant aucun ou plusieurs objets à mettre en forme.</param>
        <summary>Remplace les éléments de mise en forme d’une chaîne par les représentations sous forme de chaîne des objets correspondants dans un tableau spécifié. Un paramètre fournit des informations de mise en forme propres à la culture.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme ont été remplacés par la représentation sous forme de chaîne des objets correspondants dans <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise le [la fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir les expressions de quatre ou plus en leurs représentations sous forme de chaîne et pour incorporer ces représentations dans une chaîne. Lors de la conversion, la méthode utilise un formateur personnalisé ou la mise en forme dépendante de la culture. La méthode convertit chaque <xref:System.Object> l’argument de sa représentation sous forme de chaîne en appelant sa **ToString (IFormatProvider)** méthode ou, si correspondant de l’objet d’élément de format inclut une chaîne de format, en appelant ses **ToString(String,IFormatProvider)** (méthode). Si ces méthodes n’existent pas, elle appelle l’objet sans paramètre **ToString** (méthode).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>Exemple : Dépendante de la Culture de mise en forme  
 Cet exemple utilise la <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> méthode pour afficher la représentation sous forme de chaîne de certaines valeurs de date et d’heure et des valeurs numériques à l’aide de plusieurs cultures différentes.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="args" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  -ou- L’index d’un élément de format est inférieur à zéro, ou supérieur ou égal à la longueur du tableau <paramref name="args" />.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <summary>Remplace les éléments de mise en forme dans une chaîne par la représentation sous forme de chaîne de deux objets spécifiés.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme sont remplacés par les représentations sous forme de chaîne de <paramref name="arg0" /> et <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise le [la fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir la valeur de deux expressions en leurs représentations sous forme de chaîne et incorporer ces représentations dans une chaîne. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Exemple : Mise en forme de deux arguments  
 
 Cet exemple utilise le <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> méthode pour afficher les données de temps et de température stockées dans un type générique <xref:System.Collections.Generic.Dictionary%602> objet. Notez que la chaîne de format a trois éléments de format, bien qu’il existe uniquement deux objets à mettre en forme. Il s’agit, car le premier objet dans la liste (une valeur de date et heure) est utilisé par les deux éléments de format : le premier format élément s’affiche l’heure et la seconde affiche la date.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  -ou- L’index d’un élément de format n’est pas zéro ou un.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <summary>Remplace les éléments de mise en forme dans une chaîne par la représentation sous forme de chaîne de deux objets spécifiés. Un paramètre fournit des informations de mise en forme propres à la culture.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme sont remplacés par les représentations sous forme de chaîne de <paramref name="arg0" /> et <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise le [la fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir des deux expressions en leurs représentations sous forme de chaîne et pour incorporer ces représentations dans une chaîne. Lors de la conversion, la méthode utilise un formateur personnalisé ou la mise en forme dépendante de la culture. La méthode convertit chaque <xref:System.Object> l’argument de sa représentation sous forme de chaîne en appelant sa **ToString (IFormatProvider)** méthode ou, si correspondant de l’objet d’élément de format inclut une chaîne de format, en appelant ses **ToString(String,IFormatProvider)** (méthode). Si ces méthodes n’existent pas, elle appelle l’objet sans paramètre **ToString** (méthode).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  -ou- L’index d’un élément de format n’est pas zéro ou un.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <param name="arg2">Troisième objet à mettre en forme.</param>
        <summary>Remplace les éléments de mise en forme d’une chaîne par la représentation sous forme de chaîne de trois objets spécifiés.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme ont été remplacés par les représentations sous forme de chaîne de <paramref name="arg0" />, <paramref name="arg1" /> et <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise le [la fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir la valeur des trois expressions en leurs représentations sous forme de chaîne et incorporer ces représentations dans une chaîne. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Exemple : Mise en forme de trois arguments  
 
 Cet exemple utilise le <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> méthode pour créer une chaîne qui illustre le résultat d’une valeur booléenne `And` opération avec deux valeurs entières. Notez que la chaîne de format inclut six éléments, mais la méthode a uniquement trois éléments dans sa liste de paramètres, étant donné que chaque élément est mis en forme de deux manières différentes.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  -ou- L’index d’un élément de format est inférieur à zéro ou supérieur à deux.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <param name="arg2">Troisième objet à mettre en forme.</param>
        <summary>Remplace les éléments de mise en forme d’une chaîne par la représentation sous forme de chaîne de trois objets spécifiés. Un paramètre fournit des informations de mise en forme propres à la culture.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme ont été remplacés par les représentations sous forme de chaîne de <paramref name="arg0" />, <paramref name="arg1" /> et <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise le [la fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir des trois expressions en leurs représentations sous forme de chaîne et pour incorporer ces représentations dans une chaîne. Lors de la conversion, la méthode utilise un formateur personnalisé ou la mise en forme dépendante de la culture. La méthode convertit chaque <xref:System.Object> l’argument de sa représentation sous forme de chaîne en appelant sa **ToString (IFormatProvider)** méthode ou, si correspondant de l’objet d’élément de format inclut une chaîne de format, en appelant ses **ToString(String,IFormatProvider)** (méthode). Si ces méthodes n’existent pas, elle appelle l’objet sans paramètre **ToString** (méthode).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  -ou- L’index d’un élément de format est inférieur à zéro ou supérieur à deux.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère un objet qui peut itérer au sein des caractères individuels de cette chaîne.</summary>
        <returns>Objet énumérateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Au lieu d’appeler le <xref:System.String.GetEnumerator%2A> méthode pour récupérer un <xref:System.CharEnumerator> que vous utilisez pour énumérer une chaîne, vous devez utiliser à la place de construction d’itération de votre langage de l’objet (en c#, dans C + c++ / CLR et en Visual Basic). [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) en c#, [pour chaque](/cpp/dotnet/for-each-in) dans C + c++ / CLR, et [pour chaque](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) en Visual Basic).
  
 Cette méthode permet d’itérer au sein des caractères individuels dans une chaîne. Par exemple, Visual Basic `For Each` et c# `foreach` instructions appellent cette méthode pour retourner un <xref:System.CharEnumerator> objet qui peut fournir un accès en lecture seule aux caractères dans cette instance de chaîne.  
  
   
  
## Examples  
 L’exemple suivant itère au sein des caractères de plusieurs chaînes et affiche des informations sur les caractères individuels. Il utilise la construction d’itération langue plutôt qu’un appel à la <xref:System.String.GetEnumerator%2A> (méthode).  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage pour cette chaîne.</summary>
        <returns>Code de hachage d'un entier signé 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement de <xref:System.String.GetHashCode%2A> dépend de son implémentation, ce qui peut changer d’une version du common language runtime à un autre. Des raisons pour lesquelles cela peut se produire est pour améliorer les performances de <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Si deux objets string sont égaux, la <xref:System.String.GetHashCode%2A> méthode retourne des valeurs identiques. Toutefois, il n'est pas une valeur de code de hachage unique pour chaque valeur de chaîne unique. Différentes chaînes peuvent retourner le même code de hachage.  
>   
>  Il n’est pas garanti que le code de hachage stable. Codes de hachage de chaînes identiques peuvent différer entre les versions du .NET Framework et sur plusieurs plateformes (par exemple, 32 bits et 64 bits) pour une seule version du .NET Framework. Dans certains cas, ils peuvent même différer par domaine d’application. Cela implique deux exécutions ultérieures du même programme peuvent retourner des codes de hachage différent.  
>   
>  Par conséquent, le hachage de codes ne doivent jamais être utilisés en dehors du domaine d’application dans lequel ils ont été créés, ils ne doivent jamais être utilisés en tant que champs de clé dans une collection, et s’ils ne doivent jamais être persistants.  
>   
>  Enfin, n’utilisez pas le code de hachage au lieu d’une valeur renvoyée par une fonction de hachage cryptographique, si vous avez besoin d’un hachage cryptographique efficace. Pour les hachages de chiffrement, utilisez une classe dérivée de la <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.  
>   
>  Pour plus d’informations sur les codes de hachage, consultez <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Dans les applications de bureau, vous pouvez utiliser la [ \<UseRandomizedStringHashAlgorithm > élément](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) pour générer des codes de hachage unique sur un par domaine d’application. Cela peut réduire le nombre de collisions et améliorer les performances globales des insertions et des recherches qui utilisent des tables de hachage. L’exemple suivant montre comment utiliser le [ \<UseRandomizedStringHashAlgorithm > élément](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Il définit un pour générer des codes de hachage unique sur un par domaine d’application. Cela peut réduire le nombre de collisions et améliorer les performances globales des insertions et des recherches qui utilisent des tables de hachage. L’exemple suivant montre comment utiliser le. Il définit un `DisplayString` classe qui inclut une constante de chaîne privée, `s`, dont la valeur est « Il s’agit d’une chaîne. » Il inclut également une méthode `ShowStringHashCode` qui affiche la valeur de chaîne et son code de hachage avec le nom du domaine d'application dans lequel la méthode est exécutée.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Lorsque vous exécutez l'exemple sans fournir un fichier de configuration, il affiche une sortie similaire à la suivante. Notez que les codes de hachage pour la chaîne sont identiques dans les deux domaines d'application.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 Toutefois, si vous ajoutez le fichier de configuration suivant au répertoire de l'exemple, puis exécutez l'exemple, les codes de hachage pour la même chaîne diffèrent par domaine d'application.  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 Lorsque le fichier de configuration est présent, l'exemple affiche la sortie suivante :  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  Codes de hachage sont utilisées pour insérer et extraire efficacement les objets à clé à partir des tables de hachage. Toutefois, les codes de hachage n’identifient de chaînes. Chaînes identiques ont des codes de hachage égal, mais le common language runtime peut également affecter le même code de hachage de chaînes différentes. En outre, les codes de hachage peuvent varier par version du .NET Framework, par la plateforme au sein d’une seule version et par domaine d’application. Pour cette raison, vous ne devez pas sérialiser ou conserver les valeurs de code de hachage, ni vous les utiliser en tant que clés dans une table de hachage ou un dictionnaire.  
  
 Pour plus d’informations sur l’utilisation des codes de hachage et le `GetHashCode` méthode, consultez <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.GetHashCode%2A> méthode à l’aide de différents des chaînes d’entrée.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>La valeur retournée par <see cref="M:System.String.GetHashCode" /> est dépendante de la plateforme. Il diffère sur les versions 32 bits et 64 bits de .NET Framework. Il peut également différer entre les versions du .NET Framework.</para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne <see cref="T:System.TypeCode" /> pour la classe <see cref="T:System.String" />.</summary>
        <returns>Constante énumérée, <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche la <xref:System.TypeCode> constante énumérée pour le <xref:System.String> type.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signale l'index de base zéro de la première occurrence d'un caractère ou d'une chaîne Unicode spécifiés dans cette instance. La méthode retourne -1 si le caractère ou la chaîne est introuvable dans cette instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <summary>Signale l'index de base zéro de la première occurrence du caractère Unicode spécifié dans cette chaîne.</summary>
        <returns>Position d'index de base zéro de <paramref name="value" /> si ce caractère est disponible ou -1 s'il est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant montre comment vous pouvez rechercher un <xref:System.String> un caractère à l’aide de la <xref:System.String.IndexOf%2A> (méthode).  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans cette instance.</summary>
        <returns>Position d'index de base zéro de <paramref name="value" /> si cette chaîne est disponible ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle. La recherche commence à la première position de caractère de cette instance et continue jusqu'à la dernière position de caractère.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, à la <xref:System.String.IndexOf%28System.String%29> méthode retourne toujours 0 (zéro) pour indiquer que la correspondance au début de l’instance actuelle. Dans l’exemple suivant, la <xref:System.String.IndexOf%28System.String%29> méthode est utilisée pour rechercher des trois sous-chaînes (un trait d’union (U + 00AD), un trait d’union suivie de « n » et un trait d’union suivie de « m ») dans les deux chaînes. Une seule des chaînes contient un trait d'union conditionnel. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans chaque cas, étant donné que le trait d’union est un caractère ignorable, le résultat est le même que si le trait d’union n’avait pas été inclus dans `value`. Lorsque vous recherchez un trait d’union uniquement, la méthode retourne 0 (zéro) pour indiquer qu’il a trouvé une correspondance au début de la chaîne.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 L’exemple suivant recherche la « n » dans « animal ». Étant donné que les index de chaîne commencent à zéro au lieu, la <xref:System.String.IndexOf%28System.String%29> méthode indique que le « n » est à la position 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 L’exemple suivant utilise la <xref:System.String.IndexOf%2A> méthode pour déterminer la position de départ d’un nom d’animal dans une phrase. Il utilise ensuite cette position pour insérer un adjectif qui décrit l’animal dans la phrase.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [Best Practices for à l’aide de Strings](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent les méthodes qui requièrent des paramètres pour être explicitement spécifié. Pour rechercher le premier index d’une sous-chaîne dans une instance de chaîne à l’aide des règles de comparaison de la culture actuelle, appelez la <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> surcharge de méthode avec une valeur de <see cref="F:System.StringComparison.CurrentCulture" /> pour son paramètre 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence du caractère Unicode spécifié dans cette chaîne. La recherche commence à une position de caractère spécifiée.</summary>
        <returns>Position d’index de base zéro de <paramref name="value" /> à partir du début de la chaîne si ce caractère est trouvé, ou -1 s’il est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à 0. Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne. Si `startIndex` est égal à la longueur de l’instance de chaîne, la méthode retourne -1.  
  
 La recherche s’étend de `startIndex` à la fin de la chaîne.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.IndexOf%2A> (méthode).  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est inférieur à zéro ou supérieur à la longueur de la chaîne.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans cette instance. La recherche commence à une position de caractère spécifiée.</summary>
        <returns>Position d’index de base zéro de <paramref name="value" /> à partir du début de la instance actuelle si cette chaîne est trouvée, ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à 0. Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne. Si `startIndex` est égal à la longueur de l’instance de chaîne, la méthode retourne -1.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle. La recherche commence à la `startIndex` caractère de cette instance et continue jusqu'à la dernière position de caractère.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, à la <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> méthode retourne toujours `startIndex`, qui est la position de caractère à partir duquel commence la recherche. Dans l’exemple suivant, la <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> méthode est utilisée pour rechercher la position d’un trait d’union (U + 00AD) suivie d’un « m » dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne. Notez que, dans le cas de la première chaîne, qui inclut le trait d'union conditionnel suivi d'un « m », la méthode ne parvient pas à retourner l'index du trait d'union, mais retourne à la place celui de la lettre « m ».  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 L’exemple suivant recherche toutes les occurrences d’une chaîne spécifiée dans une chaîne cible.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est inférieur à zéro ou supérieur à la longueur de cette chaîne.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [Best Practices for à l’aide de Strings](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent les méthodes qui requièrent des paramètres pour être explicitement spécifié. Pour rechercher le premier index d’une sous-chaîne qui se produit après une position de caractère particulier à l’aide des règles de comparaison de la culture actuelle, appelez la <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> surcharge de méthode avec une valeur de <see cref="F:System.StringComparison.CurrentCulture" /> pour son paramètre 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans l'objet <see cref="T:System.String" /> actuel. Un paramètre spécifie le type de recherche à utiliser pour la chaîne spécifiée.</summary>
        <returns>Position d'index du paramètre <paramref name="value" /> si cette chaîne est trouvée ; sinon, -1. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro.  
  
 Le `comparisonType` paramètre indique de rechercher le `value` paramètre à l’aide de la culture actuelle ou invariante, à l’aide d’une recherche qui respecte la casse ou non la casse et à l’aide de word ou des règles de comparaison ordinale.  
  
   
  
## Examples  
 L’exampledemonstrates suivant trois surcharges de la <xref:System.String.IndexOf%2A> méthode qui recherche la première occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas pris en compte lorsque vous effectuez une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="comparisonType" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, à la <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> méthode retourne toujours 0 (zéro) pour indiquer que la correspondance au début de l’instance actuelle.  Dans l’exemple suivant, la <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> méthode est utilisée pour rechercher des trois sous-chaînes (un trait d’union (U + 00AD), un trait d’union suivie de « n » et un trait d’union suivie de « m ») dans les deux chaînes. Une seule des chaînes contient un trait d'union conditionnel. Si l’exemple est exécuté le [ ! Include[netfx40_short](~/Includes/netfx40-short-MD.MD)] ou une version ultérieure, comme le trait d’union est un caractère ignorable, une recherche dépendante de la culture retourne la même valeur que celle qui serait retournée si le trait d’union non incluses dans la chaîne de recherche. Une recherche ordinale, toutefois, recherche le trait d’union dans une chaîne avec succès et signale qu’il est absent de la deuxième chaîne.  [ ! csharp de code [System.String.IndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/système. String.IndexOf/CS/ignorable26.cs#26)] [ !-code vb [System.String.IndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/système. String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale l'index de base zéro de la première occurrence du caractère spécifié dans cette instance. La recherche commence à une position de caractère spécifiée et examine un nombre spécifié de positions de caractère.</summary>
        <returns>Position d’index de base zéro de <paramref name="value" /> à partir du début de la chaîne si ce caractère est trouvé, ou -1 s’il est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche commence à `startIndex` et continue à `startIndex`  +  `count` -1. Le caractère situé à `startIndex`  +  `count` n’est pas inclus dans la recherche.  
  
 Numérotation de l’index commence à 0 (zéro). Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.IndexOf%2A> (méthode).  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> est un nombre négatif.  -ou- <paramref name="startIndex" /> est supérieur à la longueur de cette chaîne.  -ou- <paramref name="count" /> est supérieur à la longueur de cette chaîne moins <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans cette instance. La recherche commence à une position de caractère spécifiée et examine un nombre spécifié de positions de caractère.</summary>
        <returns>Position d’index de base zéro de <paramref name="value" /> à partir du début de la instance actuelle si cette chaîne est trouvée, ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à 0 (zéro). Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle. La recherche commence à `startIndex` et continue à `startIndex`  +  `count` -1. Le caractère situé à `startIndex`  +  `count` n’est pas inclus dans la recherche.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, à la <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> méthode retourne toujours `startIndex`, qui est la position de caractère à partir duquel commence la recherche. Dans l’exemple suivant, la <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> méthode est utilisée pour rechercher la position d’un trait d’union (U + 00AD) suivie d’un « m » à partir de la troisième à la sixième position de caractère dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Notez que, dans le cas de la première chaîne, qui inclut le trait d'union conditionnel suivi d'un « m », la méthode ne parvient pas à retourner l'index du trait d'union, mais retourne à la place celui de la lettre « m ».  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de toutes les occurrences de la chaîne « he » dans une sous-chaîne d’une autre chaîne. Notez que le nombre de caractères à rechercher doit être recalculé, pour chaque itération de la recherche.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> est un nombre négatif.  -ou- <paramref name="startIndex" /> est supérieur à la longueur de cette chaîne.  -ou- <paramref name="count" /> est supérieur à la longueur de cette chaîne moins <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [Best Practices for à l’aide de Strings](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent les méthodes qui requièrent des paramètres pour être explicitement spécifié. Pour utiliser les règles de comparaison de la culture actuelle pour effectuer cette opération, appelez le <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> surcharge de méthode avec une valeur de <see cref="F:System.StringComparison.CurrentCulture" /> pour son paramètre 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans l'objet <see cref="T:System.String" /> actuel. Les paramètres spécifient la position de départ de la recherche dans la chaîne actuelle et le type de recherche à utiliser pour la chaîne spécifiée.</summary>
        <returns>Position d’index de base zéro du paramètre <paramref name="value" /> à partir du début de l’instance active si cette chaîne est trouvée, ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à 0. Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne. Si `startIndex` est égal à la longueur de l’instance de chaîne, la méthode retourne -1.  
  
 Le `comparisonType` paramètre indique de rechercher le `value` paramètre à l’aide de la culture actuelle ou invariante, à l’aide d’une recherche qui respecte la casse ou non la casse et à l’aide de word ou des règles de comparaison ordinale.  
  
   
  
## Examples  
 L’exampledemonstrates suivant trois surcharges de la <xref:System.String.IndexOf%2A> méthode qui recherche la première occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est inférieur à zéro ou supérieur à la longueur de cette chaîne.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas pris en compte lorsque vous effectuez une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="comparisonType" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, à la <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> méthode retourne toujours <paramref name="startIndex" />, qui est la position de caractère à partir duquel commence la recherche.  Dans l’exemple suivant, la <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> méthode est utilisée pour rechercher la position d’un trait d’union (U + 00AD) suivie d’un « m » en commençant par la position de caractère tiers dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [ ! Include[netfx40_short](~/Includes/netfx40-short-MD.MD)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Notez que, dans le cas de la première chaîne, qui inclut le trait d'union conditionnel suivi d'un « m », la méthode ne parvient pas à retourner l'index du trait d'union, mais retourne à la place celui de la lettre « m ». La méthode retourne l’index du trait de la première chaîne uniquement lorsqu’elle effectue une comparaison ordinale.  [ ! csharp de code [System.String.IndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/système. String.IndexOf/CS/ignorable25.cs#25)] [ !-code vb [System.String.IndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/système. String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans l'objet <see cref="T:System.String" /> actuel. Les paramètres spécifient le point de départ de la recherche dans la chaîne actuelle, le nombre de caractères de la chaîne dans laquelle effectuer la recherche et le type de recherche à utiliser pour la chaîne spécifiée.</summary>
        <returns>Position d’index de base zéro du paramètre <paramref name="value" /> à partir du début de l’instance active si cette chaîne est trouvée, ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à 0 (zéro). Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne.  
  
 La recherche commence à `startIndex` et continue à `startIndex`  +  `count` -1. Le caractère situé à `startIndex`  +  `count` n’est pas inclus dans la recherche.  
  
 Le `comparisonType` paramètre indique de rechercher le `value` paramètre à l’aide de la culture actuelle ou invariante, à l’aide d’une recherche qui respecte la casse ou non la casse et à l’aide de word ou des règles de comparaison ordinale.  
  
   
  
## Examples  
 L’exampledemonstrates suivant trois surcharges de la <xref:System.String.IndexOf%2A> méthode qui recherche la première occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> est un nombre négatif.  -ou- <paramref name="startIndex" /> est supérieur à la longueur de cette instance.  -ou- <paramref name="count" /> est supérieur à la longueur de cette chaîne moins <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas pris en compte lorsque vous effectuez une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="comparisonType" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, à la <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode retourne toujours <paramref name="startIndex" />, qui est la position de caractère à partir duquel commence la recherche.  Dans l’exemple suivant, la <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode est utilisée pour rechercher la position d’un trait d’union (U + 00AD) suivie d’un « m » à partir de la troisième à la sixième position de caractère dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [ ! Include[netfx40_short](~/Includes/netfx40-short-MD.MD)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Lorsqu’elle effectue une comparaison ordinale, toutefois, il recherche la sous-chaîne uniquement dans la première chaîne. Notez que dans le cas de la première chaîne, ce qui inclut le trait d’union suivi d’un « m », la méthode ne parvient pas à retourner l’index du trait, mais retourne à la place de l’index de la lettre « m » lorsqu’elle effectue une comparaison dépendante de la culture. La méthode retourne l’index du trait de la première chaîne uniquement lorsqu’elle effectue une comparaison ordinale.  [ ! csharp de code [System.String.IndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/système. String.IndexOf/CS/ignorable24.cs#24)] [ !-code vb [System.String.IndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/système. String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signale l'index de la première occurrence dans cette instance de tout caractère d'un tableau de caractères Unicode spécifié. La méthode retourne -1 si les caractères du tableau sont introuvables dans cette instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <summary>Signale l'index de base zéro de la première occurrence dans cette instance de tout caractère d'un tableau de caractères Unicode spécifié.</summary>
        <returns>Position d'index de base zéro de la première occurrence dans cette instance où un caractère quelconque dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro.  
  
 La recherche de `anyOf` respecte la casse. Si `anyOf` est un tableau vide, la méthode recherche une correspondance au début de la chaîne (autrement dit, à l’index zéro).  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche la première VOYELLE dans une chaîne.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence dans cette instance de tout caractère d'un tableau de caractères Unicode spécifié. La recherche commence à une position de caractère spécifiée.</summary>
        <returns>Position d'index de base zéro de la première occurrence dans cette instance où un caractère quelconque dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro. Le `startIndex` paramètre peut aller de 0 à moins que la longueur de l’instance de chaîne.  
  
 La recherche s’étend de `startIndex` à la fin de la chaîne.  
  
 La recherche de `anyOf` respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de l’occurrence de n’importe quel caractère de la chaîne « est » dans une sous-chaîne d’une autre chaîne.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est un nombre négatif.  -ou- <paramref name="startIndex" /> est supérieur au nombre de caractères de cette instance.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale l'index de base zéro de la première occurrence dans cette instance de tout caractère d'un tableau de caractères Unicode spécifié. La recherche commence à une position de caractère spécifiée et examine un nombre spécifié de positions de caractère.</summary>
        <returns>Position d'index de base zéro de la première occurrence dans cette instance où un caractère quelconque dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche commence à `startIndex` et continue à `startIndex`  +  `count` -1. Le caractère situé à `startIndex`  +  `count` n’est pas inclus dans la recherche.  
  
 La numérotation de l’index commence à zéro. Le `startIndex` paramètre peut aller de 0 à moins que la longueur de l’instance de chaîne.  
  
 La recherche de `anyOf` respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de l’occurrence de n’importe quel caractère de la chaîne « aid » dans une sous-chaîne d’une autre chaîne.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> est un nombre négatif.  -ou- <paramref name="count" /> + <paramref name="startIndex" /> est supérieur au nombre de caractères de cette instance.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position d'index de base zéro de l'insertion.</param>
        <param name="value">Chaîne à insérer.</param>
        <summary>Retourne une nouvelle chaîne dans laquelle une chaîne spécifiée est insérée dans cette instance à une position d'index spécifiée.</summary>
        <returns>Nouvelle chaîne qui est équivalente à cette instance, mais avec <paramref name="value" /> inséré à la position <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `startIndex` est égal à la longueur de cette instance, `value` est ajouté à la fin de cette instance.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle `value` est insérée dans l’instance actuelle.  
  
 Par exemple, la valeur de retour de `"abc".Insert(2, "XYZ")` est « abXYZc ».  
  
   
  
## Examples  
 L’exemple suivant insère un caractère d’espace dans la quatrième position de caractère (le caractère à l’index 3) d’une chaîne.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 L’application console suivante invite les utilisateurs à entrer un ou plusieurs adjectifs pour décrire deux animaux. Il appelle ensuite la <xref:System.String.Insert%2A> méthode pour insérer le texte entré par l’utilisateur dans une chaîne.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> a une valeur négative ou supérieure à la longueur de cette instance.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Chaîne à rechercher dans le pool interne.</param>
        <summary>Récupère la référence du système au <see cref="T:System.String" /> spécifié.</summary>
        <returns>Référence du système à <paramref name="str" /> si elle est dans le pool interne ; sinon, nouvelle référence à une chaîne ayant la valeur <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le common language runtime conserve le stockage de chaînes en conservant une table, appelée pool interne, qui contient une référence à chaque chaîne littérale unique déclarée ou créée par programmation dans votre programme. Par conséquent, une instance d’une chaîne littérale avec une valeur particulière n’existe qu’une seule fois dans le système.  
  
 Par exemple, si vous attribuez la même chaîne littérale à plusieurs variables, le runtime récupère la même référence à la chaîne littérale dans le pool interne et assigne à chaque variable.  
  
 Le <xref:System.String.Intern%2A> méthode utilise le pool interne pour rechercher une chaîne égale à la valeur de `str`. Si cette chaîne existe, sa référence dans le pool interne est retourné. Si la chaîne n’existe pas, une référence à `str` est ajouté dans le pool interne, cette référence est retournée.  
  
 Dans l’exemple suivant, la chaîne s1, ce qui a la valeur « MonTest », est déjà dans le pool interne, car il s’agit d’un littéral dans le programme. La <xref:System.Text.StringBuilder?displayProperty=nameWithType> classe génère un nouvel objet chaîne ayant la même valeur que s1. Une référence à cette chaîne est assignée à s2. Le <xref:System.String.Intern%2A> méthode recherche une chaîne ayant la même valeur que s2. Étant donné que cette chaîne existe, la méthode retourne la même référence que celle assignée à s1. Cette référence est ensuite assignée à s3. Les références s1 et s2 considérées comme égales, car ils font référence à des objets différents ; les références s1 et s3 sont égales, car ils font référence à la même chaîne.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Comparez cette méthode à la <xref:System.String.IsInterned%2A> (méthode).  
  
## <a name="version-considerations"></a>Considérations relatives à la version  
 Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], le <xref:System.String.Intern%2A> méthode reprend son comportement dans le .NET Framework 1.0 et 1.1 en ce qui concerne la centralisation de la chaîne vide. Dans l’exemple suivant, la variable `str1` est affectée à une référence à <xref:System.String.Empty>et la variable `str2` est affectée à la référence à <xref:System.String.Empty> qui est retourné en appelant le <xref:System.String.Intern%2A> méthode après avoir converti un <xref:System.Text.StringBuilder>objet dont la valeur est <xref:System.String.Empty> en une chaîne. Puis les références contenues dans `str1` et `str2` sont une comparaison d’égalité.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 Dans le [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], et [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` et `str2` sont égales. Dans le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] et [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` et `str2` ne sont pas égales.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Si vous essayez de réduire la quantité totale de mémoire votre application alloue, n’oubliez pas que la centralisation de chaîne a deux conséquences indésirables. Tout d’abord, la mémoire allouée pour intégrés <xref:System.String> objets n’est pas probablement être libérée tant que le common language runtime (CLR) se termine. La raison est que la référence du CLR à la dans le pool interne <xref:System.String> objet peut persister après que votre application ou votre domaine d’application, se termine. Ensuite, pour Interner une chaîne, vous devez d’abord créer la chaîne. La mémoire utilisée par le <xref:System.String> objet doit toujours être alloué, même si la mémoire doit finalement être nettoyées.  
  
 Le .NET Framework version 2.0 introduit le <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> membre de l’énumération. Le <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> membre marque un assembly comme ne nécessitant ne pas centralisation de littéral de chaîne. Vous pouvez appliquer <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> à un assembly à l’aide de la <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attribut. En outre, lorsque vous utilisez la [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) pour compiler un assembly avant l’exécution, les chaînes ne sont pas intégrés dans différents modules.  
  
   
  
## Examples  
 L’exemple suivant utilise trois chaînes égales en valeur pour déterminer si une chaîne créée récemment et une chaîne dans le pool interne sont égales.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Chaîne à rechercher dans le pool interne.</param>
        <summary>Récupère une référence à un <see cref="T:System.String" /> spécifié.</summary>
        <returns>Référence à <paramref name="str" /> si elle figure dans le pool interne du Common Language Runtime ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le common language runtime gère automatiquement une table, appelée pool interne, qui contient une seule instance de chaque constante de chaîne littérale unique déclarée dans un programme, ainsi qu’une instance unique de <xref:System.String> vous ajoutez par programme en appelant le <xref:System.String.Intern%2A> (méthode).  
  
 Le pool interne conserve le stockage de chaînes. Si vous assignez une constante de chaîne littérale à plusieurs variables, chaque variable est définie pour référencer la même constante dans le pool interne au lieu de référencer plusieurs instances différentes de <xref:System.String> qui ont des valeurs identiques.  
  
 Cette méthode recherche `str` dans le pool interne. Si `str` a déjà été dans le pool interne, une référence à cette instance est retournée ; sinon, `null` est retourné.  
  
 Comparez cette méthode à la <xref:System.String.Intern%2A> (méthode).  
  
 Cette méthode ne retourne pas une valeur booléenne. Si vous appelez la méthode parce que vous souhaitez une valeur booléenne qui indique si une chaîne particulière est dans le pool interne, vous pouvez utiliser le code suivant.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  À compter de .NET Framework version 2.0, vous pouvez substituer l’utilisation du pool interne lorsque vous utilisez la [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) pour installer un assembly dans le cache des images natives sur un ordinateur local. Pour plus d’informations, consultez les considérations relatives aux performances dans la section Notes pour le <xref:System.String.Intern%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant montre que les chaînes littérales sont intégrés automatiquement par le compilateur.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indique si cette chaîne figure dans un formulaire particulier de normalisation Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique si cette chaîne se trouve dans un formulaire de normalisation C Unicode.</summary>
        <returns>
          <see langword="true" /> si cette chaîne figure dans un formulaire de normalisation C ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains caractères Unicode ont plusieurs représentations binaires équivalentes des combinaisons d’et/ou des caractères Unicode composites. L’existence de plusieurs représentations pour un seul caractère complique la recherche, tri, filtrage et autres opérations.  
  
 La norme Unicode définit un processus appelé normalisation qui retourne une représentation binaire lorsqu’une représentation binaire équivalente d’un caractère donné. La normalisation peut être effectuée avec plusieurs algorithmes, appelés formulaires de normalisation, qui sont régis par des règles différentes. Le .NET Framework prend actuellement en charge les formulaires de normalisation C, D, KC et KD.  
  
 Pour obtenir une description des formulaires de normalisation Unicode pris en charge, consultez <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant détermine si une chaîne est normalisée avec succès selon différents formulaires de normalisation.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’instance actuelle contient des caractères Unicode non valides.</exception>
        <block subset="none" type="usage">
          <para>Le <see cref="Overload:System.String.IsNormalized" /> méthode retourne <see langword="false" /> dès qu’il rencontre le premier caractère non normalisé en une chaîne. Par conséquent, si une chaîne contient des caractères non normalisé suivis par des caractères Unicode non valides, le <see cref="Overload:System.String.Normalize" /> méthode lève un <see cref="T:System.ArgumentException" /> bien que <see cref="Overload:System.String.IsNormalized" /> retourne <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formulaire de normalisation Unicode.</param>
        <summary>Indique si cette chaîne figure dans le formulaire de normalisation Unicode spécifié.</summary>
        <returns>
          <see langword="true" /> si cette chaîne se trouve dans le formulaire de normalisation spécifié par le paramètre <paramref name="normalizationForm" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains caractères Unicode ont plusieurs représentations binaires équivalentes des combinaisons d’et/ou des caractères Unicode composites. L’existence de plusieurs représentations pour un seul caractère complique la recherche, tri, filtrage et autres opérations.  
  
 La norme Unicode définit un processus appelé normalisation qui retourne une représentation binaire lorsqu’une représentation binaire équivalente d’un caractère donné. La normalisation peut être effectuée avec plusieurs algorithmes, appelés formulaires de normalisation, qui sont régis par des règles différentes. Le .NET Framework prend actuellement en charge les formulaires de normalisation C, D, KC et KD.  
  
 Pour obtenir une description des formulaires de normalisation Unicode pris en charge, consultez <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.IsNormalized%2A> et <xref:System.String.Normalize%2A> méthodes.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’instance actuelle contient des caractères Unicode non valides.</exception>
        <block subset="none" type="usage">
          <para>Le <see cref="Overload:System.String.IsNormalized" /> méthode retourne <see langword="false" /> dès qu’il rencontre le premier caractère non normalisé en une chaîne. Par conséquent, si une chaîne contient des caractères non normalisé suivis par des caractères Unicode non valides, le <see cref="Overload:System.String.Normalize" /> méthode lève un <see cref="T:System.ArgumentException" /> bien que <see cref="Overload:System.String.IsNormalized" /> retourne <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à tester.</param>
        <summary>Indique si la chaîne spécifiée est <see langword="null" /> ou une chaîne <see cref="F:System.String.Empty" />.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> est <see langword="null" /> ou une chaîne vide ("") ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> est une méthode pratique qui vous permet de tester simultanément si un <xref:System.String> est `null` ou sa valeur est <xref:System.String.Empty>. Il est équivalent au code suivant :  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Vous pouvez utiliser la <xref:System.String.IsNullOrWhiteSpace%2A> méthode pour tester si une chaîne est `null`, sa valeur est <xref:System.String.Empty?displayProperty=nameWithType>, ou il se compose uniquement d’espaces blancs.  
  
## <a name="what-is-a-null-string"></a>Qu’est une chaîne null ?  
 Une chaîne est `null` si elle n’a été attribué une valeur (en C++ et Visual Basic) ou si la valeur a été explicitement affecté `null`. Bien que le [mise en forme composite](~/docs/standard/base-types/composite-formatting.md) fonctionnalité peut gérer correctement une chaîne null, comme le montre l’exemple suivant, une tentative pour appeler l’une si ses membres lève une <xref:System.NullReferenceException>.  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Qu’est une chaîne vide ?  
 Une chaîne est vide si elle est explicitement affectée une chaîne vide (« ») ou <xref:System.String.Empty?displayProperty=nameWithType>. Une chaîne vide est un <xref:System.String.Length%2A> de 0.  L’exemple suivant crée une chaîne vide et affiche sa valeur et sa longueur.  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 L’exemple suivant examine trois chaînes et détermine si chaque chaîne a une valeur, est une chaîne vide ou `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à tester.</param>
        <summary>Indique si une chaîne spécifiée est <see langword="null" />, vide ou se compose uniquement d'espaces blancs.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />, ou si <paramref name="value" /> est composé exclusivement d'espaces blancs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> est une méthode pratique qui est semblable au code suivant, mais offre de meilleures performances :  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Espaces blancs sont définis par la norme Unicode. Le <xref:System.String.IsNullOrWhiteSpace%2A> méthode interprète tout caractère qui retourne une valeur de `true` lorsqu’il est passé à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> méthode comme un caractère d’espace blanc.  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de chaînes, puis passe chaque élément du tableau à la <xref:System.String.IsNullOrWhiteSpace%2A> (méthode).  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatène les éléments d’un tableau spécifié ou les membres d’une collection, en utilisant le séparateur spécifié entre chaque élément ou membre.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">Chaîne à utiliser comme séparateur. L’élément <c>separator</c> est inclus dans la chaîne retournée seulement si <c>values</c> contient plusieurs éléments.</param>
        <param name="values">Collection qui contient les chaînes à concaténer.</param>
        <summary>Concatène les membres d'une collection <see cref="T:System.Collections.Generic.IEnumerable`1" /> construite de type <see cref="T:System.String" />, en utilisant le séparateur spécifié entre chaque membre.</summary>
        <returns>Chaîne composée des membres de <paramref name="values" /> délimités par la chaîne <paramref name="separator" />. Si les <paramref name="values" /> ne possèdent aucun membre, la méthode retourne <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `separator` est `null`, une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>) est utilisé à la place. Si un membre de `values` est `null`, une chaîne vide est utilisée à la place.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> est une méthode pratique qui vous permet de concaténer chaque élément dans un `IEnumerable(Of String)` collection sans avoir à convertir les éléments dans un tableau de chaînes. Il est particulièrement utile avec les expressions de requête Language-Integrated Query (LINQ). L’exemple suivant passe un `List(Of String)` objet contenant les lettres majuscules ou minuscules de l’alphabet à une expression lambda qui sélectionne des lettres qui sont égales ou supérieures à une lettre particulière (c'est-à-dire, dans l’exemple, « M »). Le `IEnumerable(Of String)` collection retournée par la <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> est passé à la méthode le <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> méthode pour afficher le résultat sous forme de chaîne unique.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 L’exemple suivant utilise le crible d’Ératosthène pour calculer les nombres premiers qui sont inférieurs ou égaux à 100. Il assigne le résultat à un <xref:System.Collections.Generic.List%601> objet de type <xref:System.String>, qu’il passe ensuite à la <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> (méthode).  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Chaîne à utiliser comme séparateur. L’élément <c>separator</c> est inclus dans la chaîne retournée seulement si <c>values</c> contient plusieurs éléments.</param>
        <param name="values">Tableau qui contient les éléments à concaténer.</param>
        <summary>Concatène les éléments d'un tableau d'objets, en utilisant le séparateur spécifié entre chaque élément.</summary>
        <returns>Chaîne composée des éléments de <paramref name="values" /> séparés par la chaîne <paramref name="separator" />. Si <paramref name="values" /> est un tableau vide, la méthode retourne <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `separator` est `null` ou si un élément de la `values` autre que le premier élément est `null`, une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>) est utilisé à la place. Consultez les section Remarques à appelants si le premier élément du `values` est `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> est une méthode pratique qui vous permet de concaténer chaque élément dans un tableau d’objets sans convertir explicitement ses éléments en chaînes. La représentation sous forme de chaîne de chaque objet dans le tableau est dérivée en appelant l’objet `ToString` (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise le crible d’Ératosthène pour calculer les nombres premiers qui sont inférieurs ou égaux à 100. Il assigne le résultat à un tableau d’entiers, qu’il passe ensuite à la <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> (méthode).  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Si le premier élément du <paramref name="values" /> est <see langword="null" />, le <see cref="M:System.String.Join(System.String,System.Object[])" /> méthode ne concaténez pas les éléments de <paramref name="values" /> mais retourne à la place <see cref="F:System.String.Empty" />. Plusieurs solutions de contournement pour résoudre ce problème sont disponibles. La plus simple consiste à affecter la valeur <see cref="F:System.String.Empty" /> au premier élément du tableau, comme l’exemple suivant montre le.  [ ! code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [ ! code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Chaîne à utiliser comme séparateur. L’élément <c>separator</c> est inclus dans la chaîne retournée seulement si <c>value</c> contient plusieurs éléments.</param>
        <param name="value">Tableau qui contient les éléments à concaténer.</param>
        <summary>Concatène tous les éléments d'un tableau de chaînes, en utilisant le séparateur spécifié entre chaque élément.</summary>
        <returns>Chaîne composée des éléments de <paramref name="value" /> séparés par la chaîne <paramref name="separator" />. Si <paramref name="value" /> est un tableau vide, la méthode retourne <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, si `separator` est «, » et les éléments de `value` sont « apple », « orange », « raisins » et « poire », `Join(separator, value)` retourne « apple, orange, raisin, poire ».  
  
 Si `separator` est `null`, une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>) est utilisé à la place. Si aucun élément de `value` est `null`, une chaîne vide est utilisée à la place.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.Join%2A> (méthode).  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Chaîne à utiliser comme séparateur. L’élément <c>separator</c> est inclus dans la chaîne retournée seulement si <c>value</c> contient plusieurs éléments.</param>
        <param name="value">Tableau qui contient les éléments à concaténer.</param>
        <param name="startIndex">Premier élément dans <c>value</c> à utiliser.</param>
        <param name="count">Nombre d’éléments de <c>value</c> à utiliser.</param>
        <summary>Concatène les éléments spécifiés d'un tableau de chaînes, en utilisant le séparateur spécifié entre chaque élément.</summary>
        <returns>Chaîne composée des chaînes de <paramref name="value" /> délimitées par la chaîne <paramref name="separator" />.  -ou- <see cref="F:System.String.Empty" /> si <paramref name="count" /> est égal à zéro et que <paramref name="value" /> ne contient aucun élément, ou si <paramref name="separator" /> et tous les éléments de <paramref name="value" /> sont <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, si `separator` est «, » et les éléments de `value` sont « apple », « orange », « raisins » et « poire », `Join(separator, value, 1, 2)` retourne « orange, raisin ».  
  
 Si `separator` est `null`, une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>) est utilisé à la place. Si aucun élément de `value` est `null`, une chaîne vide est utilisée à la place.  
  
   
  
## Examples  
 L’exemple suivant concatène deux éléments d’un tableau de noms de fruits.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="count" /> est inférieur à 0.  -ou- <paramref name="startIndex" /> plus <paramref name="count" /> est supérieur au nombre d’éléments de <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Mémoire insuffisante.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Le type des membres de <c>valeurs</c>.</typeparam>
        <param name="separator">Chaîne à utiliser comme séparateur. L’élément <c>separator</c> est inclus dans la chaîne retournée seulement si <c>values</c> contient plusieurs éléments.</param>
        <param name="values">Collection qui contient les objets à concaténer.</param>
        <summary>Concatène les membres d’une collection, en utilisant le séparateur spécifié entre chaque membre.</summary>
        <returns>Chaîne composée des membres de <paramref name="values" /> délimités par la chaîne <paramref name="separator" />. Si les <paramref name="values" /> ne possèdent aucun membre, la méthode retourne <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `separator` est `null`, une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>) est utilisé à la place. Si un membre de `values` est `null`, une chaîne vide est utilisée à la place.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> est une méthode pratique qui vous permet de concaténer chaque membre d’un <xref:System.Collections.Generic.IEnumerable%601> collection sans avoir à convertir les chaînes. La représentation sous forme de chaîne de chaque objet dans le <xref:System.Collections.Generic.IEnumerable%601> collection est dérivée en appelant l’objet `ToString` (méthode).  
  
 Cette méthode est particulièrement utile avec les expressions de requête Language-Integrated Query (LINQ). Par exemple, le code suivant définit une simple `Animal` classe qui contient le nom d’un animal et l’ordre auquel il appartient. Il définit ensuite une <xref:System.Collections.Generic.List%601> objet qui contient un nombre de `Animal` objets. Le <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> méthode d’extension est appelée pour extraire le `Animal` objets dont `Order` propriété est égale à « Rongeurs ». Le résultat est passé à la <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> (méthode).  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 L’exemple suivant utilise le crible d’Ératosthène pour calculer les nombres premiers qui sont inférieurs ou égaux à 100. Il assigne le résultat à un <xref:System.Collections.Generic.List%601> objet de type entier, qu’il passe ensuite à la <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> (méthode).  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'un caractère ou d'une chaîne Unicode spécifiés dans cette instance. La méthode retourne -1 si le caractère ou la chaîne est introuvable dans cette instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'un caractère Unicode spécifié dans cette instance.</summary>
        <returns>Position d'index de base zéro de <paramref name="value" /> si ce caractère est disponible ou -1 s'il est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et le dernier est situé à <xref:System.String.Length%2A> - 1.  
  
 Cette méthode commence la recherche à la dernière position de caractère de cette instance et se poursuit vers le début jusqu'à ce que `value` est trouvée ou que la première position de caractère a été examinée. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant définit un `ExtractFilename` méthode qui utilise le <xref:System.String.LastIndexOf%28System.Char%29> méthode pour rechercher le dernier caractère de séparation de répertoire dans une chaîne et extraire le nom du fichier de la chaîne. Si le fichier existe, la méthode retourne le nom de fichier sans son chemin d’accès.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans cette instance.</summary>
        <returns>Position d'index de départ de base zéro de <paramref name="value" /> si cette chaîne est disponible ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et le dernier est situé à <xref:System.String.Length%2A> - 1.  
  
 La recherche commence à la dernière position de caractère de cette instance et se poursuit vers le début jusqu'à ce que `value` est trouvée ou que la première position de caractère a été examinée.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, à la <xref:System.String.LastIndexOf%28System.String%29> méthode retourne toujours <xref:System.String.Length%2A?displayProperty=nameWithType> – 1, ce qui représente la dernière position d’index dans l’instance actuelle. Dans l’exemple suivant, la <xref:System.String.LastIndexOf%28System.String%29> méthode est utilisée pour rechercher des trois sous-chaînes (un trait d’union (U + 00AD), un trait d’union suivie de « n » et un trait d’union suivie de « m ») dans les deux chaînes. Une seule des chaînes contient un trait d'union conditionnel. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans chaque cas, étant donné que le trait d’union est un caractère ignorable, le résultat est le même que si le trait d’union n’avait pas été inclus dans `value`. Lorsque vous recherchez un trait d’union uniquement, la méthode retourne 6 et 5. Ces valeurs correspondent à l’index du dernier caractère dans les deux chaînes.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 L’exemple suivant supprime les balises HTML à partir d’une chaîne si les balises de début et de fin de la chaîne. Si une chaîne se termine par une clôture crochet pointu (« > »), l’exemple utilise le <xref:System.String.LastIndexOf%2A> méthode pour trouver le début de la balise de fin.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [Best Practices for à l’aide de Strings](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent les méthodes qui requièrent des paramètres pour être explicitement spécifié. Pour rechercher le dernier index d’une sous-chaîne dans une instance de chaîne à l’aide des règles de comparaison de la culture actuelle, appelez la <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> avec une valeur de la surcharge de méthode <see cref="F:System.StringComparison.CurrentCulture" /> pour son <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche s’effectue depuis <c>startIndex</c> vers le début de cette instance.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'un caractère Unicode spécifié dans cette instance. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne.</summary>
        <returns>Position d'index de base zéro de <paramref name="value" /> si ce caractère est trouvé, ou -1 s'il est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et le dernier est situé à <xref:System.String.Length%2A> -1. cette méthode commence la recherche à la `startIndex` position de cette instance et un se poursuit vers le début de l’instance actuelle jusqu'à ce que des caractères `value` est trouvée ou que la première position de caractère a été examinée. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche tous les caractères à partir du dernier caractère de la chaîne au début. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de toutes les occurrences d’un caractère dans une chaîne, depuis la fin de la chaîne au début de la chaîne.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est inférieur à zéro ou supérieur ou égal à la longueur de cette instance.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche s’effectue depuis <c>startIndex</c> vers le début de cette instance.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans cette instance. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne.</summary>
        <returns>Position d'index de départ de base zéro de <paramref name="value" /> si cette chaîne est trouvée, ou -1 si elle est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la plus petite de <paramref name="startIndex" /> et la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et le dernier est situé à <xref:System.String.Length%2A> - 1.  
  
 La recherche commence à la `startIndex` position de cette instance et un se poursuit jusqu'à ce que vers l’arrière de caractère `value` est trouvée ou que la première position de caractère a été examinée. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche tous les caractères à partir du dernier caractère de la chaîne au début.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, à la <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> méthode retourne toujours `startIndex`, qui est la position de caractère à partir duquel commence la recherche. Dans l’exemple suivant, la <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> méthode est utilisée pour trouver une sous-chaîne qui inclut un trait d’union (U + 00AD) et qui précède ou inclut la lettre « m » final dans une chaîne. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, parce que le trait d’union dans la chaîne de recherche est ignoré, la méthode pour trouver une sous-chaîne qui comprend le trait d’union et un « m » retourne la position de la lettre « m » dans la chaîne, tandis que l’appel pour trouver un substrin g qui comprend le trait d’union et « n » retourne la position de la « n ». Lorsque la chaîne de recherche contient uniquement le trait d’union, la méthode retourne l’index de la lettre « m », qui représente la valeur de `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de toutes les occurrences d’une chaîne dans la chaîne cible, depuis la fin de la chaîne cible vers le début de la chaîne cible.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" />, et <paramref name="startIndex" /> est inférieur à zéro ou supérieur à la longueur de l’instance actuelle.  -ou- L’instance actuelle est égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est inférieur à -1 ou supérieur à zéro.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [Best Practices for à l’aide de Strings](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent les méthodes qui requièrent des paramètres pour être explicitement spécifié. Pour rechercher l’index d’une sous-chaîne qui précède une position de caractère particulier à l’aide des règles de comparaison de la culture actuelle, appelez la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> avec une valeur de la surcharge de méthode <see cref="F:System.StringComparison.CurrentCulture" /> pour son <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale l'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans l'objet <see cref="T:System.String" /> actuel. Un paramètre spécifie le type de recherche à utiliser pour la chaîne spécifiée.</summary>
        <returns>Position d'index de départ de base zéro du paramètre <paramref name="value" /> si cette chaîne est disponible ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et le dernier est situé à <xref:System.String.Length%2A> - 1.  
  
 Le `comparisonType` paramètre indique de rechercher le `value` paramètre à l’aide de la culture actuelle ou invariante, à l’aide d’une recherche qui respecte la casse ou non la casse et à l’aide de word ou des règles de comparaison ordinale.  
  
 La recherche commence à la dernière position de caractère de cette instance et se poursuit vers le début jusqu'à ce que `value` est trouvée ou que la première position de caractère a été examinée.  
  
   
  
## Examples  
 L’exampledemonstrates suivant trois surcharges de la <xref:System.String.LastIndexOf%2A> méthode qui recherchent la dernière occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas pris en compte lorsque vous effectuez une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="options" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, à la <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> méthode retourne toujours <see cref="P:System.String.Length" /> – 1, ce qui représente la dernière position d’index dans l’instance actuelle.  Dans l’exemple suivant, la <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> méthode est utilisée pour rechercher des trois sous-chaînes (un trait d’union (U + 00AD), un trait d’union suivie de « n » et un trait d’union suivie de « m ») dans les deux chaînes. Une seule des chaînes contient un trait d'union conditionnel. Si l’exemple est exécuté le [ ! Include[netfx40_short](~/Includes/netfx40-short-MD.MD)] ou une version ultérieure, comme le trait d’union est un caractère ignorable, une recherche dépendante de la culture retourne la même valeur que celle qui serait retournée si le trait d’union non incluses dans la chaîne de recherche. Une recherche ordinale, toutefois, recherche le trait d’union dans une chaîne avec succès et signale qu’il est absent de la deuxième chaîne.  [ ! csharp de code [System.String.LastIndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/système. String.LastIndexOf/cs/lastindexof26.cs#26)] [ !-code vb [System.String.LastIndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/système. String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche s’effectue depuis <c>startIndex</c> vers le début de cette instance.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence du caractère Unicode spécifié dans une sous-chaîne de cette instance. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne pour un nombre spécifié de positions de caractères.</summary>
        <returns>Position d'index de base zéro de <paramref name="value" /> si ce caractère est trouvé, ou -1 s'il est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et le dernier est situé à <xref:System.String.Length%2A> - 1.  
  
 Cette méthode commence la recherche à la `startIndex` position et se poursuit vers le début de cette instance en tant que caractères `value` est trouvé ou `count` les positions de caractère aient été examinées. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche vers l’arrière `count` caractères à partir du dernier caractère dans la chaîne. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de toutes les occurrences d’un caractère dans une sous-chaîne, depuis la fin de la sous-chaîne jusqu’au début de la sous-chaîne.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est inférieur à zéro ou supérieur ou égal à la longueur de cette instance.  -ou- L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> - <paramref name="count" /> + 1 est inférieur à zéro.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche s’effectue depuis <c>startIndex</c> vers le début de cette instance.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans cette instance. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne pour un nombre spécifié de positions de caractères.</summary>
        <returns>Position d'index de départ de base zéro de <paramref name="value" /> si cette chaîne est trouvée, ou -1 si elle est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la plus petite de <paramref name="startIndex" /> et la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et le dernier est situé à <xref:System.String.Length%2A> - 1.  
  
 La recherche commence à la `startIndex` position de cette instance et un se poursuit jusqu'à ce que vers l’arrière de caractère `value` est trouvé ou `count` les positions de caractère aient été examinées. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche vers l’arrière `count` caractères à partir du dernier caractère dans la chaîne.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, à la <xref:System.String.LastIndexOf%2A> méthode retourne toujours `startIndex`, qui est la position de caractère à partir duquel commence la recherche. Dans l’exemple suivant, la <xref:System.String.LastIndexOf%2A> méthode est utilisée pour rechercher la position d’un trait d’union (U + 00AD) dans les deux caractères qui précèdent le dernier « m » de deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Notez que, dans le cas de la première chaîne, qui inclut le trait d'union conditionnel suivi d'un « m », la méthode ne parvient pas à retourner l'index du trait d'union, mais retourne à la place celui de la lettre « m ».  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de toutes les occurrences d’une chaîne dans une sous-chaîne, depuis la fin de la sous-chaîne jusqu’au début de la sous-chaîne.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.  -ou- L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est un négatif.  -ou- L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est supérieur à la longueur de cette instance.  -ou- L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> - <paramref name="count" /> + 1 spécifie une position qui ne figure pas dans cette instance.  -ou- L’instance actuelle est égale à <see cref="F:System.String.Empty" /> et <paramref name="start" /> est inférieur à -1 ou supérieur à zéro.  -ou- L’instance actuelle est égale à <see cref="F:System.String.Empty" /> et <paramref name="count" /> est supérieur à 1.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [Best Practices for à l’aide de Strings](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent les méthodes qui requièrent des paramètres pour être explicitement spécifié. Pour effectuer cette opération en utilisant les règles de comparaison de la culture actuelle, appelez la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> avec une valeur de la surcharge de méthode <see cref="F:System.StringComparison.CurrentCulture" /> pour son <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche s’effectue depuis <c>startIndex</c> vers le début de cette instance.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale l'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans l'objet <see cref="T:System.String" /> actuel. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne. Un paramètre spécifie le type de comparaison à effectuer pendant la recherche de la chaîne spécifiée.</summary>
        <returns>Position d'index de départ de base zéro du paramètre <paramref name="value" /> si cette chaîne est trouvée, ou -1 si elle est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la plus petite de <paramref name="startIndex" /> et la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et le dernier est situé à <xref:System.String.Length%2A> - 1.  
  
 La recherche commence à la `startIndex` position et se poursuit jusqu'à ce que vers l’arrière de caractères `value` est trouvée ou que la première position de caractère a été examinée. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche tous les caractères à partir du dernier caractère de la chaîne au début.  
  
 Le `comparisonType` paramètre indique de rechercher le `value` paramètre à l’aide de la culture actuelle ou invariante, à l’aide d’une recherche qui respecte la casse ou non la casse et à l’aide de word ou des règles de comparaison ordinale.  
  
   
  
## Examples  
 L’exampledemonstrates suivant trois surcharges de la <xref:System.String.LastIndexOf%2A> méthode qui recherchent la dernière occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" />, et <paramref name="startIndex" /> est inférieur à zéro ou supérieur à la longueur de l’instance actuelle.  -ou- L’instance actuelle est égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est inférieur à -1 ou supérieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas pris en compte lorsque vous effectuez une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="comparisonType" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, à la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> méthode retourne toujours <paramref name="startIndex" />, qui est la position de caractère à partir duquel commence la recherche.  Dans l’exemple suivant, la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> méthode est utilisée pour rechercher la position d’un trait d’union (U + 00AD) suivie d’un « m, » en commençant par le dernier « m » dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [ ! Include[netfx40_short](~/Includes/netfx40-short-MD.MD)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Notez que, dans le cas de la première chaîne, qui inclut le trait d'union conditionnel suivi d'un « m », la méthode ne parvient pas à retourner l'index du trait d'union, mais retourne à la place celui de la lettre « m ». La méthode retourne l’index du trait de la première chaîne uniquement lorsqu’elle effectue une comparaison ordinale.  [ ! csharp de code [System.String.LastIndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/système. String.LastIndexOf/cs/lastindexof25.cs#25)] [ !-code vb [System.String.LastIndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/système. String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche s’effectue depuis <c>startIndex</c> vers le début de cette instance.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans cette instance. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne pour le nombre spécifié de positions de caractères. Un paramètre spécifie le type de comparaison à effectuer pendant la recherche de la chaîne spécifiée.</summary>
        <returns>Position d'index de départ de base zéro du paramètre <paramref name="value" /> si cette chaîne est trouvée, ou -1 si elle est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la plus petite de <paramref name="startIndex" /> et la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et le dernier est situé à <xref:System.String.Length%2A> - 1.  
  
 La recherche commence à la `startIndex` position et se poursuit jusqu'à ce que vers l’arrière de caractères `value` est trouvé ou `count` les positions de caractère aient été examinées. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche vers l’arrière `count` caractères à partir du dernier caractère dans la chaîne.  
  
 Le `comparisonType` paramètre indique de rechercher le `value` paramètre à l’aide de la culture actuelle ou invariante, à l’aide d’une recherche qui respecte la casse ou non la casse et à l’aide de word ou des règles de comparaison ordinale.  
  
   
  
## Examples  
 L’exampledemonstrates suivant trois surcharges de la <xref:System.String.LastIndexOf%2A> méthode qui recherchent la dernière occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.  -ou- L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est un négatif.  -ou- L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est supérieur à la longueur de cette instance.  -ou- L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> + 1 - <paramref name="count" /> spécifie une position qui ne figure pas dans cette instance.  -ou- L’instance actuelle est égale à <see cref="F:System.String.Empty" /> et <paramref name="start" /> est inférieur à -1 ou supérieur à zéro.  -ou- L’instance actuelle est égale à <see cref="F:System.String.Empty" /> et <paramref name="count" /> est supérieur à 1.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas pris en compte lorsque vous effectuez une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="comparisonType" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, à la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode retourne toujours <paramref name="startIndex" />, qui est la position de caractère à partir duquel commence la recherche.  Dans l’exemple suivant, la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode est utilisée pour rechercher la première position de caractère avant le dernier « m », mais la position d’un trait d’union (U + 00AD) suivi d’un « m » dans toutes les dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [ ! Include[netfx40_short](~/Includes/netfx40-short-MD.MD)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Lorsqu’elle effectue une comparaison ordinale, toutefois, il recherche la sous-chaîne uniquement dans la première chaîne. Notez que dans le cas de la première chaîne, ce qui inclut le trait d’union suivi d’un « m », la méthode ne parvient pas à retourner l’index du trait, mais retourne à la place de l’index de la lettre « m » lorsqu’elle effectue une comparaison dépendante de la culture. La méthode retourne l’index du trait de la première chaîne uniquement lorsqu’elle effectue une comparaison ordinale.  [ ! csharp de code [System.String.LastIndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/système. String.LastIndexOf/cs/lastindexof24.cs#24)] [ !-code vb [System.String.LastIndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/système. String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signale la position d'index de base zéro de la dernière occurrence dans cette instance d'un ou plusieurs caractères spécifiés dans un tableau Unicode. La méthode retourne -1 si les caractères du tableau sont introuvables dans cette instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence dans cette instance d'un ou plusieurs caractères spécifiés dans un tableau Unicode.</summary>
        <returns>Position d'index de la dernière occurrence dans cette instance où tout caractère dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro.  
  
 Cette méthode commence la recherche à la dernière position de caractère de cette instance et se poursuit vers le début jusqu'à ce que d’un caractère dans `anyOf` est trouvée ou que la première position de caractère a été examinée. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de la dernière occurrence d’un caractère quelconque dans la chaîne « est » dans une autre chaîne.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche s’effectue depuis <c>startIndex</c> vers le début de cette instance.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence dans cette instance d'un ou plusieurs caractères spécifiés dans un tableau Unicode. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne.</summary>
        <returns>Position d'index de la dernière occurrence dans cette instance où tout caractère dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro.  
  
 Cette méthode commence la recherche à la `startIndex` position de cette instance et un se poursuit jusqu'à ce que d’un caractère dans vers l’arrière de caractère `anyOf` est trouvée ou que la première position de caractère a été examinée. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de la dernière occurrence d’un caractère quelconque dans la chaîne « est » dans une sous-chaîne d’une autre chaîne.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> spécifie une position qui ne figure pas dans cette instance.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche s’effectue depuis <c>startIndex</c> vers le début de cette instance.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence dans cette instance d'un ou plusieurs caractères spécifiés dans un tableau Unicode. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne pour un nombre spécifié de positions de caractères.</summary>
        <returns>Position d'index de la dernière occurrence dans cette instance où tout caractère dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La numérotation de l’index commence à zéro.  
  
 Cette méthode commence la recherche à la `startIndex` position de cette instance et un se poursuit jusqu'à ce que d’un caractère dans vers l’arrière de caractère `anyOf` est trouvé ou `count` les positions de caractère aient été examinées. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que le digramme soudé « Æ » (U + 00 C 6), peut être considéré comme équivalent à toute occurrence de composants du caractère dans le corriger la séquence, telle que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de la dernière occurrence d’un caractère quelconque dans la chaîne « aid » dans une sous-chaîne d’une autre chaîne.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" />, et <paramref name="count" /> ou <paramref name="startIndex" /> est un nombre négatif.  -ou- L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> moins <paramref name="count" /> + 1 est inférieur à zéro.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de caractères de l'objet <see cref="T:System.String" /> actuel.</summary>
        <value>Nombre de caractères de la chaîne actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.Length%2A> propriété retourne le nombre de <xref:System.Char> objets dans cette instance, pas le nombre de caractères Unicode. La raison est qu’un caractère Unicode peut être représenté par plusieurs <xref:System.Char>. Utilisez le <xref:System.Globalization.StringInfo?displayProperty=nameWithType> classe fonctionne avec chaque caractère Unicode à la place chaque <xref:System.Char>.  
  
 Dans certains langages, tels que C et C++, un caractère null indique la fin d’une chaîne. Dans le .NET Framework, un caractère null peut être incorporé dans une chaîne. Lorsqu’une chaîne inclut un ou plusieurs caractères null, ils sont inclus dans la longueur totale de la chaîne. Par exemple, dans la chaîne suivante, les sous-chaînes « abc » et « def » sont séparées par un caractère null. Le <xref:System.String.Length%2A> propriété retourne 7, qui indique qu’elle inclut les six caractères alphabétiques, ainsi que le caractère null.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant illustre le <xref:System.String.Length%2A> propriété.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne dont la représentation binaire se trouve dans un formulaire particulier de normalisation Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une nouvelle chaîne dont la valeur textuelle est identique à celle de cette chaîne, mais dont la représentation binaire se trouve dans un formulaire de normalisation C Unicode.</summary>
        <returns>Nouvelle chaîne normalisée dont la valeur textuelle est identique à celle de cette chaîne, mais dont la représentation binaire se trouve dans un formulaire de normalisation C Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains caractères Unicode ont plusieurs représentations binaires équivalentes des combinaisons d’et/ou des caractères Unicode composites. Par exemple, un des points de code suivant peut représenter la lettre « ắ » :  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 L’existence de plusieurs représentations pour un seul caractère complique la recherche, tri, filtrage et autres opérations.  
  
 La norme Unicode définit un processus appelé normalisation qui retourne une représentation binaire lorsqu’une représentation binaire équivalente d’un caractère donné. La normalisation peut être effectuée avec plusieurs algorithmes, appelés formulaires de normalisation, qui sont régis par des règles différentes. Le .NET Framework prend en charge les quatre formulaires de normalisation (C, D, KC et KD) qui sont définis par la norme Unicode. Lorsque deux chaînes sont représentées dans le même formulaire de normalisation, se comparé à l’aide d’une comparaison ordinale.  
  
 Pour normaliser et de comparer deux chaînes, procédez comme suit :  
  
1.  Obtenir les chaînes à comparer à partir d’une source d’entrée, tel qu’un fichier ou un périphérique d’entrée d’utilisateur.  
  
2.  Appelez le <xref:System.String.Normalize> méthode pour normaliser les chaînes à un formulaire de normalisation C.  
  
3.  Pour comparer deux chaînes, appeler une méthode qui prend en charge la comparaison de chaînes ordinale, comme le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> (méthode) et fournir une valeur de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> comme le <xref:System.StringComparison> argument. Pour trier un tableau de chaînes normalisées, passez un `comparer` valeur <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> ou <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> à la surcharge appropriée de <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Émettez les chaînes dans la sortie triée selon l’ordre indiqué par l’étape précédente.  
  
 Pour obtenir une description des formulaires de normalisation Unicode pris en charge, consultez <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant normalise une chaîne à chacun des quatre formulaires de normalisation, confirme que la chaîne a été normalisée selon le formulaire de normalisation spécifié, puis répertorie les points de code dans la chaîne normalisée.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’instance actuelle contient des caractères Unicode non valides.</exception>
        <block subset="none" type="usage">
          <para>Le <see cref="Overload:System.String.IsNormalized" /> méthode retourne <see langword="false" /> dès qu’il rencontre le premier caractère non normalisé en une chaîne. Par conséquent, si une chaîne contient des caractères non normalisé suivis par des caractères Unicode non valides, le <see cref="Overload:System.String.Normalize" /> méthode lève un <see cref="T:System.ArgumentException" /> bien que <see cref="Overload:System.String.IsNormalized" /> retourne <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formulaire de normalisation Unicode.</param>
        <summary>Retourne une nouvelle chaîne dont la valeur textuelle est identique à celle de cette chaîne, mais dont la représentation binaire se trouve dans le formulaire de normalisation Unicode spécifié.</summary>
        <returns>Nouvelle chaîne dont la valeur textuelle est identique à celle de cette chaîne, mais dont la représentation binaire se trouve dans le formulaire de normalisation spécifié par le paramètre <paramref name="normalizationForm" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains caractères Unicode ont plusieurs représentations binaires équivalentes des combinaisons d’et/ou des caractères Unicode composites. L’existence de plusieurs représentations pour un seul caractère complique la recherche, tri, filtrage et autres opérations.  
  
 La norme Unicode définit un processus appelé normalisation qui retourne une représentation binaire lorsqu’une représentation binaire équivalente d’un caractère donné. La normalisation peut être effectuée avec plusieurs algorithmes, appelés formulaires de normalisation, qui sont régis par des règles différentes. Le .NET Framework prend en charge les quatre formulaires de normalisation (C, D, KC et KD) qui sont définis par la norme Unicode. Lorsque deux chaînes sont représentés dans le même formulaire de normalisation, elles peuvent être comparées à l’aide d’une comparaison ordinale.  
  
 Pour normaliser et de comparer deux chaînes, procédez comme suit :  
  
1.  Obtenir les chaînes à comparer à partir d’une source d’entrée, tel qu’un fichier ou un périphérique d’entrée d’utilisateur.  
  
2.  Appelez le <xref:System.String.Normalize%28System.Text.NormalizationForm%29> méthode pour normaliser les chaînes à un formulaire de normalisation spécifié.  
  
3.  Pour comparer deux chaînes, appeler une méthode qui prend en charge la comparaison de chaînes ordinale, comme le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> (méthode) et fournir une valeur de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> comme le <xref:System.StringComparison> argument. Pour trier un tableau de chaînes normalisées, passez un `comparer` valeur <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> ou <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> à la surcharge appropriée de <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Émettez les chaînes dans la sortie triée selon l’ordre indiqué par l’étape précédente.  
  
 Pour obtenir une description des formulaires de normalisation Unicode pris en charge, consultez <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant normalise une chaîne à chacun des quatre formulaires de normalisation, confirme que la chaîne a été normalisée selon le formulaire de normalisation spécifié, puis répertorie les points de code dans la chaîne normalisée.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’instance actuelle contient des caractères Unicode non valides.</exception>
        <block subset="none" type="usage">
          <para>Le <see cref="Overload:System.String.IsNormalized" /> méthode retourne <see langword="false" /> dès qu’il rencontre le premier caractère non normalisé en une chaîne. Par conséquent, si une chaîne contient des caractères non normalisé suivis par des caractères Unicode non valides, le <see cref="Overload:System.String.Normalize" /> méthode peut lever une <see cref="T:System.ArgumentException" /> bien que <see cref="Overload:System.String.IsNormalized" /> retourne <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Première chaîne à comparer ou <see langword="null" />.</param>
        <param name="b">Seconde chaîne à comparer ou <see langword="null" />.</param>
        <summary>Détermine si deux chaînes spécifiées ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si la valeur de <paramref name="a" /> est égale à la valeur de <paramref name="b" /> ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.op_Equality%2A> méthode définit l’opération de l’opérateur d’égalité pour les <xref:System.String> classe. Il permet au code comme celui illustré dans la section exemple. L’opérateur, appelle à son tour, la méthode statique <xref:System.String.Equals%28System.String%2CSystem.String%29> méthode qui effectue une comparaison d’ordinale (respectant la casse et indépendantes de la culture).  
  
> [!NOTE]
>  Le compilateur Visual Basic ne résout pas l’opérateur d’égalité comme un appel à la <xref:System.String.op_Equality%2A> (méthode). Au lieu de cela, l’opérateur d’égalité encapsule un appel à la <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant illustre l’opérateur d’égalité.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Première chaîne à comparer ou <see langword="null" />.</param>
        <param name="b">Seconde chaîne à comparer ou <see langword="null" />.</param>
        <summary>Détermine si deux chaînes spécifiées ont des valeurs différentes.</summary>
        <returns>
          <see langword="true" /> si la valeur de <paramref name="a" /> est différente de la valeur de <paramref name="b" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.op_Inequality%2A> méthode définit l’opération de l’opérateur d’inégalité pour la <xref:System.String> classe.   Il permet au code comme celui illustré dans la section Exemples.  
  
 Le <xref:System.String.op_Inequality%2A> opérateur appelle à son tour la méthode statique <xref:System.String.Equals%28System.String%2CSystem.String%29> méthode qui effectue une comparaison d’ordinale (respectant la casse et indépendantes de la culture).  
  
> [!NOTE]
>  Le compilateur Visual Basic ne résout pas l’opérateur d’inégalité comme un appel à la <xref:System.String.op_Inequality%2A> (méthode). Au lieu de cela, l’opérateur d’inégalité encapsule un appel à la <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant illustre l’opérateur d’inégalité.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne d'une longueur spécifiée dans laquelle le début de la chaîne actuelle est complété par des espaces ou un caractère Unicode spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Nombre de caractères dans la chaîne qui en résulte, égal au nombre de caractères d'origine plus tout caractère de remplissage supplémentaire.</param>
        <summary>Retourne une nouvelle chaîne qui aligne les caractères de cette instance à droite en les complétant par des espaces à gauche pour une longueur totale spécifiée.</summary>
        <returns>Nouvelle chaîne équivalant à cette instance, mais alignée à droite et complétée à gauche par autant de caractères que nécessaire pour créer une longueur de <paramref name="totalWidth" />. Toutefois, si <paramref name="totalWidth" /> est inférieure à la longueur de cette instance, la méthode retourne une référence à l'instance existante. Si <paramref name="totalWidth" /> est égale à la longueur de cette instance, la méthode retourne une nouvelle chaîne qui est identique à cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un espace Unicode est défini comme 0 x 0020 hexadécimal.  
  
 Le <xref:System.String.PadLeft%28System.Int32%29> méthode remplit le début de la chaîne retournée. Cela signifie que, lorsqu’il est utilisé avec les langues de droite à gauche, il remplit la partie droite de la chaîne.  
  
> [!NOTE]
>  Si le <xref:System.String.PadLeft%2A> méthode remplit l’instance actuelle avec les caractères d’espace, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne qui est remplie avec des espaces blancs afin que sa longueur totale `totalWidth` caractères.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.PadLeft%2A> (méthode).  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> est inférieur à zéro.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Nombre de caractères dans la chaîne qui en résulte, égal au nombre de caractères d'origine plus tout caractère de remplissage supplémentaire.</param>
        <param name="paddingChar">Caractère Unicode de remplissage.</param>
        <summary>Retourne une nouvelle chaîne qui aligne les caractères de cette instance à droite en les complétant par un caractère Unicode spécifié à gauche pour une longueur totale spécifiée.</summary>
        <returns>Nouvelle chaîne équivalant à cette instance, mais alignée à droite et complétée à gauche par autant de caractères <paramref name="paddingChar" /> que nécessaire pour créer une longueur de <paramref name="totalWidth" />. Toutefois, si <paramref name="totalWidth" /> est inférieure à la longueur de cette instance, la méthode retourne une référence à l'instance existante. Si <paramref name="totalWidth" /> est égale à la longueur de cette instance, la méthode retourne une nouvelle chaîne qui est identique à cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> méthode remplit le début de la chaîne retournée. Cela signifie que, lorsqu’il est utilisé avec les langues de droite à gauche, il remplit la partie droite de la chaîne.  
  
> [!NOTE]
>  Si le <xref:System.String.PadLeft%2A> méthode remplit l’instance actuelle avec les caractères d’espace, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne qui est remplie avec la valeur principale `paddingChar` caractères de sorte que sa longueur totale `totalWidth` caractères.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.PadLeft%2A> (méthode).  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> est inférieur à zéro.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne d'une longueur spécifiée dans laquelle la fin de la chaîne actuelle est complétée par des espaces ou un caractère Unicode spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Nombre de caractères dans la chaîne qui en résulte, égal au nombre de caractères d'origine plus tout caractère de remplissage supplémentaire.</param>
        <summary>Retourne une nouvelle chaîne qui aligne les caractères de cette chaîne à gauche en les complétant par des espaces à droite pour une longueur totale spécifiée.</summary>
        <returns>Nouvelle chaîne équivalant à cette instance, mais alignée à gauche et complétée à droite par autant de caractères que nécessaire pour créer une longueur de <paramref name="totalWidth" />. Toutefois, si <paramref name="totalWidth" /> est inférieure à la longueur de cette instance, la méthode retourne une référence à l'instance existante. Si <paramref name="totalWidth" /> est égale à la longueur de cette instance, la méthode retourne une nouvelle chaîne qui est identique à cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un espace Unicode est défini comme 0 x 0020 hexadécimal.  
  
 Le <xref:System.String.PadRight%28System.Int32%29> méthode remplit la fin de la chaîne retournée. Cela signifie que, lorsqu’il est utilisé avec les langues de droite à gauche, il remplit la partie gauche de la chaîne.  
  
> [!NOTE]
>  Si le <xref:System.String.PadRight%2A> méthode remplit l’instance actuelle avec les caractères d’espace, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne qui est remplie avec l’espace blanc de fin afin que sa longueur totale `totalWidth` caractères.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.PadRight%2A> (méthode).  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> est inférieur à zéro.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Nombre de caractères dans la chaîne qui en résulte, égal au nombre de caractères d'origine plus tout caractère de remplissage supplémentaire.</param>
        <param name="paddingChar">Caractère Unicode de remplissage.</param>
        <summary>Retourne une nouvelle chaîne qui aligne les caractères de cette chaîne à gauche en les complétant par un caractère Unicode spécifié à droite pour une longueur totale spécifiée.</summary>
        <returns>Nouvelle chaîne équivalant à cette instance, mais alignée à gauche et complétée à droite par autant de caractères <paramref name="paddingChar" /> que nécessaire pour créer une longueur de <paramref name="totalWidth" />. Toutefois, si <paramref name="totalWidth" /> est inférieure à la longueur de cette instance, la méthode retourne une référence à l'instance existante. Si <paramref name="totalWidth" /> est égale à la longueur de cette instance, la méthode retourne une nouvelle chaîne qui est identique à cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> méthode remplit la fin de la chaîne retournée. Cela signifie que, lorsqu’il est utilisé avec les langues de droite à gauche, il remplit la partie gauche de la chaîne.  
  
> [!NOTE]
>  Si le <xref:System.String.PadRight%2A> méthode remplit l’instance actuelle avec les caractères d’espace, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne qui est remplie avec la fin `paddingChar` caractères de sorte que sa longueur totale `totalWidth` caractères.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.PadRight%2A> (méthode).  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> est inférieur à zéro.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne dans laquelle un nombre spécifié de caractères de la chaîne actuelle est supprimé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position de base zéro où commence la suppression des caractères.</param>
        <summary>Retourne une nouvelle chaîne dans laquelle tous les caractères de l'instance actuelle ont été supprimés à partir d'une position spécifiée et jusqu'à la dernière position.</summary>
        <returns>Nouvelle chaîne équivalente à cette chaîne, à l'exception des caractères supprimés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], les chaînes sont de base zéro. La valeur de le `startIndex` paramètre peut aller de zéro à un de moins que la longueur de l’instance de chaîne.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les caractères à partir de la position `startIndex` à la fin de la chaîne d’origine ont été supprimées.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.Remove%2A> (méthode). Le cas suivant la dernière supprime tout le texte à partir de l’index spécifié jusqu'à la fin de la chaîne. Le dernier cas supprime trois caractères à partir de l’index spécifié.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est inférieur à zéro.  -ou- <paramref name="startIndex" /> spécifie une position qui n’est pas dans cette chaîne.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position de base zéro où commence la suppression des caractères.</param>
        <param name="count">Nombre de caractères à supprimer.</param>
        <summary>Retourne une nouvelle chaîne dans laquelle un nombre spécifié de caractères a été supprimé dans l'instance actuelle à partir d'une position spécifiée.</summary>
        <returns>Nouvelle chaîne équivalente à cette instance, à l'exception des caractères supprimés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], les chaînes sont de base zéro. La valeur de le `startIndex` paramètre peut aller de zéro à un de moins que la longueur de l’instance de chaîne.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle le nombre de caractères spécifiés par le `count` paramètre ont été supprimées. Les caractères sont supprimés à la position spécifiée par `startIndex`.  
  
   
  
## Examples  
 L’exemple suivant montre comment vous pouvez supprimer le deuxième prénom d’un nom complet.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="count" /> est inférieur à zéro.  -ou- <paramref name="startIndex" /> plus <paramref name="count" /> spécifient une position en dehors de cette instance.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne dans laquelle toutes les occurrences d'un caractère Unicode spécifié ou de <see cref="T:System.String" /> dans la chaîne actuelle sont remplacées par un autre caractère Unicode spécifié ou <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Caractère Unicode à remplacer.</param>
        <param name="newChar">Caractère Unicode permettant de remplacer toutes les occurrences de <c>oldChar</c>.</param>
        <summary>Retourne une nouvelle chaîne dans laquelle toutes les occurrences d'un caractère Unicode spécifié dans cette instance sont remplacées par un autre caractère Unicode spécifié.</summary>
        <returns>Chaîne équivalente à cette instance, sauf que toutes les instances de <paramref name="oldChar" /> sont remplacées par <paramref name="newChar" />. Si <paramref name="oldChar" /> est introuvable dans l'instance actuelle, la méthode retourne l'instance actuelle sans modification.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une recherche d’ordinale (respectant la casse et indépendantes de la culture) pour rechercher `oldChar`.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle toutes les occurrences de `oldChar` sont remplacés par `newChar`.  
  
 Étant donné que cette méthode retourne la chaîne modifiée, vous pouvez chaîner les appels successifs à la <xref:System.String.Replace%2A> méthode pour effectuer plusieurs remplacements sur la chaîne d’origine. Appels de méthode sont exécutées de gauche à droite. L'exemple suivant illustre cette situation.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 L’exemple suivant crée une liste de valeurs séparées par des virgules en remplaçant par des virgules pour les valeurs vides entre une série de nombres.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Chaîne à remplacer.</param>
        <param name="newValue">Chaîne permettant de remplacer toutes les occurrences de <c>oldValue</c>.</param>
        <summary>Retourne une nouvelle chaîne dans laquelle toutes les occurrences d'une chaîne spécifiée dans l'instance actuelle sont remplacées par une autre chaîne spécifiée.</summary>
        <returns>Chaîne équivalente à la chaîne actuelle, sauf que toutes les instances de <paramref name="oldValue" /> sont remplacées par <paramref name="newValue" />. Si <paramref name="oldValue" /> est introuvable dans l'instance actuelle, la méthode retourne l'instance actuelle sans modification.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `newValue` est `null`, toutes les occurrences de `oldValue` sont supprimés.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle toutes les occurrences de `oldValue` sont remplacés par `newValue`.  
  
 Cette méthode effectue une recherche d’ordinale (respectant la casse et indépendantes de la culture) pour rechercher `oldValue`.  
  
 Étant donné que cette méthode retourne la chaîne modifiée, vous pouvez chaîner les appels successifs à la <xref:System.String.Replace%2A> méthode pour effectuer plusieurs remplacements sur la chaîne d’origine. Appels de méthode sont exécutées de gauche à droite. L'exemple suivant illustre cette situation.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant montre comment vous pouvez utiliser la <xref:System.String.Replace%2A> méthode permettant de corriger une faute d’orthographe.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> est la chaîne vide ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un tableau de chaînes qui contient les sous-chaînes de cette instance, séparées par les éléments d'une chaîne ou d'un tableau de caractères Unicode spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> est utilisé pour arrêter une chaîne délimitée en sous-chaînes. Vous pouvez utiliser soit un tableau de caractères pour spécifier zéro, un ou plusieurs caractères de délimitation (la <xref:System.String.Split%28System.Char%5B%5D%29> méthode), ou vous pouvez utiliser un tableau de caractères pour spécifier zéro, une ou plusieurs chaînes de délimitation. Les surcharges de la <xref:System.String.Split%2A> méthode vous permet de limiter le nombre de sous-chaînes retourné par la méthode (le <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> (méthode)), afin de déterminer si les chaînes vides sont incluses dans les sous-chaînes retournées (le <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> et <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> méthodes, ou Pour effectuer les deux (la <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> et <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> méthodes).  
  
> [!IMPORTANT]
>  Pour plus d’informations sur la <xref:System.String.Split%2A> la méthode, ainsi que des exemples d’appellent de chaque surcharge, consultez la documentation pour les surcharges individuels de <xref:System.String.Split%2A>.  
  
 Le <xref:System.String.Split%2A> méthode n’est pas toujours la meilleure méthode pour arrêter une chaîne délimitée en sous-chaînes. Si vous ne souhaitez pas extraire toutes les sous-chaînes d’une chaîne délimitée, ou si vous souhaitez analyser une chaîne basée sur un modèle au lieu d’un jeu de caractères de délimitation, considérez les alternatives suivantes.  
  
## <a name="regular-expressions"></a>Expressions régulières  
 Si vos chaînes conforme à un modèle fixe, vous pouvez utiliser une expression régulière pour extraire et gérer leurs éléments. Par exemple, si les chaînes prennent la forme «*nombre* *opérande* *nombre*» que vous pouvez utiliser un [expression régulière](~/docs/standard/base-types/regular-expressions.md) pour extraire et gérer les éléments de la chaîne. Voici un exemple :  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Le modèle d’expression régulière `(\d+)\s+([-+*/])\s+(\d+)` est définie comme suit :  
  
|Motif|Description |  
|-------------|-----------------|  
|`(\d+)`|Mettre en correspondance un ou plusieurs chiffres décimaux. Il s'agit du premier groupe de capture.|  
|`\s+`|Mettre en correspondance un ou plusieurs caractères d’espace blanc.|  
|`([-+*/])`|Correspond à un signe d’opérateurs arithmétiques (+, -, *, ou /). Il s'agit du deuxième groupe de capture.|  
|`\s+`|Mettre en correspondance un ou plusieurs caractères d’espace blanc.|  
|`(\d+)`|Mettre en correspondance un ou plusieurs chiffres décimaux. Il s'agit du troisième groupe de capture.|  
  
 Vous pouvez également utiliser une expression régulière pour extraire des sous-chaînes d’une chaîne basée sur un modèle plutôt qu’un ensemble fixe de caractères. Il s’agit d’un scénario courant lors d’une des conditions suivantes se produit :  
  
-   Un ou plusieurs caractères délimiteur ne pas toujours servent d’un délimiteur dans le <xref:System.String> instance.  
  
-   La séquence et le nombre de caractères de délimitation est une variable ou inconnu.  
  
 Par exemple, le <xref:System.String.Split%2A> méthode ne peut pas être utilisée pour fractionner la chaîne suivante, car le nombre de `\n` (en c#) ou `vbCrLf` (en Visual Basic) de caractères est variable, et ne pas toujours servent de délimiteurs.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Une expression régulière peut se diviser cette chaîne facilement, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Le modèle d’expression régulière `\[([^\[\]]+)\]` est définie comme suit :  
  
|Motif|Description |  
|-------------|-----------------|  
|`\[`|Mettre en correspondance un crochet ouvrant.|  
|`([^\[\]]+)`|Correspond à n’importe quel caractère qui n’est pas une ouverture ou un crochet fermant une ou plusieurs fois. Il s'agit du premier groupe de capture.|  
|`\]`|Mettre en correspondance un crochet fermant.|  
  
 Le <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthode est presque identique à <xref:System.String.Split%2A?displayProperty=nameWithType>, à ceci près qu’il fractionne une chaîne basée sur un modèle d’expression régulière au lieu d’un jeu de caractères fixe. Par exemple, l’exemple suivant utilise la <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthode pour fractionner une chaîne qui contient les sous-chaînes délimitées par différentes combinaisons de traits d’union et d’autres caractères.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Le modèle d’expression régulière `\s-\s?[+*]?\s?-\s` est définie comme suit :  
  
|Motif|Description |  
|-------------|-----------------|  
|`\s-`|Mettre en correspondance un espace blanc suivi par un trait d’union.|  
|`\s?`|Mettre en correspondance zéro ou un espace blanc.|  
|`[+*]?`|Correspond zéro ou une occurrence d’un le + ou * caractère.|  
|`\s?`|Mettre en correspondance zéro ou un espace blanc.|  
|`-\s`|Mettre en correspondance un trait d’union suivi d’un espace blanc.|  
  
## <a name="search-methods-and-the-substring-method"></a>Méthodes de recherche et de la méthode Substring  
 Si vous n’êtes pas intéressé par toutes les sous-chaînes dans une chaîne, vous préférerez peut-être utiliser une des méthodes de comparaison de chaînes qui retourne l’index de début de la correspondance. Vous pouvez ensuite appeler la <xref:System.String.Substring%2A> méthode extraire la sous-chaîne souhaité. Les méthodes de comparaison de chaînes sont les suivantes :  
  
-   <xref:System.String.IndexOf%2A>, qui retourne l’index de base zéro de la première occurrence d’un caractère ou une chaîne dans une instance de chaîne.  
  
-   <xref:System.String.IndexOfAny%2A>, qui retourne l’index de base zéro de l’instance actuelle de la chaîne de la première occurrence de n’importe quel caractère dans un tableau de caractères.  
  
-   <xref:System.String.LastIndexOf%2A>, qui retourne l’index de base zéro de la dernière occurrence d’un caractère ou une chaîne dans une instance de chaîne.  
  
-   <xref:System.String.LastIndexOfAny%2A>, qui retourne l’index de base zéro dans l’instance actuelle de la chaîne de la dernière occurrence d’un caractère quelconque dans un tableau de caractères.  
  
 L’exemple suivant utilise la <xref:System.String.IndexOf%2A> méthode pour rechercher les périodes dans une chaîne. Il utilise ensuite la <xref:System.String.Substring%2A> méthode pour retourner des phrases complètes.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Tableau de caractères qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteurs ou <see langword="null" />.</param>
        <summary>Divise une chaîne en sous-chaînes en fonction des caractères contenus dans un tableau.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette instance qui sont délimitées par un ou plusieurs caractères dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’une chaîne est délimitée par un jeu connu de caractères, vous pouvez utiliser la <xref:System.String.Split%28System.Char%5B%5D%29> méthode pour le séparer en sous-chaînes. Pour d’autres méthodes extraire des sous-chaînes d’une chaîne, consultez la [Alternatives à String.Split](#Alternatives) section.  
  
## <a name="return-value-details"></a>Détails de la valeur de retour  
 Caractères de séparation ne sont pas inclus dans les éléments du tableau retourné. Par exemple, si le tableau de séparateur inclut le caractère «- » et la valeur de l’instance actuelle de la chaîne est « aa-bb-cc », la méthode retourne un tableau qui contienne trois éléments : « aa », « bb » et « cc ».  
  
 Si cette instance ne contient aucun des caractères de `separator`, le tableau retourné se compose d’un élément unique qui contient cette instance.  
  
 Chaque élément de `separator` définit un caractère délimiteur séparé. Si deux délimiteurs sont adjacents, ou un délimiteur est trouvé au début ou à la fin de cette instance, l’élément correspondant dans le tableau retourné contient <xref:System.String.Empty>. Voici quelques exemples :  
  
|Valeur de chaîne|Séparateur|Tableau retourné|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|nouveau Char [] {',', ' '} (c#)<br /><br /> Char() = {«, » c, « « c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|nouveau Char [] {'. '} (C#)<br /><br /> Char() = {«. » c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|« Banana »|nouveau Char [] {'. '} (C#)<br /><br /> Char() = {«. » c} (Visual Basic)|{« Banana »}|  
|« Darb\nSmarba » (c#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|nouveau Char [] {} (c#)<br /><br /> Char() = {} (Visual Basic)|{"Darb", "Smarba"}|  
|« Darb\nSmarba » (c#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
## <a name="the-separator-array"></a>Le tableau de séparateur  
 Chaque élément de séparateur définit un délimiteur distinct qui se compose d’un seul caractère. Si le `separator` argument est `null` ou ne contient aucun caractère, la méthode traite des espaces comme séparateurs. Espaces blancs sont définies par Unicode standard ; elles retournent `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode).  
  
## <a name="stringsplitchar-and-compiler-overload-resolution"></a>Résolution de surcharge String.Split(Char[]) et du compilateur  
 Bien que le paramètre unique pour cette surcharge de <xref:System.String.Split%2A?displayProperty=nameWithType> est un tableau de caractères, vous pouvez l’appeler avec un seul caractère, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Étant donné que la `separator` paramètre est décoré avec le <xref:System.ParamArrayAttribute> attribut, compilateurs interprète un seul caractère comme un tableau de caractères de l’élément. Cela n’est pas le cas pour d’autres <xref:System.String.Split%2A?displayProperty=nameWithType> surcharges qui incluent un `separator` paramètre ; vous devez explicitement passer ces surcharges un tableau de caractères en tant que le `separator` argument.  
  
## <a name="comparison-details"></a>Comparaison détaillée  
 Le <xref:System.String.Split%28System.Char%5B%5D%29> méthode extrait les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs des caractères dans le `separator` de tableau et retourne ces sous-chaînes comme éléments d’un tableau.  
  
 Le <xref:System.String.Split%28System.Char%5B%5D%29> méthode recherche les délimiteurs en effectuant des comparaisons à l’aide des règles de tri ordinal qui respecte la casse. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez la <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> énumération.  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-stringsplit"></a>Alternatives à String.Split  
 Le <xref:System.String.Split%2A> méthode n’est pas toujours la meilleure méthode pour arrêter une chaîne délimitée en sous-chaînes. Si vous ne souhaitez pas extraire toutes les sous-chaînes d’une chaîne délimitée, ou si vous souhaitez analyser une chaîne basée sur un modèle au lieu d’un jeu de caractères de délimitation, considérez les alternatives suivantes.  
  
### <a name="regular-expressions"></a>Expressions régulières  
 Si vos chaînes conforme à un modèle fixe, vous pouvez utiliser une expression régulière pour extraire et gérer leurs éléments. Par exemple, si les chaînes prennent la forme «*nombre* *opérande* *nombre*» que vous pouvez utiliser un [expression régulière](~/docs/standard/base-types/regular-expressions.md) pour extraire et gérer les éléments de la chaîne. Voici un exemple :  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Le modèle d’expression régulière `(\d+)\s+([-+*/])\s+(\d+)` est définie comme suit :  
  
|Motif|Description |  
|-------------|-----------------|  
|`(\d+)`|Mettre en correspondance un ou plusieurs chiffres décimaux. Il s'agit du premier groupe de capture.|  
|`\s+`|Mettre en correspondance un ou plusieurs caractères d’espace blanc.|  
|`([-+*/])`|Correspond à un signe d’opérateurs arithmétiques (+, -, *, ou /). Il s'agit du deuxième groupe de capture.|  
|`\s+`|Mettre en correspondance un ou plusieurs caractères d’espace blanc.|  
|`(\d+)`|Mettre en correspondance un ou plusieurs chiffres décimaux. Il s'agit du troisième groupe de capture.|  
  
 Vous pouvez également utiliser une expression régulière pour extraire des sous-chaînes d’une chaîne basée sur un modèle plutôt qu’un ensemble fixe de caractères. Il s’agit d’un scénario courant lors d’une des conditions suivantes se produit :  
  
-   Un ou plusieurs caractères délimiteur ne pas toujours servent d’un délimiteur dans le <xref:System.String> instance.  
  
-   La séquence et le nombre de caractères de délimitation est une variable ou inconnu.  
  
 Par exemple, le <xref:System.String.Split%2A> méthode ne peut pas être utilisée pour fractionner la chaîne suivante, car le nombre de `\n` (en c#) ou `vbCrLf` (en Visual Basic) de caractères est variable, et ne pas toujours servent de délimiteurs.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Une expression régulière peut se diviser cette chaîne facilement, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Le modèle d’expression régulière `\[([^\[\]]+)\]` est définie comme suit :  
  
|Motif|Description |  
|-------------|-----------------|  
|`\[`|Mettre en correspondance un crochet ouvrant.|  
|`([^\[\]]+)`|Correspond à n’importe quel caractère qui n’est pas une ouverture ou un crochet fermant une ou plusieurs fois. Il s'agit du premier groupe de capture.|  
|`\]`|Mettre en correspondance un crochet fermant.|  
  
 Le <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthode est presque identique à <xref:System.String.Split%2A?displayProperty=nameWithType>, à ceci près qu’il fractionne une chaîne basée sur un modèle d’expression régulière au lieu d’un jeu de caractères fixe. Par exemple, l’exemple suivant utilise la <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthode pour fractionner une chaîne qui contient les sous-chaînes délimitées par différentes combinaisons de traits d’union et d’autres caractères.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Le modèle d’expression régulière `\s-\s?[+*]?\s?-\s` est définie comme suit :  
  
|Motif|Description |  
|-------------|-----------------|  
|`\s-`|Mettre en correspondance un espace blanc suivi par un trait d’union.|  
|`\s?`|Mettre en correspondance zéro ou un espace blanc.|  
|`[+*]?`|Correspond zéro ou une occurrence d’un le + ou * caractère.|  
|`\s?`|Mettre en correspondance zéro ou un espace blanc.|  
|`-\s`|Mettre en correspondance un trait d’union suivi d’un espace blanc.|  
  
### <a name="search-methods-and-the-substring-method"></a>Méthodes de recherche et de la méthode Substring  
 Si vous n’êtes pas intéressé par toutes les sous-chaînes dans une chaîne, vous préférerez peut-être utiliser une des méthodes de comparaison de chaînes qui retourne l’index de début de la correspondance. Vous pouvez ensuite appeler la <xref:System.String.Substring%2A> méthode extraire la sous-chaîne souhaité. Les méthodes de comparaison de chaînes sont les suivantes :  
  
-   <xref:System.String.IndexOf%2A>, qui retourne l’index de base zéro de la première occurrence d’un caractère ou une chaîne dans une instance de chaîne.  
  
-   <xref:System.String.IndexOfAny%2A>, qui retourne l’index de base zéro de l’instance actuelle de la chaîne de la première occurrence de n’importe quel caractère dans un tableau de caractères.  
  
-   <xref:System.String.LastIndexOf%2A>, qui retourne l’index de base zéro de la dernière occurrence d’un caractère ou une chaîne dans une instance de chaîne.  
  
-   <xref:System.String.LastIndexOfAny%2A>, qui retourne l’index de base zéro dans l’instance actuelle de la chaîne de la dernière occurrence d’un caractère quelconque dans un tableau de caractères.  
  
 L’exemple suivant utilise la <xref:System.String.IndexOf%2A> méthode pour rechercher les périodes dans une chaîne. Il utilise ensuite la <xref:System.String.Substring%2A> méthode pour retourner des phrases complètes.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application nécessite des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode). Vous avez également la possibilité d’utiliser le <xref:System.String.Compare%2A> méthode de localisation d’une sous-chaîne dans une chaîne.  
  
 Pour fractionner une chaîne à un caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode de localisation d’un caractère de séparation dans la chaîne. Pour fractionner une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont égaux aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes en plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la charge supplémentaire de chaque appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant montre comment extraire des mots individuels à partir d’un bloc de texte en traitant les espaces blancs et signes de ponctuation comme des séparateurs. Le tableau de caractères est passée à la `separator` paramètre de la <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> méthode se compose d’un espace et un caractère de tabulation, ainsi que les symboles de ponctuation courants.  
  
 [!code-csharp[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Dans la [ ! Include[net_v35_short](~/Includes/NET-v35-short-MD.MD)] et les versions antérieures, si la <see cref="M:System.String.Split(System.Char[])" /> méthode est passée un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner le chaîne à la <see cref="M:System.String.Trim(System.Char[])" /> fait de la méthode pour découper la chaîne. Dans la [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)], les deux méthodes utilisent un jeu identique d’espaces blancs Unicode.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Tableau de caractères qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteurs ou <see langword="null" />.</param>
        <param name="count">Nombre maximal de sous-chaînes à retourner.</param>
        <summary>Fractionne une chaîne en un nombre maximal de sous-chaînes en fonction des caractères contenus dans un tableau. Vous pouvez aussi spécifier le nombre maximal de sous-chaînes à retourner.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette instance qui sont délimitées par un ou plusieurs caractères dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caractères de séparation ne sont pas inclus dans les éléments du tableau retourné.  
  
 Si cette instance ne contient aucun des caractères de `separator`, le tableau retourné se compose d’un élément unique qui contient cette instance. Si `count` est égal à zéro, un tableau vide est retourné.  
  
 Si le `separator` paramètre est `null` ou ne contient aucun caractère, espaces blancs sont supposés pour être des séparateurs. Espaces blancs sont définis par la norme Unicode et retournent `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode).  
  
 Chaque élément de `separator` définit un caractère délimiteur séparé. Si deux délimiteurs sont adjacents, ou un délimiteur est trouvé au début ou à la fin de cette instance, l’élément de tableau correspondant contient <xref:System.String.Empty>.  
  
 S’il y a plus de `count` sous-chaînes de cette instance, la première `count` sous-chaînes moins 1 sont retournées dans la première `count` éléments moins 1 de la valeur de retour et les autres caractères dans cette instance sont retournés dans le dernier élément de la valeur de retour.  
  
 Si `count` est supérieur au nombre de sous-chaînes, les sous-chaînes disponibles sont retournées et aucune exception n’est levée.  
  
 Le tableau suivant fournit des exemples.  
  
|Valeur de chaîne|Séparateur|Nombre|Tableau retourné|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|nouveau Char [] {',', ' '} (c#)<br /><br /> Char() = {«, » c, « « c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|nouveau Char [] {'. '} (C#)<br /><br /> Char() = {«. » c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|« Banana »|nouveau Char [] {'. '} (C#)<br /><br /> Char() = {«. » c} (Visual Basic)|2|{« Banana »}|  
|« Darb\nSmarba » (c#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|nouveau Char [] {} (c#)<br /><br /> Char() = {} (Visual Basic)|1|{« Darb\nSmarba »} (C#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|  
|« Darb\nSmarba » (c#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|nouvelle Char [] null (c#)<br /><br /> Char() = Nothing|2|{"Darb", "Smarba"}|  
|« Darb\nSmarba » (c#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|nouvelle Char [] null (c#)<br /><br /> Char() = Nothing|100|{"Darb", "Smarba"}|  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application nécessite des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode) et éventuellement le <xref:System.String.Compare%2A> (méthode), pour trouver une sous-chaîne dans une chaîne.  
  
 Si vous fractionnez une chaîne au caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode de localisation d’un caractère de séparation dans la chaîne. Si vous fractionnez une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont égaux aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes en plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la charge supplémentaire de chaque appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant montre comment `count` affecte le nombre de chaînes retournées par <xref:System.String.Split%2A>.  
  
 [!code-csharp[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.</exception>
        <block subset="none" type="usage">
          <para>Dans la [ ! Include[net_v35_short](~/Includes/NET-v35-short-MD.MD)] et les versions antérieures, si la <see cref="M:System.String.Split(System.Char[])" /> méthode est passée un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner le chaîne à la <see cref="M:System.String.Trim(System.Char[])" /> fait de la méthode pour découper la chaîne. Dans la [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)], les deux méthodes utilisent un jeu identique d’espaces blancs Unicode.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tableau de caractères qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteurs ou <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> pour ignorer les éléments vides du tableau retourné ou <see cref="F:System.StringSplitOptions.None" /> pour les inclure.</param>
        <summary>Fractionne une chaîne en sous-chaînes en fonction des caractères contenus dans un tableau. Vous pouvez préciser si les sous-chaînes incluent les éléments d'un tableau vide.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette chaîne qui sont délimitées par un ou plusieurs caractères dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Détails de la valeur de retour  
 Caractères de délimitation (les caractères dans le `separator` tableau) ne sont pas inclus dans les éléments du tableau retourné. Par exemple, si le `separator` tableau inclut le caractère «- » et la valeur de l’instance actuelle de la chaîne est « aa-bb-cc », la méthode retourne un tableau qui contienne trois éléments : « aa », « bb » et « cc ».  
  
 Si cette instance ne contient aucun des caractères de `separator`, le tableau retourné se compose d’un élément unique qui contient cette instance.  
  
 Si le `options` paramètre est <xref:System.StringSplitOptions.RemoveEmptyEntries> et la longueur de cette instance est égale à zéro, la méthode retourne un tableau vide.  
  
 Chaque élément de `separator` définit un délimiteur séparé qui se compose d’un seul caractère. Si le `options` argument est <xref:System.StringSplitOptions.None>et deux délimiteurs sont adjacents, ou un délimiteur se trouve au début ou à la fin de cette instance, l’élément de tableau correspondant contient <xref:System.String.Empty?displayProperty=nameWithType>. Par exemple, si `separator` inclut deux éléments, «- » et «\_», la valeur de l’instance de chaîne est »-\_aa -\_» et la valeur de la `options` argument est <xref:System.StringSplitOptions.None>, la méthode retourne un tableau de chaînes les cinq éléments suivants :  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui précède le «- » caractère à l’index 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide entre le »-« caractère à l’index 0 et le caractère « _ » à l’index 1.  
  
3.  « aa »,  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui suit le caractère « _ » à l’index 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui suit le «- » caractère à l’index 5.  
  
## <a name="the-separator-array"></a>Le tableau de séparateur  
 Si le `separator` paramètre est `null` ou ne contient aucun caractère, espaces blancs sont supposés pour être des séparateurs. Espaces blancs sont définis par la norme Unicode et retournent `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode).  
  
 Si le `separator` paramètre dans l’appel à cette surcharge de méthode est `null`, la résolution de surcharge du compilateur échoue. Pour identifier sans ambiguïté la méthode appelée, votre code doit indiquer le type de la `null`. L’exemple suivant montre plusieurs façons d’identifier sans ambiguïté cette surcharge.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## <a name="comparison-details"></a>Comparaison détaillée  
 Le <xref:System.String.Split%2A> méthode extrait les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs des caractères dans le `separator` paramètre et retourne ces sous-chaînes comme éléments d’un tableau.  
  
 Le <xref:System.String.Split%2A> méthode recherche les délimiteurs en effectuant des comparaisons à l’aide des règles de tri ordinal qui respecte la casse. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez la <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> énumération.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application nécessite des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode) et éventuellement le <xref:System.String.Compare%2A> (méthode), pour trouver une sous-chaîne dans une chaîne.  
  
 Si vous fractionnez une chaîne au caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode de localisation d’un caractère de séparation dans la chaîne. Si vous fractionnez une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont égaux aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes en plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la charge supplémentaire de chaque appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.StringSplitOptions> énumération à inclure ou exclure des sous-chaînes générées par le <xref:System.String.Split%2A> (méthode).  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> ne fait pas partie des valeurs <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Dans la [ ! Include[net_v35_short](~/Includes/NET-v35-short-MD.MD)] et les versions antérieures, si la <see cref="M:System.String.Split(System.Char[])" /> méthode est passée un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner le chaîne à la <see cref="M:System.String.Trim(System.Char[])" /> fait de la méthode pour découper la chaîne. Dans la [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)], les deux méthodes utilisent un jeu identique d’espaces blancs Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tableau de chaînes qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteur ou <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> pour ignorer les éléments vides du tableau retourné ou <see cref="F:System.StringSplitOptions.None" /> pour les inclure.</param>
        <summary>Fractionne une chaîne en sous-chaînes en fonction des chaînes contenues dans un tableau. Vous pouvez préciser si les sous-chaînes incluent les éléments d'un tableau vide.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs chaînes dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’une chaîne est délimitée par un jeu connu de chaînes, vous pouvez utiliser la <xref:System.String.Split%2A> méthode pour le séparer en sous-chaînes.  
  
## <a name="return-value-details"></a>Détails de la valeur de retour  
 Les chaînes de délimiteur ne sont pas inclus dans les éléments du tableau retourné. Par exemple, si le `separator` tableau comprend la chaîne «-- » et la valeur de l’instance actuelle de la chaîne est « aa, bb-cc », la méthode retourne un tableau qui contienne trois éléments : « aa », « bb » et « cc ».  
  
 Si cette instance ne contient aucun des chaînes de `separator`, le tableau retourné se compose d’un élément unique qui contient cette instance.  
  
 Si le `options` paramètre est <xref:System.StringSplitOptions.RemoveEmptyEntries> et la longueur de cette instance est égale à zéro, la méthode retourne un tableau vide.  
  
 Chaque élément de `separator` définit un délimiteur séparé qui se compose d’un ou plusieurs caractères. Si le `options` argument est <xref:System.StringSplitOptions.None>et deux délimiteurs sont adjacents, ou un délimiteur se trouve au début ou à la fin de cette instance, l’élément de tableau correspondant contient <xref:System.String.Empty?displayProperty=nameWithType>. Par exemple, si `separator` inclut deux éléments, «- » et « _ », la valeur de l’instance de chaîne est « - _aa -\_» et la valeur de la `options` argument est <xref:System.StringSplitOptions.None>, la méthode retourne un tableau de chaîne avec les cinq éléments suivants :  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui précède le «- » sous-chaîne à l’index 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide entre le «- » sous-chaîne à l’index 0 et la sous-chaîne « _ » à l’index 1.  
  
3.  « aa »,  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui suit la sous-chaîne « _ » à l’index 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui suit le «- » sous-chaîne à l’index 5.  
  
## <a name="the-separator-array"></a>Le tableau de séparateur  
 Si un des éléments dans `separator` se compose de plusieurs caractères, l’intégralité de la sous-chaîne est considéré comme un délimiteur. Par exemple, si un des éléments dans `separator` est « 10 », une tentative fractionner la chaîne « This10is10a10string ». Retourne le tableau de quatre éléments suivant : {« This », « est », « a », « string ». }.  
  
 Si le `separator` paramètre est `null` ou ne contient aucun caractère, espaces blancs sont supposés pour être des séparateurs. Espaces blancs sont définis par la norme Unicode et retournent `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode).  
  
 Si le `separator` paramètre dans l’appel à cette surcharge de méthode est `null`, la résolution de surcharge du compilateur échoue. Pour identifier sans ambiguïté la méthode appelée, votre code doit indiquer le type de la `null`. L’exemple suivant montre plusieurs façons d’identifier sans ambiguïté cette surcharge.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## <a name="comparison-details"></a>Comparaison détaillée  
 Le <xref:System.String.Split%2A> méthode extrait les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs des chaînes dans le `separator` paramètre et retourne ces sous-chaînes comme éléments d’un tableau.  
  
 Le <xref:System.String.Split%2A> méthode recherche les délimiteurs en effectuant des comparaisons à l’aide des règles de tri ordinal qui respecte la casse. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez la <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> énumération.  
  
 Le <xref:System.String.Split%2A> méthode ignore tout élément de `separator` dont la valeur est `null` ou une chaîne vide (« »).  
  
 Afin d’éviter des résultats ambigus lorsque des chaînes dans `separator` ont en commun, les caractères le <xref:System.String.Split%2A> opération se poursuit à partir du début à la fin de la valeur de l’instance et recherche le premier élément de `separator` est égal à un délimiteur dans le instance. L’ordre dans lequel les sous-chaînes sont trouvés dans l’instance est prioritaire sur l’ordre des éléments dans `separator`.  
  
 Par exemple, considérez une instance dont la valeur est « abcdef ». Si le premier élément de `separator` a été « ef » et le deuxième élément était « bcde », le résultat de l’opération de fractionnement serait un tableau de chaînes qui contient deux éléments, « a » et « f ». Il s’agit, car la sous-chaîne dans l’instance, « bcde », est rencontrée et correspond à un élément dans `separator` avant que la sous-chaîne « f » est rencontrée.  
  
 Toutefois, si le premier élément du `separator` était « bcd » et le deuxième élément était « bc », le résultat de l’opération de fractionnement serait un tableau de chaînes qui contient deux éléments, « a » et « ef ». Il s’agit, car « bcd » est le premier délimiteur de `separator` qui correspond à un délimiteur de l’instance. Si l’ordre des séparateurs d’a été inversé de sorte que le premier élément a été « bc » et le deuxième élément était « bcd », le résultat est un tableau de chaînes qui contient deux éléments, « a » et « def ».  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application nécessite des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode) et éventuellement le <xref:System.String.Compare%2A> (méthode), pour trouver une sous-chaîne dans une chaîne.  
  
 Si vous fractionnez une chaîne au caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode de localisation d’un caractère de séparation dans la chaîne. Si vous fractionnez une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont égaux aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes en plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la charge supplémentaire de chaque appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant illustre la différence dans les tableaux retournés par l’appel d’une chaîne <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> méthode avec ses `options` paramètre égal à <xref:System.StringSplitOptions.None?displayProperty=nameWithType> et <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 L’exemple suivant définit un tableau de séparateurs qui incluent des signes de ponctuation et espaces. Passage de ce tableau, ainsi qu’une valeur de <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> à la <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> méthode retourne un tableau qui se compose des mots individuels à partir de la chaîne.  
  
 [!code-csharp[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Notez que la méthode est appelée avec le `options` affectée à l’argument <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Cela empêche le tableau retourné à partir, y compris <xref:System.String.Empty?displayProperty=nameWithType> valeurs qui représentent les correspondances de sous-chaîne vide entre les signes de ponctuation et espaces.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> ne fait pas partie des valeurs <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Dans la [ ! Include[net_v35_short](~/Includes/NET-v35-short-MD.MD)] et les versions antérieures, si la <see cref="M:System.String.Split(System.Char[])" /> méthode est passée un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner le chaîne à la <see cref="M:System.String.Trim(System.Char[])" /> fait de la méthode pour découper la chaîne. Dans la [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)], les deux méthodes utilisent un jeu identique d’espaces blancs Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tableau de caractères qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteurs ou <see langword="null" />.</param>
        <param name="count">Nombre maximal de sous-chaînes à retourner.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> pour ignorer les éléments vides du tableau retourné ou <see cref="F:System.StringSplitOptions.None" /> pour les inclure.</param>
        <summary>Fractionne une chaîne en un nombre maximal de sous-chaînes en fonction des caractères contenus dans un tableau.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette chaîne qui sont délimitées par un ou plusieurs caractères dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caractères de séparation ne sont pas inclus dans les éléments du tableau retourné.  
  
 Si cette instance ne contient aucun des caractères de `separator`, ou `count` paramètre est 1, le tableau retourné se compose d’un élément unique qui contient cette instance. Si le `separator` paramètre est `null` ou ne contient aucun caractère, espaces blancs sont supposés pour être des séparateurs. Espaces blancs sont définis par la norme Unicode et retournent `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode). Toutefois, si le `separator` paramètre dans l’appel à cette surcharge de méthode est `null`, la résolution de surcharge du compilateur échoue. Pour identifier sans ambiguïté la méthode appelée, votre code doit indiquer le type de la valeur null. L’exemple suivant montre plusieurs façons d’identifier sans ambiguïté cette surcharge.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Si le `count` paramètre est égal à zéro, ou le `options` paramètre est <xref:System.StringSplitOptions.RemoveEmptyEntries> et la longueur de cette instance est égale à zéro, un tableau vide est retourné.  
  
 Chaque élément de `separator` définit un caractère délimiteur séparé. Si le `options` paramètre est <xref:System.StringSplitOptions.None>et deux délimiteurs sont adjacents, ou un délimiteur se trouve au début ou à la fin de cette instance, l’élément de tableau correspondant contient <xref:System.String.Empty>.  
  
 S’il y a plus de `count` sous-chaînes de cette instance, la première `count` sous-chaînes moins 1 sont retournées dans la première `count` éléments moins 1 de la valeur de retour et les autres caractères dans cette instance sont retournés dans le dernier élément de la valeur de retour.  
  
 Si `count` est supérieur au nombre de sous-chaînes, les sous-chaînes disponibles sont retournées et aucune exception n’est levée.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application nécessite des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode) et éventuellement le <xref:System.String.Compare%2A> (méthode), pour trouver une sous-chaîne dans une chaîne.  
  
 Si vous fractionnez une chaîne au caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode de localisation d’un caractère de séparation dans la chaîne. Si vous fractionnez une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont égaux aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes en plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la charge supplémentaire de chaque appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.StringSplitOptions> énumération à inclure ou exclure des sous-chaînes générées par le <xref:System.String.Split%2A> (méthode).  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> ne fait pas partie des valeurs <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Dans la [ ! Include[net_v35_short](~/Includes/NET-v35-short-MD.MD)] et les versions antérieures, si la <see cref="M:System.String.Split(System.Char[])" /> méthode est passée un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner le chaîne à la <see cref="M:System.String.Trim(System.Char[])" /> fait de la méthode pour découper la chaîne. Dans la [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)], les deux méthodes utilisent un jeu identique d’espaces blancs Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tableau de chaînes qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteur ou <see langword="null" />.</param>
        <param name="count">Nombre maximal de sous-chaînes à retourner.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> pour ignorer les éléments vides du tableau retourné ou <see cref="F:System.StringSplitOptions.None" /> pour les inclure.</param>
        <summary>Fractionne une chaîne en un nombre maximal de sous-chaînes en fonction des chaînes contenues dans un tableau. Vous pouvez préciser si les sous-chaînes incluent les éléments d'un tableau vide.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs chaînes dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Détails de la valeur de retour  
 Les chaînes de délimiteur ne sont pas inclus dans les éléments du tableau retourné.  
  
 Si cette instance ne contient aucun des chaînes de `separator`, ou `count` paramètre est 1, le tableau retourné se compose d’un élément unique qui contient cette instance. Si le `separator` paramètre est `null` ou ne contient aucun caractère, espaces blancs sont supposés pour être des séparateurs. Espaces blancs sont définis par la norme Unicode et retournent `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode). Toutefois, si le `separator` paramètre dans l’appel à cette surcharge de méthode est `null`, la résolution de surcharge du compilateur échoue. Pour identifier sans ambiguïté la méthode appelée, votre code doit indiquer le type de la `null`. L’exemple suivant montre plusieurs façons d’identifier sans ambiguïté cette surcharge.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Si le `count` paramètre est égal à zéro, ou le `options` paramètre est <xref:System.StringSplitOptions.RemoveEmptyEntries> et la longueur de cette instance est égale à zéro, un tableau vide est retourné.  
  
 Chaque élément de `separator` définit un délimiteur séparé qui se compose d’un ou plusieurs caractères. Si le `options` paramètre est <xref:System.StringSplitOptions.None>et deux délimiteurs sont adjacents, ou un délimiteur se trouve au début ou à la fin de cette instance, l’élément de tableau correspondant contient <xref:System.String.Empty>.  
  
 S’il y a plus de `count` sous-chaînes de cette instance, la première `count` sous-chaînes moins 1 sont retournées dans la première `count` éléments moins 1 de la valeur de retour et les autres caractères dans cette instance sont retournés dans le dernier élément de la valeur de retour.  
  
 Si `count` est supérieur au nombre de sous-chaînes, les sous-chaînes disponibles sont retournées et aucune exception n’est levée.  
  
## <a name="the-separator-array"></a>Le tableau de séparateur  
 Si un des éléments dans `separator` se compose de plusieurs caractères, l’intégralité de la sous-chaîne est considéré comme un délimiteur. Par exemple, si un des éléments dans `separator` est « 10 », une tentative fractionner la chaîne « This10is10a10string ». retourne ce tableau de quatre éléments : {« This », « est », « a », « string ». }.  
  
## <a name="comparison-details"></a>Comparaison détaillée  
 Le <xref:System.String.Split%2A> méthode extrait les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs des chaînes dans le `separator` paramètre et retourne ces sous-chaînes comme éléments d’un tableau.  
  
 Le <xref:System.String.Split%2A> méthode recherche les délimiteurs en effectuant des comparaisons à l’aide des règles de tri ordinal qui respecte la casse. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez la <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> énumération.  
  
 Le <xref:System.String.Split%2A> méthode ignore tout élément de `separator` dont la valeur est `null` ou une chaîne vide (« »).  
  
 Afin d’éviter des résultats ambigus lorsque des chaînes dans `separator` ont en commun, les caractères le <xref:System.String.Split%2A> méthode passe à partir du début à la fin de la valeur de l’instance et recherche le premier élément de `separator` est égal à un délimiteur dans le instance. L’ordre dans lequel les sous-chaînes sont trouvés dans l’instance est prioritaire sur l’ordre des éléments dans `separator`.  
  
 Par exemple, considérez une instance dont la valeur est « abcdef ». Si le premier élément de `separator` a été « ef » et le deuxième élément était « bcde », le résultat de l’opération de fractionnement serait « a » et « f ». Il s’agit, car la sous-chaîne dans l’instance, « bcde », est rencontrée et correspond à un élément dans `separator` avant que la sous-chaîne « f » est rencontrée.  
  
 Toutefois, si le premier élément du `separator` était « bcd » et le deuxième élément était « bc », le résultat de l’opération de fractionnement serait « a » et « ef ». Il s’agit, car « bcd » est le premier délimiteur de `separator` qui correspond à un délimiteur de l’instance. Si l’ordre des séparateurs d’a été inversé de sorte que le premier élément a été « bc » et le deuxième élément était « bcd », le résultat est « a » et « def ».  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application nécessite des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode) et éventuellement le <xref:System.String.Compare%2A> (méthode), pour trouver une sous-chaîne dans une chaîne.  
  
 Si vous fractionnez une chaîne au caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode de localisation d’un caractère de séparation dans la chaîne. Si vous fractionnez une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont égaux aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes en plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la charge supplémentaire de chaque appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.StringSplitOptions> énumération à inclure ou exclure des sous-chaînes générées par le <xref:System.String.Split%2A> (méthode).  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> ne fait pas partie des valeurs <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Dans la [ ! Include[net_v35_short](~/Includes/NET-v35-short-MD.MD)] et les versions antérieures, si la <see cref="M:System.String.Split(System.Char[])" /> méthode est passée un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner le chaîne à la <see cref="M:System.String.Trim(System.Char[])" /> fait de la méthode pour découper la chaîne. Dans la [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)], les deux méthodes utilisent un jeu identique d’espaces blancs Unicode.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si le début de cette instance de chaîne correspond à une chaîne spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer.</param>
        <summary>Détermine si le début de cette instance de chaîne correspond à la chaîne spécifiée.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> correspond au début de cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode compare `value` à la sous-chaîne au début de cette instance est la même longueur que `value`et retourne une indication si elles sont égales. Pour être égale, `value` doit être une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>), doit être une référence à cette même instance ou correspondre au début de cette instance.  
  
 Cette méthode effectue une comparaison de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle.  
  
   
  
## Examples  
 L’exemple suivant définit un `StripStartTags` méthode qui utilise le <xref:System.String.StartsWith%28System.String%29> balises de début de méthode pour supprimer le code HTML à partir du début d’une chaîne. Notez que le `StripStartTags` méthode est appelée pour vous assurer que plusieurs balises de début HTML au début de la ligne sont supprimés de manière récursive. L’exemple ne supprime pas les balises HTML incorporés dans une chaîne.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [Best Practices for à l’aide de Strings](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent les méthodes qui requièrent des paramètres pour être explicitement spécifié. Pour déterminer si une chaîne commence par une sous-chaîne particulière en utilisant les règles de comparaison de la culture actuelle, appelez la <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> avec une valeur de la surcharge de méthode <see cref="F:System.StringComparison.CurrentCulture" /> pour son <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer.</param>
        <param name="comparisonType">Une des valeurs d’énumération qui détermine le mode de comparaison entre cette chaîne et <c>value</c>.</param>
        <summary>Détermine si le début de cette instance de chaîne correspond à la chaîne spécifiée quand elle est comparée à l'aide de l'option spécifiée.</summary>
        <returns>
          <see langword="true" /> si cette instance commence par <paramref name="value" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.StartsWith%2A> méthode compare la `value` paramètre à la sous-chaîne au début de cette chaîne et retourne une valeur qui indique s’ils sont égaux. Pour être égale, `value` doit être une référence à cette même chaîne, doit être une chaîne vide (« »), ou correspondre au début de cette chaîne. Le type de comparaison effectuée par le <xref:System.String.StartsWith%2A> méthode dépend de la valeur de le `comparisonType` paramètre. La comparaison peut utiliser les conventions de la culture actuelle (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> et <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) ou la culture dite indifférente (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> et <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), ou il peut se composer d’une comparaison caractère par caractère de points de code (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). La comparaison peut également être sensible à la casse (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, ou <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), ou il peut ignorer la casse (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 L’exemple suivant recherche la chaîne « the » au début d’une chaîne de plus de temps qui commence par le mot « The ». Comme la sortie de l’exemple, un appel à la <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> méthode qui effectue une comparaison indépendante de la culture, mais la casse ne correspond pas à la chaîne, pendant un appel qui effectue une comparaison de culture et scénarios insensitive correspond à la chaîne.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 L’exemple suivant détermine si une chaîne commence par une sous-chaîne particulière. Elle initialise un tableau de chaînes à deux dimensions. Le premier élément dans la deuxième dimension contient une chaîne, et le deuxième élément contient la chaîne à rechercher au début de la première chaîne. Les résultats sont affectés par le choix de la culture, si la casse est ignorée et indique si une comparaison ordinale est effectuée. Notez que lorsque l’instance de chaîne contient un digramme soudé, comparaisons dépendantes de la culture avec ses caractères consécutifs mettre en correspondance.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <param name="culture">Informations culturelles qui déterminent le mode de comparaison entre cette chaîne et <c>value</c>. Si <c>culture</c> est <see langword="null" />, la culture actuelle est utilisée.</param>
        <summary>Détermine si le début de cette instance de chaîne correspond à la chaîne spécifiée quand elle est comparée à l'aide de la culture spécifiée.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> correspond au début de cette chaîne ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode compare la `value` paramètre à la sous-chaîne au début de cette chaîne est la même longueur que `value`et retourne une valeur qui indique s’ils sont égaux. Pour être égale, `value` doit être une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>), doit être une référence à cette même instance ou correspondre au début de cette instance.  
  
 Cette méthode effectue une comparaison à l’aide de la casse spécifiée et la culture.  
  
   
  
## Examples  
 L’exemple suivant détermine si une chaîne se produit au début d’une autre chaîne. Le <xref:System.String.StartsWith%2A> méthode est appelée plusieurs fois avec respect de la casse, non-respect de la casse et différentes cultures qui influencent les résultats de la recherche.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère une sous-chaîne de cette instance.  Ce membre est surchargé. Pour obtenir des informations complètes sur ce membre, notamment sa syntaxe, son utilisation et des exemples s’y rapportant, cliquez sur un nom dans la liste de surcharge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position de caractère de départ de base zéro d'une sous-chaîne dans cette instance.</param>
        <summary>Récupère une sous-chaîne de cette instance. La sous-chaîne commence à une position de caractère spécifiée et continue jusqu'à la fin de la chaîne.</summary>
        <returns>Chaîne équivalente à la sous-chaîne qui commence à <paramref name="startIndex" /> dans cette instance ou <see cref="F:System.String.Empty" /> si <paramref name="startIndex" /> est égal à la longueur de cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous appelez le <xref:System.String.Substring%2A> méthode pour extraire une sous-chaîne d’une chaîne qui commence à une position de caractère spécifiée et se termine à la fin de la chaîne. La position de caractère de début est de base zéro ; en d’autres termes, le premier caractère dans la chaîne est à l’index 0, pas l’index 1. Pour extraire une sous-chaîne qui commence à une position de caractère spécifiée et se termine avant à la fin de la chaîne, appelez le <xref:System.String.Substring%2A> (méthode).  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne qui commence à la `startIndex` position dans la chaîne actuelle.  
  
 Pour extraire une sous-chaîne qui commence par un caractère particulier ou d’une séquence de caractères, appeler une méthode telle que <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> pour obtenir la valeur de `startIndex`. Le deuxième exemple illustre cela ; Il extrait une valeur de clé qui commence à une position de caractère après le caractère « = ».  
  
 Si `startIndex` est égal à zéro, la méthode retourne la chaîne d’origine est inchangée.  
  
   
  
## Examples  
 L’exemple suivant montre comment obtenir une sous-chaîne à partir d’une chaîne.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 L’exemple suivant utilise le <xref:System.String.Substring%2A> (méthode) pour séparer les paires clé/valeur qui sont délimitées par une est égal à (« = ») de caractères.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Le <xref:System.String.IndexOf%2A> méthode est utilisée pour obtenir la position du caractère égal dans la chaîne. L’appel à la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> méthode extrait le nom de clé, qui commence par le premier caractère dans la chaîne et s’étend sur le nombre de caractères retournés par l’appel à la <xref:System.String.IndexOf%2A> (méthode). L’appel à la <xref:System.String.Substring%28System.Int32%29> méthode extrait ensuite la valeur affectée à la clé. Il commence à une position de caractère au-delà du caractère égal à et s’étend à la fin de la chaîne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position de caractère de départ de base zéro d'une sous-chaîne dans cette instance.</param>
        <param name="length">Nombre de caractères dans la sous-chaîne.</param>
        <summary>Récupère une sous-chaîne de cette instance. La sous-chaîne commence à une position de caractère spécifiée et sa longueur est définie.</summary>
        <returns>Chaîne équivalente à la sous-chaîne de longueur <paramref name="length" /> qui commence à <paramref name="startIndex" /> dans cette instance ou <see cref="F:System.String.Empty" /> si <paramref name="startIndex" /> est égal à la longueur de cette instance et <paramref name="length" /> a la valeur zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous appelez le <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> méthode pour extraire une sous-chaîne d’une chaîne qui commence à une position de caractère spécifiée et se termine avant la fin de la chaîne. La position de caractère de début est de base zéro ; en d’autres termes, le premier caractère dans la chaîne est à l’index 0, pas l’index 1. Pour extraire une sous-chaîne qui commence à une position de caractère spécifiée et continue jusqu'à la fin de la chaîne, appelez le <xref:System.String.Substring%28System.Int32%29> (méthode).  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne avec `length` caractères à partir de la `startIndex` position dans la chaîne actuelle.  
  
 Le `length` paramètre représente le nombre total de caractères à extraire à partir de l’instance actuelle de la chaîne. Cela inclut le caractère de début située à l’index `startIndex`.  En d’autres termes, le <xref:System.String.Substring%2A> méthode tente d’extraire des caractères de l’index `startIndex` index `startIndex`  +  `length` - 1.  
  
 Pour extraire une sous-chaîne qui commence par un caractère particulier ou d’une séquence de caractères, appeler une méthode telle que <xref:System.String.IndexOf%2A> ou <xref:System.String.LastIndexOf%2A> pour obtenir la valeur de `startIndex`.  
  
 Si la sous-chaîne s’étend de `startIndex` à une séquence de caractère spécifiée, vous pouvez appeler une méthode, tel que <xref:System.String.IndexOf%2A> ou <xref:System.String.LastIndexOf%2A> pour obtenir l’index de caractère de fin ou de la séquence de caractères.  Vous pouvez ensuite convertir en cette valeur à une position d’index dans la chaîne comme suit :  
  
-   Si vous avez effectué une recherche pour un seul caractère qui consiste à marquer la fin de la sous-chaîne, la `length` paramètre est égal à `endIndex`  -  `startIndex` + 1, où `endIndex` est la valeur de retour de la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> méthode. L’exemple suivant extrait un bloc continu de caractères « b » d’une chaîne.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Si vous avez effectué une recherche pour plusieurs caractères pour marquer la fin de la sous-chaîne, la `length` paramètre est égal à `endIndex`  +  `endMatchLength`  -  `startIndex`, où `endIndex` est la valeur de retour de la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> méthode., et `endMatchLength` est la longueur de la séquence de caractères qui marque la fin de la sous-chaîne. L’exemple suivant extrait un bloc de texte qui contient un document XML `<definition>` élément.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Si le caractère ou une séquence de caractères n’est pas inclus dans la fin de la sous-chaîne, la `length` paramètre est égal à `endIndex`  -  `startIndex`, où `endIndex` est la valeur de retour de la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> méthode.  
  
 Si `startIndex` est égal à zéro et est égal à la longueur de la chaîne actuelle, la méthode retourne la chaîne d’origine est inchangée.  
  
   
  
## Examples  
 L’exemple suivant illustre un simple appel à la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> méthode qui extrait des deux caractères d’une chaîne commençant à la sixième position de caractère (autrement dit, à l’index 5).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 L’exemple suivant utilise la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> méthode dans les trois cas suivants pour isoler des sous-chaînes dans une chaîne. Dans les deux cas les sous-chaînes sont utilisées dans les comparaisons, et dans le troisième cas une exception est levée, car les paramètres non valides sont spécifiés.  
  
-   Extrait le caractère unique et la troisième position dans la chaîne (à l’index 2) et le compare avec un « c ». Cette comparaison retourne `true`.  
  
-   Il extrait de zéro caractères en commençant à la quatrième position dans la chaîne (à l’index 3) et le transmet à la <xref:System.String.IsNullOrEmpty%2A> (méthode). Cette fonction retourne true, car l’appel à la <xref:System.String.Substring%2A> méthode renvoie <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Il tente d’extraire un seul caractère, en commençant à la quatrième position dans la chaîne. Étant donné qu’aucun caractère à cette position, l’appel de méthode lève une <xref:System.ArgumentOutOfRangeException> exception.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 L’exemple suivant utilise le <xref:System.String.Substring%2A> (méthode) pour séparer les paires clé/valeur qui sont délimitées par une est égal à (« = ») de caractères.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Le <xref:System.String.IndexOf%2A> méthode est utilisée pour obtenir la position du caractère égal dans la chaîne. L’appel à la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> méthode extrait le nom de clé, qui commence par le premier caractère dans la chaîne et s’étend sur le nombre de caractères retournés par l’appel à la <xref:System.String.IndexOf%2A> (méthode). L’appel à la <xref:System.String.Substring%28System.Int32%29> méthode extrait ensuite la valeur affectée à la clé. Il commence à une position de caractère au-delà du caractère égal à et s’étend à la fin de la chaîne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> plus <paramref name="length" /> indique une position qui n’est pas dans cette instance.  -ou- <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein de l'objet <see cref="T:System.String" /> actuel.</summary>
        <returns>Énumérateur fortement typé qui peut être utilisé pour parcourir l’objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut être utilisé uniquement lorsque le <xref:System.String> instance est effectuée en une <xref:System.Collections.Generic.IEnumerable%601> objet d’interface. Pour plus d'informations, voir la méthode <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein de l'objet <see cref="T:System.String" /> actuel.</summary>
        <returns>Énumérateur qui peut être utilisé pour itérer au sein de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.Collections.IEnumerable>. Pour plus d'informations, voir la méthode <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> si la valeur de la chaîne actuelle est <see cref="F:System.Boolean.TrueString" /> ; <see langword="false" /> si la valeur de la chaîne actuelle est <see cref="F:System.Boolean.FalseString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de la chaîne actuelle n'est pas <see cref="F:System.Boolean.TrueString" /> ou <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l'objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l'objet <see cref="T:System.String" /> actuel est un nombre supérieur à <see cref="F:System.Byte.MaxValue" /> ou inférieur à <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Caractère à l'index 0 dans l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l'objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l'objet <see cref="T:System.String" /> est un nombre inférieur à <see cref="F:System.Decimal.MinValue" /> ou supérieur à <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l'objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l'objet <see cref="T:System.String" /> est un nombre inférieur à <see cref="F:System.Double.MinValue" /> ou supérieur à <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l'objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l'objet <see cref="T:System.String" /> actuel est un nombre supérieur à <see cref="F:System.Int16.MaxValue" /> ou inférieur à <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l'objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l'objet <see cref="T:System.String" /> actuel est un nombre supérieur à <see cref="F:System.SByte.MaxValue" /> ou inférieur à <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet retourné.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ChangeType%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">La valeur de l'objet <see cref="T:System.String" /> en cours ne peut pas être convertie dans le type spécifié par le paramètre <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l'objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l'objet <see cref="T:System.String" /> actuel est un nombre supérieur à <see cref="F:System.UInt16.MaxValue" /> ou inférieur à <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l'objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l'objet <see cref="T:System.String" /> en cours est un nombre supérieur à <see cref="F:System.UInt32.MaxValue" /> ou inférieur à <see cref="F:System.UInt32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie les caractères de cette instance vers un tableau de caractères Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie les caractères de cette instance vers un tableau de caractères Unicode.</summary>
        <returns>Tableau de caractères Unicode dont les éléments sont les caractères individuels de cette instance. Si cette instance est une chaîne vide, le tableau retourné est vide et sa longueur est égale à zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie chaque caractère (autrement dit, chaque <xref:System.Char> objet) dans une chaîne à un tableau de caractères. Le premier caractère copié est à l’index zéro du tableau de caractères retourné ; le dernier caractère copié est à l’index <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1.  
  
 Pour créer une chaîne de caractères dans un tableau de caractères, appelez le <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructeur.  
  
 Pour créer un tableau d’octets qui contient les caractères encodés dans une chaîne, instanciez approprié <xref:System.Text.Encoding> objet et appeler ses <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> (méthode). Voici quelques-unes des encodages standard disponibles dans le .NET Framework :  
  
|Encodage|Object|  
|--------------|------------|  
|non|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Pour plus d’informations, consultez [l’encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.String.ToCharArray%2A> méthode pour extraire les caractères dans une chaîne à un tableau de caractères. Il affiche ensuite la chaîne d’origine et les éléments du tableau.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 L’exemple suivant définit une chaîne contenant les caractères utilisés comme séparateurs dans une chaîne délimitée. Il appelle ensuite la <xref:System.String.ToCharArray%2A> méthode pour créer un tableau de caractères qui peut être passé à la <xref:System.String.Split%28System.Char%5B%5D%29> (méthode) pour séparer la chaîne délimitée dans ses sous-chaînes individuels.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position de départ d'une sous-chaîne dans cette instance.</param>
        <param name="length">Longueur de la sous-chaîne dans cette instance.</param>
        <summary>Copie les caractères d'une sous-chaîne spécifiée de cette instance vers un tableau de caractères Unicode.</summary>
        <returns>Tableau de caractères Unicode dont les éléments sont le nombre de caractères <paramref name="length" /> dans cette instance commençant à partir de la position de caractère <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie les caractères dans une partie d’une chaîne en tableau de caractères. Pour créer une chaîne à partir d’une plage de caractères dans un tableau de caractères, appelez le <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructeur.  
  
 Le `startIndex` paramètre est de base zéro. Autrement dit, l’index du premier caractère dans l’instance de chaîne est zéro.  
  
 Si `length` est égal à zéro, le tableau retourné est vide et a une longueur nulle. Si cette instance est `null` ou une chaîne vide (« »), le tableau retourné est vide et a une longueur nulle.  
  
 Pour créer un tableau d’octets qui contient les caractères encodés dans une partie d’une chaîne, instanciez approprié <xref:System.Text.Encoding> objet et appeler ses <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> (méthode). Voici quelques-unes des encodages standard disponibles dans le .NET Framework :  
  
|Encodage|Object|  
|--------------|------------|  
|non|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Pour plus d’informations, consultez [l’encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 L’exemple suivant convertit une sous-chaîne dans une chaîne en un tableau de caractères, puis énumère et affiche les éléments du tableau.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro.  -ou- <paramref name="startIndex" /> plus <paramref name="length" /> est supérieur à la longueur de cette instance.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une copie de cette chaîne convertie en minuscules.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une copie de cette chaîne convertie en minuscules.</summary>
        <returns>Chaîne en minuscules.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode prend en compte les règles de casse de la culture actuelle.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en minuscules.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 L’opération de casse qui résulte de l’appel du <xref:System.String.ToLower> méthode tient compte des conventions de casse de la culture actuelle. Si vous avez besoin de la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou une clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> méthodes. Cela produit le même résultat dans chaque culture (contrairement à la <xref:System.String.ToLower> méthode) et plus efficace.  
  
   
  
## Examples  
 L’exemple suivant convertit plusieurs chaînes de casse mixtes en minuscules.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [Best Practices for à l’aide de Strings](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de casse de chaîne qui substituent des valeurs par défaut et à la place appellent les méthodes qui requièrent des paramètres pour être explicitement spécifié. Pour convertir un caractère en minuscule à l’aide des conventions de casse de la culture actuelle, appelez la <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> avec une valeur de la surcharge de méthode <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> pour son <paramref name="culture" /> paramètre.</para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Objet qui fournit les règles de casse propres à la culture.</param>
        <summary>Retourne une copie de cette chaîne en minuscules, à l'aide des règles de casse de la culture spécifiée.</summary>
        <returns>Équivalent en minuscules de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Règles de casse de la culture spécifiée par le `culture` paramètre déterminent la manière dont la casse de la chaîne est modifiée.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en minuscules.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 Si vous passez le <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> méthode un <xref:System.Globalization.CultureInfo> autre que l’objet <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, l’opération de casse prend en considération les règles spécifiques à la culture. Si vous avez besoin de la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou une clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> (méthode). Cela produit le même résultat dans chaque culture et plus efficace.  
  
   
  
## Examples  
 L’exemple suivant convertit deux chaînes de caractères majuscules en minuscules à l’aide de cultures États-Unis et Turc-Turquie, puis compare les chaînes en minuscules. Les chaînes en majuscules sont identiques, sauf que pour chaque occurrence de l’Unicode LATIN lettre majuscule I dans une chaîne, la chaîne contient lettre majuscule de LATIN I avec point ci-dessus.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une copie de cet objet <see cref="T:System.String" /> converti en minuscules à l'aide des règles de casse de la culture indifférente.</summary>
        <returns>Équivalent en minuscules de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La culture dite indifférente représente une culture qui est indépendante de la culture. Il est associé à la langue anglaise, mais pas avec un pays ou une région. Pour plus d'informations, consultez la propriété <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Si votre application dépend de la casse d’une chaîne de la modification d’une façon prévisible n’est pas affectée par la culture actuelle, utilisez la <xref:System.String.ToLowerInvariant%2A> (méthode). Le <xref:System.String.ToLowerInvariant%2A> méthode est équivalente à `ToLower(CultureInfo.InvariantCulture)`. La méthode est recommandée lorsqu’une collection de chaînes doit apparaître dans un ordre prédictible dans un contrôle d’interface utilisateur.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en minuscules.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 Si vous avez besoin de la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou une clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> méthodes.  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de chaînes qui contient un mot unique dans plusieurs langues. Le <xref:System.String.ToLowerInvariant%2A> méthode est utilisée pour remplir les éléments d’un tableau parallèle avec la version de la casse de chaque mot. Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> méthode est utilisée pour trier le tableau sensible à la casse selon l’ordre des éléments dans le tableau en minuscule pour vous assurer que les éléments apparaissent dans le même ordre indépendamment du langage.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la valeur de cette instance en <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne cette instance de <see cref="T:System.String" /> ; aucune conversion n'est effectivement effectuée.</summary>
        <returns>Chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne simplement la chaîne actuelle est inchangée, il n’est pas nécessaire d’appeler directement. Il est généralement appelée implicitement dans une forme d’opération, comme le montre l’exemple composite.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.String.ToString%2A> (méthode). Notez que l’exemple n’appelle pas explicitement le <xref:System.String.ToString%2A> (méthode). Au lieu de cela, la méthode est appelée implicitement par le [mise en forme composite](~/docs/standard/base-types/composite-formatting.md) fonctionnalité.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Réservé) Objet fournissant des informations de mise en forme propres à la culture.</param>
        <summary>Retourne cette instance de <see cref="T:System.String" /> ; aucune conversion n'est effectivement effectuée.</summary>
        <returns>Chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` est réservé et ne participe actuellement pas à cette opération.  
  
 Cette méthode retourne simplement la chaîne actuelle est inchangée, il n’est pas nécessaire d’appeler directement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une copie de cette chaîne convertie en majuscules.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une copie de cette chaîne convertie en majuscules.</summary>
        <returns>Équivalent en majuscules de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise les règles de casse de la culture actuelle pour convertir chaque caractère dans l’instance actuelle en son équivalent en majuscule. Si un caractère n’a pas d’équivalent en majuscule, il est inclus inchangé dans la chaîne retournée.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en majuscules.  
  
 Le <xref:System.String.ToUpper%2A> méthode est souvent utilisée pour convertir une chaîne en majuscules afin qu’il peut être utilisé dans une comparaison respectant la casse. Une meilleure méthode pour effectuer la comparaison respectant la casse est d’appeler une méthode de comparaison de chaînes qui a un <xref:System.StringComparison> dont vous affectez la valeur de paramètre <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> pour obtenir une comparaison dépendante de la culture, non-respect de la casse.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 L’opération de casse qui résulte de l’appel du <xref:System.String.ToUpper> méthode tient compte des conventions de casse de la culture actuelle. Si vous avez besoin de la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou une clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> (méthode). Cela produit le même résultat dans chaque culture (contrairement à la <xref:System.String.ToUpper> méthode) et plus efficace.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.String.ToUpper%2A> méthode pour convertir une série de chaînes de caractères qui contiennent chaque caractère Latin de base, Supplément Latin-1 et Latin étendu-A jeux de caractères. Il affiche ensuite chaque chaîne dont le caractère majuscule est différent de son caractère minuscule.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [Best Practices for à l’aide de Strings](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de casse de chaîne qui substituent des valeurs par défaut et à la place appellent les méthodes qui requièrent des paramètres pour être explicitement spécifié. Pour convertir une chaîne en majuscules à l’aide des conventions de casse de la culture actuelle, appelez la <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> avec une valeur de la surcharge de méthode <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> pour son <paramref name="culture" /> paramètre.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Objet qui fournit les règles de casse propres à la culture.</param>
        <summary>Retourne une copie de cette chaîne convertie en majuscules à l'aide des règles de casse de la culture spécifiée.</summary>
        <returns>Équivalent en majuscules de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Règles de casse de la culture spécifiée par le `culture` paramètre déterminent la manière dont la casse d’une chaîne est modifiée.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en majuscules.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 Si vous passez le <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> méthode un <xref:System.Globalization.CultureInfo> autre que l’objet <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, l’opération de casse prend en considération les règles spécifiques à la culture. Si vous avez besoin de la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou une clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> (méthode). Cela produit le même résultat dans chaque culture et plus efficace.  
  
   
  
## Examples  
 L’exemple suivant convertit une chaîne de caractères minuscules en deux chaînes de caractères en majuscules à l’aide de cultures États-Unis et Turc-Turquie, puis compare les chaînes en majuscules. Les chaînes en majuscules sont identiques, sauf que pour chaque occurrence de l’Unicode LATIN lettre majuscule I dans une chaîne, la chaîne contient lettre majuscule de LATIN I avec point ci-dessus.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une copie de cet objet <see cref="T:System.String" /> converti en majuscules à l'aide des règles de casse de la culture indifférente.</summary>
        <returns>Équivalent en majuscules de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La culture dite indifférente représente une culture qui est indépendante de la culture. Il est associé à la langue anglaise, mais pas avec un pays ou une région. Pour plus d'informations, consultez la propriété <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Si votre application dépend de la casse d’une chaîne de la modification d’une façon prévisible n’est pas affectée par la culture actuelle, utilisez la <xref:System.String.ToUpperInvariant%2A> (méthode). Le <xref:System.String.ToUpperInvariant%2A> méthode est équivalente à `ToUpper(CultureInfo.InvariantCulture)`. La méthode est recommandée lorsqu’une collection de chaînes doit apparaître dans un ordre prédictible dans un contrôle d’interface utilisateur.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en majuscules.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 Si vous avez besoin de la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou une clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> méthodes.  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de chaînes qui contient un mot unique dans plusieurs langues. Le <xref:System.String.ToUpperInvariant%2A> méthode est utilisée pour remplir les éléments d’un tableau parallèle avec la version de la casse de chaque mot. Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> méthode est utilisée pour trier le tableau sensible à la casse selon l’ordre des éléments dans le tableau en majuscule pour vérifier que les éléments s’affichent dans le même ordre indépendamment du langage.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne dans laquelle toutes les occurrences situées au début et à la fin d'un jeu de caractères spécifiés dans l'objet <see cref="T:System.String" /> actuel sont supprimées.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les espaces blancs de début ou de fin de chaîne de l'objet <see cref="T:System.String" /> actuel.</summary>
        <returns>Chaîne restante après la suppression de tous les espaces blancs de début et de fin de la chaîne actuelle. Si aucun caractère ne peut être tronqué dans l'instance active, la méthode retourne l'instance active inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.Trim%2A> méthode supprime de la chaîne actuelle, tous les caractères d’espace blanc et de fin. Chaque opération de suppression de début et de fin s’arrête lorsqu’un caractère autre qu’un espace blanc est rencontré. Par exemple, si la chaîne actuelle est « abc xyz », la <xref:System.String.Trim%2A> méthode retourne « abc xyz ». Pour supprimer les caractères d’espace blanc entre les mots dans une chaîne, utilisez un [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Si le <xref:System.String.Trim%2A> méthode supprime tous les caractères à partir de l’instance actuelle, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les caractères espace blanc de début et de fin trouvés dans l’instance actuelle sont supprimés.  
  
 Si la chaîne actuelle est égale à <xref:System.String.Empty> ou tous les caractères dans l’instance actuelle sont des espaces blancs, la méthode retourne <xref:System.String.Empty>.  
  
 Espaces blancs sont définis par la norme Unicode. Le <xref:System.String.Trim> méthode supprime tous les caractères de début et de fin qui produisent une valeur de retour de `true` lorsqu’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.String.Trim?displayProperty=nameWithType> méthode pour supprimer tout espace blanc supplémentaire dans des chaînes entrées par l’utilisateur avant de les concaténer.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures conservent une liste interne des blancs que cette méthode supprime. En commençant par la [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)], la méthode supprime tous les caractères d’espaces blancs Unicode (autrement dit, les caractères qui produisent une <see langword="true" /> valeur de retour lorsqu’ils sont passés à la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> méthode). Grâce à cette modification, le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures, supprime deux caractères, ZERO WIDTH SPACE (U + 200 b) et espace insécable de largeur zéro (U + FEFF), qui le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)] et ne supprime pas les versions ultérieures. En outre, le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures ne les supprime trois caractères d’espaces blancs Unicode : séparateur de voyelle en MONGOL (U + 180E), espace insécable étroite (U + 202F) et espace moyenne mathématique (U + 205F).</para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tableau de caractères Unicode à supprimer, ou <see langword="null" />.</param>
        <summary>Supprime, de l'objet <see cref="T:System.String" /> actuel, toutes les occurrences situées au début et à la fin d'un jeu de caractères spécifiés dans un tableau.</summary>
        <returns>Chaîne qui reste après la suppression de toutes les occurrences des caractères contenus dans le paramètre <paramref name="trimChars" /> du début et de la fin de la chaîne actuelle. Si <paramref name="trimChars" /> est <see langword="null" /> ou est un tableau vide, les espaces blancs sont plutôt supprimés. Si aucun caractère ne peut être tronqué dans l'instance active, la méthode retourne l'instance active inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.Trim%2A> méthode supprime de la chaîne actuelle, tous les caractères de début et de fin qui se trouvent dans le `trimChars` paramètre. Chacun de début et de fin trim opération s’arrête lorsqu’un caractère qui n’est pas `trimChars` est rencontrée. Par exemple, si la chaîne actuelle est « 123abc456xyz789 » et `trimChars` contient les chiffres à partir de « 1 » à « 9 », le <xref:System.String.Trim%2A> méthode retourne « abc456xyz ».  
  
> [!NOTE]
>  Si le <xref:System.String.Trim%2A> méthode supprime tous les caractères à partir de l’instance actuelle, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les premiers et derniers `trimChars` caractères ont été trouvés dans l’instance actuelle sont supprimés.  
  
 Si la chaîne actuelle est égale à <xref:System.String.Empty> ou tous les caractères dans l’instance actuelle sont des caractères dans le `trimChars` de tableau, la méthode retourne <xref:System.String.Empty>.  
  
 Si `trimChars` est `null` ou un tableau vide, cette méthode supprime tous les caractères de début ou de fin qui entraînent le retour de la méthode `true` lorsqu’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode),  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> méthode pour supprimer l’espace, astérisque (*) et des caractères apostrophe (') à partir d’une chaîne.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures conserve une liste interne d’espaces blancs que cette méthode supprime si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide. En commençant par la [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)], si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide, la méthode supprime tous les caractères d’espaces blancs Unicode (autrement dit, les caractères qui produisent une <see langword="true" /> valeur de retour lorsqu’ils sont passés à la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> (méthode)). Grâce à cette modification, le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures, supprime deux caractères, ZERO WIDTH SPACE (U + 200 b) et espace insécable de largeur zéro (U + FEFF), qui le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)] et ne supprime pas les versions ultérieures. En outre, le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures ne les supprime trois caractères d’espaces blancs Unicode : séparateur de voyelle en MONGOL (U + 180E), espace insécable étroite (U + 202F) et espace moyenne mathématique (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tableau de caractères Unicode à supprimer, ou <see langword="null" />.</param>
        <summary>Supprime, de l'objet <see cref="T:System.String" /> actuel, toutes les occurrences situées à la fin d'un jeu de caractères spécifiés dans un tableau.</summary>
        <returns>Chaîne qui reste après la suppression de toutes les occurrences des caractères contenus dans le paramètre <paramref name="trimChars" /> de la fin de la chaîne actuelle. Si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide, ce sont les espaces blancs Unicode qui sont supprimés. Si aucun caractère ne peut être tronqué dans l'instance active, la méthode retourne l'instance active inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.TrimEnd%2A> méthode supprime de la chaîne actuelle, tous les caractères de fin qui se trouvent dans le `trimChars` paramètre. L’opération de suppression s’arrête quand le premier caractère qui n’est pas `trimChars` est rencontré à la fin de la chaîne. Par exemple, si la chaîne actuelle est « 123abc456xyz789 » et `trimChars` contient les chiffres à partir de « 1 » à « 9 », le <xref:System.String.TrimEnd%2A> méthode retourne « 123abc456xyz ».  
  
> [!NOTE]
>  Si le <xref:System.String.TrimEnd%2A> méthode supprime tous les caractères à partir de l’instance actuelle, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les caractères trouvés dans `trimChars` sont supprimés de la chaîne actuelle.  
  
   
  
## Examples  
 L’exemple suivant montre comment vous pouvez utiliser la <xref:System.String.TrimEnd%28System.Char%5B%5D%29> méthode pour supprimer un espace blanc ou les marques de ponctuation à la fin d’une chaîne.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures conserve une liste interne d’espaces blancs que cette méthode supprime si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide. En commençant par la [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)], si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide, la méthode supprime tous les caractères d’espaces blancs Unicode (autrement dit, les caractères qui produisent une <see langword="true" /> valeur de retour lorsqu’ils sont passés à la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> (méthode)). Grâce à cette modification, le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures, supprime deux caractères, ZERO WIDTH SPACE (U + 200 b) et espace insécable de largeur zéro (U + FEFF), qui le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)] et ne supprime pas les versions ultérieures. En outre, le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures ne les supprime trois caractères d’espaces blancs Unicode : séparateur de voyelle en MONGOL (U + 180E), espace insécable étroite (U + 202F) et espace moyenne mathématique (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tableau de caractères Unicode à supprimer, ou <see langword="null" />.</param>
        <summary>Supprime, de l'objet <see cref="T:System.String" /> actuel, toutes les occurrences situées au début d'un jeu de caractères spécifiés dans un tableau.</summary>
        <returns>Chaîne qui reste après la suppression de toutes les occurrences des caractères contenus dans le paramètre <paramref name="trimChars" /> du début de la chaîne actuelle. Si <paramref name="trimChars" /> est <see langword="null" /> ou est un tableau vide, les espaces blancs sont plutôt supprimés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.TrimStart%2A> méthode supprime de la chaîne actuelle, tous les caractères de début qui se trouvent dans le `trimChars` paramètre. L’opération de suppression s’arrête lorsqu’un caractère qui n’est pas `trimChars` est rencontrée. Par exemple, si la chaîne actuelle est « 123abc456xyz789 » et `trimChars` contient les chiffres à partir de « 1 » à « 9 », le <xref:System.String.TrimStart%2A> méthode retourne « abc456xyz789 ».  
  
> [!NOTE]
>  Si le <xref:System.String.TrimStart%2A> méthode supprime tous les caractères à partir de l’instance actuelle, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les caractères d’espace blanc au début trouvés dans l’instance actuelle sont supprimés.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.String.TrimStart%2A> méthode pour supprimer un espace blanc et les caractères de commentaire des lignes de code source. Le `StripComments` méthode encapsule un appel à <xref:System.String.TrimStart%2A> et lui passe un tableau de caractères qui contient un espace et le caractère de commentaire, qui est une apostrophe (') en Visual Basic et une barre oblique (/) en c#. Le <xref:System.String.TrimStart%2A> méthode est également appelée pour supprimer des espaces blancs lors de l’évaluation si une chaîne est un commentaire.  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 L’exemple suivant illustre un appel à la méthode `StripComments`.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures conserve une liste interne d’espaces blancs que cette méthode supprime si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide. En commençant par la [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)], si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide, la méthode supprime tous les caractères d’espaces blancs Unicode (autrement dit, les caractères qui produisent une <see langword="true" /> valeur de retour lorsqu’ils sont passés à la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> (méthode)). Grâce à cette modification, le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures, supprime deux caractères, ZERO WIDTH SPACE (U + 200 b) et espace insécable de largeur zéro (U + FEFF), qui le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v40_short](~/Includes/NET-V40-short-MD.MD)] et ne supprime pas les versions ultérieures. En outre, le <see cref="M:System.String.Trim" /> méthode dans le [ ! Include[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] et les versions antérieures ne les supprime trois caractères d’espaces blancs Unicode : séparateur de voyelle en MONGOL (U + 180E), espace insécable étroite (U + 202F) et espace moyenne mathématique (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>