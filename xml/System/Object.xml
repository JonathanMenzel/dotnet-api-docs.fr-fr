<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="15f433904f15b52fc408db54f7fd65e20a71b739" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174247" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Prend en charge toutes les classes de la hiérarchie des classes du .NET Framework et fournit des services de bas niveau à des classes dérivées. Il s'agit de la classe de base fondamentale parmi toutes les classes du .NET Framework. Elle constitue la racine de la hiérarchie des types.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Langues ne nécessitent généralement pas d’une classe déclare l’héritage de <xref:System.Object> , car l’héritage est implicite.  
  
 Étant donné que toutes les classes dans le .NET Framework sont dérivées de <xref:System.Object>, toutes les méthodes définies dans la <xref:System.Object> classe n’est disponible dans tous les objets dans le système. Classes dérivées peuvent et substituer certaines de ces méthodes, notamment :  
  
-   <xref:System.Object.Equals%2A> -Prend en charge les comparaisons entre des objets.  
  
-   <xref:System.Object.Finalize%2A> -Effectue des opérations de nettoyage avant qu’un objet est automatiquement récupéré.  
  
-   <xref:System.Object.GetHashCode%2A> -Génère un nombre correspondant à la valeur de l’objet pour prendre en charge l’utilisation d’une table de hachage.  
  
-   <xref:System.Object.ToString%2A> -Fabrique une chaîne de texte explicite qui décrit une instance de la classe.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Si vous concevez une classe, comme une collection, qui doit gérer tout type d’objet, vous pouvez créer des membres de classe qui acceptent des instances de la <xref:System.Object> classe. Toutefois, le processus de conversion boxing et unboxing d’un type a un coût de performances. Si vous savez que votre nouvelle classe devra souvent gérer certains types valeur, vous pouvez utiliser une des deux solutions suivantes pour réduire le coût de conversion boxing.  
  
-   Créer une méthode générale qui accepte un <xref:System.Object> type et un ensemble de surcharges de méthode spécifique au type qui acceptent chaque type de valeur que votre classe à gérer souvent. S’il existe une méthode spécifique au type qui accepte le type de paramètre appelant, aucun boxing se produit et la méthode spécifique au type est appelée. S’il n’existe aucun argument de la méthode qui correspond au type de paramètre appelant, le paramètre est convertie (boxed) et la méthode générale est appelée.  
  
-   Concevoir votre type et ses membres pour utiliser des génériques. Le common language runtime crée un type générique fermé lorsque vous créez une instance de votre classe et que vous spécifiez un argument de type générique. La méthode générique est spécifique au type et peut être appelée sans avoir à évaluer le paramètre appelant.  
  
 Bien qu’il est parfois nécessaire de développer des classes à usage général qui acceptent et retournent <xref:System.Object> types, vous pouvez améliorer les performances en fournissant également une classe spécifique au type pour gérer un type fréquemment utilisé. Par exemple, en fournissant une classe qui est spécifique à la définition et l’obtention des valeurs booléennes élimine le coût de conversion boxing et unboxing des valeurs booléennes.  
  
   
  
## Examples  
 L’exemple suivant définit un type Point dérivé le <xref:System.Object> classe et substitue un grand nombre de méthodes virtuelles de la <xref:System.Object> classe. En outre, l’exemple montre comment appeler la plupart des statiques et les méthodes de l’instance du <xref:System.Object> classe.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statique public (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe. Les membres d’instance ne sont pas garantis être thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est appelé par les constructeurs dans les classes dérivées, mais il peut également être utilisé pour créer directement une instance de la <xref:System.Object> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si deux instances d'objets sont égales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer à l'objet actuel.</param>
        <summary>Détermine si l'objet spécifié est identique à l'objet actuel.</summary>
        <returns>
          <see langword="true" /> si l'objet spécifié est égal à l'objet actuel ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de comparaison entre l’instance actuelle et la `obj` paramètre varie selon que l’instance actuelle est un type référence ou un type valeur.  
  
-   Si l’instance actuelle est un type référence, le <xref:System.Object.Equals%28System.Object%29> méthode teste l’égalité de référence et un appel à la <xref:System.Object.Equals%28System.Object%29> méthode est équivalente à un appel à la <xref:System.Object.ReferenceEquals%2A> (méthode). L’égalité des références signifie que les variables d’objet qui sont comparées font référence au même objet. L’exemple suivant illustre le résultat de ce type de comparaison. Il définit un `Person` (classe), qui est un type référence, et appelle le `Person` constructeur de classe à instancier deux nouveaux `Person` objets, `person1a` et `person2`, qui ont la même valeur. Il affecte également `person1a` à une autre variable objet, `person1b`. Comme la sortie de l’exemple, `person1a` et `person1b` sont égales, car elles référencent le même objet. Toutefois, `person1a` et `person2` ne sont pas égales, même si elles ont la même valeur.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Si l’instance actuelle est un type valeur, le <xref:System.Object.Equals%28System.Object%29> méthode teste l’égalité de valeur. L’égalité des valeurs signifie que les éléments suivants :  
  
    -   Les deux objets sont du même type. Comme le montre l’exemple suivant, un <xref:System.Byte> objet qui a la valeur 12 n’est pas égale un <xref:System.Int32> objet qui a une valeur de 12, car les deux objets ont des types différents d’exécution.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Les valeurs des champs publics et privés des deux objets sont égales. L’exemple suivant teste l’égalité des valeurs. Il définit un `Person` structure, qui est un type valeur, et appelle le `Person` constructeur de classe à instancier deux nouveaux `Person` objets, `person1` et `person2`, qui ont la même valeur. Comme le montre la sortie de l’exemple, bien que les deux variables objets font référence à des objets différents, `person1` et `person2` sont égaux, car ils ont la même valeur pour privé `personName` champ.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Étant donné que la <xref:System.Object> est la classe de base pour tous les types dans le .NET Framework, la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode fournit la comparaison d’égalité par défaut pour tous les autres types. Toutefois, les types souvent remplacer le <xref:System.Object.Equals%2A> méthode pour implémenter l’égalité des valeurs. Pour plus d’informations, consultez les Notes pour les appelants et les Notes pour les sections de l’attention des héritiers.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notes pour le [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Lorsque vous appelez le <xref:System.Object.Equals%28System.Object%29> la surcharge de méthode sur une classe dans le [!INCLUDE[wrt](~/includes/wrt-md.md)], il fournit le comportement par défaut pour les classes qui ne remplacent pas <xref:System.Object.Equals%28System.Object%29>. Cela fait partie de la prise en charge le .NET Framework fournit pour les [!INCLUDE[wrt](~/includes/wrt-md.md)] (consultez [.NET Framework prend en charge pour les applications du Windows Store et Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes de la [!INCLUDE[wrt](~/includes/wrt-md.md)] n’héritent pas <xref:System.Object>et n’implémentent pas actuellement un <xref:System.Object.Equals%28System.Object%29> (méthode). Toutefois, ils semblent avoir <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, et <xref:System.Object.GetHashCode%2A> méthodes lorsque vous les utilisez dans votre code c# ou Visual Basic et le .NET Framework fournit le comportement par défaut pour ces méthodes.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] les classes qui sont écrits en c# ou Visual Basic peuvent substituer la <xref:System.Object.Equals%28System.Object%29> surcharge de méthode.  
  
## <a name="notes-for-callers"></a>Remarques pour les appelants  
 Les classes dérivées remplacer fréquemment le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode pour implémenter l’égalité des valeurs. En outre, les types fournissent aussi fréquemment une surcharge supplémentaire fortement typée pour le `Equals` méthode, généralement en implémentant le <xref:System.IEquatable%601> interface. Lorsque vous appelez le `Equals` méthode pour tester l’égalité, vous devez savoir si l’instance actuelle se substitue à <xref:System.Object.Equals%2A?displayProperty=nameWithType> et comprendre comment un appel particulier à un `Equals` méthode est résolue. Sinon, vous effectuer un test d’égalité qui est différente de ceux que vous aviez prévus, et la méthode peut retourner une valeur inattendue.  
  
 L'exemple suivant illustre cette situation. Il instancie trois <xref:System.Text.StringBuilder> objets avec des chaînes identiques, puis appelle quatre `Equals` méthodes. La première méthode d’appel retourne `true`et le retour de trois autres `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 Dans le premier cas, fortement typé <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> surcharge de méthode qui teste l’égalité des valeurs, est appelée. Étant donné que les chaînes attribué aux deux <xref:System.Text.StringBuilder> objets sont égaux, la méthode retourne `true`. Toutefois, <xref:System.Text.StringBuilder> ne remplace pas <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. Pour cette raison, lorsque le <xref:System.Text.StringBuilder> objet est converti en un <xref:System.Object>, lorsque un <xref:System.Text.StringBuilder> instance est assignée à une variable de type <xref:System.Object>et à quel moment le <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> méthode est passée de deux <xref:System.Text.StringBuilder> objets, la valeur par défaut <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>méthode est appelée. Étant donné que <xref:System.Text.StringBuilder> est un type référence, cela équivaut à passer les deux <xref:System.Text.StringBuilder> des objets sur le <xref:System.Object.ReferenceEquals%2A> (méthode). Bien que les trois <xref:System.Text.StringBuilder> objets contiennent des chaînes identiques, ils font référence à trois objets distincts. Par conséquent, ces trois appels de méthode retour `false`.  
  
 Vous pouvez comparer l’objet actuel à un autre objet pour égalité des références en appelant le <xref:System.Object.ReferenceEquals%2A> (méthode). En Visual Basic, vous pouvez également utiliser le `is` (mot clé) (par exemple, `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Remarques pour les héritiers de  
 Lorsque vous définissez votre propre type, ce type hérite des fonctionnalités définies par le `Equals` méthode de son type de base. Le tableau suivant répertorie l’implémentation par défaut de la `Equals` méthode pour les principales catégories de types dans le .NET Framework.  
  
|Catégorie de type|Égalité défini par|Commentaires|  
|-------------------|-------------------------|--------------|  
|Classe dérivée directement à partir de <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Égalité de référence ; équivalent à l’appel <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Structure|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Égalité des valeurs ; une comparaison octet par octet directe ou comparaison de champ par champ à l’aide de la réflexion.|  
|Énumération|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Valeurs doivent avoir le même type d’énumération et la même valeur sous-jacente.|  
|délégué|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Les délégués doivent avoir le même type avec les listes d’appel identiques.|  
|Interface|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Égalité des références.|  
  
 Pour un type valeur, vous devez toujours remplacer <xref:System.Object.Equals%2A>, car les tests d’égalité qui reposent sur la réflexion offrent des performances médiocres. Vous pouvez également substituer l’implémentation par défaut de <xref:System.Object.Equals%2A> pour les types de référence pour tester l’égalité des valeurs au lieu de l’égalité des références et pour définir la signification précise de l’égalité des valeurs. De telles implémentations de <xref:System.Object.Equals%2A> retourner `true` si les deux objets ont la même valeur, même s’ils ne sont pas la même instance. L’implémenteur du type décide ce qui constitue la valeur d’un objet, mais il est généralement tout ou partie des données stockées dans les variables d’instance de l’objet. Par exemple, la valeur d’un <xref:System.String> objet est basé sur les caractères de la chaîne ; le <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> substitutions de méthode le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> retour de méthode `true` pour les deux instances contiennent les mêmes caractères dans le même ordre de chaîne.  
  
 L’exemple suivant montre comment substituer la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode pour tester l’égalité des valeurs. Il remplace le <xref:System.Object.Equals%2A> méthode pour la `Person` classe. Si `Person` accepté son implémentation de la classe de base de l’égalité, deux `Person` objets serait égales uniquement si elles référencé un objet unique. Toutefois, dans ce cas, deux `Person` objets sont égales si elles ont la même valeur pour le `Person.Id` propriété.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Outre l’écrasement <xref:System.Object.Equals%2A>, vous pouvez implémenter la <xref:System.IEquatable%601> interface afin de fournir un test fortement typé pour l’égalité.  
  
 Les instructions suivantes doivent être remplies pour toutes les implémentations de la <xref:System.Object.Equals%28System.Object%29> (méthode). Dans la liste, `x`, `y`, et `z` représentent des références d’objet qui ne sont pas **null**.  
  
-   `x.Equals(x)` Retourne `true`, sauf dans les scénarios qui impliquent des types à virgule flottante. Voir ISO/IEC/IEEE 60559:2011, informatique--microprocesseur systèmes--arithmétique à virgule flottante.  
  
-   `x.Equals(y)` Retourne la même valeur que `y.Equals(x)`.  
  
-   `x.Equals(y)` Retourne `true` si les deux `x` et `y` sont `NaN`.  
  
-   Si `(x.Equals(y) && y.Equals(z))` retourne `true`, puis `x.Equals(z)` retourne `true`.  
  
-   Les appels successifs à `x.Equals(y)` retournent la même valeur tant que les objets référencés par `x` et `y` ne sont pas modifiées.  
  
-   `x.Equals(null)` retourne `false`.  
  
 Les implémentations de <xref:System.Object.Equals%2A> ne doit pas lever d’exceptions ; ils doivent toujours retourner une valeur. Par exemple, si `obj` est `null`, le <xref:System.Object.Equals%2A> méthode doit retourner `false` au lieu de lever une <xref:System.ArgumentNullException>.  
  
 Suivez ces recommandations lors de la substitution <xref:System.Object.Equals%28System.Object%29>:  
  
-   Les types qui implémentent <xref:System.IComparable> doit remplacer <xref:System.Object.Equals%28System.Object%29>.  
  
-   Types qui substituent <xref:System.Object.Equals%28System.Object%29> doit également substituer <xref:System.Object.GetHashCode%2A>; sinon, les tables de hachage peut ne pas fonctionneront correctement.  
  
-   Vous devez envisager d’implémenter le <xref:System.IEquatable%601> interface pour prendre en charge fortement typé vérifie l’égalité. Votre <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implémentation doit retourner des résultats cohérents avec <xref:System.Object.Equals%2A>.  
  
-   Si votre langage de programmation prend en charge la surcharge d’opérateur et si vous surchargez l’opérateur d’égalité pour un type donné, vous devez également substituer la <xref:System.Object.Equals%28System.Object%29> méthode pour retourner le même résultat que l’opérateur d’égalité. Cela permet de garantir que code de bibliothèque de classe qui utilise <xref:System.Object.Equals%2A> (tel que <xref:System.Collections.ArrayList> et <xref:System.Collections.Hashtable>) se comporte de manière cohérente avec le mode d’utilisation de l’opérateur d’égalité par le code d’application.  
  
### <a name="guidelines-for-reference-types"></a>Recommandations pour les Types référence  
 Les directives suivantes s’appliquent à la substitution de <xref:System.Object.Equals%28System.Object%29> pour un type référence :  
  
-   Pensez à substituer <xref:System.Object.Equals%2A> si la sémantique de type est basée sur le fait que le type représente une ou plusieurs valeurs.  
  
-   La plupart des types référence ne doivent pas surcharger l’opérateur d’égalité, même s’ils substituent <xref:System.Object.Equals%2A>. Toutefois, si vous implémentez un type référence qui doit avoir une sémantique de valeur, par exemple un type nombre complexe, vous devez substituer l’opérateur d’égalité.  
  
-   Vous ne devez pas substituer <xref:System.Object.Equals%2A> sur un type référence mutable. C’est parce que la substitution de <xref:System.Object.Equals%2A> requiert également substituer la <xref:System.Object.GetHashCode%2A> méthode, comme indiqué dans la section précédente. Cela signifie que le code de hachage d’une instance d’un type référence mutable peut changer pendant sa durée de vie, ce qui peut entraîner l’objet à être perdues dans une table de hachage.  
  
### <a name="guidelines-for-value-types"></a>Recommandations pour les Types valeur  
 Les directives suivantes s’appliquent à la substitution de <xref:System.Object.Equals%28System.Object%29> pour un type valeur :  
  
-   Si vous définissez un type valeur qui inclut un ou plusieurs champs dont les valeurs sont des types référence, vous devez substituer <xref:System.Object.Equals%28System.Object%29>. Le <xref:System.Object.Equals%28System.Object%29> implémentation fournie par <xref:System.ValueType> effectue une comparaison octet par octet pour les types de valeur dont les champs sont tous les types valeur, mais il utilise la réflexion pour effectuer une comparaison de champ par champ de types de valeur dont les champs sont des types référence.  
  
-   Si vous substituez <xref:System.Object.Equals%2A> et votre langage de développement prend en charge la surcharge d’opérateur, vous devez surcharger l’opérateur d’égalité.  
  
-   Vous devez implémenter la <xref:System.IEquatable%601> interface. Fortement typées <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> méthode évite de boxing le `obj` argument.  
  
   
  
## Examples  
 L’exemple suivant montre un `Point` classe qui remplace le <xref:System.Object.Equals%2A> méthode pour fournir l’égalité des valeurs et un `Point3D` classe qui est dérivée de `Point`. Étant donné que `Point` substitue <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> pour tester l’égalité des valeurs, le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode n’est pas appelée. Toutefois, `Point3D.Equals` appelle `Point.Equals` car `Point` implémente <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> d’une manière qui fournit l’égalité des valeurs.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 Le `Point.Equals` méthode vérifie pour vous assurer que le `obj` argument n’est pas **null** et qu’elle fait référence à une instance du même type que cet objet. Si une des vérifications échoue, la méthode retourne `false`.  
  
 Le `Point.Equals` les appels de méthode le <xref:System.Object.GetType%2A> méthode pour déterminer si les types d’exécution des deux objets sont identiques. Si la méthode a utilisé une vérification sous la forme `obj is Point` en c# ou `TryCast(obj, Point)` en Visual Basic, elle retourne `true` dans les cas où `obj` est une instance d’une classe dérivée de `Point`, même si `obj` et en cours instance ne sont pas du même type de Runtime. Après avoir vérifié que les deux objets sont du même type, la méthode effectue un cast `obj` au type `Point` et retourne le résultat de la comparaison de champs d’instance des deux objets.  
  
 Dans `Point3D.Equals`, héritées `Point.Equals` (méthode), qui remplace <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, est appelée avant toute autre action. Étant donné que `Point3D` est une classe sealed (`NotInheritable` en Visual Basic), une vérification sous la forme `obj is Point` en c# ou `TryCast(obj, Point)` en Visual Basic est suffisante pour vous assurer que `obj` est un `Point3D` objet. S’il s’agit un `Point3D` de l’objet, elle est convertie en un `Point` de l’objet et passé à l’implémentation de classe de base de <xref:System.Object.Equals%2A>. Uniquement lorsque hérité `Point.Equals` méthode retourne `true` est la méthode de comparaison du `z` introduites dans la classe dérivée de champs d’instance.  
  
 L’exemple suivant définit un `Rectangle` classe qui implémente en interne un rectangle sous forme de deux `Point` objets. Le `Rectangle` classe également remplacements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> pour fournir l’égalité des valeurs.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Certains langages tels que c# et Visual Basic prennent en charge la surcharge d’opérateur. Quand un type surcharge l’opérateur d’égalité, il doit également substituer la <xref:System.Object.Equals%28System.Object%29> méthode pour fournir les mêmes fonctionnalités. Cela est généralement accomplie en écrivant la <xref:System.Object.Equals%28System.Object%29> méthode en termes de l’opérateur d’égalité surchargé, comme dans l’exemple suivant.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Étant donné que `Complex` est un type valeur, il ne peut pas être dérivé.  Par conséquent, le remplacement <xref:System.Object.Equals%28System.Object%29> méthode pas nécessaire d’appeler <xref:System.Object.GetType%2A> pour déterminer la durée d’exécution précise de type de chaque objet, mais peut plutôt utiliser la `is` opérateur en c# ou le `TypeOf` opérateur en Visual Basic pour vérifier le type de la `obj` paramètre.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Premier objet à comparer.</param>
        <param name="objB">Deuxième objet à comparer.</param>
        <summary>Détermine si les instances d'objet spécifiées sont considérées comme égales.</summary>
        <returns>
          <see langword="true" /> si les objets sont considérés comme identiques ; sinon, <see langword="false" />. Si <paramref name="objA" /> et <paramref name="objB" /> ont tous deux la valeur **null**, la méthode retourne <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode statique <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> méthode indique si deux objets, `objA` et `objB`, sont égales. Il vous permet également de tester les objets dont la valeur est **null** d’égalité. Il compare `objA` et `objB` pour l’égalité comme suit :  
  
-   Il détermine si les deux objets représentent la même référence d’objet. Si, dans ce cas, la méthode retourne `true`. Ce test revient à appeler le <xref:System.Object.ReferenceEquals%2A> (méthode). En outre, si les deux `objA` et `objB` sont **null**, la méthode retourne `true`.  
  
-   Il détermine si soit `objA` ou `objB` est **null**. Si, par conséquent, elle retourne `false`.  
  
-   Si les deux objets ne représentent pas la même référence d’objet, et aucun n’est **null**, il appelle `objA`.`Equals` (`objB`) et retourne le résultat. Cela signifie que si `objA` remplace la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode, ce remplacement est appelé.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> (méthode) et le compare avec le <xref:System.Object.ReferenceEquals%2A> (méthode).  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Autorise un objet à tenter de libérer des ressources et à exécuter d'autres opérations de nettoyage avant qu'il ne soit récupéré par une opération garbage collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Object.Finalize%2A> méthode est utilisée pour effectuer des opérations de nettoyage sur les ressources non managées détenues par l’objet actuel avant la destruction de l’objet. La méthode est protégée et par conséquent, est accessible uniquement par le biais de cette classe ou une classe dérivée.  
  
 Dans cette section :  
  
-   [Fonctionne de la finalisation](#How)  
  
-   [Notes pour les implémenteurs](#Notes)  
  
-   [L’alternative de SafeHandle](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Fonctionne de la finalisation  
 Le <xref:System.Object> classe ne fournit pas d’implémentation pour la <xref:System.Object.Finalize%2A> (méthode) et que le garbage collector ne marque pas les types dérivés de <xref:System.Object> pour la finalisation, sauf si elles remplacent les <xref:System.Object.Finalize%2A> (méthode).  
  
 Si un type remplace le <xref:System.Object.Finalize%2A> (méthode), le garbage collector ajoute une entrée pour chaque instance du type à une structure interne appelée la file d’attente de finalisation. La file d’attente de finalisation contient des entrées pour tous les objets dans le tas managé dont le code de la finalisation doit s’exécuter avant que le garbage collector puisse récupérer la mémoire. Le garbage collector appelle ensuite la <xref:System.Object.Finalize%2A> méthode automatiquement dans les conditions suivantes :  
  
-   Une fois que le garbage collector a découvert qu’un objet est inaccessible, à moins que l’objet a été dispensé de finalisation par un appel à la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).  
  
-   Pendant l’arrêt d’un domaine d’application, sauf si l’objet est exempté de la finalisation. Lors de l’arrêt, même les objets qui sont encore accessibles finalisées.  
  
 <xref:System.Object.Finalize%2A> est automatiquement appelé qu’une seule fois sur une instance donnée, sauf si l’objet est réinscrit à l’aide d’un mécanisme comme <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> et <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode) n’a pas été appelée par la suite.  
  
 <xref:System.Object.Finalize%2A> opérations présentent les limitations suivantes :  
  
-   L’heure exacte à laquelle s’exécute le finaliseur n’est pas défini. Pour garantir la libération des ressources pour implémenter des instances de votre classe, un `Close` méthode ou fournissez un <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> mise en œuvre.  
  
-   Les finaliseurs de deux objets ne sont pas garanties pour s’exécuter dans un ordre spécifique, même si un objet fait référence à l’autre. Autrement dit, si l’objet a une référence à l’objet B, et possèdent des finaliseurs, l’objet B peut avoir déjà été finalisation lorsque le finaliseur de l’objet A démarre.  
  
-   Le thread sur lequel s’exécute le finaliseur n’est pas spécifié.  
  
 Le <xref:System.Object.Finalize%2A> méthode ne peut pas s’exécuter jusqu'à son achèvement, ou s’exécute ne peut-être pas du tout dans les circonstances exceptionnelles suivantes :  
  
-   Si un autre finaliseur se bloque indéfiniment (augmentent dans une boucle infinie, essaie d’obtenir un verrou, il peut obtenir jamais et ainsi de suite). Étant donné que le runtime tente d’exécuter des finaliseurs jusqu'à son achèvement, les autres finaliseurs ne pas être appelés si un finaliseur se bloque indéfiniment.  
  
-   Si le processus se termine sans donner au runtime une chance de les nettoyer. Dans ce cas, la première notification d’arrêt du processus du runtime est une notification DLL_PROCESS_DETACH.  
  
 Le runtime continue à finaliser des objets pendant l’arrêt aussi longtemps que le nombre d’objets finalisables diminue.  
  
 Si <xref:System.Object.Finalize%2A> ou une substitution de <xref:System.Object.Finalize%2A> lève une exception et que le runtime n’est pas hébergée par une application qui substitue la stratégie par défaut, le runtime termine le processus et aucun active `try` / `finally` blocs ou les finaliseurs sont exécutés. Ce comportement garantit l’intégrité du processus si le finaliseur ne peut pas libérer ou détruire des ressources.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Substitution de la méthode Finalize 
 Vous devez substituer <xref:System.Object.Finalize%2A> pour une classe qui utilise des ressources non managées, telles que les handles de fichiers ou des connexions de base de données qui doivent être lancées lorsque l’objet managé qui les utilise est ignoré pendant le garbage collection. Vous ne devez pas implémenter un <xref:System.Object.Finalize%2A> méthode pour les objets managés, car le garbage collector libère automatiquement les ressources managées.  
  
> [!IMPORTANT]
>  Si un <xref:System.Runtime.InteropServices.SafeHandle> objet n’est disponible qui encapsule votre ressource non managée, l’alternative recommandée consiste à implémenter le modèle de suppression avec un handle sécurisé et ne pas substituer <xref:System.Object.Finalize%2A>. Pour plus d’informations, consultez [alternative de SafeHandle le](#SafeHandle) section.  
  
 Le <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode ne fait rien par défaut, mais vous devez remplacer <xref:System.Object.Finalize%2A> uniquement si nécessaire et uniquement pour libérer les ressources non managées. Récupération de mémoire a tendance à s’allonger considérablement si une opération de finalisation est exécutée, car elle nécessite au moins deux opérations garbage collection. En outre, vous devez substituer la <xref:System.Object.Finalize%2A> types de méthode pour référence uniquement. Le common language runtime finalise uniquement les types référence. Il ignore les finaliseurs dans les types valeur.  

L’étendue de la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode est `protected`. Vous devez conserver cette portée limitée lorsque vous substituez la méthode dans votre classe. En conservant un <xref:System.Object.Finalize%2A> méthode protégée, empêcher les utilisateurs de votre application à partir de l’appel d’un objet <xref:System.Object.Finalize%2A> directement la méthode.
  
 Chaque implémentation de <xref:System.Object.Finalize%2A> dans un type dérivé doit appeler mise en œuvre de son type de base de <xref:System.Object.Finalize%2A>. C’est le cas uniquement dans l’application le code est autorisé à appeler <xref:System.Object.Finalize%2A>. D’un objet <xref:System.Object.Finalize%2A> méthode ne doit pas appeler une méthode sur les objets autres que ceux de sa classe de base. Il s’agit, car les autres objets appelées pu être collectées en même temps que l’objet appelant, comme dans le cas d’un arrêt de runtime de langage commun. 
  
> [!NOTE]
>  Le compilateur c# n’autorise pas vous permet de remplacer le <xref:System.Object.Finalize%2A> (méthode). Au lieu de cela, vous fournissez un finaliseur en implémentant un [destructeur](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) pour votre classe. Un destructeur c# appelle automatiquement le destructeur de sa classe de base.  
>   
>  Visual C++ fournit aussi sa propre syntaxe pour l’implémentation de la <xref:System.Object.Finalize%2A> (méthode). Pour plus d’informations, consultez la section « Destructeurs et finaliseurs » de [Comment : définir et consommer des Classes et Structs (C + c++ / CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Étant donné que le garbage collection est non déterministe, vous ne savez pas précisément à quel moment le garbage collector effectue la finalisation. Pour libérer des ressources immédiatement, vous pouvez également choisir d’implémenter le [modèle de suppression](~/docs/standard/design-guidelines/dispose-pattern.md) et <xref:System.IDisposable> interface. Le <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation peut être appelée par les consommateurs de votre classe de libérer des ressources non managées, et vous pouvez utiliser la <xref:System.Object.Finalize%2A> méthode pour libérer les ressources non managées dans le cas où la <xref:System.IDisposable.Dispose%2A> méthode n’est pas appelée.  
  
 <xref:System.Object.Finalize%2A> peut effectuer quasiment toute action, y compris ressusciter (un objet qui rendre à nouveau accessible) a été nettoyé pendant le garbage collection. Toutefois, l’objet peut uniquement être réactivé une seule fois ; <xref:System.Object.Finalize%2A> ne peut pas être appelée sur des objets ressuscités pendant le garbage collection. Il existe une seule action que votre implémentation de <xref:System.Object.Finalize%2A> ne doit jamais prendre : il ne doit jamais lever une exception. Si toutes les exceptions levées par les méthodes appelées à partir de la <xref:System.Object.Finalize%2A> (méthode) ne sont pas gérées par le <xref:System.Object.Finalize%2A> (méthode), le runtime suppose que le <xref:System.Object.Finalize%2A> méthode retournée et continue à appeler le <xref:System.Object.Finalize%2A> méthodes d’autres objets. 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>L'alternative de SafeHandle  
 Création des finaliseurs fiables est souvent difficile, car vous ne pouvez pas faire d’hypothèses concernant l’état de votre application et non prises en charge des exceptions de système comme <xref:System.OutOfMemoryException> et <xref:System.StackOverflowException> terminer le finaliseur. Au lieu d’implémenter un finaliseur pour votre classe pour libérer les ressources non managées, vous pouvez utiliser un objet qui est dérivé de la <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> classe pour encapsuler les ressources non managées et implémentez le modèle de suppression sans un finaliseur. Le .NET Framework fournit les classes suivantes dans le <xref:Microsoft.Win32?displayProperty=nameWithType> espace de noms qui sont dérivés de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> est une classe wrapper pour un handle de fichier.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> est une classe wrapper pour des handles de fichier mappé en mémoire.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> est une classe wrapper pour un pointeur vers un bloc de mémoire non managée.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, et <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> sont des classes wrapper pour des handles de chiffrement.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> est une classe wrapper pour des handles de canal.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> est une classe wrapper pour un handle à une clé de Registre.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> est une classe wrapper pour un handle d’attente.  
  
 L’exemple suivant utilise le [modèle de suppression](~/docs/standard/design-guidelines/dispose-pattern.md) avec des handles sécurisés au lieu de remplacer le <xref:System.Object.Finalize%2A> (méthode). Il définit un `FileAssociation` classe qui encapsule des informations du Registre sur l’application qui traite les fichiers avec une extension de fichier particulière. Les handles de deux Registre retournés en tant que `out` paramètres par Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) les appels de fonction sont passés à la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructeur. Le type de protégé `Dispose` méthode appelle ensuite la `SafeRegistryHandle.Dispose` méthode pour libérer ces deux poignées.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 L’exemple suivant vérifie que la <xref:System.Object.Finalize%2A> méthode est appelée lorsqu’un objet qui substitue <xref:System.Object.Finalize%2A> est détruit. Notez que, dans une application de production, le <xref:System.Object.Finalize%2A> méthode est substituée pour libérer les ressources non managées détenues par l’objet. Notez également que l’exemple c# fournit un destructeur au lieu de remplacer le <xref:System.Object.Finalize%2A> (méthode).  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Pour obtenir un exemple supplémentaire qui remplace le <xref:System.Object.Finalize%2A> (méthode), consultez le <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait office de fonction de hachage par défaut.</summary>
        <returns>Code de hachage pour l'objet actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un code de hachage est une valeur numérique qui est utilisée pour insérer et identifier un objet dans une collection en fonction de hachage telles que la <xref:System.Collections.Generic.Dictionary%602> (classe), le <xref:System.Collections.Hashtable> classe ou un type dérivé de la <xref:System.Collections.DictionaryBase> classe. Le <xref:System.Object.GetHashCode%2A> méthode fournit ce code de hachage pour les algorithmes qui doivent les contrôles rapides d’égalité d’objet.  
  
> [!NOTE]
>  Pour plus d’informations sur l’utilisation des codes de hachage dans les tables de hachage et de certains algorithmes de code de hachage supplémentaires, consultez le [fonction de hachage](https://en.wikipedia.org/wiki/Hash_function) entrée dans Wikipedia.  
  
 Deux objets qui sont des codes de hachage de retour égale sont égaux. Toutefois, l’inverse n’est pas vrai : codes de hachage égal n’impliquent pas l’égalité d’objet, car les différents objets (inégaux) peuvent avoir des codes de hachage identiques. En outre, le .NET Framework ne garantit pas l’implémentation par défaut de la <xref:System.Object.GetHashCode%2A> (méthode) et la valeur retournée par cette méthode peuvent différer entre les versions du .NET Framework et de plateformes, telles que les plateformes 32 bits et 64 bits. Pour ces raisons, n’utilisez pas l’implémentation par défaut de cette méthode comme un identificateur d’objet pour des raisons de hachage. Deux conséquences suivent à partir de ce :  
  
-   Vous ne devez pas supposer que les codes de hachage égale impliquent l’égalité d’objet.  
  
-   Vous ne devez jamais conserver ou utiliser un code de hachage en dehors du domaine d’application dans lequel il a été créé, car le même objet peuvent être hachées entre les plateformes, les processus et les domaines d’application.  
  
> [!WARNING]
>  Un code de hachage est prévu pour une insertion et de recherche dans les collections sont basées sur une table de hachage. Un code de hachage n’est pas une valeur permanente. Pour cette raison :  
>   
>  -   Ne pas sérialiser les valeurs de code de hachage ou les stocker dans les bases de données.  
> -   N’utilisez pas le code de hachage comme clé pour récupérer un objet à partir d’une collection à clé.  
> -   Ne pas envoyer les codes de hachage entre les domaines d’application ou processus. Dans certains cas, les codes de hachage peuvent être calculées sur une base domaine par processus ou par application.  
> -   N’utilisez pas le code de hachage au lieu d’une valeur renvoyée par une fonction de hachage cryptographique, si vous avez besoin d’un hachage cryptographique efficace. Pour les hachages de chiffrement, utilisez une classe dérivée de la <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.  
> -   Ne testez pas l’égalité des codes de hachage pour déterminer si deux objets sont égaux. (Les objets inégales peuvent avoir des codes de hachage identiques.) Pour tester l’égalité, appelez le <xref:System.Object.ReferenceEquals%2A> ou <xref:System.Object.Equals%2A> (méthode).  
  
 Le <xref:System.Object.GetHashCode%2A> méthode peut être substituée par un type dérivé. Si <xref:System.Object.GetHashCode%2A> est ne pas substituée, codes de hachage pour les types référence sont calculées en appelant le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> méthode de classe de base, qui calcule un code de hachage basée sur la référence d’un objet ; pour plus d’informations, consultez <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. En d’autres termes, deux objets pour lesquels le <xref:System.Object.ReferenceEquals%2A> méthode retourne `true` ont des codes de hachage identiques. Si les types valeur ne substituent pas <xref:System.Object.GetHashCode%2A>, le <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> méthode de la classe de base utilise la réflexion pour calculer le code de hachage basé sur les valeurs des champs du type. En d’autres termes, les types de valeur dont les champs ont des valeurs égales ont des codes de hachage égale. Pour plus d’informations sur la substitution de <xref:System.Object.GetHashCode%2A>, consultez la section « Remarques à l’attention des héritiers ».  
  
> [!WARNING]
>  Si vous remplacez le <xref:System.Object.GetHashCode%2A> (méthode), vous devez également substituer <xref:System.Object.Equals%2A>et vice versa. Si votre substituée <xref:System.Object.Equals%2A> méthode retourne `true` lorsque les deux objets sont testées pour l’égalité, votre substituée <xref:System.Object.GetHashCode%2A> méthode doit retourner la même valeur pour les deux objets.  
  
 Si un objet qui est utilisé comme clé dans une table de hachage ne fournit pas une implémentation utile de <xref:System.Object.GetHashCode%2A>, vous pouvez spécifier un fournisseur de code de hachage en fournissant une <xref:System.Collections.IEqualityComparer> mise en œuvre à une des surcharges de la <xref:System.Collections.Hashtable> constructeur de classe.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notes pour le [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Lorsque vous appelez le <xref:System.Object.GetHashCode%2A> méthode sur une classe dans le [!INCLUDE[wrt](~/includes/wrt-md.md)], il fournit le comportement par défaut pour les classes qui ne remplacent pas <xref:System.Object.GetHashCode%2A>. Cela fait partie de la prise en charge le .NET Framework fournit pour les [!INCLUDE[wrt](~/includes/wrt-md.md)] (consultez [.NET Framework prend en charge pour les applications du Windows Store et Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes de la [!INCLUDE[wrt](~/includes/wrt-md.md)] n’héritent pas <xref:System.Object>et n’implémentent pas actuellement un <xref:System.Object.GetHashCode%2A>. Toutefois, ils semblent avoir <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, et <xref:System.Object.GetHashCode%2A> méthodes lorsque vous les utilisez dans votre code c# ou Visual Basic et le .NET Framework fournit le comportement par défaut pour ces méthodes.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] les classes qui sont écrits en c# ou Visual Basic peuvent substituer la <xref:System.Object.GetHashCode%2A> (méthode).  
  
   
  
## Examples  
 Une des méthodes plus simples pour calculer un code de hachage pour une valeur numérique qui a la même ou à une plage plus petite que la <xref:System.Int32> est de type à retourner simplement cette valeur. L’exemple suivant montre une telle implémentation pour un `Number` structure.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Souvent, un type a plusieurs champs de données qui peuvent participer à la génération du code de hachage. Permet de générer un code de hachage consiste à combiner ces champs à l’aide un `XOR (eXclusive OR)` opération, comme indiqué dans l’exemple suivant.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 L’exemple précédent retourne le même code de hachage pour (n1, n2) et (n2, n1) et par conséquent, peut générer des collisions ceux souhaitable. Un nombre de solutions est disponible afin que les codes de hachage dans ces cas ne sont pas identiques. Un consiste à retourner le code de hachage d’un `Tuple` objet qui reflète l’ordre de chaque champ. L’exemple suivant montre une implémentation possible qui utilise le <xref:System.Tuple%602> classe. Notez, cependant, que la surcharge des performances de l’instanciation d’un `Tuple` objet peut affecter considérablement les performances globales d’une application qui stocke un grand nombre d’objets dans les tables de hachage.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Une autre solution de remplacement implique les codes de hachage individuels de pondération en migrant les codes de hachage de champs successifs à gauche par deux ou plusieurs bits. De façon optimale, au lieu d’être supprimés, les bits décalés au-delà de bit 31 doivent habiller plutôt qu’ignorées. Étant donné que les bits sont ignorés par les opérateurs de décalage vers la gauche en c# et Visual Basic, cela requiert la création d’une méthode MAJ-wrap gauche comme suit :  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 L’exemple suivant utilise ensuite cette méthode MAJ-wrap pour calculer le code de hachage de la `Point` structure utilisée dans les exemples précédents.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Une fonction de hachage est utilisée pour générer rapidement un nombre (code de hachage) qui correspond à la valeur d’un objet. Fonctions de hachage sont généralement propres à chaque type et, pour l’unicité, doivent utiliser au moins un des champs d’instance comme entrée. Codes de hachage ne doivent pas être calculées en utilisant les valeurs des champs statiques.  Pour les classes dérivées de <see cref="T:System.Object" />, le <see langword="GetHashCode" /> méthode peut déléguer à la classe de base <see cref="M:System.Object.GetHashCode" /> mise en œuvre uniquement si la classe dérivée définit l’égalité comme l’égalité des références. L’implémentation par défaut de <see cref="M:System.Object.GetHashCode" /> pour référence types retourne un code de hachage qui est équivalent à celui retourné par la <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> (méthode). Vous pouvez substituer <see cref="M:System.Object.GetHashCode" /> pour les types référence immuable. En règle générale, pour les types référence mutables, vous devez substituer <see cref="M:System.Object.GetHashCode" /> uniquement si : - vous pouvez calculer le code de hachage à partir des champs qui ne sont pas mutable ; ou - vous pouvez vous assurer que le code de hachage d’un objet mutable ne change pas pendant que l’objet est contenu dans un collecti sur qui s’appuie sur son code de hachage.  Sinon, vous pouvez considérer que la perte de l’objet mutable dans la table de hachage. Si vous choisissez de remplacer <see cref="M:System.Object.GetHashCode" /> pour un type référence mutable, la documentation doit indiquer clairement que les utilisateurs de votre type ne doivent pas changer les valeurs d’objet alors que l’objet est stocké dans une table de hachage.  Pour les types valeur, <see cref="M:System.ValueType.GetHashCode" /> fournit une implémentation de code de hachage par défaut qui utilise la réflexion. Vous devez envisager de substitution pour de meilleures performances.  <block subset="none" type="note"><para> Pour plus d’informations et des exemples qui calculent des codes de hachage de plusieurs manières, consultez la section Exemples.  </para></block>  Une fonction de hachage doit avoir les propriétés suivantes : - si deux objets sont considérés comme égaux, la <see cref="M:System.Object.GetHashCode" /> méthode pour chaque objet doit retourner la même valeur. Toutefois, si deux objets ne sont pas considérés comme égaux, la <see cref="M:System.Object.GetHashCode" /> méthodes pour les deux objets n’ont pas à retourner des valeurs différentes.  -La <see cref="M:System.Object.GetHashCode" /> méthode pour un objet doit constamment retourner le même code de hachage tant qu’il n’existe aucune modification à l’état de l’objet qui détermine la valeur de retour de l’objet [méthode System.Object.Equals](xref:System.Object.Equals*). Notez que cela est vrai uniquement pour l’exécution en cours d’une application, et qu’un code de hachage différent peut être retourné si l’application est exécutée à nouveau.  -Pour des performances optimales, une fonction de hachage doit générer une distribution uniforme pour toutes les entrées, y compris les entrées qui sont fortement en cluster. Une conséquence est que les petites modifications à l’état de l’objet doivent entraînent des modifications volumineuses dans le code de hachage qui en résulte pour de meilleures performances de table de hachage.  -Fonctions de hachage doivent être peu coûteuses à calculer.  -La <see cref="M:System.Object.GetHashCode" /> méthode lever d’exceptions.  Par exemple, l’implémentation de la <see cref="M:System.String.GetHashCode" /> méthode fournie par la <see cref="T:System.String" /> classe retourne des codes de hachage identiques pour les valeurs de chaîne identiques. Par conséquent, deux <see cref="T:System.String" /> objets retournent le même code de hachage s’ils représentent la même valeur de chaîne. En outre, la méthode utilise tous les caractères dans la chaîne pour générer une sortie distribuée de manière raisonnablement aléatoire, même si l’entrée est ordonnée en clusters dans certaines plages (par exemple, de nombreux utilisateurs peuvent comporter des chaînes qui contiennent uniquement les 128 caractères ASCII inférieurs, même si un chaîne peut contenir les 65 535 caractères Unicode).  En fournissant une fonction de hachage adéquate sur une classe peut affecter considérablement les performances de l’ajout de ces objets à une table de hachage. Dans une table de hachage avec des clés qui fournissent une bonne implémentation d’une fonction de hachage, recherche un élément du temps constant (par exemple, il s’agit d’une opération o (1)). Dans une table de hachage avec une mauvaise implémentation d’une fonction de hachage, les performances d’une recherche varie selon le nombre d’éléments dans la table de hachage (par exemple, une opération O('n'), où « n » est le nombre d’éléments dans la table de hachage). Un utilisateur malveillant peut entrer des données qui augmente le nombre de collisions, ce qui peut dégrader considérablement les performances des applications qui dépendent des tables de hachage, les conditions suivantes : - lorsque les fonctions de hachage produisent des conflits fréquents.  -Lorsqu’une proportion élevée d’objets dans une table de hachage produisent des codes de hachage qui sont égaux ou approximativement égal à un autre.  -Lorsque les utilisateurs d’entrée les données à partir de laquelle le code de hachage est calculé.  Classes dérivées qui substituent <see cref="M:System.Object.GetHashCode" /> doit également substituer <see cref="M:System.Object.Equals(System.Object)" /> pour garantir que deux objets considérés comme égaux possèdent le même code de hachage ; sinon, le <see cref="T:System.Collections.Hashtable" /> type peut ne pas fonctionne correctement.</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le <see cref="T:System.Type" /> de l'instance actuelle.</summary>
        <returns>Type exact de l'instance actuelle au moment de l'exécution.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que <xref:System.Object?displayProperty=nameWithType> est la classe de base pour tous les types dans le système de type .NET Framework, le <xref:System.Object.GetType%2A> méthode peut être utilisée pour retourner <xref:System.Type> objets qui représentent tous les types .NET Framework. Le .NET Framework reconnaît les cinq catégories de types suivantes :  
  
-   Classes, qui sont dérivés de <xref:System.Object?displayProperty=nameWithType>,  
  
-   Types valeur, qui sont dérivées de <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Les interfaces sont dérivés de <xref:System.Object?displayProperty=nameWithType> en commençant par le .NET Framework 2.0.  
  
-   Énumérations qui sont dérivées de <xref:System.Enum?displayProperty=nameWithType>.  
  
-   Les délégués sont dérivés de <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Pour deux objets `x` et `y` qui ont des types de runtime identiques, `Object.ReferenceEquals(x.GetType(),y.GetType())` retourne `true`. L’exemple suivant utilise le <xref:System.Object.GetType%2A> méthode avec la <xref:System.Object.ReferenceEquals%2A> méthode pour déterminer si une valeur numérique est du même type que les deux autres valeurs numériques.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Pour déterminer si un objet est un type spécifique, vous pouvez utiliser le mot clé de comparaison du type de votre langage ou construire. Par exemple, vous pouvez utiliser la `TypeOf…Is` construire en Visual Basic ou `is` (mot clé) en c#.  
  
 Le <xref:System.Object.GetType%2A> méthode est héritée par tous les types qui dérivent de <xref:System.Object>. Cela signifie que, en plus d’utiliser le mot clé de comparaison de votre propre langage, vous pouvez utiliser la <xref:System.Object.GetType%2A> méthode pour déterminer le type d’un objet particulier, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 Le <xref:System.Type> objet expose les métadonnées associées à la classe de courant <xref:System.Object>.  
  
   
  
## Examples  
 L’exemple de code suivant montre que <xref:System.Object.GetType%2A> retourne le type de runtime de l’instance actuelle.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie superficielle du <see cref="T:System.Object" /> actuel.</summary>
        <returns>Copie superficielle du <see cref="T:System.Object" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Object.MemberwiseClone%2A> méthode crée une copie superficielle en créant un nouvel objet, puis en copiant les champs non statiques de l’objet actuel vers le nouvel objet. Si un champ est un type valeur, une copie bit par bit du champ est effectuée. Si un champ est un type référence, la référence est copiée, mais l’objet référencé n’est pas. Par conséquent, l’objet d’origine et son clone font référence au même objet.  
  
 Par exemple, considérez un objet appelé X qui fait référence à son tour, les objets A et B, C. Une copie superficielle de X crée l’objet X2 qui fait également référence à des objets A et B. En revanche, une copie complète de X crée un nouvel objet X2 qui fait référence à nouveaux objets A2 et B2, qui sont des copies de A et B. B2 référence à son tour, le nouvel objet C2, qui est une copie de C. L’exemple illustre la différence entre un shallow et une opération de copie complète.  
  
 Il existe plusieurs façons pour implémenter une opération de copie complète si l’opération de copie superficielle exécutée par le <xref:System.Object.MemberwiseClone%2A> (méthode) ne répond pas à vos besoins. Notamment :  
  
-   Appeler un constructeur de classe de l’objet doit être copié pour créer un second objet avec les valeurs de propriété provenant du premier objet. Cela suppose que les valeurs d’un objet sont entièrement définis par son constructeur de classe.  
  
-   Appelez le <xref:System.Object.MemberwiseClone%2A> méthode pour créer une copie superficielle d’un objet et assigner des objets dont les valeurs sont les mêmes que l’objet d’origine à des propriétés ou des champs dont les valeurs sont des types référence. Le `DeepCopy` méthode dans l’exemple illustre cette approche.  
  
-   Sérialiser l’objet de manière complète copiés et restaurer les données sérialisées à une variable objet différent.  
  
-   Utiliser la réflexion pour effectuer l’opération de copie complète avec la récurrence.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.Object.MemberwiseClone%2A> (méthode). Il définit un `ShallowCopy` méthode qui appelle le <xref:System.Object.MemberwiseClone%2A> méthode pour effectuer une opération de copie superficielle sur un `Person` objet. Il définit également un `DeepCopy` méthode qui effectue une opération de copie complète sur un `Person` objet.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 Dans cet exemple, le `Person.IdInfo` propriété retourne un `IdInfo` objet. Comme la sortie de l’exemple, lorsqu’un `Person` est cloné en appelant le <xref:System.Object.MemberwiseClone%2A> (méthode), le clonage `Person` objet est une copie indépendante de l’objet d’origine, sauf qu’elles partagent le même `Person.IdInfo` référence d’objet. Par conséquent, modification du clone `Person.IdInfo` propriété modifie l’objet d’origine `Person.IdInfo` propriété. En revanche, quand une opération de copie complète est effectuée, le clonage `Person` de l’objet, y compris son `Person.IdInfo` propriété, peut être modifiée sans affecter l’objet d’origine.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Premier objet à comparer.</param>
        <param name="objB">Deuxième objet à comparer.</param>
        <summary>Détermine si les instances de <see cref="T:System.Object" /> spécifiées sont identiques.</summary>
        <returns>
          <see langword="true" /> si <paramref name="objA" /> est la même instance que <paramref name="objB" /> ou si les deux ont la valeur **null** ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la <xref:System.Object.Equals%2A> méthode et l’opérateur d’égalité, le <xref:System.Object.ReferenceEquals%2A> méthode ne peut pas être substituée. Pour cette raison, si vous souhaitez tester deux références à l’égalité des objets et vous ne savez pas sur l’implémentation de la `Equals` (méthode), vous pouvez appeler la <xref:System.Object.ReferenceEquals%2A> (méthode).  
  
 Toutefois, la valeur de retour de la <xref:System.Object.ReferenceEquals%2A> méthode peut apparaître comme étant anormaux dans ces deux scénarios :  
  
-   Lors de la comparaison des types valeur. Si `objA` et `objB` sont des types valeur, ils sont convertis avant d’être passés à la <xref:System.Object.ReferenceEquals%2A> (méthode). Cela signifie que si les deux `objA` et `objB` représentent la même instance d’un type valeur, le <xref:System.Object.ReferenceEquals%2A> méthode néanmoins retourne `false`, comme le montre l’exemple suivant.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Pour plus d’informations sur les types valeur boxing, consultez [conversion Boxing et Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Lors de la comparaison de chaînes. Si `objA` et `objB` sont des chaînes, la <xref:System.Object.ReferenceEquals%2A> retourne de la méthode `true` si la chaîne est dans le pool interne. Il n’effectue pas un test de l’égalité des valeurs.  Dans l’exemple suivant, `s1` et `s2` sont égales, car elles sont deux instances d’une chaîne dans le pool interne unique. Toutefois, `s3` et `s4` ne sont pas égales, car même si elles sont ont des valeurs de chaîne identique, cette chaîne n’est pas intégrée.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Pour plus d’informations sur la centralisation des chaînes, consultez <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Object.ReferenceEquals%2A> pour déterminer si deux objets sont identiques.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une chaîne qui représente l'objet actuel.</summary>
        <returns>Chaîne qui représente l'objet actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> principales est mise en forme de méthode dans le .NET Framework. Il convertit un objet en sa représentation sous forme de chaîne afin qu’il soit adapté à l’affichage. (Pour plus d’informations sur la mise en forme de la prise en charge dans le .NET Framework, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).) Implémentations par défaut de la <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode retourne le nom qualifié complet du type de l’objet.  
  
> [!IMPORTANT]
>  Vous avez atteint cette page en suivant le lien à partir de la liste des membres d’un autre type. C’est parce que ce type ne se substitue pas <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Au lieu de cela, il hérite de la fonctionnalité de le <xref:System.Object.ToString%2A?displayProperty=nameWithType> (méthode).  
  
 Les types remplacer fréquemment le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour fournir une représentation de chaîne plus appropriée d’un type particulier. Types de surcharge aussi fréquemment le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour prendre en charge les chaînes de format ou la mise en forme dépendante de la culture.  
  
 Dans cette section :  
  
 [La méthode Object.ToString () par défaut](#Default)   
 [Substitution de la méthode Object.ToString)](#Overriding)   
 [Surcharge de la méthode ToString](#Overloading)   
 [Extension de la méthode Object.ToString](#Extending)   
 [Notes pour le Windows Runtime](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>La méthode Object.ToString () par défaut  
 L’implémentation par défaut de la <xref:System.Object.ToString%2A> méthode retourne le nom qualifié complet du type de la <xref:System.Object>, comme le montre l’exemple suivant.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Étant donné que <xref:System.Object> est la classe de base de tous les types de référence dans le .NET Framework, ce comportement est hérité par les types de référence qui ne remplacent pas les <xref:System.Object.ToString%2A> (méthode). L'exemple suivant illustre ce comportement. Il définit une classe nommée `Object1` qui accepte l’implémentation par défaut de tous les <xref:System.Object> membres. Son <xref:System.Object.ToString%2A> méthode retourne le nom de type qualifié complet de l’objet.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Substitution de la méthode Object.ToString)  
 Les types couramment remplacer le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour retourner une chaîne qui représente l’instance d’objet. Par exemple, les types de base telles que <xref:System.Char>, <xref:System.Int32>, et <xref:System.String> fournir <xref:System.Object.ToString%2A> qu’il retourne la forme de chaîne de la valeur que l’objet représente. L’exemple suivant définit une classe, `Object2`, qui remplace la <xref:System.Object.ToString%2A> le nom de type, ainsi que sa valeur de retour de méthode.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 Le tableau suivant répertorie les catégories de type dans le .NET Framework et indique si elles remplacent les <xref:System.Object.ToString%2A?displayProperty=nameWithType> (méthode).  
  
|Catégorie de type|Substitue Object.ToString)|Comportement|  
|-------------------|-----------------------------------|--------------|  
|Classe|N/A|N/A|  
|Structure|Oui (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Identique à Object.ToString)|  
|Énumération|Oui (<xref:System.Enum.ToString?displayProperty=nameWithType>)|Le nom de membre|  
|Interface|Non|N/A|  
|délégué|Non|N/A|  
  
 Consultez les section Remarques à l’attention des héritiers pour plus d’informations sur la substitution <xref:System.Object.ToString%2A>.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>Surcharge de la méthode ToString  
 Outre l’écrasement sans paramètre <xref:System.Object.ToString?displayProperty=nameWithType> surcharge de méthode, de nombreux types du `ToString` méthode pour fournir des versions de la méthode qui acceptent des paramètres. En règle générale, cela est fait pour prendre en charge la mise en forme variable et la mise en forme dépendante de la culture.  
  
 L’exemple suivant surcharge le `ToString` méthode pour retourner une chaîne de résultat qui inclut la valeur des champs variés d’une `Automobile` classe. Il définit quatre chaînes de format : G, qui retourne le nom du modèle et l’année ; D, qui retourne le nom du modèle, année et nombre de portes ; C, qui retourne le nom du modèle, année et nombre de cylindres ; et, qui retourne une chaîne avec toutes les valeurs de champ de quatre.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 L’exemple suivant appelle surchargées <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> méthode pour afficher la mise en forme dépendante de la culture d’une valeur monétaire.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Pour plus d’informations sur les chaînes de format et la mise en forme dépendante de la culture, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md). Pour les chaînes de format pris en charge par les valeurs numériques, consultez [des chaînes de Format numériques Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md). Pour les chaînes de format pris en charge par les valeurs de date et d’heure, consultez [Standard de Date et heure des chaînes de Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [les chaînes de Format de temps et de Date personnalisée](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Extension de la méthode Object.ToString  
 Parce qu’un type hérite de la valeur par défaut <xref:System.Object.ToString%2A?displayProperty=nameWithType> (méthode), vous pouvez trouver son comportement indésirables et souhaitez le modifier. Cela est particulièrement vrai des tableaux et des classes de collection. Pendant que vous pouvez attendre la `ToString` méthode d’une classe de collection ou du tableau pour afficher les valeurs de ses membres, il affiche à la place le nom de type qualifié complet de type, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Vous avez plusieurs options pour produire la chaîne de résultat que vous souhaitez.  
  
-   Si le type est un tableau, un objet de collection ou un objet qui implémente le <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601> interfaces, vous pouvez énumérer ses éléments à l’aide de la `foreach` instruction en c# ou le `For Each...Next` construire en Visual Basic.  
  
-   Si la classe n’est pas `sealed` (en c#) ou `NotInheritable` (en Visual Basic), vous pouvez développer une classe wrapper qui hérite de la classe de base dont <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode que vous souhaitez personnaliser. Au minimum, cela nécessite que vous procédez comme suit :  
  
    1.  Implémenter des constructeurs nécessaires. Classes dérivées n’héritent pas de leurs constructeurs de classe de base.  
  
    2.  Remplacer la <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour retourner la chaîne de résultat que vous souhaitez.  
  
     L’exemple suivant définit une classe wrapper pour la <xref:System.Collections.Generic.List%601> classe. Il remplace le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour afficher la valeur de chaque méthode de la collection plutôt que le nom de type qualifié complet.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Développer un [méthode d’extension](~/docs/standard/design-guidelines/extension-methods.md) qui retourne la chaîne de résultat souhaité. Notez que vous ne pouvez pas remplacer la valeur par défaut <xref:System.Object.ToString%2A?displayProperty=nameWithType> de cette manière (méthode) (autrement dit, votre classe d’extension (en c#) ou un module (Visual Basic) ne peut pas avoir une méthode sans paramètre nommée `ToString` qui est appelée à la place du type d’origine `ToString` (méthode) . Vous devrez fournir un autre nom pour votre sans paramètre `ToString` remplacement.  
  
     L’exemple suivant définit deux méthodes qui étendent la <xref:System.Collections.Generic.List%601> classe : un sans paramètre `ToString2` (méthode) et un `ToString` méthode avec un <xref:System.String> paramètre qui représente une chaîne de format.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notes pour le [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Lorsque vous appelez le <xref:System.Object.ToString%2A> méthode sur une classe dans le [!INCLUDE[wrt](~/includes/wrt-md.md)], il fournit le comportement par défaut pour les classes qui ne remplacent pas <xref:System.Object.ToString%2A>. Cela fait partie de la prise en charge le .NET Framework fournit pour les [!INCLUDE[wrt](~/includes/wrt-md.md)] (consultez [.NET Framework prend en charge pour les applications du Windows Store et Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes de la [!INCLUDE[wrt](~/includes/wrt-md.md)] n’héritent pas <xref:System.Object>et n’implémentent pas toujours un <xref:System.Object.ToString%2A>. Toutefois, ils apparaissent toujours avoir <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, et <xref:System.Object.GetHashCode%2A> méthodes lorsque vous les utilisez dans votre code c# ou Visual Basic et le .NET Framework fournit un comportement par défaut pour ces méthodes.  
  
 En commençant par le [!INCLUDE[net_v451](~/includes/net-v451-md.md)], le common language runtime utilise [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) sur un [!INCLUDE[wrt](~/includes/wrt-md.md)] objet avant de revenir à l’implémentation par défaut de <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] les classes qui sont écrits en c# ou Visual Basic peuvent substituer la <xref:System.Object.ToString%2A> (méthode).  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>Le [!INCLUDE[wrt](~/includes/wrt-md.md)] et l’Interface IStringable  
 En commençant par [!INCLUDE[win81](~/includes/win81-md.md)], le [!INCLUDE[wrt](~/includes/wrt-md.md)] inclut un [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) dont la méthode unique, de l’interface [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), fournit le support de mise en forme base comparable à celle fourni par <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Pour éviter toute ambiguïté, vous ne devez pas implémenter [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) sur les types managés.  
  
 Lorsque les objets managés sont appelées par du code natif ou en code écrit dans des langages tels que JavaScript ou C + c++ / CX, ils s’affichent pour implémenter [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). Le common language runtime route automatiquement les appels à partir de [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) à <xref:System.Object.ToString%2A?displayProperty=nameWithType> de l’événement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) n’est pas implémentée sur l’objet managé.  
  
> [!WARNING]
>  Étant donné que le common language runtime auto-implémente [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) pour tous les types dans gérés [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] applications, nous recommandons que vous ne fournissez pas votre propre [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) mise en œuvre. Mise en œuvre [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) peut entraîner un comportement inattendu lors de l’appel `ToString` à partir de la [!INCLUDE[wrt](~/includes/wrt-md.md)], C + c++ / CX ou JavaScript.  
  
 Si vous choisissez d’implémenter [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) dans un type managé public qui est exporté dans un [!INCLUDE[wrt](~/includes/wrt-md.md)] composant, les restrictions suivantes s’appliquent :  
  
-   Vous pouvez définir le [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface uniquement dans une relation « la classe implémente », tels que  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     en C#, ou  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     en Visual Basic.  
  
-   Vous ne pouvez pas implémenter [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) sur une interface.  
  
-   Vous ne pouvez pas déclarer un paramètre de type [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ne peut pas être le type de retour d’une méthode, une propriété ou un champ.  
  
-   Vous ne pouvez pas masquer votre [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implémentation de classes de base à l’aide d’une définition de méthode telle que la suivante :  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Au lieu de cela, le [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implémentation doit toujours remplacer l’implémentation de classe de base. Vous pouvez masquer une implémentation `ToString` uniquement en l'appelant sur une instance de classe fortement typée.  
  
 Notez que dans diverses conditions, les appels à partir du code natif à un type managé qui implémente [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ou masque son [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implémentation peut entraîner un comportement inattendu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lorsque vous implémentez vos propres types, vous devez substituer la <see cref="M:System.Object.ToString" /> méthode pour retourner des valeurs qui sont pertinents pour ces types. Classes dérivées qui requièrent davantage de contrôle sur la mise en forme que <see cref="M:System.Object.ToString" /> fournit peuvent implémenter la <see cref="T:System.IFormattable" /> interface. Son <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> méthode vous permet de définir des chaînes de format qui contrôlent la mise en forme et d’utiliser un <see cref="T:System.IFormatProvider" /> objet qui peut fournir pour la mise en forme propres à la culture.  Les remplacements de la <see cref="M:System.Object.ToString" /> méthode doit suivre les recommandations suivantes :-la chaîne retournée doit être lisible par l’homme et conviviale.  -La chaîne retournée doit identifier de manière unique la valeur de l’instance d’objet.  -La chaîne retournée doit être aussi courte que possible afin qu’il soit adapté à l’affichage par un débogueur.  -Votre <see cref="M:System.Object.ToString" /> substitution ne doit pas retourner <see cref="F:System.String.Empty" /> ou une chaîne null.  -Votre <see cref="M:System.Object.ToString" /> remplacement ne doit pas lever d’exception.  -Si la représentation sous forme de chaîne d’une instance est dépendante de la culture ou peut être mise en forme de plusieurs façons, implémentez le <see cref="T:System.IFormattable" /> interface.  -Si la chaîne retournée inclut des informations sensibles, vous devez tout d’abord demander une autorisation appropriée. Si la demande réussit, vous pouvez retourner des informations sensibles. dans le cas contraire, vous devez retourner une chaîne qui exclut les informations sensibles.  -Votre <see cref="M:System.Object.ToString" /> remplacement ne doit avoir aucun effet observable afin d’éviter les problèmes de débogage. Par exemple, un appel à la <see cref="M:System.Object.ToString" /> méthode ne doit pas modifier la valeur des champs d’instance.  -Si le type implémente une méthode d’analyse (ou <see langword="Parse" /> ou <see langword="TryParse" /> méthode, un constructeur ou une autre méthode statique qui instancie une instance du type à partir d’une chaîne), vous devez vous assurer que la chaîne retournée par la <see cref="M:System.Object.ToString" /> méthode peut être converti en une instance d’objet.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>