<Type Name="Activator" FullName="System.Activator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="33496946a13ba8e7a29674ceaab89361b3bde664" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30730893" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Contient des méthodes permettant de créer des types d'objets localement ou à distance, ou d'obtenir des références à des objets distants existants. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Activator.CreateInstance%2A> méthode crée une instance d’un type défini dans un assembly en appelant le constructeur qui correspond le mieux les arguments spécifiés. Si aucun argument n’est spécifié, le constructeur qui ne prend aucun paramètre, autrement dit, le constructeur par défaut, est appelé.  
  
 Vous devez disposer des autorisations suffisantes pour rechercher et appeler un constructeur ; Sinon, une exception est levée. Par défaut, seuls les constructeurs publics sont considérées comme lors de la recherche un constructeur. Si aucun constructeur ou un constructeur par défaut ne peut être trouvé, une exception est levée.  
  
 Un paramètre binder spécifie un objet qui recherche un assembly pour un constructeur approprié. Vous pouvez spécifier votre propre classeur et critères de recherche. Si aucun classeur n’est spécifié, un binder par défaut est utilisé. Pour plus d'informations, consultez la classe <xref:System.Reflection.Binder?displayProperty=nameWithType> et <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Un paramètre de preuve affecte la stratégie de sécurité et les autorisations pour le constructeur. Pour plus d'informations, consultez la classe <xref:System.Security.Policy.Evidence?displayProperty=nameWithType>.  
  
 Une instance d’un type peut être créée sur un site local ou distant. Si le type est créé à distance, un paramètre d’attribut d’activation Spécifie l’URI du site distant. L’appel à la création de l’instance peut passer par des sites intermédiaires avant d’atteindre le site distant. Autres attributs d’activation peuvent modifier l’environnement ou contexte dans lequel l’appel agit sur les sites distants et intermédiaires.  
  
 Si l’instance est créée localement, une référence à cet objet est retournée. Si l’instance est créée à distance, une référence à un proxy est retournée. L’objet distant est manipulée via le proxy comme s’il s’agissait d’un objet local.  
  
 Le <xref:System.Activator.GetObject%2A> méthode crée un proxy pour un objet en cours d’exécution à distance, un objet bien connu activé par serveur ou un service Web XML. Vous pouvez spécifier le support de connexion, autrement dit, le canal. Pour plus d'informations, consultez la classe <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType>.  
  
 Les assemblys contiennent des définitions de type. Le <xref:System.Activator.CreateInstance%2A> méthode crée une instance d’un type à partir d’un assembly en cours d’exécution. Le <xref:System.Activator.CreateInstanceFrom%2A> méthode crée une instance d’un fichier qui contient un assembly. Le <xref:System.Activator.CreateComInstanceFrom%2A> méthode crée une instance d’un objet COM à partir d’un fichier qui contient un assembly.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la <xref:System.Activator> classe pour construire dynamiquement des objets au moment de l’exécution.  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance de l'objet COM dont le nom est spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom d’un fichier qui contient un assembly dans lequel le type nommé <c>typeName</c> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <summary>Crée une instance de l'objet COM dont le nom est spécifié, en utilisant le fichier d'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribut avec une valeur de `true` doit être appliqué explicitement ou par défaut au type COM afin que la <xref:System.Activator.CreateComInstanceFrom%2A> méthode peut créer une instance de ce type ; sinon, <xref:System.TypeLoadException> est levée.  
  
 Pour plus d’informations sur les autres exceptions pouvant être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ou <paramref name="assemblyName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Il est impossible de créer une instance par l’intermédiaire de COM.  
  
 - ou -  
  
 <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable ou le module que vous essayez de charger ne spécifie pas une extension de nom de fichier.</exception>
        <exception cref="T:System.MemberAccessException">Il est impossible de créer une instance d’une classe abstraite.  
  
 - ou -  
  
 Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> est la chaîne vide ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quelle que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom d’un fichier qui contient un assembly dans lequel le type nommé <c>typeName</c> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="hashValue">Valeur du code de hachage calculé.</param>
        <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les fichiers et générer le nom fort.</param>
        <summary>Crée une instance de l'objet COM dont le nom est spécifié, en utilisant le fichier d'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribut avec une valeur de `true` doit être appliqué explicitement ou par défaut au type COM afin que la <xref:System.Activator.CreateComInstanceFrom%2A> méthode peut créer une instance de ce type ; sinon, <xref:System.TypeLoadException> est levée.  
  
 Pour plus d’informations sur les autres exceptions pouvant être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ou <paramref name="assemblyName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> est la chaîne vide ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes, ou le nom de l’assembly comprend plus de MAX_PATH caractères.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable ou le module que vous essayez de charger ne spécifie pas une extension de nom de fichier.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> a été trouvé, mais impossible de le charger.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.</exception>
        <exception cref="T:System.Security.SecurityException">Une base de code qui ne commence pas par “file://” a été spécifiée sans le <see langword="WebPermission" /> requis.</exception>
        <exception cref="T:System.TypeLoadException">Impossible de créer une instance par l’intermédiaire de COM.  
  
 - ou -  
  
 <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite.  
  
 - ou -  
  
 Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quelle que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire un URI qui commence par « file:// ». Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance du type spécifié à l'aide du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Objet de contexte d’activation qui spécifie l’objet à créer.</param>
        <summary>Crée une instance du type désigné par l'objet <see cref="T:System.ActivationContext" /> spécifié.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à l'objet créé récemment.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Le contexte d’activation est utilisé pendant l’activation basée sur un manifeste pour configurer la stratégie de domaine et fournir un modèle de sécurité basée sur l’application. Le <xref:System.ActivationContext> classe contient un <xref:System.ApplicationIdentity> objet qui fournit l’accès au manifeste d’application. Pour plus d'informations, consultez la classe <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur par défaut de ce type.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur à appeler doit être accessible.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Activator.CreateInstance%28System.Type%29> (méthode). Instances de plusieurs types différents sont créés et leurs valeurs par défaut sont affichés.  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
 - ou -  
  
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - ou -  
  
 La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
 - ou -  
  
 L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.MemberAccessException" />, à la place.  
  
</para>
          </block>  
  
 L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.MissingMemberException" />, à la place.  
  
</para>
          </block>  
  
 Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quelle que soit leurs jeux d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
        <Parameter Name="activationCustomData" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="activationContext">Objet de contexte d’activation qui spécifie l’objet à créer.</param>
        <param name="activationCustomData">Tableau de chaînes Unicode qui contiennent les données d'activation personnalisées.</param>
        <summary>Crée une instance du type désigné par l'objet <see cref="T:System.ActivationContext" /> spécifié et activé avec les données d'activation personnalisées spécifiées.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à l'objet créé récemment.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Le contexte d’activation est utilisé pendant l’activation basée sur un manifeste pour configurer la stratégie de domaine et fournir un modèle de sécurité basée sur l’application. Le <xref:System.ActivationContext> classe contient un <xref:System.ApplicationIdentity> objet qui fournit l’accès au manifeste d’application. Pour plus d'informations, consultez la classe <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de l’assembly dans lequel le type nommé <c>typeName</c> est recherché. Si <c>assemblyName</c> a la valeur <see langword="null" />, la recherche s’effectue dans l’assembly en cours d’exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <summary>Crée une instance du type dont le nom est spécifié, en utilisant l'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
 `assemblyName` peut être une des opérations suivantes :  
  
-   Le nom simple d’un assembly, sans son extension de fichier ou chemin d’accès. Par exemple, vous devez spécifier `TypeExtensions` pour un assembly dont chemin d’accès et le nom est.\bin\TypeExtensions.dll.  
  
-   Le nom complet d’un assembly signé, ce qui se compose de son nom simple, la version, culture et jeton de clé publique ; par exemple, « TypeExtensions, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 181869f2f7435b51 ».  
  
 Pour plus d’informations sur la façon dont le common language runtime identifie et charge les assemblys, consultez [méthode de localisation des assemblys par le Runtime](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md). Pour plus d’informations sur l’utilisation du fichier de configuration d’application pour définir les emplacements de l’assembly, consultez [spécifiant l’emplacement d’un Assembly](~/docs/framework/configure-apps/specify-assembly-location.md). Si `assemblyName` est trouvé, il est chargé dans le contexte par défaut.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple suivant définit une classe nommée `Person` dans un assembly nommé `PersonInfo`. Notez que la `Person` classe possède deux constructeurs, y compris sans paramètre.  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 L’exemple suivant appelle la <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> méthode pour instancier le `Person` classe. Il requiert une référence à PersonInfo.dll à ajouter au projet. Étant donné que la <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> les appels de méthode le `Person` constructeur de classe par défaut, l’exemple affecte une valeur à son `Name` propriété.  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 Toutefois, <xref:System.Activator.CreateInstance%2A> est fréquemment appelée pour instancier un type qui dépasse les limites de l’ordinateur ou qui n’est pas connu au moment du design. Dans ce cas, vous ne pouvez pas inclure une référence à l’assembly dans le projet et ne peut pas effectuer des appels de liaison anticipée pour les membres du type. Pour contourner cette limitation, l’exemple suivant utilise le <xref:System.Activator.CreateInstance%2A> (méthode), ainsi que la réflexion pour affecter une valeur à la `Person` l’objet `Name` propriété et afficher sa valeur.  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Vous ne pouvez pas créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" /> ou de tableaux de ces types n’est pas prise en charge.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
 - ou -  
  
 Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quelle que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <param name="nonPublic">
          <see langword="true" /> si un constructeur par défaut public ou non public peut correspondre ; <see langword="false" /> si seul un constructeur public par défaut peut correspondre.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur par défaut de ce type.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres et types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les membres et types non publics est limité à l’appelant de l’accorder défini ou à un sous-ensemble de ce. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
 - ou -  
  
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - ou -  
  
 La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
 - ou -  
  
 L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quelle que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur à appeler doit être accessible et doit fournir la correspondance la plus spécifique avec la liste d’arguments spécifiés.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> méthode pour créer un <xref:System.String> objet. Il appelle le <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> constructeur pour instancier une chaîne qui contient les dix éléments à partir d’un tableau de caractères en commençant à la position quatorzième.  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 L’exemple suivant crée un tableau en escalier, dont les éléments sont des arguments à passer à un <xref:System.String> constructeur. L’exemple passe ensuite chaque tableau à la <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> méthode à appeler le constructeur de la chaîne appropriée.  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
 - ou -  
  
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - ou -  
  
 La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
 - ou -  
  
 L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
 - ou -  
  
 Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.MemberAccessException" />, à la place.  
  
</para>
          </block>  
  
 L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.MissingMemberException" />, à la place.  
  
</para>
          </block>  
  
 Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quelle que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine distant dans lequel le type nommé <c>typeName</c> est créé.</param>
        <param name="assemblyName">Nom de l’assembly dans lequel le type nommé <c>typeName</c> est recherché. Si <c>assemblyName</c> a la valeur <see langword="null" />, la recherche s’effectue dans l’assembly en cours d’exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant l'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstance%2A> lorsqu’un ordinateur hôte doit exécuter du code dans un domaine d’application qui a des autorisations de sécurité limitées.  
  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  Cette méthode utilise <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> pour que l’appelant immédiat d’avoir une confiance totale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ou <paramref name="domain" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d'un type abstrait.  
  
 - ou -  
  
 Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" /> ou de tableaux de ces types n’est pas prise en charge.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
 - ou -  
  
 Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour pouvoir appeler des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de l’assembly dans lequel le type nommé <c>typeName</c> est recherché. Si <c>assemblyName</c> a la valeur <see langword="null" />, la recherche s’effectue dans l’assembly en cours d’exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
 Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié, en utilisant l'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des types non publics est limité au jeu d’autorisations de l’appelant ou à un sous-ensemble de ce. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
 - ou -  
  
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
 - ou -  
  
 <paramref name="activationAttributes" /> n'est pas <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />.  
  
 .</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
 - ou -  
  
 Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Une erreur s'est produite lorsque la tentative d'activation à distance dans une cible spécifié dans <paramref name="activationAttributes" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quelle que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
 Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur à appeler doit être accessible et doit fournir la correspondance la plus spécifique avec la liste d’arguments spécifiés.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
 - ou -  
  
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - ou -  
  
 La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
 - ou -  
  
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
 - ou -  
  
 L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
 - ou -  
  
 Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quelle que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>type</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <c>bindingAttr</c> et <c>args</c> pour rechercher et identifier le constructeur <c>type</c>. Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>type</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur à appeler doit fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée sous les contraintes du binder spécifié et les attributs de liaison.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres et types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les membres et types non publics est limité à l’appelant de l’accorder défini ou à un sous-ensemble de ce. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
 - ou -  
  
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - ou -  
  
 La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
 - ou -  
  
 L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
 - ou -  
  
 Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou de <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quelle que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>type</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <c>bindingAttr</c> et <c>args</c> pour rechercher et identifier le constructeur <c>type</c>. Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>type</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
 Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur à appeler doit fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée sous les contraintes du binder spécifié et les attributs de liaison.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres et types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de membres et les types non publics est limité à de l’appelant jeu d’autorisations ou à un de ses sous-ensembles. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
 - ou -  
  
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 - ou -  
  
 La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
 - ou -  
  
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
 - ou -  
  
 L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
 - ou -  
  
 Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou de <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour en fournissant la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quelle que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de l’assembly dans lequel le type nommé <c>typeName</c> est recherché. Si <c>assemblyName</c> a la valeur <see langword="null" />, la recherche s’effectue dans l’assembly en cours d’exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <c>typeName</c> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <c>bindingAttr</c> et <c>args</c> pour rechercher et identifier le constructeur <c>typeName</c>. Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
 Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié, à l'aide de l'assembly nommé et du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des membres et types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les membres et types non publics est limité à l’appelant de l’accorder défini ou à un sous-ensemble de ce. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5.)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
 - ou -  
  
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
 - ou -  
  
 Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
 - ou -  
  
 Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quelle que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine dans lequel le type nommé <c>typeName</c> est créé.</param>
        <param name="assemblyName">Nom de l’assembly dans lequel le type nommé <c>typeName</c> est recherché. Si <c>assemblyName</c> a la valeur <see langword="null" />, la recherche s’effectue dans l’assembly en cours d’exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <c>typeName</c> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <c>bindingAttr</c> et <c>args</c> pour rechercher et identifier le constructeur <c>typeName</c>. Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
 Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant l'assembly nommé et le constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstance%2A> lorsqu’un ordinateur hôte doit exécuter du code dans un domaine d’application qui a des autorisations de sécurité limitées.  
  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  Cette méthode utilise <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> pour que l’appelant immédiat d’avoir une confiance totale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
 - ou -  
  
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
 - ou -  
  
 Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
 - ou -  
  
 Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour pouvoir appeler des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de l’assembly dans lequel le type nommé <c>typeName</c> est recherché. Si <c>assemblyName</c> a la valeur <see langword="null" />, la recherche s’effectue dans l’assembly en cours d’exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <c>typeName</c> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <c>bindingAttr</c> et <c>args</c> pour rechercher et identifier le constructeur <c>typeName</c>. Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
 Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <param name="securityInfo">Informations utilisées pour prendre des décisions de stratégie de sécurité et accorder des autorisations de code.</param>
        <summary>Crée une instance du type dont le nom est spécifié, à l'aide de l'assembly nommé et du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des membres et types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les membres et types non publics est limité à l’appelant de l’accorder défini ou à un sous-ensemble de ce. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
 - ou -  
  
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
 - ou -  
  
 Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
 - ou -  
  
 Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quelle que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine dans lequel le type nommé <c>typeName</c> est créé.</param>
        <param name="assemblyName">Nom de l’assembly dans lequel le type nommé <c>typeName</c> est recherché. Si <c>assemblyName</c> a la valeur <see langword="null" />, la recherche s’effectue dans l’assembly en cours d’exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <c>typeName</c> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <c>bindingAttr</c> et <c>args</c> pour rechercher et identifier le constructeur <c>typeName</c>. Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit généralement d'un tableau qui contient un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> spécifie l'URL qui est requise pour activer un objet distant.</param>
        <param name="securityAttributes">Informations utilisées pour prendre des décisions de stratégie de sécurité et accorder des autorisations de code.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant l'assembly nommé et le constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstance%2A> lorsqu’un ordinateur hôte doit exécuter du code dans un domaine d’application qui a des autorisations de sécurité limitées.  
  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  Cette méthode utilise <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> pour que l’appelant immédiat d’avoir une confiance totale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
 - ou -  
  
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
 - ou -  
  
 Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
 - ou -  
  
 Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour pouvoir appeler des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Type à créer.</typeparam>
        <summary>Crée une instance du type désigné par le paramètre de type générique spécifié, à l’aide du constructeur sans paramètre.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Activator.CreateInstance%60%601> méthode générique est utilisée par les compilateurs pour implémenter l’instanciation des types spécifiés par les paramètres de type. Par exemple, dans la méthode générique suivante, l’implémentation de `new T()` (`gcnew T()` en C++) utilise le <xref:System.Activator.CreateInstance%60%601> méthode générique.  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 En général, il n’est pas le <xref:System.Activator.CreateInstance%60%601> le code d’une méthode générique dans une application, car le type doit être connu au moment de la compilation. Si le type est connu au moment de la compilation, la syntaxe d’instanciation normale peut être utilisée (`new` opérateur en c#, `New` en Visual Basic, `gcnew` en C++). Si le type n’est pas connu au moment de la compilation, vous pouvez appeler une surcharge non générique de <xref:System.Activator.CreateInstance%2A>.  
  
 Aucune surcharge de la <xref:System.Activator.CreateInstance%60%601> une méthode générique qui prennent des listes d’arguments, étant donné que les surcharges non génériques de <xref:System.Activator.CreateInstance%2A> fournissent déjà une résolution de constructeur à liaison tardive.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.MissingMemberException" />, à la place.  
  
</para>
          </block>  
  
 Le type qui est spécifié pour <paramref name="T" /> ne comporte pas de constructeur sans paramètre.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance du type dont le nom est spécifié, à l'aide du fichier d'assembly nommé et du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom d’un fichier qui contient un assembly dans lequel le type nommé <c>typeName</c> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <summary>Crée une instance du type dont le nom est spécifié, en utilisant le fichier d'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Pour plus d’informations sur les autres exceptions pouvant être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Activator.CreateInstanceFrom%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Activator> classe.  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant a les <see cref="T:System.Security.Permissions.FileIOPermission" /> nécessaires.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher des chemins d’accès et lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quelle que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine distant dans lequel le type nommé <c>typeName</c> est créé.</param>
        <param name="assemblyFile">Nom d’un fichier qui contient un assembly dans lequel le type nommé <c>typeName</c> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant le fichier d'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstanceFrom%2A> lorsqu’un ordinateur hôte doit exécuter du code dans un domaine d’application qui a des autorisations de sécurité limitées.  
  
 Utilisez la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  Cette méthode utilise <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> pour que l’appelant immédiat d’avoir une confiance totale.  
  
 Pour plus d’informations sur les autres exceptions pouvant être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant a les <see cref="T:System.Security.Permissions.FileIOPermission" /> nécessaires.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher des chemins d’accès et lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom d’un fichier qui contient un assembly dans lequel le type nommé <c>typeName</c> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
 Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié, en utilisant le fichier d'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Pour plus d’informations sur les autres exceptions pouvant être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant a les <see cref="T:System.Security.Permissions.FileIOPermission" /> nécessaires.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher des chemins d’accès et lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quelle que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom d’un fichier qui contient un assembly dans lequel le type nommé <c>typeName</c> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <c>typeName</c> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <c>bindingAttr</c> et <c>args</c> pour rechercher et identifier le constructeur <c>typeName</c>. Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
 Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié, à l'aide du fichier d'assembly nommé et du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Pour plus d’informations sur les autres exceptions pouvant être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation <see cref="T:System.Security.Permissions.FileIOPermission" /> requise.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher des chemins d’accès et lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quelle que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine distant dans lequel le type nommé <c>typeName</c> est créé.</param>
        <param name="assemblyFile">Nom d’un fichier qui contient un assembly dans lequel le type nommé <c>typeName</c> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <c>typeName</c> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <c>bindingAttr</c> et <c>args</c> pour rechercher et identifier le constructeur <c>typeName</c>. Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
 Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant le fichier d'assembly nommé et le constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstanceFrom%2A> lorsqu’un ordinateur hôte doit exécuter du code dans un domaine d’application qui a des autorisations de sécurité limitées.  
  
 Utilisez la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Pour plus d’informations sur les autres exceptions pouvant être levées par des méthodes appelées, consultez les sections d’Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant a les <see cref="T:System.Security.Permissions.FileIOPermission" /> nécessaires.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
 - ou -  
  
 <paramref name="assemblyName" /> a été compilé pour une version du common language runtime qui est ultérieur à la version chargée actuellement.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour en fournissant la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher des chemins d’accès et lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quelle que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom d’un fichier qui contient un assembly dans lequel le type nommé <c>typeName</c> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <c>typeName</c> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <c>bindingAttr</c> et <c>args</c> pour rechercher et identifier le constructeur <c>typeName</c>. Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
 Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <param name="securityInfo">Informations utilisées pour prendre des décisions de stratégie de sécurité et accorder des autorisations de code.</param>
        <summary>Crée une instance du type dont le nom est spécifié, à l'aide du fichier d'assembly nommé et du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Pour plus d’informations sur les autres exceptions pouvant être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation <see cref="T:System.Security.Permissions.FileIOPermission" /> requise.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher des chemins d’accès et lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quelle que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine distant dans lequel le type nommé <c>typeName</c> est créé.</param>
        <param name="assemblyFile">Nom d’un fichier qui contient un assembly dans lequel le type nommé <c>typeName</c> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <c>typeName</c> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <c>bindingAttr</c> et <c>args</c> pour rechercher et identifier le constructeur <c>typeName</c>. Si <c>binder</c> a la valeur <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <c>args</c> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
 Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <param name="securityAttributes">Informations utilisées pour prendre des décisions de stratégie de sécurité et accorder des autorisations de code.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant le fichier d'assembly nommé et le constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstanceFrom%2A> lorsqu’un ordinateur hôte doit exécuter du code dans un domaine d’application qui a des autorisations de sécurité limitées.  
  
 Utilisez la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  Cette méthode utilise <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> pour que l’appelant immédiat d’avoir une confiance totale.  
  
 Pour plus d’informations sur les autres exceptions pouvant être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant a les <see cref="T:System.Security.Permissions.FileIOPermission" /> nécessaires.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
 - ou -  
  
 Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour en fournissant la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher des chemins d’accès et lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quelle que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un proxy pour un objet ou service web XML connu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet connu auquel vous souhaitez vous connecter.</param>
        <param name="url">URL de l'objet connu.</param>
        <summary>Crée un proxy pour l'objet connu indiqué par le type et l'URL spécifiés.</summary>
        <returns>Proxy qui désigne un point de terminaison pris en charge par l'objet connu demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le proxy pour envoyer des messages à l’objet distant. Aucuns messages ne sont envoyés sur le réseau jusqu'à ce qu’une méthode est appelée sur le proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="url" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> n'est pas marshalé par référence et n'est pas une interface.</exception>
        <exception cref="T:System.MemberAccessException">Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet connu auquel vous souhaitez vous connecter.</param>
        <param name="url">URL de l'objet connu.</param>
        <param name="state">Données propres au canal ou <see langword="null" />.</param>
        <summary>Crée un proxy pour l'objet connu indiqué par le type, l'URL et les données de canal spécifiés.</summary>
        <returns>Proxy qui désigne un point de terminaison pris en charge par l'objet connu demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le proxy pour envoyer des messages à l’objet distant. Aucuns messages ne sont envoyés sur le réseau jusqu'à ce qu’une méthode est appelée sur le proxy.  
  
 Le `state` paramètre communique des informations au canal et est passé à la <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="url" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> n'est pas marshalé par référence et n'est pas une interface.</exception>
        <exception cref="T:System.MemberAccessException">Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="rgszNames">Tableau passé des noms à mapper.</param>
        <param name="cNames">Nombre de noms à mapper.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les noms.</param>
        <param name="rgDispId">Tableau alloué par l'appelant qui reçoit les ID correspondant aux noms.</param>
        <summary>Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informations de type à retourner.</param>
        <param name="lcid">Identificateur des paramètres régionaux pour les informations de type.</param>
        <param name="ppTInfo">Objet qui reçoit un pointeur vers l'objet d'informations de type demandé.</param>
        <summary>Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Cette méthode retourne un pointeur vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet. Ce paramètre est passé sans être initialisé.</param>
        <summary>Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identificateur de dispatch qui identifie le membre.</param>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les arguments.</param>
        <param name="wFlags">Indicateurs décrivant le contexte de l'appel.</param>
        <param name="pDispParams">Pointeur vers une structure qui contient un tableau d'arguments, un tableau d'arguments DISPID pour les arguments nommés et le nombre d'éléments dans les tableaux.</param>
        <param name="pVarResult">Pointeur vers l'emplacement où le résultat doit être stocké.</param>
        <param name="pExcepInfo">Pointeur vers une structure qui contient les informations sur les exceptions.</param>
        <param name="puArgErr">Index du premier argument comportant une erreur.</param>
        <summary>Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
  </Members>
</Type>