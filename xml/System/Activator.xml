<Type Name="Activator" FullName="System.Activator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="653dee04e0aeaaf8b5bb35be34df72ee8bf2dfa1" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52255417" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <TypeSignature Language="F#" Value="type Activator = class&#xA;    interface _Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Contient des méthodes permettant de créer des types d'objets localement ou à distance, ou d'obtenir des références à des objets distants existants. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Activator.CreateInstance%2A> méthode crée une instance d’un type défini dans un assembly en appelant le constructeur qui correspond le mieux les arguments spécifiés. Si aucun argument n’est spécifié, le constructeur qui ne prend aucun paramètre, autrement dit, le constructeur par défaut, est appelé.  
  
 Vous devez disposer des autorisations suffisantes pour rechercher et appeler un constructeur ; Sinon, une exception est levée. Par défaut, seuls les constructeurs publics sont considérés comme lors de la recherche d’un constructeur. Si aucun constructeur ou un constructeur par défaut ne peut être trouvé, une exception est levée.  
  
 Un paramètre binder spécifie un objet qui recherche un assembly pour un constructeur approprié. Vous pouvez spécifier votre propre classeur et critères de recherche. Si aucun classeur n’est spécifié, un binder par défaut est utilisé. Pour plus d'informations, consultez la classe <xref:System.Reflection.Binder?displayProperty=nameWithType> et <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Un paramètre de preuve affecte la stratégie de sécurité et les autorisations pour le constructeur. Pour plus d'informations, consultez la classe <xref:System.Security.Policy.Evidence?displayProperty=nameWithType>.  
  
 Une instance d’un type peut être créée sur un site local ou distant. Si le type est créé à distance, un paramètre d’attribut d’activation Spécifie l’URI du site distant. L’appel pour créer l’instance peut passer par des sites intermédiaires avant d’atteindre le site distant. Autres attributs d’activation peuvent modifier l’environnement ou le contexte, dans lequel l’appel opère sur les sites distants et intermédiaires.  
  
 Si l’instance est créée localement, une référence à cet objet est retournée. Si l’instance est créée à distance, une référence à un proxy est retournée. L’objet distant est manipulé par le biais du proxy comme s’il s’agissait d’un objet local.  
  
 Le <xref:System.Activator.GetObject%2A> méthode crée un proxy à un objet en cours d’exécution à distance, un objet de connu activé par le serveur ou un service Web XML. Vous pouvez spécifier le support de connexion, autrement dit, le canal. Pour plus d'informations, consultez la classe <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType>.  
  
 Les assemblys contiennent des définitions de type. Le <xref:System.Activator.CreateInstance%2A> méthode crée une instance d’un type à partir d’un assembly en cours d’exécution. Le <xref:System.Activator.CreateInstanceFrom%2A> méthode crée une instance d’un fichier qui contient un assembly. Le <xref:System.Activator.CreateComInstanceFrom%2A> méthode crée une instance d’un objet COM à partir d’un fichier qui contient un assembly.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Activator> classe pour construire dynamiquement des objets en cours d’exécution.  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance de l'objet COM dont le nom est spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom d'un fichier qui contient un assembly dans lequel le type nommé <paramref name="typeName" /> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <summary>Crée une instance de l'objet COM dont le nom est spécifié, en utilisant le fichier d'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Un <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribut avec une valeur de `true` doit être explicitement ou par défaut appliqué au type COM afin que la <xref:System.Activator.CreateComInstanceFrom%2A> méthode peut créer une instance de ce type ; sinon, <xref:System.TypeLoadException> est levée.  
  
 Pour plus d’informations sur les autres exceptions qui peuvent être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ou <paramref name="assemblyName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Il est impossible de créer une instance par l’intermédiaire de COM.  
  
- ou - 
 <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable ou le module que vous essayez de charger ne spécifie pas une extension de nom de fichier.</exception>
        <exception cref="T:System.MemberAccessException">Il est impossible de créer une instance d’une classe abstraite.  
  
- ou - 
Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> est la chaîne vide ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quel que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom d'un fichier qui contient un assembly dans lequel le type nommé <paramref name="typeName" /> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="hashValue">Valeur du code de hachage calculé.</param>
        <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les fichiers et générer le nom fort.</param>
        <summary>Crée une instance de l'objet COM dont le nom est spécifié, en utilisant le fichier d'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Un <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribut avec une valeur de `true` doit être explicitement ou par défaut appliqué au type COM afin que la <xref:System.Activator.CreateComInstanceFrom%2A> méthode peut créer une instance de ce type ; sinon, <xref:System.TypeLoadException> est levée.  
  
 Pour plus d’informations sur les autres exceptions qui peuvent être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ou <paramref name="assemblyName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> est la chaîne vide ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.
        
- ou - 
 <paramref name="assemblyName" /> dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable ou le module que vous essayez de charger ne spécifie pas une extension de nom de fichier.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> a été trouvé, mais impossible de le charger.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.</exception>
        <exception cref="T:System.Security.SecurityException">Une base de code qui ne commence pas par “file://” a été spécifiée sans le <see langword="WebPermission" /> requis.</exception>
        <exception cref="T:System.TypeLoadException">Impossible de créer une instance par l’intermédiaire de COM.  
  
- ou - 
 <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite.  
  
- ou - 
Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quel que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire un URI qui commence par « file:// ». Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance du type spécifié à l'aide du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance activationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Objet de contexte d’activation qui spécifie l’objet à créer.</param>
        <summary>Crée une instance du type désigné par l'objet <see cref="T:System.ActivationContext" /> spécifié.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à l'objet créé récemment.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Le contexte d’activation est utilisé pendant l’activation basée sur un manifeste pour définir la stratégie de domaine et fournissent un modèle de sécurité basée sur l’application. Le <xref:System.ActivationContext> classe contient un <xref:System.ApplicationIdentity> objet qui fournit l’accès au manifeste d’application. Pour plus d'informations, consultez la classe <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type -&gt; obj" Usage="System.Activator.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur par défaut de ce type.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur à appeler doit être accessible.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Activator.CreateInstance%28System.Type%29> (méthode). Instances de plusieurs types différents sont créés et leurs valeurs par défaut sont affichés.  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
- ou - 
L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.MemberAccessException" />, à la place.  
  
</para>
          </block>  
  
 L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.MissingMemberException" />, à la place.  
  
</para>
          </block>  
  
 Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics indépendamment de leurs jeux d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext * string[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (activationContext, activationCustomData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
        <Parameter Name="activationCustomData" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="activationContext">Objet de contexte d’activation qui spécifie l’objet à créer.</param>
        <param name="activationCustomData">Tableau de chaînes Unicode qui contiennent les données d'activation personnalisées.</param>
        <summary>Crée une instance du type désigné par l'objet <see cref="T:System.ActivationContext" /> spécifié et activé avec les données d'activation personnalisées spécifiées.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à l'objet créé récemment.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Le contexte d’activation est utilisé pendant l’activation basée sur un manifeste pour définir la stratégie de domaine et fournissent un modèle de sécurité basée sur l’application. Le <xref:System.ActivationContext> classe contient un <xref:System.ApplicationIdentity> objet qui fournit l’accès au manifeste d’application. Pour plus d'informations, consultez la classe <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de l'assembly dans lequel le type nommé <paramref name="typeName" /> est recherché. Si <paramref name="assemblyName" /> est <see langword="null" />, la recherche s'effectue dans l'assembly en cours d'exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <summary>Crée une instance du type dont le nom est spécifié, en utilisant l'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
 `assemblyName` peut être une des opérations suivantes :  
  
-   Le nom simple d’un assembly, sans son extension de fichier ou chemin d’accès. Par exemple, vous devez spécifier `TypeExtensions` pour un assembly dont chemin d’accès et le nom est.\bin\TypeExtensions.dll.  
  
-   Le nom complet d’un assembly signé, ce qui se compose de son nom simple, la version, culture et jeton de clé publique ; par exemple, « TypeExtensions, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 181869f2f7435b51 ».  
  
 Pour plus d’informations sur la manière dont le common language runtime identifie et charge les assemblys, consultez [méthode de localisation des assemblys par le Runtime](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md). Pour plus d’informations sur l’utilisation de son fichier de configuration pour définir les emplacements de l’assembly, consultez [spécifiant l’emplacement d’un Assembly](~/docs/framework/configure-apps/specify-assembly-location.md). Si `assemblyName` est trouvé, il est chargé dans le contexte par défaut.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple suivant définit une classe nommée `Person` dans un assembly nommé `PersonInfo`. Notez que la `Person` classe possède deux constructeurs, un d'entre eux n’a aucun paramètre.  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 L’exemple suivant appelle la <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> méthode pour instancier le `Person` classe. Cela nécessite une référence à PersonInfo.dll à ajouter au projet. Étant donné que le <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> les appels de méthode le `Person` constructeur de classe par défaut, l’exemple affecte une valeur à son `Name` propriété.  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 Toutefois, <xref:System.Activator.CreateInstance%2A> est fréquemment appelée pour instancier un type qui traverse les limites de l’ordinateur ou qui n’est pas connu au moment du design. Dans ce cas, vous ne pouvez pas inclure une référence à l’assembly dans le projet et ne peut pas effectuer des appels à liaison anticipée pour les membres du type. Pour contourner cette limitation, l’exemple suivant utilise le <xref:System.Activator.CreateInstance%2A> (méthode), ainsi que la réflexion pour affecter une valeur à la `Person` l’objet `Name` propriété et afficher sa valeur.  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Vous ne pouvez pas créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" /> ou de tableaux de ces types n’est pas prise en charge.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
- ou - 
Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quel que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * bool -&gt; obj" Usage="System.Activator.CreateInstance (type, nonPublic)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <param name="nonPublic">
          <see langword="true" /> si un constructeur par défaut public ou non public peut correspondre ; <see langword="false" /> si seul un constructeur public par défaut peut correspondre.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur par défaut de ce type.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres et types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les membres et types non publics est limité à l’appelant accorder défini ou à un sous-ensemble de ce. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
- ou - 
L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quel que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur à appeler doit être accessible et doit fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> méthode pour créer un <xref:System.String> objet. Il appelle le <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> constructeur pour instancier une chaîne qui contient les dix éléments à partir d’un tableau de caractères en commençant à la position quatorzième.  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 L’exemple suivant crée un tableau en escalier, dont les éléments sont des arguments à passer à un <xref:System.String> constructeur. Cet exemple passe ensuite chaque tableau pour le <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> méthode à appeler le constructeur de la chaîne appropriée.  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
- ou - 
L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- ou - 
Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.MemberAccessException" />, à la place.  
  
</para>
          </block>  
  
 L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.MissingMemberException" />, à la place.  
  
</para>
          </block>  
  
 Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quel que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine distant dans lequel le type nommé <paramref name="typeName" /> est créé.</param>
        <param name="assemblyName">Nom de l'assembly dans lequel le type nommé <paramref name="typeName" /> est recherché. Si <paramref name="assemblyName" /> est <see langword="null" />, la recherche s'effectue dans l'assembly en cours d'exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant l'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstance%2A> quand un ordinateur hôte doit exécuter du code dans un domaine d’application qui restreint les autorisations de sécurité.  
  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  Cette méthode utilise <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> pour que l’appelant immédiat avoir une confiance totale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ou <paramref name="domain" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d'un type abstrait.  
  
- ou - 
Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" /> ou de tableaux de ces types n’est pas prise en charge.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
- ou - 
Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">pour la capacité d’invoquer des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de l'assembly dans lequel le type nommé <paramref name="typeName" /> est recherché. Si <paramref name="assemblyName" /> est <see langword="null" />, la recherche s'effectue dans l'assembly en cours d'exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié, en utilisant l'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des types non publics est limité au jeu d’autorisations de l’appelant ou à un sous-ensemble de ce. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
- ou - 
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
 <paramref name="activationAttributes" /> n’est pas un tableau <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />  
  
.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
- ou - 
Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Une erreur s’est produite lors de la tentative d’activation à distance dans une cible spécifiée dans <paramref name="activationAttributes" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quel que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur à appeler doit être accessible et doit fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les types non publics est limité à l’octroi de l’appelant Définissez ou à un sous-ensemble de celle-ci. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
- ou - 
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- ou - 
Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quel que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <paramref name="type" />. Si <paramref name="bindingAttr" /> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <paramref name="bindingAttr" /> et <paramref name="args" /> pour rechercher et identifier le constructeur <paramref name="type" />. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <paramref name="args" /> pour les types formels déclarés du constructeur <paramref name="type" />. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur à appeler doit fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée sous les contraintes du binder spécifié et des attributs de liaison.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres et types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les membres et types non publics est limité à l’appelant accorder défini ou à un sous-ensemble de ce. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
- ou - 
L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- ou - 
Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou de <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quel que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet à créer.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <paramref name="type" />. Si <paramref name="bindingAttr" /> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <paramref name="bindingAttr" /> et <paramref name="args" /> pour rechercher et identifier le constructeur <paramref name="type" />. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <paramref name="args" /> pour les types formels déclarés du constructeur <paramref name="type" />. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié à l'aide du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur à appeler doit fournir la correspondance la plus spécifique avec la liste d’arguments spécifiée sous les contraintes du binder spécifié et des attributs de liaison.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres et types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de membres et les types non publics est limité à l’appelant octroyer le jeu ou à un de ses sous-ensembles. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> n'est pas un <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> ne peut pas être <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
- ou - 
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
L’assembly qui contient <paramref name="type" /> est un assembly dynamique qui a été créé avec <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- ou - 
Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur appelé lève une exception.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu par l’intermédiaire de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou de <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> est un objet COM, mais l’identificateur de classe utilisé pour obtenir le type n’est pas valide, ou la classe identifiée n’est pas inscrite.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> n’est pas un type valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour apporter une preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quel que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de l'assembly dans lequel le type nommé <paramref name="typeName" /> est recherché. Si <paramref name="assemblyName" /> est <see langword="null" />, la recherche s'effectue dans l'assembly en cours d'exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <paramref name="typeName" /> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <paramref name="typeName" />. Si <paramref name="bindingAttr" /> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <paramref name="bindingAttr" /> et <paramref name="args" /> pour rechercher et identifier le constructeur <paramref name="typeName" />. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <paramref name="args" /> pour les types formels déclarés du constructeur <paramref name="typeName" />. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié, à l'aide de l'assembly nommé et du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des membres et types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les membres et types non publics est limité à l’appelant accorder défini ou à un sous-ensemble de ce. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
- ou - 
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
- ou - 
Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quel que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine dans lequel le type nommé <paramref name="typeName" /> est créé.</param>
        <param name="assemblyName">Nom de l'assembly dans lequel le type nommé <paramref name="typeName" /> est recherché. Si <paramref name="assemblyName" /> est <see langword="null" />, la recherche s'effectue dans l'assembly en cours d'exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <paramref name="typeName" /> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <paramref name="typeName" />. Si <paramref name="bindingAttr" /> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <paramref name="bindingAttr" /> et <paramref name="args" /> pour rechercher et identifier le constructeur <paramref name="typeName" />. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <paramref name="args" /> pour les types formels déclarés du constructeur <paramref name="typeName" />. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant l'assembly nommé et le constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstance%2A> quand un ordinateur hôte doit exécuter du code dans un domaine d’application qui restreint les autorisations de sécurité.  
  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  Cette méthode utilise <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> pour que l’appelant immédiat avoir une confiance totale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
- ou - 
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
- ou - 
Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">pour la capacité d’invoquer des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de l'assembly dans lequel le type nommé <paramref name="typeName" /> est recherché. Si <paramref name="assemblyName" /> est <see langword="null" />, la recherche s'effectue dans l'assembly en cours d'exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <paramref name="typeName" /> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <paramref name="typeName" />. Si <paramref name="bindingAttr" /> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <paramref name="bindingAttr" /> et <paramref name="args" /> pour rechercher et identifier le constructeur <paramref name="typeName" />. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <paramref name="args" /> pour les types formels déclarés du constructeur <paramref name="typeName" />. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <param name="securityInfo">Informations utilisées pour prendre des décisions de stratégie de sécurité et accorder des autorisations de code.</param>
        <summary>Crée une instance du type dont le nom est spécifié, à l'aide de l'assembly nommé et du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour créer des membres et types non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations de l’assembly qui contient les membres et types non publics est limité à l’appelant accorder défini ou à un sous-ensemble de ce. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
- ou - 
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
- ou - 
Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quel que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine dans lequel le type nommé <paramref name="typeName" /> est créé.</param>
        <param name="assemblyName">Nom de l'assembly dans lequel le type nommé <paramref name="typeName" /> est recherché. Si <paramref name="assemblyName" /> est <see langword="null" />, la recherche s'effectue dans l'assembly en cours d'exécution.</param>
        <param name="typeName">Nom qualifié complet du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <paramref name="typeName" /> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <paramref name="typeName" />. Si <paramref name="bindingAttr" /> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <paramref name="bindingAttr" /> et <paramref name="args" /> pour rechercher et identifier le constructeur <paramref name="typeName" />. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <paramref name="args" /> pour les types formels déclarés du constructeur <paramref name="typeName" />. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit généralement d'un tableau qui contient un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> spécifie l'URL qui est requise pour activer un objet distant.</param>
        <param name="securityAttributes">Informations utilisées pour prendre des décisions de stratégie de sécurité et accorder des autorisations de code.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant l'assembly nommé et le constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstance%2A> quand un ordinateur hôte doit exécuter du code dans un domaine d’application qui restreint les autorisations de sécurité.  
  
 Utilisez <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  Cette méthode utilise <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> pour que l’appelant immédiat avoir une confiance totale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Le type COM n’a pas été obtenu via <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La création de types <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> et <see cref="T:System.RuntimeArgumentHandle" />, ou de tableaux de ces types, n’est pas prise en charge.  
  
- ou - 
 <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
Le constructeur qui correspond le mieux à <paramref name="args" /> a des arguments <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.  
  
- ou - 
Le nom de l’assembly ou la base de code n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">pour la capacité d’invoquer des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberSignature Language="F#" Value="static member CreateInstance : unit -&gt; 'T" Usage="System.Activator.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Type à créer.</typeparam>
        <summary>Crée une instance du type désigné par le paramètre de type générique spécifié, à l’aide du constructeur sans paramètre.</summary>
        <returns>Référence au nouvel objet créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Activator.CreateInstance%60%601> méthode générique est utilisé par les compilateurs pour implémenter l’instanciation des types spécifiés par les paramètres de type. Par exemple, dans la méthode générique suivante, l’implémentation de `new T()` (`gcnew T()` en C++) utilise le <xref:System.Activator.CreateInstance%60%601> méthode générique.  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 En règle générale, il n’existe aucune utilité pour la <xref:System.Activator.CreateInstance%60%601> une méthode générique dans une application de code, car le type doit être connu au moment de la compilation. Si le type est connu au moment de la compilation, la syntaxe d’instanciation normale peut être utilisée (`new` opérateur en c#, `New` en Visual Basic, `gcnew` dans C++). Si le type n’est pas connu au moment de la compilation, vous pouvez appeler une surcharge non générique de <xref:System.Activator.CreateInstance%2A>.  
  
 Aucune surcharge de la <xref:System.Activator.CreateInstance%60%601> une méthode générique qui acceptent des listes d’arguments, étant donné que les surcharges non génériques de <xref:System.Activator.CreateInstance%2A> fournissent déjà une résolution de constructeur à liaison tardive.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.MissingMemberException" />, à la place.  
  
</para>
          </block>  
  
 Le type qui est spécifié pour <paramref name="T" /> n’a pas de constructeur sans paramètre.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance du type dont le nom est spécifié, à l'aide du fichier d'assembly nommé et du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom d'un fichier qui contient un assembly dans lequel le type nommé <paramref name="typeName" /> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <summary>Crée une instance du type dont le nom est spécifié, en utilisant le fichier d'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Pour plus d’informations sur les autres exceptions qui peuvent être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Activator.CreateInstanceFrom%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Activator> classe.  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant a les <see cref="T:System.Security.Permissions.FileIOPermission" /> nécessaires.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher les chemins d’accès de répertoire et de lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quel que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine distant dans lequel le type nommé <paramref name="typeName" /> est créé.</param>
        <param name="assemblyFile">Nom d'un fichier qui contient un assembly dans lequel le type nommé <paramref name="typeName" /> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant le fichier d'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstanceFrom%2A> quand un ordinateur hôte doit exécuter du code dans un domaine d’application qui restreint les autorisations de sécurité.  
  
 Utilisez le <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  Cette méthode utilise <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> pour que l’appelant immédiat avoir une confiance totale.  
  
 Pour plus d’informations sur les autres exceptions qui peuvent être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant a les <see cref="T:System.Security.Permissions.FileIOPermission" /> nécessaires.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher les chemins d’accès de répertoire et de lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom d'un fichier qui contient un assembly dans lequel le type nommé <paramref name="typeName" /> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié, en utilisant le fichier d'assembly nommé et le constructeur par défaut.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Pour plus d’informations sur les autres exceptions qui peuvent être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant a les <see cref="T:System.Security.Permissions.FileIOPermission" /> nécessaires.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher les chemins d’accès de répertoire et de lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder à des types non publics, quel que soit leur jeu d’autorisations. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom d'un fichier qui contient un assembly dans lequel le type nommé <paramref name="typeName" /> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <paramref name="typeName" /> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <paramref name="typeName" />. Si <paramref name="bindingAttr" /> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <paramref name="bindingAttr" /> et <paramref name="args" /> pour rechercher et identifier le constructeur <paramref name="typeName" />. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <paramref name="args" /> pour les types formels déclarés du constructeur <paramref name="typeName" />. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié, à l'aide du fichier d'assembly nommé et du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Pour plus d’informations sur les autres exceptions qui peuvent être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation <see cref="T:System.Security.Permissions.FileIOPermission" /> requise.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher les chemins d’accès de répertoire et de lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quel que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine distant dans lequel le type nommé <paramref name="typeName" /> est créé.</param>
        <param name="assemblyFile">Nom d'un fichier qui contient un assembly dans lequel le type nommé <paramref name="typeName" /> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <paramref name="typeName" /> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <paramref name="typeName" />. Si <paramref name="bindingAttr" /> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <paramref name="bindingAttr" /> et <paramref name="args" /> pour rechercher et identifier le constructeur <paramref name="typeName" />. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <paramref name="args" /> pour les types formels déclarés du constructeur <paramref name="typeName" />. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant le fichier d'assembly nommé et le constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstanceFrom%2A> quand un ordinateur hôte doit exécuter du code dans un domaine d’application qui restreint les autorisations de sécurité.  
  
 Utilisez le <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Pour plus d’informations sur les autres exceptions qui peuvent être levées par des méthodes appelées, consultez les sections d’Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant a les <see cref="T:System.Security.Permissions.FileIOPermission" /> nécessaires.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
 <paramref name="assemblyName" /> a été compilé pour une version du common language runtime qui est ultérieur à la version chargée actuellement.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour apporter une preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher les chemins d’accès de répertoire et de lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quel que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom d'un fichier qui contient un assembly dans lequel le type nommé <paramref name="typeName" /> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <paramref name="typeName" /> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <paramref name="typeName" />. Si <paramref name="bindingAttr" /> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <paramref name="bindingAttr" /> et <paramref name="args" /> pour rechercher et identifier le constructeur <paramref name="typeName" />. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <paramref name="args" /> pour les types formels déclarés du constructeur <paramref name="typeName" />. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <param name="securityInfo">Informations utilisées pour prendre des décisions de stratégie de sécurité et accorder des autorisations de code.</param>
        <summary>Crée une instance du type dont le nom est spécifié, à l'aide du fichier d'assembly nommé et du constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
 Pour plus d’informations sur les autres exceptions qui peuvent être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation <see cref="T:System.Security.Permissions.FileIOPermission" /> requise.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher les chemins d’accès de répertoire et de lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quel que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine distant dans lequel le type nommé <paramref name="typeName" /> est créé.</param>
        <param name="assemblyFile">Nom d'un fichier qui contient un assembly dans lequel le type nommé <paramref name="typeName" /> est recherché.</param>
        <param name="typeName">Nom du type préféré.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour spécifier que la recherche de <paramref name="typeName" /> ne respecte pas la casse ; <see langword="false" /> pour spécifier que la recherche respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <paramref name="typeName" />. Si <paramref name="bindingAttr" /> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui utilise <paramref name="bindingAttr" /> et <paramref name="args" /> pour rechercher et identifier le constructeur <paramref name="typeName" />. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau d'arguments dont le nombre, l'ordre et le type correspondent aux paramètres du constructeur à appeler. Si <paramref name="args" /> est un tableau vide ou <see langword="null" />, le constructeur qui ne prend aucun paramètre (constructeur par défaut) est appelé.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <paramref name="args" /> pour les types formels déclarés du constructeur <paramref name="typeName" />. Si <paramref name="culture" /> est <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Il s'agit, en général, d'un tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <param name="securityAttributes">Informations utilisées pour prendre des décisions de stratégie de sécurité et accorder des autorisations de code.</param>
        <summary>Crée une instance du type dont le nom est spécifié dans le domaine distant spécifié, en utilisant le fichier d'assembly nommé et le constructeur qui correspond le mieux aux paramètres spécifiés.</summary>
        <returns>Handle qui doit être désencapsulé pour accéder à la nouvelle instance créée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Activator.CreateInstanceFrom%2A> quand un ordinateur hôte doit exécuter du code dans un domaine d’application qui restreint les autorisations de sécurité.  
  
 Utilisez le <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> méthode pour désencapsuler la valeur de retour.  
  
> [!NOTE]
>  Cette méthode utilise <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> pour que l’appelant immédiat avoir une confiance totale.  
  
 Pour plus d’informations sur les autres exceptions qui peuvent être levées par des méthodes appelées, consultez la section Exceptions de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> et <xref:System.Activator.CreateInstance%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas l’autorisation d’appeler ce constructeur.</exception>
        <exception cref="T:System.MemberAccessException">Impossible de créer une instance d’une classe abstraite, ou ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Le constructeur, qui a été appelé via la réflexion, a levé une exception.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant a les <see cref="T:System.Security.Permissions.FileIOPermission" /> nécessaires.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> n’est pas un tableau vide, et le type à créer ne dérive pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
Le CLR (Common Language Runtime) version 2.0 ou ultérieure est actuellement chargé et <paramref name="assemblyName" /> a été compilé pour une version du CLR qui est ultérieure à la version actuellement chargée. Notez que les versions 2.0, 3.0 et 3.5 du .NET Framework utilisent toutes le CLR version 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour apporter une preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la possibilité de rechercher les chemins d’accès de répertoire et de lire leur contenu. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres, quel que soit leur jeu d’autorisations et les types non publics. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un proxy pour un objet ou service web XML connu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string -&gt; obj" Usage="System.Activator.GetObject (type, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet connu auquel vous souhaitez vous connecter.</param>
        <param name="url">URL de l'objet connu.</param>
        <summary>Crée un proxy pour l'objet connu indiqué par le type et l'URL spécifiés.</summary>
        <returns>Proxy qui désigne un point de terminaison pris en charge par l'objet connu demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le proxy pour envoyer des messages à l’objet distant. Aucuns messages ne sont envoyés sur le réseau jusqu'à ce qu’une méthode est appelée sur le proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="url" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> n'est pas marshalé par référence et n'est pas une interface.</exception>
        <exception cref="T:System.MemberAccessException">Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string * obj -&gt; obj" Usage="System.Activator.GetObject (type, url, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet connu auquel vous souhaitez vous connecter.</param>
        <param name="url">URL de l'objet connu.</param>
        <param name="state">Données propres au canal ou <see langword="null" />.</param>
        <summary>Crée un proxy pour l'objet connu indiqué par le type, l'URL et les données de canal spécifiés.</summary>
        <returns>Proxy qui désigne un point de terminaison pris en charge par l'objet connu demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le proxy pour envoyer des messages à l’objet distant. Aucuns messages ne sont envoyés sur le réseau jusqu'à ce qu’une méthode est appelée sur le proxy.  
  
 Le `state` paramètre communique des informations au canal et est passé à la <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="url" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> n'est pas marshalé par référence et n'est pas une interface.</exception>
        <exception cref="T:System.MemberAccessException">Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="rgszNames">Tableau passé des noms à mapper.</param>
        <param name="cNames">Nombre de noms à mapper.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les noms.</param>
        <param name="rgDispId">Tableau alloué par l'appelant qui reçoit les ID correspondant aux noms.</param>
        <summary>Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informations de type à retourner.</param>
        <param name="lcid">Identificateur des paramètres régionaux pour les informations de type.</param>
        <param name="ppTInfo">Objet qui reçoit un pointeur vers l'objet d'informations de type demandé.</param>
        <summary>Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Cette méthode retourne un pointeur vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet. Ce paramètre est passé sans être initialisé.</param>
        <summary>Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identificateur de dispatch qui identifie le membre.</param>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les arguments.</param>
        <param name="wFlags">Indicateurs décrivant le contexte de l'appel.</param>
        <param name="pDispParams">Pointeur vers une structure qui contient un tableau d'arguments, un tableau d'arguments DISPID pour les arguments nommés et le nombre d'éléments dans les tableaux.</param>
        <param name="pVarResult">Pointeur vers l'emplacement où le résultat doit être stocké.</param>
        <param name="pExcepInfo">Pointeur vers une structure qui contient les informations sur les exceptions.</param>
        <param name="puArgErr">Index du premier argument comportant une erreur.</param>
        <summary>Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
  </Members>
</Type>