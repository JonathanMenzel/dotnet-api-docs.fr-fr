<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Array.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe075fe79373523154dee59083c1e0c45afe5404a045.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5fe79373523154dee59083c1e0c45afe5404a045</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</source>
          <target state="translated">Fournit des méthodes pour la création, la manipulation, la recherche ainsi que le tri des tableaux et sert de classe de base pour tous les tableaux du Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is not part of the <ph id="ph2">&lt;xref:System.Collections&gt;</ph> namespaces.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe n’est pas dans le cadre de la <ph id="ph2">&lt;xref:System.Collections&gt;</ph> espaces de noms.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, it is still considered a collection because it is based on the <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Toutefois, il est toujours considérée comme une collection, car il est basé sur le <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is the base class for language implementations that support arrays.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> est la classe de base pour les implémentations de langage qui prend en charge les tableaux.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, only the system and compilers can derive explicitly from the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Toutefois, seul le système et les compilateurs peuvent dériver explicitement de la <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Users should employ the array constructs provided by the language.</source>
          <target state="translated">Les utilisateurs doivent employer les constructions de tableau fournies par le langage.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An element is a value in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Un élément est une valeur dans un <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The length of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the total number of elements it can contain.</source>
          <target state="translated">La longueur d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> est le nombre total d’éléments qu’elle peut contenir.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The lower bound of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the index of its first element.</source>
          <target state="translated">La limite inférieure d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> est l’index de son premier élément.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound, but it has a lower bound of zero by default.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Array&gt;</ph> peut avoir une limite inférieure quelconque, mais il a une limite inférieure de zéro par défaut.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>A different lower bound can be defined when creating an instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class using <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>.A multidimensional <ph id="ph3">&lt;xref:System.Array&gt;</ph> can have different bounds for each dimension.</source>
          <target state="translated">Une limite inférieure différente peut être définie lors de la création d’une instance de la <ph id="ph1">&lt;xref:System.Array&gt;</ph> à l’aide de la classe <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>. Un multidimensionnelles <ph id="ph3">&lt;xref:System.Array&gt;</ph> peut avoir différentes limites pour chaque dimension.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An array can have a maximum of 32 dimensions.</source>
          <target state="translated">Un tableau peut avoir un maximum de 32 dimensions.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Unlike the classes in the <ph id="ph1">&lt;xref:System.Collections&gt;</ph> namespaces, <ph id="ph2">&lt;xref:System.Array&gt;</ph> has a fixed capacity.</source>
          <target state="translated">Contrairement aux classes dans le <ph id="ph1">&lt;xref:System.Collections&gt;</ph> espaces de noms, <ph id="ph2">&lt;xref:System.Array&gt;</ph> a une capacité fixe.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>To increase the capacity, you must create a new <ph id="ph1">&lt;xref:System.Array&gt;</ph> object with the required capacity, copy the elements from the old <ph id="ph2">&lt;xref:System.Array&gt;</ph> object to the new one, and delete the old <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Pour augmenter la capacité, vous devez créer un nouveau <ph id="ph1">&lt;xref:System.Array&gt;</ph> de l’objet avec la capacité requise, copier les éléments de l’ancien <ph id="ph2">&lt;xref:System.Array&gt;</ph> de l’objet dans le nouveau et supprimer l’ancien <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>By default, the maximum size of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is 2 gigabytes (GB).</source>
          <target state="translated">Par défaut, la taille maximale d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> est de 2 gigaoctets (Go).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>In a 64-bit environment, you can avoid the size restriction by setting the <ph id="ph1">`enabled`</ph> attribute of the <bpt id="p1">[</bpt>gcAllowVeryLargeObjects<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)</ept> configuration element to <ph id="ph2">`true`</ph> in the run-time environment.</source>
          <target state="translated">Dans un environnement 64 bits, vous pouvez éviter la restriction de taille en définissant le <ph id="ph1">`enabled`</ph> attribut de la <bpt id="p1">[</bpt>gcAllowVeryLargeObjects<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)</ept> élément de configuration <ph id="ph2">`true`</ph> dans l’environnement d’exécution.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, the array will still be limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</source>
          <target state="translated">Toutefois, le tableau sera limité à un total de 4 milliards éléments, ainsi qu’un index maximal de 0X7FEFFFFF dans n’importe quelle dimension donnée (0X7FFFFFC7 pour les tableaux d’octets et les tableaux de structures d’un octet).</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Single-dimensional arrays implement the <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType&gt;</ph> generic interfaces.</source>
          <target state="translated">Tableaux unidimensionnels implémentent la <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType&gt;</ph> et <ph id="ph5">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType&gt;</ph> interfaces génériques.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Les implémentations sont fournies aux tableaux au moment de l’exécution, et par conséquent, les interfaces génériques n’apparaissent pas dans la syntaxe de déclaration pour le <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>In addition,  there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations).</source>
          <target state="translated">En outre, il n’existe aucun rubriques de référence pour les membres d’interface sont accessibles uniquement par la conversion d’un tableau de type d’interface générique (implémentations d’interface explicites).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Le point clé à connaître lorsque vous effectuez un cast d’un tableau à une de ces interfaces est que les membres qui ajoutent, insérer ou supprimer des éléments lèvent <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects provide information about array type declarations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> objets fournissent des informations sur les déclarations de type tableau.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> objects with the same array type share the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> les objets avec le même type de tableau partagent le même <ph id="ph2">&lt;xref:System.Type&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Type.IsArray%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetElementType%2A?displayProperty=nameWithType&gt;</ph> might not return the expected results with <ph id="ph3">&lt;xref:System.Array&gt;</ph> because if an array is cast to the type <ph id="ph4">&lt;xref:System.Array&gt;</ph>, the result is an object, not an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsArray%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Type.GetElementType%2A?displayProperty=nameWithType&gt;</ph> peut ne pas retourner les résultats attendus avec <ph id="ph3">&lt;xref:System.Array&gt;</ph> , car si un tableau est converti en type <ph id="ph4">&lt;xref:System.Array&gt;</ph>, le résultat est un objet, pas un tableau.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>That is, <ph id="ph1">`typeof(System.Array).IsArray`</ph> returns <ph id="ph2">`false`</ph>, and <ph id="ph3">`typeof(System.Array).GetElementType`</ph> returns <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Autrement dit, <ph id="ph1">`typeof(System.Array).IsArray`</ph> retourne <ph id="ph2">`false`</ph>, et <ph id="ph3">`typeof(System.Array).GetElementType`</ph> retourne <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> méthode copie les éléments non seulement entre les tableaux du même type, mais également entre les tableaux standard de types différents ; elle gère le casting de type automatiquement.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Some methods, such as <ph id="ph1">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.CopyTo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.GetValue%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.SetValue%2A&gt;</ph>, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays.</source>
          <target state="translated">Certaines méthodes, telles que <ph id="ph1">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.CopyTo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.GetValue%2A&gt;</ph>, et <ph id="ph5">&lt;xref:System.Array.SetValue%2A&gt;</ph>, fournissent des surcharges qui acceptent des entiers 64 bits comme paramètres pour prendre en charge les tableaux de grande capacité.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Array.LongLength%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> return 64-bit integers indicating the length of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LongLength%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> retournent des entiers 64 bits qui indique la longueur du tableau.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not guaranteed to be sorted.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> n’est pas garanti d’être triées.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>You must sort the <ph id="ph1">&lt;xref:System.Array&gt;</ph> prior to performing operations (such as <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph>) that require the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to be sorted.</source>
          <target state="translated">Vous devez trier les <ph id="ph1">&lt;xref:System.Array&gt;</ph> avant d’effectuer des opérations (telles que <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph>) qui nécessitent la <ph id="ph3">&lt;xref:System.Array&gt;</ph> à trier.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Using an <ph id="ph1">&lt;xref:System.Array&gt;</ph> object of pointers in native code is not supported and will throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> for several methods.</source>
          <target state="translated">À l’aide un <ph id="ph1">&lt;xref:System.Array&gt;</ph> objet de pointeurs en code natif n’est pas prise en charge et lève un <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> pour plusieurs méthodes.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The following code example shows how <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> copies elements between an array of type integer and an array of type <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Le code suivant montre l’exemple comment <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> copie les éléments entre un tableau de type entier et un tableau de type <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The following code example creates and initializes an <ph id="ph1">&lt;xref:System.Array&gt;</ph> and displays its properties and its elements.</source>
          <target state="translated">L’exemple de code suivant crée et initialise un <ph id="ph1">&lt;xref:System.Array&gt;</ph> et affiche ses propriétés et ses éléments.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Statique public (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> en Visual Basic) de ce type sont thread-safe.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">Il n'est pas garanti que les membres d'instance soient thread-safe.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>This implementation does not provide a synchronized (thread safe) wrapper for an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; however, .NET Framework classes based on <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph3">&lt;see cref="P:System.Array.SyncRoot" /&gt;</ph> property.</source>
          <target state="translated">Cette implémentation ne fournit pas synchronisé wrapper (thread-safe) pour un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; Toutefois, les classes .NET Framework basées sur <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> fournissent leur propre version synchronisée de la collection à l’aide de la <ph id="ph3">&lt;see cref="P:System.Array.SyncRoot" /&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The one-dimensional, zero-based array to wrap in a read-only <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> wrapper.</source>
          <target state="translated">Tableau unidimensionnel, de base zéro pour encapsuler un wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> en lecture seule.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>Returns a read-only wrapper for the specified array.</source>
          <target state="translated">Retourne un wrapper en lecture seule pour le tableau spécifié.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>A read-only <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> wrapper for the specified array.</source>
          <target state="translated">Wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> en lecture seule pour le tableau spécifié.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>To prevent any modifications to the array, expose the array only through this wrapper.</source>
          <target state="translated">Pour éviter toute modification dans le tableau, exposent uniquement par l’intermédiaire de ce wrapper.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Une collection est en lecture seule est simplement une collection avec un wrapper qui empêche la modification de la collection ; Par conséquent, si des modifications sont apportées à la collection sous-jacente, la collection en lecture seule reflète ces modifications.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The following example wraps an array in a read-only <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>.</source>
          <target state="translated">L’exemple suivant encapsule un tableau en lecture seule <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches a one-dimensional sorted <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> for a value, using a binary search algorithm.</source>
          <target state="translated">Recherche une valeur dans un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> trié unidimensionnel, à l’aide d’un algorithme de recherche binaire.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel trié à explorer.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The object to search for.</source>
          <target state="translated">Objet à rechercher.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each element of the array and by the specified object.</source>
          <target state="translated">Recherche un élément spécifique dans tout un tableau trié unidimensionnel, à l’aide de l’interface <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> implémentée par chaque élément du tableau et par l’objet spécifié.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Index de la <ph id="ph1">&lt;paramref name="value" /&gt;</ph> spécifiée dans l’<ph id="ph2">&lt;paramref name="array" /&gt;</ph> spécifié, si <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est trouvé.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est inférieur à un ou plusieurs éléments dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est supérieur à tous les éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Si cette méthode est appelée avec un <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est présent dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatives.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> doivent être triées avant d’appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Vous pouvez appliquer l’opérateur de complément de bits (~ en c#, <ph id="ph1">`Not`</ph> en Visual Basic) au résultat négatif pour produire un index.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Si cet index est un supérieur à la limite supérieure du tableau, il n’existe aucun élément supérieur à <ph id="ph1">`value`</ph> dans le tableau.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Sinon, c’est l’index du premier élément supérieur à <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">Soit <ph id="ph1">`value`</ph> ou tous les éléments de <ph id="ph2">`array`</ph> doit implémenter la <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, qui est utilisée pour les comparaisons.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par le <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implémentation ; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If<ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Si<ph id="ph1">`value`</ph> n’implémente pas le <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> les éléments d’interface <ph id="ph3">`array`</ph> ne sont pas testées pour <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> avant le début de la recherche.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Une exception est levée si la recherche rencontre un élément qui n’implémente pas <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Les éléments en double sont autorisés.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> contient plusieurs éléments égal à <ph id="ph2">`value`</ph>, la méthode retourne l’index d’une des occurrences uniquement et pas nécessairement le.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> peut toujours être comparé à n’importe quel autre type de référence. Par conséquent, les comparaisons avec <ph id="ph2">`null`</ph> ne génèrent pas d’exception.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Pour chaque élément testé, <ph id="ph1">`value`</ph> est passée à approprié <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> mise en œuvre, même si <ph id="ph3">`value`</ph> est <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Autrement dit, le <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implémentation détermine comment un élément donné est comparé à <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (journal <ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> to locate a specific object in an <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> pour localiser un objet spécifique dans un <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The array is created with its elements in ascending sort order.</source>
          <target state="translated">Le tableau est créé avec ses éléments dans l’ordre de tri croissant.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method requires the array to be sorted in ascending order.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> méthode requiert que le tableau à trier dans l’ordre croissant.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> est d’un type qui n’est pas compatible avec les éléments de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> n’implémente pas l’interface <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> et la recherche rencontre un élément qui n’implémente pas l’interface <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel trié à explorer.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The object to search for.</source>
          <target state="translated">Objet à rechercher.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implémentation de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> à utiliser pendant la comparaison d'éléments.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser l’implémentation de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">Recherche une valeur dans l’intégralité d’un tableau trié unidimensionnel, à l’aide de l’interface <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Index de la <ph id="ph1">&lt;paramref name="value" /&gt;</ph> spécifiée dans l’<ph id="ph2">&lt;paramref name="array" /&gt;</ph> spécifié, si <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est trouvé.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est inférieur à un ou plusieurs éléments dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est supérieur à tous les éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Si cette méthode est appelée avec un <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est présent dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatives.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> doivent être triées avant d’appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Vous pouvez appliquer l’opérateur de complément de bits (~ en c#, <ph id="ph1">`Not`</ph> en Visual Basic) au résultat négatif pour produire un index.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Si cet index est un supérieur à la limite supérieure du tableau, il n’existe aucun élément supérieur à <ph id="ph1">`value`</ph> dans le tableau.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Sinon, c’est l’index du premier élément supérieur à <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Le comparateur personnalise la façon dont les éléments sont comparés.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Par exemple, vous pouvez utiliser un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> en tant que comparateur pour effectuer des recherches de chaîne pas la casse.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> n’est pas <ph id="ph2">`null`</ph>, les éléments de <ph id="ph3">`array`</ph> sont comparées à la valeur spécifiée à l’aide de la <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implémentation.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par <ph id="ph2">`comparer`</ph>; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If<ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Si<ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, la comparaison est effectuée à l’aide de la <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implémentation fournie par l’élément lui-même ou par la valeur spécifiée.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par le <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implémentation ; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph> et <ph id="ph3">`value`</ph> n’implémente pas le <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> les éléments d’interface <ph id="ph5">`array`</ph> ne sont pas testées pour <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> avant le début de la recherche.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Une exception est levée si la recherche rencontre un élément qui n’implémente pas <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Les éléments en double sont autorisés.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> contient plusieurs éléments égal à <ph id="ph2">`value`</ph>, la méthode retourne l’index d’une des occurrences uniquement et pas nécessairement le.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> peut toujours être comparé à n’importe quel autre type de référence. Par conséquent, les comparaisons avec <ph id="ph2">`null`</ph> ne génèrent pas d’exception.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Pour chaque élément testé, <ph id="ph1">`value`</ph> est passée à approprié <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> mise en œuvre, même si <ph id="ph3">`value`</ph> est <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Autrement dit, le <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implémentation détermine comment un élément donné est comparé à <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (journal <ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> et <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est d’un type qui n’est pas compatible avec les éléments de <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> n’implémente pas l’interface <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> et la recherche rencontre un élément qui n’implémente pas l’interface <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel trié à explorer.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Index de départ de la plage dans laquelle effectuer la recherche.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The length of the range to search.</source>
          <target state="translated">Longueur de la plage dans laquelle effectuer la recherche.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The object to search for.</source>
          <target state="translated">Objet à rechercher.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each element of the array and by the specified value.</source>
          <target state="translated">Recherche une valeur dans une plage d’éléments d’un tableau trié unidimensionnel, à l’aide de l’interface <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> implémentée par chaque élément du tableau et par la valeur spécifiée.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Index de la <ph id="ph1">&lt;paramref name="value" /&gt;</ph> spécifiée dans l’<ph id="ph2">&lt;paramref name="array" /&gt;</ph> spécifié, si <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est trouvé.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est inférieur à un ou plusieurs éléments dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est supérieur à tous les éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Si cette méthode est appelée avec un <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est présent dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatives.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> doivent être triées avant d’appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
          <target state="translated">Vous pouvez appliquer l’opérateur de complément de bits (~ en c#, <ph id="ph1">`Not`</ph> en Visual Basic) au résultat négatif pour produire un index.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Si cet index est un supérieur à la limite supérieure du tableau, il n’existe aucun élément supérieur à <ph id="ph1">`value`</ph> dans le tableau.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Sinon, c’est l’index du premier élément supérieur à <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">Soit <ph id="ph1">`value`</ph> ou tous les éléments de <ph id="ph2">`array`</ph> doit implémenter la <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, qui est utilisée pour les comparaisons.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par le <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implémentation ; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Si <ph id="ph1">`value`</ph> n’implémente pas le <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> les éléments d’interface <ph id="ph3">`array`</ph> ne sont pas testées pour <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> avant le début de la recherche.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Une exception est levée si la recherche rencontre un élément qui n’implémente pas <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Les éléments en double sont autorisés.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> contient plusieurs éléments égal à <ph id="ph2">`value`</ph>, la méthode retourne l’index d’une des occurrences uniquement et pas nécessairement le.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> peut toujours être comparé à n’importe quel autre type de référence. Par conséquent, les comparaisons avec <ph id="ph2">`null`</ph> ne génèrent pas d’exception.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Pour chaque élément testé, <ph id="ph1">`value`</ph> est passée à approprié <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> mise en œuvre, même si <ph id="ph3">`value`</ph> est <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Autrement dit, le <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implémentation détermine comment un élément donné est comparé à <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (journal <ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure d’<ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> est d’un type qui n’est pas compatible avec les éléments de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> n’implémente pas l’interface <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> et la recherche rencontre un élément qui n’implémente pas l’interface <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel trié à explorer.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Index de départ de la plage dans laquelle effectuer la recherche.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The length of the range to search.</source>
          <target state="translated">Longueur de la plage dans laquelle effectuer la recherche.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The object to search for.</source>
          <target state="translated">Objet à rechercher.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implémentation de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> à utiliser pendant la comparaison d'éléments.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser l’implémentation de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">Recherche une valeur dans une plage d’éléments d’un tableau trié unidimensionnel à l’aide de l’interface <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Index de la <ph id="ph1">&lt;paramref name="value" /&gt;</ph> spécifiée dans l’<ph id="ph2">&lt;paramref name="array" /&gt;</ph> spécifié, si <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est trouvé.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est inférieur à un ou plusieurs éléments dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est supérieur à tous les éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Si cette méthode est appelée avec un <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est présent dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatives.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> doivent être triées avant d’appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Vous pouvez appliquer l’opérateur de complément de bits (~ en c#, <ph id="ph1">`Not`</ph> en Visual Basic) au résultat négatif pour produire un index.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Si cet index est un supérieur à la limite supérieure du tableau, il n’existe aucun élément supérieur à <ph id="ph1">`value`</ph> dans le tableau.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Sinon, c’est l’index du premier élément supérieur à <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Le comparateur personnalise la façon dont les éléments sont comparés.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Par exemple, vous pouvez utiliser un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> en tant que comparateur pour effectuer des recherches de chaîne pas la casse.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> n’est pas <ph id="ph2">`null`</ph>, les éléments de <ph id="ph3">`array`</ph> sont comparées à la valeur spécifiée à l’aide de la <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implémentation.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par <ph id="ph2">`comparer`</ph>; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, la comparaison est effectuée à l’aide de la <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implémentation fournie par l’élément lui-même ou par la valeur spécifiée.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par le <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implémentation ; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph> et <ph id="ph3">`value`</ph> n’implémente pas le <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> les éléments d’interface <ph id="ph5">`array`</ph> ne sont pas testées pour <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> avant le début de la recherche.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Une exception est levée si la recherche rencontre un élément qui n’implémente pas <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Les éléments en double sont autorisés.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> contient plusieurs éléments égal à <ph id="ph2">`value`</ph>, la méthode retourne l’index d’une des occurrences uniquement et pas nécessairement le.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph> peut toujours être comparé à n’importe quel autre type de référence. Par conséquent, les comparaisons avec <ph id="ph2">`null`</ph> ne génèrent pas d’exception lors de l’utilisation <ph id="ph3">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Pour chaque élément testé, <ph id="ph1">`value`</ph> est passée à approprié <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> mise en œuvre, même si <ph id="ph3">`value`</ph> est <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Autrement dit, le <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implémentation détermine comment un élément donné est comparé à <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (journal <ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure d’<ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> et <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est d’un type qui n’est pas compatible avec les éléments de <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> n’implémente pas l’interface <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> et la recherche rencontre un élément qui n’implémente pas l’interface <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro trié unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The object to search for.</source>
          <target state="translated">Objet à rechercher.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and by the specified object.</source>
          <target state="translated">Recherche un élément spécifique dans un tableau entier trié unidimensionnel, à l’aide de l’interface générique <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implémentée par chaque élément de <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> et par l’objet spécifié.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Index de la <ph id="ph1">&lt;paramref name="value" /&gt;</ph> spécifiée dans l’<ph id="ph2">&lt;paramref name="array" /&gt;</ph> spécifié, si <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est trouvé.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est inférieur à un ou plusieurs éléments dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est supérieur à tous les éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Si cette méthode est appelée avec un <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est présent dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatives.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> doivent être triées avant d’appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">`array`</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si <ph id="ph1">`array`</ph> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Vous pouvez appliquer l’opérateur de complément de bits (~ en c#, <ph id="ph1">`Not`</ph> en Visual Basic) au résultat négatif pour produire un index.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Si cet index est égal à la taille du tableau, ne contient aucun élément supérieur à <ph id="ph1">`value`</ph> dans le tableau.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Sinon, c’est l’index du premier élément supérieur à <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
          <target state="translated"><ph id="ph1">`T`</ph> doit implémenter le <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interface générique, qui est utilisée pour les comparaisons.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par le <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implémentation ; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Les éléments en double sont autorisés.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> contient plusieurs éléments égal à <ph id="ph2">`value`</ph>, la méthode retourne l’index d’une des occurrences uniquement et pas nécessairement le.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> peut toujours être comparé à n’importe quel autre type de référence. Par conséquent, les comparaisons avec <ph id="ph2">`null`</ph> ne génèrent pas d’exception.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Pour chaque élément testé, <ph id="ph1">`value`</ph> est passée à approprié <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> mise en œuvre, même si <ph id="ph3">`value`</ph> est <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Autrement dit, le <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implémentation détermine comment un élément donné est comparé à <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (journal <ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> surcharge de méthode générique et le <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> surcharge de méthode générique.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>An array of strings is created, in no particular order.</source>
          <target state="translated">Un tableau de chaînes est créé, dans aucun ordre particulier.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Le tableau est affiché, trié et affiche de nouveau.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Les tableaux doivent être triées pour pouvoir utiliser le <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Les appels à la <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> les méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Si vous utilisez la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> surcharge de méthode générique est ensuite utilisée pour rechercher des deux chaînes, qui n’est pas dans le tableau et l’autre qui est.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Le tableau et la valeur de retour de la <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> méthode sont passés à la <ph id="ph2">`ShowWhere`</ph> une méthode générique, qui affiche la valeur d’index si la chaîne est trouvée, sinon les éléments de la chaîne de recherche se situant entre s’il s’agissait du tableau.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The index is negative if the string is not in the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph>-1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">L’index est négatif si la chaîne n’est pas dans le tableau, donc la <ph id="ph1">`ShowWhere`</ph> méthode accepte le complément de bits (le ~ opérateur en c# et Visual C++, <ph id="ph2">`Xor`</ph>-1 en Visual Basic) pour obtenir l’index du premier élément dans la liste qui est supérieure à la recherche str effectue une opération.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="T" /&gt;</ph> n’implémente pas l’interface générique <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro trié unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The object to search for.</source>
          <target state="translated">Objet à rechercher.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implémentation de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> à utiliser pendant la comparaison d'éléments.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser l’implémentation de <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Recherche une valeur dans l’intégralité d’un tableau trié unidimensionnel, à l’aide de l’interface générique <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Index de la <ph id="ph1">&lt;paramref name="value" /&gt;</ph> spécifiée dans l’<ph id="ph2">&lt;paramref name="array" /&gt;</ph> spécifié, si <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est trouvé.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est inférieur à un ou plusieurs éléments dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est supérieur à tous les éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Si cette méthode est appelée avec un <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est présent dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatives.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> doivent être triées avant d’appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
          <target state="translated">Vous pouvez appliquer l’opérateur de complément de bits (~ en c#, <ph id="ph1">`Not`</ph> en Visual Basic) au résultat négatif pour produire un index.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Si cet index est égal à la taille du tableau, ne contient aucun élément supérieur à <ph id="ph1">`value`</ph> dans le tableau.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Sinon, c’est l’index du premier élément supérieur à <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Le comparateur personnalise la façon dont les éléments sont comparés.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Par exemple, vous pouvez utiliser un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> en tant que comparateur pour effectuer des recherches de chaîne pas la casse.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> n’est pas <ph id="ph2">`null`</ph>, les éléments de <ph id="ph3">`array`</ph> sont comparées à la valeur spécifiée à l’aide de la <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implémentation d’interface générique.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par <ph id="ph2">`comparer`</ph>; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided by <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, la comparaison est effectuée à l’aide de la <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> implémentation d’interface générique fournie par <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par le <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implémentation ; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable%601&gt;</ph> before the search begins.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph> et <ph id="ph3">`value`</ph> n’implémente pas le <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> interface générique, les éléments de <ph id="ph5">`array`</ph> ne sont pas testées pour <ph id="ph6">&lt;xref:System.IComparable%601&gt;</ph> avant le début de la recherche.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph>.</source>
          <target state="translated">Une exception est levée si la recherche rencontre un élément qui n’implémente pas <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Les éléments en double sont autorisés.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> contient plusieurs éléments égal à <ph id="ph2">`value`</ph>, la méthode retourne l’index d’une des occurrences uniquement et pas nécessairement le.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> peut toujours être comparé à n’importe quel autre type de référence. Par conséquent, les comparaisons avec <ph id="ph2">`null`</ph> ne génèrent pas d’exception.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Pour chaque élément testé, <ph id="ph1">`value`</ph> est passée à approprié <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> mise en œuvre, même si <ph id="ph3">`value`</ph> est <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Autrement dit, le <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implémentation détermine comment un élément donné est comparé à <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (journal <ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload.</source>
          <target state="translated">L’exemple suivant illustre la <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge de méthode générique et le <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge de méthode générique.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L’exemple de code définit un autre comparateur pour les chaînes nommées <ph id="ph1">`ReverseCompare`</ph>, qui implémente le <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> dans Visual C++) interface générique.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Le comparateur appelle la <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> méthode, en inversant l’ordre des comparateurs afin que les chaînes triées de haut en bas au lieu de faible à élevé.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Le tableau est affiché, trié et affiche de nouveau.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Les tableaux doivent être triées pour pouvoir utiliser le <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Les appels à la <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> les méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Si vous utilisez la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge de méthode générique est ensuite utilisée pour rechercher des deux chaînes, qui n’est pas dans le tableau et l’autre qui est.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Le tableau et la valeur de retour de la <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> méthode sont passés à la <ph id="ph2">`ShowWhere`</ph> une méthode générique, qui affiche la valeur d’index si la chaîne est trouvée, sinon les éléments de la chaîne de recherche se situant entre s’il s’agissait du tableau.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">L’index est négatif si la chaîne n’est pas n tableau, donc la <ph id="ph1">`ShowWhere`</ph> méthode accepte le complément de bits (le ~ opérateur en c# et Visual C++, <ph id="ph2">`Xor`</ph> -1 en Visual Basic) pour obtenir l’index du premier élément dans la liste qui est supérieure à la recherche de String NG.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> et <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est d’un type qui n’est pas compatible avec les éléments de <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>, et <ph id="ph3">&lt;paramref name="T" /&gt;</ph> n’implémente pas l’interface générique <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro, unidimensionnel et trié à explorer.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Index de départ de la plage dans laquelle effectuer la recherche.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The length of the range to search.</source>
          <target state="translated">Longueur de la plage dans laquelle effectuer la recherche.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The object to search for.</source>
          <target state="translated">Objet à rechercher.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and by the specified value.</source>
          <target state="translated">Recherche une valeur dans une plage d’éléments d’un tableau trié unidimensionnel, à l’aide de l’interface générique <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implémentée par chaque élément de <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> et par la valeur spécifiée.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Index de la <ph id="ph1">&lt;paramref name="value" /&gt;</ph> spécifiée dans l’<ph id="ph2">&lt;paramref name="array" /&gt;</ph> spécifié, si <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est trouvé.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est inférieur à un ou plusieurs éléments dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est supérieur à tous les éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Si cette méthode est appelée avec un <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est présent dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatives.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> doivent être triées avant d’appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si le tableau ne contient pas la valeur spécifiée, la méthode retourne un entier négatif.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Vous pouvez appliquer l’opérateur de complément de bits (~ en c#, <ph id="ph1">`Not`</ph> en Visual Basic) au résultat négatif pour produire un index.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Si cet index est égal à la taille du tableau, ne contient aucun élément supérieur à <ph id="ph1">`value`</ph> dans le tableau.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Sinon, c’est l’index du premier élément supérieur à <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
          <target state="translated"><ph id="ph1">`T`</ph> doit implémenter le <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interface générique, qui est utilisée pour les comparaisons.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par le <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implémentation ; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Les éléments en double sont autorisés.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> contient plusieurs éléments égal à <ph id="ph2">`value`</ph>, la méthode retourne l’index d’une des occurrences uniquement et pas nécessairement le.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> peut toujours être comparé à n’importe quel autre type de référence. Par conséquent, les comparaisons avec <ph id="ph2">`null`</ph> ne génèrent pas d’exception.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Pour chaque élément testé, <ph id="ph1">`value`</ph> est passée à approprié <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> mise en œuvre, même si <ph id="ph3">`value`</ph> est <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Autrement dit, le <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implémentation détermine comment un élément donné est comparé à <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (journal <ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> est d’un type qui n’est pas compatible avec les éléments de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="T" /&gt;</ph> n’implémente pas l’interface générique <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro, unidimensionnel et trié à explorer.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to search.</source>
          <target state="translated">Index de départ de la plage dans laquelle effectuer la recherche.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The length of the range to search.</source>
          <target state="translated">Longueur de la plage dans laquelle effectuer la recherche.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The object to search for.</source>
          <target state="translated">Objet à rechercher.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implémentation de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> à utiliser pendant la comparaison d'éléments.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser l’implémentation de <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Recherche une valeur dans une plage d’éléments d’un tableau trié unidimensionnel, à l’aide de l’interface générique <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Index de la <ph id="ph1">&lt;paramref name="value" /&gt;</ph> spécifiée dans l’<ph id="ph2">&lt;paramref name="array" /&gt;</ph> spécifié, si <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est trouvé.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est inférieur à un ou plusieurs éléments dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable et que <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est supérieur à tous les éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Si cette méthode est appelée avec un <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est présent dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatives.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> doivent être triées avant d’appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si le tableau ne contient pas la valeur spécifiée, la méthode retourne un entier négatif.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Vous pouvez appliquer l’opérateur de complément de bits (~ en c#, <ph id="ph1">`Not`</ph> en Visual Basic) au résultat négatif pour produire un index.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Si cet index est égal à la taille du tableau, ne contient aucun élément supérieur à <ph id="ph1">`value`</ph> dans le tableau.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Sinon, c’est l’index du premier élément supérieur à <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Le comparateur personnalise la façon dont les éléments sont comparés.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Par exemple, vous pouvez utiliser un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> en tant que comparateur pour effectuer des recherches de chaîne pas la casse.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> n’est pas <ph id="ph2">`null`</ph>, les éléments de <ph id="ph3">`array`</ph> sont comparées à la valeur spécifiée à l’aide de la <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implémentation d’interface générique.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par <ph id="ph2">`comparer`</ph>; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided for type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, la comparaison est effectuée à l’aide de la <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> implémentation d’interface générique fournie pour le type <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> doit déjà être trié par ordre croissant selon l’ordre de tri défini par le <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implémentation ; sinon, le résultat peut être incorrect.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Les éléments en double sont autorisés.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> contient plusieurs éléments égal à <ph id="ph2">`value`</ph>, la méthode retourne l’index d’une des occurrences uniquement et pas nécessairement le.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph> peut toujours être comparé à n’importe quel autre type de référence. Par conséquent, les comparaisons avec <ph id="ph2">`null`</ph> ne génèrent pas d’exception lors de l’utilisation <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Pour chaque élément testé, <ph id="ph1">`value`</ph> est passée à approprié <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> mise en œuvre, même si <ph id="ph3">`value`</ph> est <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Autrement dit, le <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implémentation détermine comment un élément donné est comparé à <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (journal <ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> et <ph id="ph3">&lt;paramref name="value" /&gt;</ph> est d’un type qui n’est pas compatible avec les éléments de <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>, et <ph id="ph3">&lt;paramref name="T" /&gt;</ph>n’implémente pas l’interface générique <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The array whose elements need to be cleared.</source>
          <target state="translated">Le tableau dont les éléments doivent être effacés.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range of elements to clear.</source>
          <target state="translated">Index de départ de la plage d'éléments à effacer.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The number of elements to clear.</source>
          <target state="translated">Nombre d'éléments à effacer.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Sets a range of elements in an array to the default value of each element type.</source>
          <target state="translated">Définit une plage d'éléments dans un tableau à la valeur par défaut de chaque type d'élément.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method resets each element in an array to the element type's default value.</source>
          <target state="translated">Cette méthode remplace chaque élément dans un tableau du type d’élément par défaut.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>It sets elements of reference types (including <ph id="ph1">&lt;xref:System.String&gt;</ph> elements) to <ph id="ph2">`null`</ph>, and sets elements of value types to the default values shown in the following table.</source>
          <target state="translated">Il définit des éléments de types référence (y compris <ph id="ph1">&lt;xref:System.String&gt;</ph> éléments) à <ph id="ph2">`null`</ph>et définit des éléments de types de valeur pour les valeurs par défaut indiqués dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Type</source>
          <target state="translated">Type</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Value</source>
          <target state="translated">Value</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>All integral and floating point numeric types</source>
          <target state="translated">Tous les types numériques intégraux et à virgule flottante</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>0 (zero)</source>
          <target state="translated">0 (zéro)</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Other value types</source>
          <target state="translated">Autres types de valeur</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Default value of the type's fields</source>
          <target state="translated">Valeur par défaut des champs du type</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The range of cleared elements wrap from row to row in a multi-dimensional array.</source>
          <target state="translated">La plage d’éléments effacés est renvoyée à partir de la ligne à la ligne dans un tableau multidimensionnel.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method only clears the values of the elements; it does not delete the elements themselves.</source>
          <target state="translated">Cette méthode efface uniquement les valeurs des éléments ; elle ne supprime pas les éléments eux-mêmes.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>An array has a fixed size; therefore, elements cannot be added or removed.</source>
          <target state="translated">Un tableau a une taille fixe ; Par conséquent, les éléments ne peuvent pas être ajoutés ou supprimés.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> method to reset integer values in a one-dimensional, two-dimensional, and three-dimensional array.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> méthode pour rétablir les valeurs entières dans un tableau unidimensionnel, deux et trois dimensions.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The following example defines a <ph id="ph1">`TimeZoneTime`</ph> structure that includes a <ph id="ph2">&lt;xref:System.TimeZoneInfo&gt;</ph> field and a <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> field.</source>
          <target state="translated">L’exemple suivant définit un <ph id="ph1">`TimeZoneTime`</ph> structure qui comprend un <ph id="ph2">&lt;xref:System.TimeZoneInfo&gt;</ph> champ et un <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> champ.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> method to clear one element in a two-element array of <ph id="ph2">`TimeZoneTime`</ph> values.</source>
          <target state="translated">Il appelle ensuite la <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> méthode pour effacer un élément dans un tableau à deux éléments de <ph id="ph2">`TimeZoneTime`</ph> valeurs.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The method sets the value of the cleared element to the default value of a <ph id="ph1">&lt;xref:System.TimeZoneInfo&gt;</ph> object, which is <ph id="ph2">`null`</ph>, and the default value of a <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> object, which is <ph id="ph4">&lt;xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La méthode définit la valeur de l’élément effacée à la valeur par défaut d’un <ph id="ph1">&lt;xref:System.TimeZoneInfo&gt;</ph> objet, qui est <ph id="ph2">`null`</ph>et la valeur par défaut une <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> objet, qui est <ph id="ph4">&lt;xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the size of <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">La somme d’<ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> est supérieure à la taille d’<ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Array.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Crée une copie superficielle de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Array.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Copie superficielle de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies only the elements of the <ph id="ph2">&lt;xref:System.Array&gt;</ph>, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Une copie superficielle d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copie uniquement les éléments de la <ph id="ph2">&lt;xref:System.Array&gt;</ph>, si elles sont des types référence ou types valeur, mais elle ne copie pas les objets que les références.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The references in the new <ph id="ph1">&lt;xref:System.Array&gt;</ph> point to the same objects that the references in the original <ph id="ph2">&lt;xref:System.Array&gt;</ph> point to.</source>
          <target state="translated">Les références dans la nouvelle <ph id="ph1">&lt;xref:System.Array&gt;</ph> des objets qui pointent vers le même les références dans l’original <ph id="ph2">&lt;xref:System.Array&gt;</ph> pointez.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">En revanche, une copie complète d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copie les éléments et tout ce que fait référence directement ou indirectement par les éléments.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The clone is of the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> as the original <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Le clone est du même <ph id="ph1">&lt;xref:System.Type&gt;</ph> que l’original <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The following code example clones a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> array and demonstrates the behavior of a shallow copy.</source>
          <target state="translated">Les éléments suivants exemple de code clone un <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> de tableau et illustre le comportement d’une copie superficielle.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui contient les données à copier.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Entier 32 bits qui représente l’index du <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> auquel la copie commence.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui reçoit les données.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">Entier 32 bits qui représente l’index du <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> auquel le stockage commence.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Entier 32 bits qui représente le nombre d'éléments à copier.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Copie une plage d’éléments à partir d’un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> commençant à l’index source spécifié, puis les colle dans un autre <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> commençant à l’index de destination spécifié.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Guarantees that all changes are undone if the copy does not succeed completely.</source>
          <target state="translated">Garantit que toutes les modifications sont annulées si la copie ne se déroule pas intégralement avec succès.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Le <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> paramètres doivent avoir le même nombre de dimensions.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> type must be the same as or derived from the <ph id="ph2">`destinationArray`</ph> type; otherwise, an <ph id="ph3">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown.</source>
          <target state="translated">Le <ph id="ph1">`sourceArray`</ph> type doit être identique ou dérivé de la <ph id="ph2">`destinationArray`</ph> type ; sinon, un <ph id="ph3">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Unlike <ph id="ph1">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> verifies the compatibility of the array types before performing any operation.</source>
          <target state="translated">Contrairement aux <ph id="ph1">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> vérifie la compatibilité des types de tableau avant d’effectuer toute opération.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Lors de la copie entre des tableaux multidimensionnels, le tableau se comporte comme un tableau unidimensionnel de long, où les lignes (ou les colonnes) sont placés sur le plan conceptuel bout en bout.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Par exemple, si un tableau possède trois lignes (ou colonnes) avec quatre éléments chaque, copie de six éléments à partir du début du tableau copiez toutes les quatre éléments de la première ligne (ou colonne) et les deux premiers éléments de la deuxième ligne (ou colonne).</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Pour démarrer la copie à partir du deuxième élément du troisième ligne (ou colonne), <ph id="ph1">`sourceIndex`</ph> doit être la limite supérieure de la première ligne (ou colonne) plus la longueur de la deuxième ligne (ou colonne) plus deux.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Si <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> se chevauchent, cette méthode se comporte comme si les valeurs d’origine de <ph id="ph3">`sourceArray`</ph> ont été conservés dans un emplacement temporaire avant <ph id="ph4">`destinationArray`</ph> est remplacé.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Cette méthode est équivalente à la fonction C/C++ standard <ph id="ph1">`memmove`</ph>, et non <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Les tableaux peuvent être des tableaux de type référence ou des tableaux de type valeur.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Si <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> des tableaux de type référence ou des tableaux de type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, une copie superficielle est effectuée.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Une copie superficielle d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> est un nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph> contenant des références aux mêmes éléments que l’original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Les éléments eux-mêmes ou tout élément référencé par les éléments ne sont pas copiés.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">En revanche, une copie complète d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copie les éléments et tout ce que fait référence directement ou indirectement par les éléments.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If this method throws an exception while copying, the <ph id="ph1">`destinationArray`</ph> remains unchanged; therefore, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> can be used within a constrained execution region (<ph id="ph3">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>).</source>
          <target state="translated">Si cette méthode lève une exception lors de la copie, le <ph id="ph1">`destinationArray`</ph> reste inchangée ; par conséquent, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> peut être utilisé dans une région d’exécution limitée (<ph id="ph3">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> et <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> ont des classements différents.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> type is neither the same as nor derived from the <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> type.</source>
          <target state="translated">Le type <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> n’est pas le même que le type <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>, ni un dérivé de celui-ci.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Au moins un élément de <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> ne peut pas être converti en type <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> est inférieur à la limite inférieure de la première dimension de <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> est inférieur à la limite inférieure de la première dimension de <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est supérieur au nombre d’éléments compris entre <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> et la fin de <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est supérieur au nombre d’éléments compris entre <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> et la fin de <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The type of the elements of the source array.</source>
          <target state="translated">Type des éléments du tableau source.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The type of the elements of the target array.</source>
          <target state="translated">Type des éléments du tableau cible.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to convert to a target type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel de base zéro à convertir en un type cible.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>A <ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph> that converts each element from one type to another type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph> qui convertit chaque élément d’un type en un autre type.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>Converts an array of one type to an array of another type.</source>
          <target state="translated">Convertit un tableau d'un type en un tableau d'un autre type.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>An array of the target type containing the converted elements from the source array.</source>
          <target state="translated">Tableau du type cible qui contient les éléments convertis du tableau source.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> is a delegate to a method that converts an object to the target type.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> est un délégué à une méthode qui convertit un objet en type cible.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph>, and the converted elements are saved in the new array.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à la <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph>, et les éléments convertis sont enregistrés dans le nouveau tableau.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The source <ph id="ph1">`array`</ph> remains unchanged.</source>
          <target state="translated">La source <ph id="ph1">`array`</ph> demeure inchangée.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The following code example defines a method named <ph id="ph1">`PointFToPoint`</ph> that converts a <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> structure to a <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structure.</source>
          <target state="translated">L’exemple de code suivant définit une méthode nommée <ph id="ph1">`PointFToPoint`</ph> qui convertit un <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> structure un <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structure.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The example then creates an array of <ph id="ph1">&lt;xref:System.Drawing.PointF&gt;</ph> structures, creates a <ph id="ph2">`Converter&lt;PointF, Point&gt;`</ph> delegate (<ph id="ph3">`Converter(Of PointF, Point)`</ph> in Visual Basic) to represent the <ph id="ph4">`PointFToPoint`</ph> method, and passes the delegate to the <ph id="ph5">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple crée ensuite un tableau de <ph id="ph1">&lt;xref:System.Drawing.PointF&gt;</ph> structures, crée un <ph id="ph2">`Converter&lt;PointF, Point&gt;`</ph> déléguer (<ph id="ph3">`Converter(Of PointF, Point)`</ph> en Visual Basic) pour représenter le <ph id="ph4">`PointFToPoint`</ph> (méthode) et passe le délégué à la <ph id="ph5">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The <ph id="ph1">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> method passes each element of the input list to the <ph id="ph2">`PointFToPoint`</ph> method and puts the converted elements into a new list of <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> méthode passe chaque élément de la liste d’entrée à la <ph id="ph2">`PointFToPoint`</ph> (méthode) et met les éléments convertis dans une nouvelle liste de <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>Both lists are displayed.</source>
          <target state="translated">Les deux listes sont affichées.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source><ph id="ph1">&lt;paramref name="converter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="converter" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Copies a range of elements in one <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and performs type casting and boxing as required.</source>
          <target state="translated">Copie une plage d’éléments d’un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vers un autre <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> et effectue éventuellement le casting de type et le boxing.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui contient les données à copier.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui reçoit les données.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Entier 32 bits qui représente le nombre d'éléments à copier.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element.</source>
          <target state="translated">Copie une série d’éléments de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en commençant au premier élément, et les colle dans un autre <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en commençant au premier élément.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The length is specified as a 32-bit integer.</source>
          <target state="translated">La longueur est spécifiée sous forme d'un entier 32 bits.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Le <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> paramètres doivent avoir le même nombre de dimensions.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
          <target state="translated">En outre, <ph id="ph1">`destinationArray`</ph> doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à prendre en compte les données copiées.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
          <target state="translated">Lors de la copie entre des tableaux multidimensionnels, le tableau se comporte comme un tableau unidimensionnel de long, où les lignes (ou les colonnes) sont placés sur le plan conceptuel bout en bout.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Par exemple, si un tableau possède trois lignes (ou colonnes) avec quatre éléments chaque, copie de six éléments à partir du début du tableau copiez toutes les quatre éléments de la première ligne (ou colonne) et les deux premiers éléments de la deuxième ligne (ou colonne).</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Si <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> se chevauchent, cette méthode se comporte comme si les valeurs d’origine de <ph id="ph3">`sourceArray`</ph> ont été conservés dans un emplacement temporaire avant <ph id="ph4">`destinationArray`</ph> est remplacé.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Cette méthode est équivalente à la fonction C/C++ standard <ph id="ph1">`memmove`</ph>, et non <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Les tableaux peuvent être des tableaux de type référence ou des tableaux de type valeur.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Cast de type est effectuée, selon les besoins.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Lors de la copie à partir d’un tableau de type référence à un tableau de type valeur, chaque élément est unboxed, puis copié.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Lors de la copie à partir d’un tableau de type valeur dans un tableau de type référence, chaque élément est converti (boxed), puis copié.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Lors de la copie d’un tableau de type référence ou type de valeur vers un <ph id="ph1">&lt;xref:System.Object&gt;</ph> tableau, un <ph id="ph2">&lt;xref:System.Object&gt;</ph> est créé pour contenir chaque valeur ou référence, puis copié.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Lors de la copie d’un <ph id="ph1">&lt;xref:System.Object&gt;</ph> un tableau de type référence ou type valeur et l’attribution de tableau n’est pas possible, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Si <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> des tableaux de type référence ou des tableaux de type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, une copie superficielle est effectuée.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Une copie superficielle d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> est un nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph> contenant des références aux mêmes éléments que l’original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Les éléments eux-mêmes ou tout élément référencé par les éléments ne sont pas copiés.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">En revanche, une copie complète d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copie les éléments et tout ce que fait référence directement ou indirectement par les éléments.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> est levée si les tableaux sont de types incompatibles.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Compatibilité de type est définie comme suit :</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Un type est compatible avec lui-même.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Un type valeur est compatible avec <ph id="ph1">&lt;xref:System.Object&gt;</ph> et avec un type interface implémenté par ce type de valeur.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Un type valeur est considéré comme connecté à une interface uniquement s’il implémente cette interface directement.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Les types déconnectés ne sont pas compatibles.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Deux types valeur (prédéfini) intrinsèques sont compatibles si la copie à partir du type de source pour le type de destination est une conversion étendue.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Une conversion étendue jamais perd le plus d’informations, tandis qu’une conversion restrictive peut perdre des informations.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Par exemple, convertir un entier signé 32 bits à un entier signé 64 bits est une conversion étendue, et la conversion d’un entier signé 64 bits à un entier signé 32 bits est une conversion restrictive.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Un type non intrinsèque valeur (défini par l’utilisateur) est compatible uniquement avec lui-même.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Les énumérations ont une conversion implicite vers <ph id="ph1">&lt;xref:System.Enum&gt;</ph> et leur type sous-jacent.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Si tous les éléments de <ph id="ph1">`sourceArray`</ph> nécessite un cast aval (par exemple, à partir d’une classe de base pour une classe dérivée ou d’une interface vers un objet) et un ou plusieurs éléments ne peut pas être convertis au type correspondant dans <ph id="ph2">`destinationArray`</ph>, un <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Si cette méthode lève une exception lors de la copie, l’état de <ph id="ph1">`destinationArray`</ph> n’est pas défini.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> et <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> ont des classements différents.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> et <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sont de types incompatibles.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Au moins un élément de <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> ne peut pas être converti en type <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est supérieur au nombre d’éléments de <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est supérieur au nombre d’éléments de <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui contient les données à copier.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui reçoit les données.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Entier 64 bits qui représente le nombre d'éléments à copier.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The integer must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">L’entier doit être compris entre zéro et <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclus.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element.</source>
          <target state="translated">Copie une série d’éléments de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en commençant au premier élément, et les colle dans un autre <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en commençant au premier élément.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The length is specified as a 64-bit integer.</source>
          <target state="translated">La longueur est spécifiée sous forme d'un entier 64 bits.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Le <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> paramètres doivent avoir le même nombre de dimensions.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
          <target state="translated">En outre, <ph id="ph1">`destinationArray`</ph> doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à prendre en compte les données copiées.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
          <target state="translated">Lors de la copie entre des tableaux multidimensionnels, le tableau se comporte comme un tableau unidimensionnel de long, où les lignes (ou les colonnes) sont placés sur le plan conceptuel bout en bout.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Par exemple, si un tableau possède trois lignes (ou colonnes) avec quatre éléments chaque, copie de six éléments à partir du début du tableau copiez toutes les quatre éléments de la première ligne (ou colonne) et les deux premiers éléments de la deuxième ligne (ou colonne).</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Si <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> se chevauchent, cette méthode se comporte comme si les valeurs d’origine de <ph id="ph3">`sourceArray`</ph> ont été conservés dans un emplacement temporaire avant <ph id="ph4">`destinationArray`</ph> est remplacé.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Cette méthode est équivalente à la fonction C/C++ standard <ph id="ph1">`memmove`</ph>, et non <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Les tableaux peuvent être des tableaux de type référence ou des tableaux de type valeur.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Cast de type est effectuée, selon les besoins.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Lors de la copie à partir d’un tableau de type référence à un tableau de type valeur, chaque élément est unboxed, puis copié.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Lors de la copie à partir d’un tableau de type valeur dans un tableau de type référence, chaque élément est converti (boxed), puis copié.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Lors de la copie d’un tableau de type référence ou type de valeur vers un <ph id="ph1">&lt;xref:System.Object&gt;</ph> tableau, un <ph id="ph2">&lt;xref:System.Object&gt;</ph> est créé pour contenir chaque valeur ou référence, puis copié.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Lors de la copie d’un <ph id="ph1">&lt;xref:System.Object&gt;</ph> un tableau de type référence ou type valeur et l’attribution de tableau n’est pas possible, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Si <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> des tableaux de type référence ou des tableaux de type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, une copie superficielle est effectuée.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Une copie superficielle d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> est un nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph> contenant des références aux mêmes éléments que l’original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Les éléments eux-mêmes ou tout élément référencé par les éléments ne sont pas copiés.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">En revanche, une copie complète d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copie les éléments et tout ce que fait référence directement ou indirectement par les éléments.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> est levée si les tableaux sont de types incompatibles.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Compatibilité de type est définie comme suit :</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Un type est compatible avec lui-même.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Un type valeur est compatible avec <ph id="ph1">&lt;xref:System.Object&gt;</ph> et avec un type interface implémenté par ce type de valeur.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Un type valeur est considéré comme connecté à une interface uniquement s’il implémente cette interface directement.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Les types déconnectés ne sont pas compatibles.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Deux types valeur (prédéfini) intrinsèques sont compatibles si la copie à partir du type de source pour le type de destination est une conversion étendue.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Une conversion étendue jamais perd le plus d’informations, tandis qu’une conversion restrictive peut perdre des informations.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Par exemple, convertir un entier signé 32 bits à un entier signé 64 bits est une conversion étendue, et la conversion d’un entier signé 64 bits à un entier signé 32 bits est une conversion restrictive.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Un type non intrinsèque valeur (défini par l’utilisateur) est compatible uniquement avec lui-même.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Les énumérations ont une conversion implicite vers <ph id="ph1">&lt;xref:System.Enum&gt;</ph> et leur type sous-jacent.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Si tous les éléments de <ph id="ph1">`sourceArray`</ph> nécessite un cast aval (par exemple, à partir d’une classe de base pour une classe dérivée ou d’une interface vers un objet) et un ou plusieurs éléments ne peut pas être convertis au type correspondant dans <ph id="ph2">`destinationArray`</ph>, un <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Si cette méthode lève une exception lors de la copie, l’état de <ph id="ph1">`destinationArray`</ph> n’est pas défini.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> et <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> ont des classements différents.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> et <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sont de types incompatibles.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Au moins un élément de <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> ne peut pas être converti en type <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à 0 ou supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est supérieur au nombre d’éléments de <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est supérieur au nombre d’éléments de <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui contient les données à copier.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Entier 32 bits qui représente l’index du <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> auquel la copie commence.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui reçoit les données.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">Entier 32 bits qui représente l’index du <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> auquel le stockage commence.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Entier 32 bits qui représente le nombre d'éléments à copier.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Copie une plage d’éléments à partir d’un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> commençant à l’index source spécifié, puis les colle dans un autre <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> commençant à l’index de destination spécifié.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The length and the indexes are specified as 32-bit integers.</source>
          <target state="translated">La longueur et les index sont spécifiés en tant qu'entiers 32 bits.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Le <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> paramètres doivent avoir le même nombre de dimensions.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
          <target state="translated">En outre, <ph id="ph1">`destinationArray`</ph> doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à partir de la <ph id="ph2">`destinationIndex`</ph> position pour accueillir les données copiées.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Lors de la copie entre des tableaux multidimensionnels, le tableau se comporte comme un tableau unidimensionnel de long, où les lignes (ou les colonnes) sont placés sur le plan conceptuel bout en bout.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Par exemple, si un tableau possède trois lignes (ou colonnes) avec quatre éléments chaque, copie de six éléments à partir du début du tableau copiez toutes les quatre éléments de la première ligne (ou colonne) et les deux premiers éléments de la deuxième ligne (ou colonne).</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Pour démarrer la copie à partir du deuxième élément du troisième ligne (ou colonne), <ph id="ph1">`sourceIndex`</ph> doit être la limite supérieure de la première ligne (ou colonne) plus la longueur de la deuxième ligne (ou colonne) plus deux.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Si <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> se chevauchent, cette méthode se comporte comme si les valeurs d’origine de <ph id="ph3">`sourceArray`</ph> ont été conservés dans un emplacement temporaire avant <ph id="ph4">`destinationArray`</ph> est remplacé.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Cette méthode est équivalente à la fonction C/C++ standard <ph id="ph1">`memmove`</ph>, et non <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Les tableaux peuvent être des tableaux de type référence ou des tableaux de type valeur.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Cast de type est effectuée, selon les besoins.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Lors de la copie à partir d’un tableau de type référence à un tableau de type valeur, chaque élément est unboxed, puis copié.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Lors de la copie à partir d’un tableau de type valeur dans un tableau de type référence, chaque élément est converti (boxed), puis copié.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Lors de la copie d’un tableau de type référence ou type de valeur vers un <ph id="ph1">&lt;xref:System.Object&gt;</ph> tableau, un <ph id="ph2">&lt;xref:System.Object&gt;</ph> est créé pour contenir chaque valeur ou référence, puis copié.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Lors de la copie d’un <ph id="ph1">&lt;xref:System.Object&gt;</ph> un tableau de type référence ou type valeur et l’attribution de tableau n’est pas possible, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Si <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> des tableaux de type référence ou des tableaux de type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, une copie superficielle est effectuée.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Une copie superficielle d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> est un nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph> contenant des références aux mêmes éléments que l’original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Les éléments eux-mêmes ou tout élément référencé par les éléments ne sont pas copiés.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">En revanche, une copie complète d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copie les éléments et tout ce que fait référence directement ou indirectement par les éléments.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> est levée si les tableaux sont de types incompatibles.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Compatibilité de type est définie comme suit :</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Un type est compatible avec lui-même.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Un type valeur est compatible avec <ph id="ph1">&lt;xref:System.Object&gt;</ph> et avec un type interface implémenté par ce type de valeur.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Un type valeur est considéré comme connecté à une interface uniquement s’il implémente cette interface directement.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Les types déconnectés ne sont pas compatibles.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Deux types valeur (prédéfini) intrinsèques sont compatibles si la copie à partir du type de source pour le type de destination est une conversion étendue.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Une conversion étendue jamais perd le plus d’informations, tandis qu’une conversion restrictive peut perdre des informations.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Par exemple, convertir un entier signé 32 bits à un entier signé 64 bits est une conversion étendue, et la conversion d’un entier signé 64 bits à un entier signé 32 bits est une conversion restrictive.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Un type non intrinsèque valeur (défini par l’utilisateur) est compatible uniquement avec lui-même.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Les énumérations ont une conversion implicite vers <ph id="ph1">&lt;xref:System.Enum&gt;</ph> et leur type sous-jacent.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Si tous les éléments de <ph id="ph1">`sourceArray`</ph> nécessite un cast aval (par exemple, à partir d’une classe de base pour une classe dérivée ou d’une interface vers un objet) et un ou plusieurs éléments ne peut pas être convertis au type correspondant dans <ph id="ph2">`destinationArray`</ph>, un <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Si cette méthode lève une exception lors de la copie, l’état de <ph id="ph1">`destinationArray`</ph> n’est pas défini.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to copy from one <ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Object&gt;</ph> to another <ph id="ph3">&lt;xref:System.Array&gt;</ph> of type integer.</source>
          <target state="translated">L’exemple de code suivant montre comment copier à partir d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> de type <ph id="ph2">&lt;xref:System.Object&gt;</ph> vers un autre <ph id="ph3">&lt;xref:System.Array&gt;</ph> de type entier.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> et <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> ont des classements différents.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> et <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sont de types incompatibles.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Au moins un élément de <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> ne peut pas être converti en type <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> est inférieur à la limite inférieure de la première dimension de <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> est inférieur à la limite inférieure de la première dimension de <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est supérieur au nombre d’éléments compris entre <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> et la fin de <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est supérieur au nombre d’éléments compris entre <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> et la fin de <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui contient les données à copier.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Entier 64 bits qui représente l’index du <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> auquel la copie commence.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui reçoit les données.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">Entier 64 bits qui représente l’index du <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> auquel le stockage commence.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Entier 64 bits qui représente le nombre d'éléments à copier.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The integer must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">L’entier doit être compris entre zéro et <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclus.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Copie une plage d’éléments à partir d’un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> commençant à l’index source spécifié, puis les colle dans un autre <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> commençant à l’index de destination spécifié.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The length and the indexes are specified as 64-bit integers.</source>
          <target state="translated">La longueur et les index sont spécifiés en tant qu'entiers 64 bits.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Le <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> paramètres doivent avoir le même nombre de dimensions.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
          <target state="translated">En outre, <ph id="ph1">`destinationArray`</ph> doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à partir de la <ph id="ph2">`destinationIndex`</ph> position pour accueillir les données copiées.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Lors de la copie entre des tableaux multidimensionnels, le tableau se comporte comme un tableau unidimensionnel de long, où les lignes (ou les colonnes) sont placés sur le plan conceptuel bout en bout.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Par exemple, si un tableau possède trois lignes (ou colonnes) avec quatre éléments chaque, copie de six éléments à partir du début du tableau copiez toutes les quatre éléments de la première ligne (ou colonne) et les deux premiers éléments de la deuxième ligne (ou colonne).</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Pour démarrer la copie à partir du deuxième élément du troisième ligne (ou colonne), <ph id="ph1">`sourceIndex`</ph> doit être la limite supérieure de la première ligne (ou colonne) plus la longueur de la deuxième ligne (ou colonne) plus deux.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Si <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> se chevauchent, cette méthode se comporte comme si les valeurs d’origine de <ph id="ph3">`sourceArray`</ph> ont été conservés dans un emplacement temporaire avant <ph id="ph4">`destinationArray`</ph> est remplacé.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Cette méthode est équivalente à la fonction C/C++ standard <ph id="ph1">`memmove`</ph>, et non <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Les tableaux peuvent être des tableaux de type référence ou des tableaux de type valeur.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Cast de type est effectuée, selon les besoins.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Lors de la copie à partir d’un tableau de type référence à un tableau de type valeur, chaque élément est unboxed, puis copié.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Lors de la copie à partir d’un tableau de type valeur dans un tableau de type référence, chaque élément est converti (boxed), puis copié.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Lors de la copie d’un tableau de type référence ou type de valeur vers un <ph id="ph1">&lt;xref:System.Object&gt;</ph> tableau, un <ph id="ph2">&lt;xref:System.Object&gt;</ph> est créé pour contenir chaque valeur ou référence, puis copié.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Lors de la copie d’un <ph id="ph1">&lt;xref:System.Object&gt;</ph> un tableau de type référence ou type valeur et l’attribution de tableau n’est pas possible, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Si <ph id="ph1">`sourceArray`</ph> et <ph id="ph2">`destinationArray`</ph> des tableaux de type référence ou des tableaux de type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, une copie superficielle est effectuée.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Une copie superficielle d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> est un nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph> contenant des références aux mêmes éléments que l’original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Les éléments eux-mêmes ou tout élément référencé par les éléments ne sont pas copiés.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">En revanche, une copie complète d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copie les éléments et tout ce que fait référence directement ou indirectement par les éléments.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> est levée si les tableaux sont de types incompatibles.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Compatibilité de type est définie comme suit :</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Un type est compatible avec lui-même.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Un type valeur est compatible avec <ph id="ph1">&lt;xref:System.Object&gt;</ph> et avec un type interface implémenté par ce type de valeur.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Un type valeur est considéré comme connecté à une interface uniquement s’il implémente cette interface directement.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Les types déconnectés ne sont pas compatibles.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Deux types valeur (prédéfini) intrinsèques sont compatibles si la copie à partir du type de source pour le type de destination est une conversion étendue.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Une conversion étendue jamais perd le plus d’informations, tandis qu’une conversion restrictive peut perdre des informations.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Par exemple, convertir un entier signé 32 bits à un entier signé 64 bits est une conversion étendue, et la conversion d’un entier signé 64 bits à un entier signé 32 bits est une conversion restrictive.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Un type non intrinsèque valeur (défini par l’utilisateur) est compatible uniquement avec lui-même.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Les énumérations ont une conversion implicite vers <ph id="ph1">&lt;xref:System.Enum&gt;</ph> et leur type sous-jacent.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Si tous les éléments de <ph id="ph1">`sourceArray`</ph> nécessite un cast aval (par exemple, à partir d’une classe de base pour une classe dérivée ou d’une interface vers un objet) et un ou plusieurs éléments ne peut pas être convertis au type correspondant dans <ph id="ph2">`destinationArray`</ph>, un <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Si cette méthode lève une exception lors de la copie, l’état de <ph id="ph1">`destinationArray`</ph> n’est pas défini.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The following code example shows how to copy from one <ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Object&gt;</ph> to another <ph id="ph3">&lt;xref:System.Array&gt;</ph> of type integer.</source>
          <target state="translated">L’exemple de code suivant montre comment copier à partir d’un <ph id="ph1">&lt;xref:System.Array&gt;</ph> de type <ph id="ph2">&lt;xref:System.Object&gt;</ph> vers un autre <ph id="ph3">&lt;xref:System.Array&gt;</ph> de type entier.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> et <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> ont des classements différents.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> et <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sont de types incompatibles.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Au moins un élément de <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> ne peut pas être converti en type <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> est en dehors de la plage d’index valides pour <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> est en dehors de la plage d’index valides pour <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à 0 ou supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est supérieur au nombre d’éléments compris entre <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> et la fin de <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est supérieur au nombre d’éléments compris entre <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> et la fin de <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array.</source>
          <target state="translated">Copie tous les éléments du tableau unidimensionnel actuel dans le tableau unidimensionnel spécifié.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
          <target state="translated">Tableau unidimensionnel constituant la destination des éléments copiés à partir du tableau actuel.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>A 32-bit integer that represents the index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Entier 32 bits qui représente l’index dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> auquel la copie commence.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
          <target state="translated">Copie tous les éléments du tableau unidimensionnel actuel dans le tableau unidimensionnel spécifié en commençant à l'index du tableau de destination spécifié.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">L'index est spécifié en tant qu'entier 32 bits.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
          <target state="translated">Cette méthode copie tous les éléments de l’instance actuelle de tableau pour le <ph id="ph1">`array`</ph> tableau de destination, en commençant à l’index <ph id="ph2">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
          <target state="translated">Le <ph id="ph1">`array`</ph> tableau de destination doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à prendre en compte les éléments copiés.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Otherwise, the method throws an exception.</source>
          <target state="translated">Sinon, la méthode lève une exception.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Cette méthode prend en charge la <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
          <target state="translated">Si implémentant <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> est pas explicitement requise, utilisez <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> pour éviter toute indirection supplémentaire.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
          <target state="translated">Si cette méthode lève une exception lors de la copie, l’état de <ph id="ph1">`array`</ph> n’est pas défini.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>. Il effectue une copie superficielle uniquement.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment copier un <ph id="ph1">&lt;xref:System.Array&gt;</ph> vers un autre <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph> with a nonzero lower bound.</source>
          <target state="translated">L’exemple de code suivant montre comment copier un <ph id="ph1">&lt;xref:System.Array&gt;</ph> vers un autre <ph id="ph2">&lt;xref:System.Array&gt;</ph> avec une limite inférieure différente de zéro.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Note that the entire source <ph id="ph1">&lt;xref:System.Array&gt;</ph> is copied, including empty elements that overwrite existing elements in the target <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Notez que la source entière <ph id="ph1">&lt;xref:System.Array&gt;</ph> est copié, y compris les éléments vides qui remplacent les éléments existants dans la cible <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure d’<ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source array is greater than the available number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans le tableau source est supérieur au nombre d’éléments disponible entre <ph id="ph1">&lt;paramref name="index" /&gt;</ph> et la fin du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destination.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Le type du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> source ne peut pas être converti automatiquement en type du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destination.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The source array is multidimensional.</source>
          <target state="translated">Le tableau source est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>At least one element in the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast to the type of destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Au moins un élément du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> source ne peut pas être casté en type du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destination.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
          <target state="translated">Tableau unidimensionnel constituant la destination des éléments copiés à partir du tableau actuel.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>A 64-bit integer that represents the index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Entier 64 bits qui représente l’index dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> auquel la copie commence.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
          <target state="translated">Copie tous les éléments du tableau unidimensionnel actuel dans le tableau unidimensionnel spécifié en commençant à l'index du tableau de destination spécifié.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">L'index est spécifié en tant qu'entier 64 bits.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
          <target state="translated">Cette méthode copie tous les éléments de l’instance actuelle de tableau pour le <ph id="ph1">`array`</ph> tableau de destination, en commençant à l’index <ph id="ph2">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
          <target state="translated">Le <ph id="ph1">`array`</ph> tableau de destination doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à prendre en compte les éléments copiés.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Otherwise, the method throws an exception.</source>
          <target state="translated">Sinon, la méthode lève une exception.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Cette méthode prend en charge la <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
          <target state="translated">Si implémentant <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> est pas explicitement requise, utilisez <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> pour éviter toute indirection supplémentaire.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
          <target state="translated">Si cette méthode lève une exception lors de la copie, l’état de <ph id="ph1">`array`</ph> n’est pas défini.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>. Il effectue une copie superficielle uniquement.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment copier un <ph id="ph1">&lt;xref:System.Array&gt;</ph> vers un autre <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph> with a nonzero lower bound.</source>
          <target state="translated">L’exemple de code suivant montre comment copier un <ph id="ph1">&lt;xref:System.Array&gt;</ph> vers un autre <ph id="ph2">&lt;xref:System.Array&gt;</ph> avec une limite inférieure différente de zéro.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Note that the entire source <ph id="ph1">&lt;xref:System.Array&gt;</ph> is copied, including empty elements that overwrite existing elements in the target <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Notez que la source entière <ph id="ph1">&lt;xref:System.Array&gt;</ph> est copié, y compris les éléments vides qui remplacent les éléments existants dans la cible <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est en dehors de la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The number of elements in the source array is greater than the available number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans le tableau source est supérieur au nombre d’éléments disponible entre <ph id="ph1">&lt;paramref name="index" /&gt;</ph> et la fin du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destination.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Le type du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> source ne peut pas être casté automatiquement en type du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destination.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> source est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>At least one element in the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast to the type of destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Au moins un élément du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> source ne peut pas être casté en type du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destination.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The size of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Taille du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Creates a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and length, with zero-based indexing.</source>
          <target state="translated">Crée un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> et de la longueur spécifiés, à l’aide d’un index de base zéro.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>A new one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length, using zero-based indexing.</source>
          <target state="translated">Nouveau <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> et de la longueur spécifiés, avec un index de base zéro.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Contrairement à la plupart des classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fournit le <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Les éléments de type référence sont initialisés à <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Éléments de type valeur sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The following code example shows how to create and initialize a one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment créer et initialiser une dimension <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n'est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est un type générique ouvert.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>An array of 32-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Tableau d’entiers 32 bits qui représentent la taille de chaque dimension du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Crée un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> et des longueurs de dimensions spécifiés, à l’aide d’un index de base zéro.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The dimension lengths are specified in an array of 32-bit integers.</source>
          <target state="translated">Les longueurs de dimensions sont spécifiées en tant qu'entiers 32 bits.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nouveau <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> spécifié avec la longueur déterminée pour chaque dimension, à l’aide d’un index de base zéro.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Contrairement à la plupart des classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fournit le <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans le <ph id="ph1">`lengths`</ph> tableau doit être égal au nombre de dimensions dans le nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque élément de la <ph id="ph1">`lengths`</ph> tableau doive spécifier la longueur de la dimension correspondante dans le nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Les éléments de type référence sont initialisés à <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Éléments de type valeur sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le produit de toutes les valeurs de <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment créer et initialiser un multidimensionnelles <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> contient moins d’un élément.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n'est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est un type générique ouvert.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero.</source>
          <target state="translated">Toute valeur de <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> est inférieure à zéro.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>An array of 64-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Tableau d’entiers 64 bits qui représentent la taille de chaque dimension du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Each integer in the array must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">Chaque entier du tableau doit être compris entre zéro et <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> inclus.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Crée un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> et des longueurs de dimensions spécifiés, à l’aide d’un index de base zéro.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The dimension lengths are specified in an array of 64-bit integers.</source>
          <target state="translated">Les longueurs de dimensions sont spécifiées en tant qu'entiers 64 bits.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nouveau <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> spécifié avec la longueur déterminée pour chaque dimension, à l’aide d’un index de base zéro.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Contrairement à la plupart des classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fournit le <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans le <ph id="ph1">`lengths`</ph> tableau doit être égal au nombre de dimensions dans le nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque élément de la <ph id="ph1">`lengths`</ph> tableau doive spécifier la longueur de la dimension correspondante dans le nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Les éléments de type référence sont initialisés à <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Éléments de type valeur sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le produit de toutes les valeurs de <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment créer et initialiser un multidimensionnelles <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> contient moins d’un élément.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n'est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est un type générique ouvert.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Toute valeur dans <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> est inférieure à 0 ou supérieure à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The size of the first dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Taille de la première dimension du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The size of the second dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Taille de la deuxième dimension du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Creates a two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Crée un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à deux dimensions du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> et des longueurs de dimensions spécifiés, à l’aide d’un index de base zéro.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>A new two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nouveau <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à deux dimensions du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> spécifié avec la longueur déterminée pour chaque dimension, à l’aide d’un index de base zéro.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Contrairement à la plupart des classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fournit le <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Les éléments de type référence sont initialisés à <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Éléments de type valeur sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph> and <ph id="ph4">`length2`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le produit de <ph id="ph3">`length1`</ph> et <ph id="ph4">`length2`</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The following code example shows how to create and initialize a two-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment créer et initialiser une à deux dimensions <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n'est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est un type générique ouvert.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A one-dimensional array that contains the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Tableau unidimensionnel qui contient la taille de chaque dimension du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A one-dimensional array that contains the lower bound (starting index) of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Tableau unidimensionnel qui contient la limite inférieure (index de départ) de chaque dimension du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with the specified lower bounds.</source>
          <target state="translated">Crée un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> et des longueurs de dimensions spécifiés, avec les limites inférieures déterminées.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length and lower bound for each dimension.</source>
          <target state="translated">Nouveau <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> spécifié avec la longueur et la limite inférieure déterminées pour chaque dimension.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Contrairement à la plupart des classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fournit le <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">`lengths`</ph> and <ph id="ph2">`lowerBounds`</ph> arrays must have the same number of elements.</source>
          <target state="translated">Le <ph id="ph1">`lengths`</ph> et <ph id="ph2">`lowerBounds`</ph> tableaux doivent avoir le même nombre d’éléments.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans le <ph id="ph1">`lengths`</ph> tableau doit être égal au nombre de dimensions dans le nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque élément de la <ph id="ph1">`lengths`</ph> tableau doive spécifier la longueur de la dimension correspondante dans le nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Each element of the <ph id="ph1">`lowerBounds`</ph> array must specify the lower bound of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque élément de la <ph id="ph1">`lowerBounds`</ph> tableau doive spécifier la limite inférieure de la dimension correspondante dans le nouveau <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</source>
          <target state="translated">En règle générale, la bibliothèque de classes .NET Framework et de nombreux langages de programmation ne gèrent pas les limites inférieures différentes de zéro.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Les éléments de type référence sont initialisés à <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Éléments de type valeur sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le produit de toutes les valeurs de <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> with specified lower bounds.</source>
          <target state="translated">L’exemple de code suivant montre comment créer et initialiser un multidimensionnelles <ph id="ph1">&lt;xref:System.Array&gt;</ph> avec les limites inférieures déterminées.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated">Le tableau <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> contient moins d’un élément.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> and <ph id="ph2">&lt;paramref name="lowerBounds" /&gt;</ph> arrays do not contain the same number of elements.</source>
          <target state="translated">Les tableaux <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> et <ph id="ph2">&lt;paramref name="lowerBounds" /&gt;</ph> ne contiennent pas le même nombre d’éléments.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n'est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est un type générique ouvert.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero.</source>
          <target state="translated">Toute valeur de <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> est inférieure à zéro.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> is very large, such that the sum of a dimension's lower bound and length is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Toute valeur de <ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> est très grande, comme la somme de la limite inférieure d’une dimension et de la longueur est supérieure à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the first dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Taille de la première dimension du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the second dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Taille de la deuxième dimension du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the third dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Taille de la troisième dimension du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à créer.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Creates a three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Crée un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à trois dimensions du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> et des longueurs de dimensions spécifiés, à l’aide d’un index de base zéro.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>A new three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nouveau <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à trois dimensions du <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> spécifié avec la longueur déterminée pour chaque dimension, à l’aide d’un index de base zéro.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Contrairement à la plupart des classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fournit le <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Les éléments de type référence sont initialisés à <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Éléments de type valeur sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph>, <ph id="ph4">`length2`</ph>, and <ph id="ph5">`length3`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le produit de <ph id="ph3">`length1`</ph>, <ph id="ph4">`length2`</ph>, et <ph id="ph5">`length3`</ph>.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The following code example shows how to create and initialize a three-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment créer et initialiser un à trois dimensions <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> n'est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> n’est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> est un type générique ouvert.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length3" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length3" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Empty``1">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Array.Empty``1">
          <source>Returns an empty array.</source>
          <target state="translated">Retourne un tableau vide.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Array.Empty``1">
          <source>Returns an empty <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Retourne un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vide.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the elements to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> qui définit les conditions des éléments à rechercher.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">Détermine si le tableau spécifié contient des éléments qui correspondent aux conditions définies par le prédicat spécifié.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="array" /&gt;</ph> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="array" /&gt;</ph> contient un ou plusieurs éléments qui correspondent aux conditions définies par le prédicat spécifié ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> est un délégué à une méthode qui retourne <ph id="ph2">`true`</ph> si l’objet passé à elle correspond aux conditions définies dans ce délégué.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when a match is found.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, et le traitement s’arrête lorsqu’une correspondance est trouvée.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate explicitly.</source>
          <target state="translated">En c# et Visual Basic, il n’est pas nécessaire de créer le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> déléguer explicitement.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example specifies the match conditions for the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method usinglambda expressions to check whether a planet starts with a given letter or whether the planet is found on the given array.</source>
          <target state="translated">L’exemple suivant spécifie les conditions de correspondance pour le <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> expressions usinglambda de méthode pour vérifier si une planète commence par une lettre donnée, ou si la planète se trouve sur le tableau donné.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method to indicate whether any names in a string array begin with a specified character.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> méthode pour indiquer si tous les noms dans un tableau de chaînes commencent par un caractère spécifié.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The example instantiates a <ph id="ph1">`StringSearcher`</ph> object by passing the string to search for to its class constructor.</source>
          <target state="translated">L’exemple instancie un <ph id="ph1">`StringSearcher`</ph> en passant la chaîne à rechercher pour son constructeur de classe.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">`StringSearcher.StartsWith`</ph> method has same signature as the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Le <ph id="ph1">`StringSearcher.StartsWith`</ph> méthode a la même signature que le <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>When the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method is called, each member of the array is passed to the delegate until it returns <ph id="ph2">`true`</ph> or iterates all the elements in the array.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> est appelée, chaque membre du tableau est passé au délégué, jusqu'à ce qu’elle retourne <ph id="ph2">`true`</ph> ou itère au sein de tous les éléments du tableau.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>You can also use a lambda expression rather than explicitly define a method whose signature corresponds to that of the delegate.</source>
          <target state="translated">Vous pouvez également utiliser une expression lambda non définir explicitement une méthode dont la signature correspond à celle du délégué.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example replaces the <ph id="ph1">`StringSearcher`</ph> class and its <ph id="ph2">`StartsWith`</ph> method with a lambda expression.</source>
          <target state="translated">L’exemple suivant remplace le <ph id="ph1">`StringSearcher`</ph> classe et ses <ph id="ph2">`StartsWith`</ph> méthode avec une expression lambda.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Le tableau de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The predicate that defines the conditions of the element to search for.</source>
          <target state="translated">Le prédicat qui définit les conditions de l’élément à rechercher.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne la première occurrence dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> entier.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Premier élément qui correspond aux conditions définies par le prédicat spécifié, s'il est trouvé ; sinon, valeur par défaut du type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method or a lambda expression that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate or lambda expression.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> est un délégué à une méthode ou une expression lambda qui retourne <ph id="ph2">`true`</ph> si l’objet passé à elle correspond aux conditions définies dans la délégué ou l’expression lambda.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, starting with the first element and ending with the last element.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, en commençant par le premier élément et se terminant par le dernier élément.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">Le traitement est arrêté lorsqu’une correspondance est trouvée.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The following example uses a <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate with the <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> generic method to search an array of <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</source>
          <target state="translated">L’exemple suivant utilise un <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> délégué avec le <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> une méthode générique pour rechercher un tableau de <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The method the delegate represents, <ph id="ph1">`ProductGT10`</ph>, returns <ph id="ph2">`true`</ph> if the product of the X and Y fields is greater than 100,000.</source>
          <target state="translated">La méthode que le délégué représente, <ph id="ph1">`ProductGT10`</ph>, retourne <ph id="ph2">`true`</ph> si le produit des champs X et Y est supérieur à 100 000.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> method calls the delegate for each element of the array, returning the first point that meets the test condition.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> méthode appelle le délégué pour chaque élément du tableau, en retournant le premier point qui remplit la condition de test.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Visual Basic and C# users do not have to create the delegate explicitly or specify the type argument of the generic method.</source>
          <target state="translated">Visual Basic et c# les utilisateurs n’ont pas créer le délégué explicitement ou de spécifier l’argument de type de la méthode générique.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The compilers determine the necessary types from the method arguments you supply.</source>
          <target state="translated">Les compilateurs déterminent les types nécessaires à partir de vous fournissez les arguments de la méthode.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Rather than explicitly defining a method with the necessary signature, instantiating a <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate, and passing the delegate to the <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> method, it is customary to use a lambda expression.</source>
          <target state="translated">Au lieu de définir explicitement une méthode avec la signature nécessaire, l’instanciation d’un <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> délégué et en passant le délégué à la <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> (méthode), il est courant d’utiliser une expression lambda.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The following example is identical to the previous one, except that it uses a lambda expression as the <ph id="ph1">`match`</ph> argument.</source>
          <target state="translated">L’exemple suivant est identique au précédent, sauf qu’elle utilise une expression lambda en tant que le <ph id="ph1">`match`</ph> argument.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the elements to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> qui définit les conditions des éléments à rechercher.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Retrieves all the elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">Récupère tous les éléments qui correspondent aux conditions définies par le prédicat spécifié.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>An <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> contenant tous les éléments qui correspondent aux conditions définies par le prédicat spécifié, s'il existe ; sinon, un <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> vide.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> est un délégué à une méthode qui retourne <ph id="ph2">`true`</ph> si l’objet passé à elle correspond aux conditions définies dans ce délégué.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and the elements that match the conditions are saved in the returned array.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, et les éléments qui correspondent aux conditions sont enregistrés dans le tableau retourné.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The following example creates an array of 50 random numbers with values that can range from 0 to 1,000.</source>
          <target state="translated">L’exemple suivant crée un tableau de nombres aléatoires 50 avec des valeurs qui peuvent s’échelonner de 0 à 1 000.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> method with a lambda expression that returns the values that range from 300 to 600.</source>
          <target state="translated">Il appelle ensuite la <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> méthode avec une expression lambda qui retourne les valeurs comprises entre 300 à 600.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Note that the lambda expression is passed a parameter named <ph id="ph1">`x`</ph>;  this represents the individual array member that is passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Notez que l’expression lambda est passée à un paramètre nommé <ph id="ph1">`x`</ph>;  représente le membre du groupe individuel qui est transmis à la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Also note that the local <ph id="ph1">`lBound`</ph> and <ph id="ph2">`uBound`</ph> variables are accessible within the lambda expression.</source>
          <target state="translated">Notez également que l’ordinateur local <ph id="ph1">`lBound`</ph> et <ph id="ph2">`uBound`</ph> les variables sont accessibles au sein de l’expression lambda.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, et <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> les méthodes génériques.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Un tableau de chaînes est créé, contenant 8 noms dinosaure deux (aux emplacements 1 et 5) se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L’exemple de code définit également une méthode de prédicat de recherche nommée <ph id="ph1">`EndsWithSaurus`</ph>, qui accepte un paramètre de chaîne et retourne une valeur Boolean qui indique si la chaîne d’entrée se termine par « saurus ».</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generic method traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> méthode générique parcourt le tableau à partir du début, chaque élément en passant à la <ph id="ph2">`EndsWithSaurus`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element "Amargasaurus".</source>
          <target state="translated">La recherche s’arrête lorsque la <ph id="ph1">`EndsWithSaurus`</ph> retourne de la méthode <ph id="ph2">`true`</ph> pour l’élément « Amargasaurus ».</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">En c# et Visual Basic, il n’est pas nécessaire de créer le <ph id="ph1">`Predicate&lt;string&gt;`</ph> déléguer (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explicitement.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generic method is used to search the array backward from the end.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> méthode générique est utilisée pour rechercher le tableau à partir de la fin.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>It finds the element "Dilophosaurus" at position 5.</source>
          <target state="translated">Il recherche l’élément « Dilophosaurus » à la position 5.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic method is used to return an array containing all the elements that end in "saurus".</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> méthode générique est utilisée pour retourner un tableau contenant tous les éléments qui se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The elements are displayed.</source>
          <target state="translated">Les éléments sont affichés.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">L’exemple de code montre également le <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> les méthodes génériques.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Recherche un élément qui correspond aux conditions définies par un prédicat spécifié, et retourne l'index de base zéro de la première occurrence dans un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ou dans l'une partie de ses parties.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> qui définit les conditions de l’élément à rechercher.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la première occurrence trouvée dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> entier.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Index de base zéro de la première occurrence d’un élément qui répond aux conditions définies par <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si cette occurrence est trouvée ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> recherche est effectuée vers l’avant à partir du premier élément au dernier élément.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> est un délégué à une méthode qui retourne <ph id="ph2">`true`</ph> si l’objet passé à elle correspond aux conditions définies dans ce délégué.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à le <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">L’exemple de code suivant illustre les trois surcharges de la <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> méthode générique.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Un tableau de chaînes est créé, contenant 8 noms dinosaure deux (aux emplacements 1 et 5) se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L’exemple de code définit également une méthode de prédicat de recherche nommée <ph id="ph1">`EndsWithSaurus`</ph>, qui accepte un paramètre de chaîne et retourne une valeur Boolean qui indique si la chaîne d’entrée se termine par « saurus ».</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode parcourt le tableau à partir du début, chaque élément en passant à la <ph id="ph2">`EndsWithSaurus`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">La recherche s’arrête lorsque la <ph id="ph1">`EndsWithSaurus`</ph> retourne de la méthode <ph id="ph2">`true`</ph> pour l’élément à la position 1.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">En c# et Visual Basic, il n’est pas nécessaire de créer le <ph id="ph1">`Predicate&lt;string&gt;`</ph> déléguer (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explicitement.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 2 à la fin du tableau.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Il recherche l’élément à la position 5.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher la plage de trois éléments en commençant à la position 2.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Index de début de base zéro de la recherche.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> qui définit les conditions de l’élément à rechercher.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the specified index to the last element.</source>
          <target state="translated">Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la première occurrence trouvée dans la plage d'éléments de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui s'étend de l'index spécifié au dernier élément.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Index de base zéro de la première occurrence d’un élément qui répond aux conditions définies par <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si cette occurrence est trouvée ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at the last element.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> recherche est effectuée vers l’avant <ph id="ph2">`startIndex`</ph> et jusqu’au dernier élément.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> est un délégué à une méthode qui retourne <ph id="ph2">`true`</ph> si l’objet passé à elle correspond aux conditions définies dans ce délégué.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à le <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le nombre d’éléments à partir de <ph id="ph3">`startIndex`</ph> à la fin de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">L’exemple de code suivant illustre les trois surcharges de la <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> méthode générique.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Un tableau de chaînes est créé, contenant 8 noms dinosaure deux (aux emplacements 1 et 5) se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L’exemple de code définit également une méthode de prédicat de recherche nommée <ph id="ph1">`EndsWithSaurus`</ph>, qui accepte un paramètre de chaîne et retourne une valeur Boolean qui indique si la chaîne d’entrée se termine par « saurus ».</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode parcourt le tableau à partir du début, chaque élément en passant à la <ph id="ph2">`EndsWithSaurus`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">La recherche s’arrête lorsque la <ph id="ph1">`EndsWithSaurus`</ph> retourne de la méthode <ph id="ph2">`true`</ph> pour l’élément à la position 1.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">En c# et Visual Basic, il n’est pas nécessaire de créer le <ph id="ph1">`Predicate&lt;string&gt;`</ph> déléguer (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explicitement.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 2 à la fin du tableau.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Il recherche l’élément à la position 5.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher la plage de trois éléments en commençant à la position 2.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> n’est pas compris dans la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Index de début de base zéro de la recherche.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> qui définit les conditions de l’élément à rechercher.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
          <target state="translated">Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la première occurrence trouvée dans la plage d'éléments de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui commence à l'index spécifié et contient le nombre d'éléments spécifié.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Index de base zéro de la première occurrence d’un élément qui répond aux conditions définies par <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si cette occurrence est trouvée ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> recherche est effectuée vers l’avant <ph id="ph2">`startIndex`</ph> et se terminant à <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> -1, si <ph id="ph5">`count`</ph> est supérieur à 0.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> est un délégué à une méthode qui retourne <ph id="ph2">`true`</ph> si l’objet passé à elle correspond aux conditions définies dans ce délégué.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à le <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">L’exemple de code suivant illustre les trois surcharges de la <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> méthode générique.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Un tableau de chaînes est créé, contenant 8 noms dinosaure deux (aux emplacements 1 et 5) se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L’exemple de code définit également une méthode de prédicat de recherche nommée <ph id="ph1">`EndsWithSaurus`</ph>, qui accepte un paramètre de chaîne et retourne une valeur Boolean qui indique si la chaîne d’entrée se termine par « saurus ».</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode parcourt le tableau à partir du début, chaque élément en passant à la <ph id="ph2">`EndsWithSaurus`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">La recherche s’arrête lorsque la <ph id="ph1">`EndsWithSaurus`</ph> retourne de la méthode <ph id="ph2">`true`</ph> pour l’élément à la position 1.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">En c# et Visual Basic, il n’est pas nécessaire de créer le <ph id="ph1">`Predicate&lt;string&gt;`</ph> déléguer (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explicitement.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 2 à la fin du tableau.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Il recherche l’élément à la position 5.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher la plage de trois éléments en commençant à la position 2.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> n’est pas compris dans la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne spécifient pas une section valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> qui définit les conditions de l’élément à rechercher.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne la dernière occurrence dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> entier.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Dernier élément qui correspond aux conditions définies par le prédicat spécifié, s'il est trouvé ; sinon, valeur par défaut du type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> est un délégué à une méthode qui retourne <ph id="ph2">`true`</ph> si l’objet passé à elle correspond aux conditions définies dans ce délégué.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, moving backward in the <ph id="ph3">&lt;xref:System.Array&gt;</ph>, starting with the last element and ending with the first element.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, déplacement vers l’arrière dans le <ph id="ph3">&lt;xref:System.Array&gt;</ph>, en commençant par le dernier élément et se terminant par le premier élément.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">Le traitement est arrêté lorsqu’une correspondance est trouvée.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, et <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> les méthodes génériques.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Un tableau de chaînes est créé, contenant 8 noms dinosaure deux (aux emplacements 1 et 5) se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L’exemple de code définit également une méthode de prédicat de recherche nommée <ph id="ph1">`EndsWithSaurus`</ph>, qui accepte un paramètre de chaîne et retourne une valeur Boolean qui indique si la chaîne d’entrée se termine par « saurus ».</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generic method traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> méthode générique parcourt le tableau à partir du début, chaque élément en passant à la <ph id="ph2">`EndsWithSaurus`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element "Amargasaurus".</source>
          <target state="translated">La recherche s’arrête lorsque la <ph id="ph1">`EndsWithSaurus`</ph> retourne de la méthode <ph id="ph2">`true`</ph> pour l’élément « Amargasaurus ».</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the<ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">En c# et Visual Basic, il n’est pas nécessaire de créer le<ph id="ph1">`Predicate&lt;string&gt;`</ph> déléguer (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explicitement.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generic method is used to search the array backward from the end.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> méthode générique est utilisée pour rechercher le tableau à partir de la fin.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>It finds the element "Dilophosaurus" at position 5.</source>
          <target state="translated">Il recherche l’élément « Dilophosaurus » à la position 5.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic method is used to return an array containing all the elements that end in "saurus".</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> méthode générique est utilisée pour retourner un tableau contenant tous les éléments qui se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The elements are displayed.</source>
          <target state="translated">Les éléments sont affichés.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">L’exemple de code montre également le <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> les méthodes génériques.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Recherche un élément qui correspond aux conditions définies par un prédicat spécifié, et retourne l'index de base zéro de la dernière occurrence dans un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ou dans l'une partie de ses parties.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> qui définit les conditions de l’élément à rechercher.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la dernière occurrence trouvée dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> entier.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Index de base zéro de la dernière occurrence d'un élément qui correspond aux conditions définies par <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si cette occurrence est trouvée ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> recherche est effectuée vers l’arrière à partir du dernier élément du premier élément.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> est un délégué à une méthode qui retourne <ph id="ph2">`true`</ph> si l’objet passé à elle correspond aux conditions définies dans ce délégué.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à le <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">L’exemple de code suivant illustre les trois surcharges de la <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> méthode générique.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Un tableau de chaînes est créé, contenant 8 noms dinosaure deux (aux emplacements 1 et 5) se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L’exemple de code définit également une méthode de prédicat de recherche nommée <ph id="ph1">`EndsWithSaurus`</ph>, qui accepte un paramètre de chaîne et retourne une valeur Boolean qui indique si la chaîne d’entrée se termine par « saurus ».</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode parcourt le tableau vers le haut de la fin, chaque élément en passant à la <ph id="ph2">`EndsWithSaurus`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">La recherche s’arrête lorsque la <ph id="ph1">`EndsWithSaurus`</ph> retourne de la méthode <ph id="ph2">`true`</ph> pour l’élément à la position 5.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">En c# et Visual Basic, il n’est pas nécessaire de créer le <ph id="ph1">`Predicate&lt;string&gt;`</ph> déléguer (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explicitement.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 4 au début du tableau.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Il recherche l’élément à la position 1.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher la plage de trois éléments commençant à la position 4 et en (autrement dit, 2, 3 et 4).</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Index de début de base zéro de la recherche vers le haut.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> qui définit les conditions de l’élément à rechercher.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la dernière occurrence trouvée dans la plage d'éléments du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui s'étend du premier élément à l'index spécifié.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Index de base zéro de la dernière occurrence d'un élément qui correspond aux conditions définies par <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si cette occurrence est trouvée ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> est effectuée vers l’arrière commençant à <ph id="ph2">`startIndex`</ph> et jusqu’au premier élément.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> est un délégué à une méthode qui retourne <ph id="ph2">`true`</ph> si l’objet passé à elle correspond aux conditions définies dans ce délégué.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à le <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le nombre d’éléments à partir du début de <ph id="ph3">`array`</ph> à <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">L’exemple de code suivant illustre les trois surcharges de la <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> méthode générique.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Un tableau de chaînes est créé, contenant 8 noms dinosaure deux (aux emplacements 1 et 5) se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L’exemple de code définit également une méthode de prédicat de recherche nommée <ph id="ph1">`EndsWithSaurus`</ph>, qui accepte un paramètre de chaîne et retourne une valeur Boolean qui indique si la chaîne d’entrée se termine par « saurus ».</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode parcourt le tableau vers le haut de la fin, chaque élément en passant à la <ph id="ph2">`EndsWithSaurus`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">La recherche s’arrête lorsque la <ph id="ph1">`EndsWithSaurus`</ph> retourne de la méthode <ph id="ph2">`true`</ph> pour l’élément à la position 5.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">En c# et Visual Basic, il n’est pas nécessaire de créer le <ph id="ph1">`Predicate&lt;string&gt;`</ph> déléguer (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explicitement.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 4 au début du tableau.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Il recherche l’élément à la position 1.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher la plage de trois éléments commençant à la position 4 et en (autrement dit, 2, 3 et 4).</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> n’est pas compris dans la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Index de début de base zéro de la recherche vers le haut.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> qui définit les conditions de l’élément à rechercher.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la dernière occurrence trouvée dans la plage d'éléments du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui contient le nombre d'éléments spécifié et se termine à l'index spécifié.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Index de base zéro de la dernière occurrence d'un élément qui correspond aux conditions définies par <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si cette occurrence est trouvée ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> est effectuée vers l’arrière commençant à <ph id="ph2">`startIndex`</ph> et se terminant à <ph id="ph3">`startIndex`</ph> moins <ph id="ph4">`count`</ph> + 1, si <ph id="ph5">`count`</ph> est supérieur à 0.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> est un délégué à une méthode qui retourne <ph id="ph2">`true`</ph> si l’objet passé à elle correspond aux conditions définies dans ce délégué.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à le <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">L’exemple de code suivant illustre les trois surcharges de la <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> méthode générique.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Un tableau de chaînes est créé, contenant 8 noms dinosaure deux (aux emplacements 1 et 5) se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L’exemple de code définit également une méthode de prédicat de recherche nommée <ph id="ph1">`EndsWithSaurus`</ph>, qui accepte un paramètre de chaîne et retourne une valeur Boolean qui indique si la chaîne d’entrée se termine par « saurus ».</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode parcourt le tableau vers le haut de la fin, chaque élément en passant à la <ph id="ph2">`EndsWithSaurus`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">La recherche s’arrête lorsque la <ph id="ph1">`EndsWithSaurus`</ph> retourne de la méthode <ph id="ph2">`true`</ph> pour l’élément à la position 5.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">En c# et Visual Basic, il n’est pas nécessaire de créer le <ph id="ph1">`Predicate&lt;string&gt;`</ph> déléguer (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explicitement.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 4 au début du tableau.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Il recherche l’élément à la position 1.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> surcharge de méthode est utilisée pour rechercher la plage de trois éléments commençant à la position 4 et en (autrement dit, 2, 3 et 4).</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> n’est pas compris dans la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne spécifient pas une section valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> on whose elements the action is to be performed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel de base zéro sur les éléments duquel l'action doit être exécutée.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph> to perform on each element of <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph> à exécuter sur chaque élément de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>Performs the specified action on each element of the specified array.</source>
          <target state="translated">Exécute l'action spécifiée sur chaque élément du tableau spécifié.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> is a delegate to a method that performs an action on the object passed to it.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> est un délégué à une méthode qui effectue une action sur l’objet passé.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Action%601&gt;</ph>.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à le <ph id="ph2">&lt;xref:System.Action%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The following example shows how to use <ph id="ph1">&lt;xref:System.Array.ForEach%2A&gt;</ph> to display the squares of each element in an integer array.</source>
          <target state="translated">L’exemple suivant montre comment utiliser <ph id="ph1">&lt;xref:System.Array.ForEach%2A&gt;</ph> pour afficher les carrés de chaque élément dans un tableau d’entiers.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source><ph id="ph1">&lt;paramref name="action" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Array.GetEnumerator">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Retourne <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> pour l'objet <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Array.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> pour <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">(Visual Basic, c#)</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">Le <ph id="ph1">`foreach`</ph> instruction du langage c# (<ph id="ph2">`for each`</ph> en C++, <ph id="ph3">`For Each`</ph> en Visual Basic) masque la complexité des énumérateurs.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Il est donc recommandé d'utiliser <ph id="ph1">`foreach`</ph> plutôt que de manipuler l'énumérateur directement.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Au départ, l’énumérateur est positionné avant le premier élément de la collection.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> replace également l'énumérateur à cette position.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">À cette position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> n'est pas défini.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Par conséquent, vous devez appeler <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> retourne le même objet tant que <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> n'est pas appelé.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> affecte l'élément suivant à <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> dépasse la fin de la collection, l’énumérateur est placée après le dernier élément dans la collection et <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retourne <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Lorsque l’énumérateur est à cette position, les appels suivants à <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> également retourner <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Si le dernier appel à <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retourné <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> n’est pas défini.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Pour attribuer une nouvelle fois <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> au premier élément de la collection, vous pouvez appeler <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> suivi de <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Un énumérateur est valide tant que la collection demeure inchangée.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Si des modifications sont apportées à la collection, telles que l’ajout, la modification ou la suppression d’éléments, l’énumérateur est définitivement invalidé et son comportement n’est pas défini.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">L’énumérateur ne dispose pas d’un accès exclusif à la collection. Par conséquent, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Array.GetEnumerator%2A&gt;</ph> to list the elements of an array.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser <ph id="ph1">&lt;xref:System.Array.GetEnumerator%2A&gt;</ph> pour répertorier les éléments d’un tableau.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>A zero-based dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> whose length needs to be determined.</source>
          <target state="translated">Dimension de base zéro de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> dont la longueur doit être déterminée.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>Gets a 32-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient un entier 32 bits qui représente le nombre d'éléments dans la dimension spécifiée de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>A 32-bit integer that represents the number of elements in the specified dimension.</source>
          <target state="translated">Entier 32 bits qui représente le nombre d'éléments dans la dimension spécifiée.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> is <ph id="ph2">`GetLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Un exemple de <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> est <ph id="ph2">`GetLength(0)`</ph>, qui retourne le nombre d’éléments dans la première dimension de le <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>The following example shows how to use <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> to display the dimensions of two arrays with different ranks.</source>
          <target state="translated">L’exemple suivant montre comment utiliser <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> pour afficher les dimensions de deux tableaux avec des classements différents.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> est supérieur ou égal à <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>A zero-based dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> whose length needs to be determined.</source>
          <target state="translated">Dimension de base zéro de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> dont la longueur doit être déterminée.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>Gets a 64-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient un entier 64 bits qui représente le nombre d’éléments dans la dimension spécifiée de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>A 64-bit integer that represents the number of elements in the specified dimension.</source>
          <target state="translated">Entier 64 bits qui représente le nombre d'éléments dans la dimension spécifiée.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> is <ph id="ph2">`GetLongLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Un exemple de <ph id="ph1">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> est <ph id="ph2">`GetLongLength(0)`</ph>, qui retourne le nombre d’éléments dans la première dimension de le <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> est supérieur ou égal à <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>A zero-based dimension of the array whose starting index needs to be determined.</source>
          <target state="translated">Dimension de base zéro du tableau dont l'index de départ doit être déterminé.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Gets the index of the first element of the specified dimension in the array.</source>
          <target state="translated">Obtient l'index du premier élément de la dimension spécifiée dans le tableau.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The index of the first element of the specified dimension in the array.</source>
          <target state="translated">Index du premier élément de la dimension spécifiée dans le tableau.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">`GetLowerBound(0)`</ph> returns the starting index of the first dimension of the array, and <ph id="ph2">`GetLowerBound(Rank - 1)`</ph> returns the starting index of the last dimension of the array.</source>
          <target state="translated"><ph id="ph1">`GetLowerBound(0)`</ph> Retourne l’index de départ de la première dimension du tableau, et <ph id="ph2">`GetLowerBound(Rank - 1)`</ph> retourne l’index de départ de la dernière dimension du tableau.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> méthode retourne toujours une valeur qui indique l’index de la limite inférieure du tableau, même si le tableau est vide.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Note that, although most arrays in the .NET Framework are zero-based (that is, the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based.</source>
          <target state="translated">Notez que, bien que la plupart des tableaux dans le .NET Framework sont de base zéro (autrement dit, la <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> retourne la valeur zéro pour chaque dimension d’un tableau), le .NET Framework ne prend pas en charge les tableaux qui ne sont pas de base zéro.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Such arrays can be created with the <ph id="ph1">&lt;xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29&gt;</ph> method, and can also be returned from unmanaged code.</source>
          <target state="translated">Ces tableaux peut être créés avec le <ph id="ph1">&lt;xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29&gt;</ph> (méthode) et peut également être renvoyé à partir de code non managé.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes pour afficher les limites d’un tableau unidimensionnel et à deux dimensions et pour afficher les valeurs de leurs éléments de tableau.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> est supérieur ou égal à <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>A zero-based dimension of the array whose upper bound needs to be determined.</source>
          <target state="translated">Dimension de base zéro du tableau dont la limite supérieure doit être déterminée.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>Gets the index of the last element of the specified dimension in the array.</source>
          <target state="translated">Obtient l'index du dernier élément de la dimension spécifiée dans le tableau.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty.</source>
          <target state="translated">Index du dernier élément de la dimension spécifiée dans le tableau, ou -1 si la dimension spécifiée est vide.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">`GetUpperBound(0)`</ph> returns the last index in the first dimension of the array, and <ph id="ph2">`GetUpperBound(Rank - 1)`</ph> returns the last index of the last dimension of the array.</source>
          <target state="translated"><ph id="ph1">`GetUpperBound(0)`</ph> Retourne le dernier index de la première dimension du tableau, et <ph id="ph2">`GetUpperBound(Rank - 1)`</ph> retourne le dernier index de la dernière dimension du tableau.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes pour afficher les limites d’un tableau unidimensionnel et à deux dimensions et pour afficher les valeurs de leurs éléments de tableau.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> est supérieur ou égal à <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Gets the value of the specified element in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient la valeur de l'élément spécifié dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 32 bits qui représente la position de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient la valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">L'index est spécifié en tant qu'entier 32 bits.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si la valeur de <ph id="ph3">`index`</ph> est hors limites.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement une dimension.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est en dehors de la plage d'index valide pour le <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Tableau unidimensionnel d'entier 32 bits qui représentent les index qui spécifient la position de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient la valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The indexes are specified as an array of 32-bit integers.</source>
          <target state="translated">Les index sont spécifiés sous la forme d'un tableau d'entiers 32 bits.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans <ph id="ph1">`indices`</ph> doit être égal au nombre de dimensions dans le <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Tous les éléments dans le <ph id="ph1">`indices`</ph> tableau doit spécifier collectivement la position de l’élément souhaité dans les données multidimensionnelles <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si un des index est hors limites.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Le nombre de dimensions dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours n'est pas égal au nombre d'éléments dans <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Tous les éléments de <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> sont en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 64 bits qui représente la position de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient la valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">L'index est spécifié en tant qu'entier 64 bits.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si la valeur de <ph id="ph3">`index`</ph> est hors limites.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement une dimension.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est en dehors de la plage d'index valide pour le <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Tableau unidimensionnel d’entiers 64 bits qui représentent les index spécifiant la position de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient la valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The indexes are specified as an array of 64-bit integers.</source>
          <target state="translated">Les index sont spécifiés sous la forme d'un tableau d'entiers 64 bits.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans <ph id="ph1">`indices`</ph> doit être égal au nombre de dimensions dans le <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Tous les éléments dans le <ph id="ph1">`indices`</ph> tableau doit spécifier collectivement la position de l’élément souhaité dans les données multidimensionnelles <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si un des index est hors limites.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Le nombre de dimensions dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours n'est pas égal au nombre d'éléments dans <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Tous les éléments de <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> sont en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 32 bits qui représente l'index de la première dimension de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 32 bits qui représente l'index de la seconde dimension de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient la valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à deux dimensions.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Les index sont spécifiés en tant qu'entiers 32 bits.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à deux dimensions.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si un des index est hors limites.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement deux dimensions.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> est en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 64 bits qui représente l’index de la première dimension de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 64 bits qui représente l’index de la deuxième dimension de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient la valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à deux dimensions.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Les index sont spécifiés en tant qu'entiers 64 bits.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à deux dimensions.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si un des index est hors limites.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement deux dimensions.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> est en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 32 bits qui représente l'index de la première dimension de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 32 bits qui représente l'index de la seconde dimension de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 32 bits qui représente l'index de la troisième dimension de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient la valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à trois dimensions.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Les index sont spécifiés en tant qu'entiers 32 bits.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à trois dimensions.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si un des index est hors limites.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement trois dimensions.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> est en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 64 bits qui représente l’index de la première dimension de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 64 bits qui représente l’index de la deuxième dimension de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Entier 64 bits qui représente l’index de la troisième dimension de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient la valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à trois dimensions.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Les index sont spécifiés en tant qu'entiers 64 bits.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Valeur à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à trois dimensions.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si un des index est hors limites.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement trois dimensions.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> est en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array or in a range of elements in the array.</source>
          <target state="translated">Recherche l'objet spécifié et retourne l'index de sa première occurrence dans un tableau unidimensionnel ou dans une plage d'éléments dans le tableau.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Tableau unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
          <target state="translated">Recherche l'objet spécifié et retourne l'index de sa première occurrence dans un tableau unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">L’index de la première occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dans <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, s’il existe ; sinon, la limite inférieure du tableau -1.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This method searches all the elements of a one-dimensional arrayfor <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Cette méthode recherche tous les éléments d’une dimension arrayfor <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling each element's <ph id="ph3">`Equals`</ph> method until it finds a match.</source>
          <target state="translated">Pour déterminer si <ph id="ph1">`value`</ph> existe dans <ph id="ph2">`array`</ph>, la méthode effectue une comparaison d’égalité en appelant de chaque élément <ph id="ph3">`Equals`</ph> méthode jusqu'à ce qu’il trouve une correspondance.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Cela signifie que si l’élément remplace la <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> méthode, ce remplacement est appelé.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if<ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Étant donné que la plupart des tableaux ont une limite inférieure de zéro, cette méthode retourne généralement -1 si<ph id="ph1">`value`</ph> n’est pas trouvée.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">Dans les rares cas où la limite inférieure du tableau est égale à <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0 x 80000000) et <ph id="ph2">`value`</ph> n’est trouvé, cette méthode retourne <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">L’exemple appelle trois surcharges de la <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> méthode pour rechercher l’index d’une chaîne dans un tableau de chaînes :</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, pour déterminer la première occurrence de la chaîne « the » dans un tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, pour déterminer la première occurrence de la chaîne « the » dans la quatrième aux derniers éléments d’un tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, pour déterminer la première occurrence de la chaîne « the » dans une chaîne de tableau à partir de l’élément qui suit la dernière correspondance à la fin du tableau.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Tableau unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The starting index of the search.</source>
          <target state="translated">Index de départ de la recherche.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zéro) est valide dans un tableau vide.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Recherche l'objet spécifié dans une plage d'éléments d'un tableau unidimensionnel, et retourne l'index de sa première occurrence.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The range extends from a specified index to the end of the array.</source>
          <target state="translated">La plage s'étend d'un index spécifié à la fin du tableau.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if it’s found, within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Index de la première occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, s’il est trouvé, au sein de la plage d’éléments de <ph id="ph2">&lt;paramref name="array" /&gt;</ph> qui s’étend de <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> jusqu’au dernier élément ; sinon, limite inférieure du tableau moins 1.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This method searches a one-dimensional array from the element at index <ph id="ph1">`startIndex`</ph> to the last element.</source>
          <target state="translated">Cette méthode recherche dans un tableau unidimensionnel à partir de l’élément au niveau de l’index <ph id="ph1">`startIndex`</ph> jusqu’au dernier élément.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
          <target state="translated">Pour déterminer si <ph id="ph1">`value`</ph> existe dans <ph id="ph2">`array`</ph>, la méthode effectue une comparaison d’égalité en appelant le <ph id="ph3">`Equals`</ph> (méthode) de chaque élément jusqu'à ce qu’il trouve une correspondance.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Cela signifie que si l’élément remplace la <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> méthode, ce remplacement est appelé.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if <ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Étant donné que la plupart des tableaux ont une limite inférieure de zéro, cette méthode retourne généralement -1 si <ph id="ph1">`value`</ph> n’est pas trouvée.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">Dans les rares cas où la limite inférieure du tableau est égale à <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0 x 80000000) et <ph id="ph2">`value`</ph> n’est trouvé, cette méthode retourne <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>,the method returns -1.</source>
          <target state="translated">Si <ph id="ph1">`startIndex`</ph> est égal à <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, la méthode retourne -1.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`startIndex`</ph> est supérieur à <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, la méthode lève un <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le nombre d’éléments à partir de <ph id="ph3">`startIndex`</ph> à la fin de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">L’exemple appelle trois surcharges de la <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> méthode pour rechercher l’index d’une chaîne dans un tableau de chaînes :</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, pour déterminer la première occurrence de la chaîne « the » dans un tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, pour déterminer la première occurrence de la chaîne « the » dans la quatrième aux derniers éléments d’un tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, pour déterminer la première occurrence de la chaîne « the » dans une chaîne de tableau à partir de l’élément qui suit la dernière correspondance à la fin du tableau.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> est en dehors de la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Tableau unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The starting index of the search.</source>
          <target state="translated">Index de départ de la recherche.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zéro) est valide dans un tableau vide.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The number of elements to search.</source>
          <target state="translated">Nombre d'éléments à explorer.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence.</source>
          <target state="translated">Recherche l'objet spécifié dans une plage d'éléments d'un tableau unidimensionnel, et retourne l'index de sa première occurrence.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The range extends from a specified index for a specified number of elements.</source>
          <target state="translated">La plage commence à un index spécifié pour un nombre d'éléments spécifié.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if it’s found in the <ph id="ph2">&lt;paramref name="array" /&gt;</ph> from index <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph5"> + </ph><ph id="ph6">&lt;paramref name="count" /&gt;</ph> - 1; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Index de la première occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, s’il existe dans le <ph id="ph2">&lt;paramref name="array" /&gt;</ph> entre l’index <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> et <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph5"> + </ph><ph id="ph6">&lt;paramref name="count" /&gt;</ph> - 1 ; sinon, limite inférieure du tableau moins 1.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method searches the elements of a one-dimensional arrayfrom <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
          <target state="translated">Cette méthode recherche les éléments d’une dimension arrayfrom <ph id="ph1">`startIndex`</ph> à <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> -1, si <ph id="ph4">`count`</ph> est supérieur à 0.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
          <target state="translated">Pour déterminer si <ph id="ph1">`value`</ph> existe dans <ph id="ph2">`array`</ph>, la méthode effectue une comparaison d’égalité en appelant le <ph id="ph3">`Equals`</ph> (méthode) de chaque élément jusqu'à ce qu’il trouve une correspondance.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Cela signifie que si l’élément remplace la <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> méthode, ce remplacement est appelé.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Becausemost arrays have a lower bound of zero, this method generally returns –1 when <ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Becausemost tableaux ont une limite inférieure de zéro, en règle générale, cette méthode retourne-1 si <ph id="ph1">`value`</ph> n’est pas trouvée.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> (0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">Dans les rares cas où la limite inférieure du tableau est égale à <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> (0 x 80000000) et <ph id="ph2">`value`</ph> n’est trouvé, cette méthode retourne <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startindex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method returns -1.</source>
          <target state="translated">Si <ph id="ph1">`startindex`</ph> est égal à <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, la méthode retourne -1.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`startIndex`</ph> est supérieur à <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, la méthode lève un <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">L’exemple appelle trois surcharges de la <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> méthode pour rechercher l’index d’une chaîne dans un tableau de chaînes :</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, pour déterminer la première occurrence de la chaîne « the » dans un tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, pour déterminer la première occurrence de la chaîne « the » dans la quatrième aux derniers éléments d’un tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, pour déterminer la première occurrence de la chaîne « the » dans une chaîne de tableau à partir de l’élément qui suit la dernière correspondance à la fin du tableau.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>To determine the value of the <ph id="ph1">`count`</ph> argument, it subtracts the upper bound of the array from the starting index and adds one.</source>
          <target state="translated">Pour déterminer la valeur de la <ph id="ph1">`count`</ph> argument, il soustrait la limite supérieure du tableau à partir de l’index de départ et ajoute une.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> n’est pas compris dans la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne spécifient pas une section valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Le tableau de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
          <target state="translated">Recherche l'objet spécifié et retourne l'index de sa première occurrence dans un tableau unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Index de base zéro de la première occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dans l’ensemble de l’<ph id="ph2">&lt;paramref name="array" /&gt;</ph>, s’il existe ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This method searches all the elements of a one-dimensional array for <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Cette méthode recherche tous les éléments d’un tableau unidimensionnel pour <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Pour déterminer si <ph id="ph1">`value`</ph> existe dans <ph id="ph2">`array`</ph>, la méthode effectue une comparaison d’égalité en appelant le <ph id="ph3">`T.Equals`</ph> méthode sur chaque élément.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Cela signifie que si <ph id="ph1">`T`</ph> remplace la <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> méthode, ce remplacement est appelé.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant illustre les trois surcharges génériques de la <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et l’emplacement d’index 5.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> surcharge de méthode de recherche dans le tableau à partir du début et de la première occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau en commençant par l’emplacement d’index 3 et en continuant à la fin du tableau et la deuxième occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher une plage de deux entrées, en commençant à l’emplacement d’index deux ; elle retourne – 1, car il n’existe aucune instance de la chaîne de recherche dans cette plage.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Le tableau de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Index de début de base zéro de la recherche.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zéro) est valide dans un tableau vide.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Recherche l'objet spécifié dans une plage d'éléments d'un tableau unidimensionnel, et retourne l'index de sa première occurrence.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The range extends from a specified index to the end of the array.</source>
          <target state="translated">La plage s'étend d'un index spécifié à la fin du tableau.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element, if found; otherwise, –1.</source>
          <target state="translated">Index de base zéro de la première occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dans la plage d'éléments du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> qui s'étend de <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> jusqu'au dernier élément, s'il existe ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This method searches a one-dimensional array from the element at <ph id="ph1">`startIndex`</ph> to the end of the array.</source>
          <target state="translated">Cette méthode recherche dans un tableau unidimensionnel à partir de l’élément au niveau <ph id="ph1">`startIndex`</ph> à la fin du tableau.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Pour déterminer si <ph id="ph1">`value`</ph> existe dans <ph id="ph2">`array`</ph>, la méthode effectue une comparaison d’égalité en appelant le <ph id="ph3">`T.Equals`</ph> méthode sur chaque élément.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Cela signifie que si <ph id="ph1">`T`</ph> remplace la <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> méthode, ce remplacement est appelé.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph>,the method returns -1.If <ph id="ph3">`startIndex`</ph> is greater than <ph id="ph4">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph5">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`startIndex`</ph> est égal à <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph>, la méthode retourne - 1.If <ph id="ph3">`startIndex`</ph> est supérieur à <ph id="ph4">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, la méthode lève un <ph id="ph5">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le nombre d’éléments à partir de <ph id="ph3">`startIndex`</ph> à la fin de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant illustre les trois surcharges génériques de la <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et l’emplacement d’index 5.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> surcharge de méthode de recherche dans le tableau à partir du début et de la première occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau en commençant par l’emplacement d’index 3 et en continuant à la fin du tableau et la deuxième occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher une plage de deux entrées, en commençant à l’emplacement d’index deux ; elle retourne – 1, car il n’existe aucune instance de la chaîne de recherche dans cette plage.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> n’est pas compris dans la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Le tableau de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Index de début de base zéro de la recherche.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zéro) est valide dans un tableau vide.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Recherche l'objet spécifié dans une plage d'éléments d'un tableau unidimensionnel, et retourne l'index de sa première occurrence.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The range extends from a specified index for a specified number of elements.</source>
          <target state="translated">La plage commence à un index spécifié pour un nombre d'éléments spécifié.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that starts at <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and contains the number of elements specified in <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Index de base zéro de la première occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dans la plage d'éléments du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> qui commence à <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> et qui contient le nombre d'éléments spécifiés dans <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, s'il existe ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method searchesthe elements of a one-dimensional array from <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
          <target state="translated">Cette éléments searchesthe de méthode d’un tableau unidimensionnel à partir de <ph id="ph1">`startIndex`</ph> à <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> -1, si <ph id="ph4">`count`</ph> est supérieur à 0.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Pour déterminer si <ph id="ph1">`value`</ph> existe dans <ph id="ph2">`array`</ph>, la méthode effectue une comparaison d’égalité en appelant le <ph id="ph3">`T.Equals`</ph> méthode sur chaque élément.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Cela signifie que si <ph id="ph1">`T`</ph> remplace la <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> méthode, ce remplacement est appelé.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method returns -1.</source>
          <target state="translated">Si <ph id="ph1">`startIndex`</ph> est égal à <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, la méthode retourne -1.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`startIndex`</ph> est supérieur à <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, la méthode lève un <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant illustre les trois surcharges génériques de la <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et l’emplacement d’index 5.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> surcharge de méthode de recherche dans le tableau à partir du début et de la première occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau en commençant par l’emplacement d’index 3 et en continuant à la fin du tableau et la deuxième occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher une plage de deux entrées, en commençant à l’emplacement d’index deux ; elle retourne – 1, car il n’existe aucune instance de la chaîne de recherche dans cette plage.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> n’est pas compris dans la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne spécifient pas une section valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Array.Initialize">
          <source>Initializes every element of the value-type <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> by calling the default constructor of the value type.</source>
          <target state="translated">Initialise tous les éléments du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de type valeur en appelant le constructeur par défaut du type valeur.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>This method is designed to help compilers support value-type arrays; most users do not need this method.</source>
          <target state="translated">Cette méthode est conçue pour aider les compilateurs à prendre en charge des tableaux de type valeur ; la plupart des utilisateurs n’avez pas besoin de cette méthode.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>It must not be used on reference-type arrays.</source>
          <target state="translated">Il ne doit pas être utilisé sur des tableaux de type référence.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not a value-type <ph id="ph2">&lt;xref:System.Array&gt;</ph> or if the value type does not have a default constructor, the <ph id="ph3">&lt;xref:System.Array&gt;</ph> is not modified.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Array&gt;</ph> n’est pas un type valeur <ph id="ph2">&lt;xref:System.Array&gt;</ph> ou si le type de valeur n’a pas de constructeur par défaut, le <ph id="ph3">&lt;xref:System.Array&gt;</ph> n’est pas modifié.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>The value-type <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound and any number of dimensions.</source>
          <target state="translated">Le type de valeur <ph id="ph1">&lt;xref:System.Array&gt;</ph> peut avoir une limite inférieure quelconque et n’importe quel nombre de dimensions.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</source>
          <target state="translated">Vous pouvez utiliser cette méthode uniquement sur les types valeur qui possèdent des constructeurs. Toutefois, les types de valeur natifs c# n’ont pas de constructeurs.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="P:System.Array.IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Obtient une valeur indiquant si <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> est de taille fixe.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>This property is always <ph id="ph1">&lt;see langword="true" /&gt;</ph> for all arrays.</source>
          <target state="translated">Cette propriété est toujours <ph id="ph1">&lt;see langword="true" /&gt;</ph> pour tous les tableaux.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implémente le <ph id="ph2">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> propriété car il est requis par le <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>An array with a fixed size does not allow the addition or removal of elements after the array is created, but it allows the modification of existing elements.</source>
          <target state="translated">Un tableau avec une taille fixe ne permet pas l’ajout ou la suppression d’éléments après le tableau est créé, mais permet la modification des éléments existants.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="P:System.Array.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is read-only.</source>
          <target state="translated">Obtient une valeur indiquant si <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph> for all arrays.</source>
          <target state="translated">Cette propriété est toujours <ph id="ph1">&lt;see langword="false" /&gt;</ph> pour tous les tableaux.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsReadOnly%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implémente le <ph id="ph2">&lt;xref:System.Array.IsReadOnly%2A&gt;</ph> propriété car il est requis par le <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</source>
          <target state="translated">Un tableau qui est en lecture seule n’autorise pas l’ajout, la suppression ou la modification d’éléments après que le tableau est créé.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>If you require a read-only collection, use a <ph id="ph1">&lt;xref:System.Collections&gt;</ph> class that implements the <ph id="ph2">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Si vous avez besoin d’une collection en lecture seule, utilisez un <ph id="ph1">&lt;xref:System.Collections&gt;</ph> classe qui implémente le <ph id="ph2">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>If you cast or convert an array to an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface object, the <ph id="ph2">&lt;xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType&gt;</ph> property returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si vous effectuez un cast ou convertir un tableau à une <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> objet d’interface, le <ph id="ph2">&lt;xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType&gt;</ph> propriété renvoie <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>However, if you cast or convert an array to a <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> interface, the <ph id="ph2">`IsReadOnly`</ph> property returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Toutefois, si vous effectuez un cast ou convertir un tableau à un <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> interface, le <ph id="ph2">`IsReadOnly`</ph> propriété renvoie <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="P:System.Array.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Obtient une valeur indiquant si l'accès à <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> est synchronisé (thread-safe).</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph> for all arrays.</source>
          <target state="translated">Cette propriété est toujours <ph id="ph1">&lt;see langword="false" /&gt;</ph> pour tous les tableaux.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsSynchronized%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implémente le <ph id="ph2">&lt;xref:System.Array.IsSynchronized%2A&gt;</ph> propriété car il est requis par le <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Les classes .NET framework basées sur <ph id="ph1">&lt;xref:System.Array&gt;</ph> fournissent leur propre version synchronisée de la collection à l’aide de la <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Les classes qui utilisent des tableaux peuvent également implémenter leur propre à l’aide de la synchronisation du <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
          <target state="translated">Le code de synchronisation doit effectuer les opérations sur les <ph id="ph1">`SyncRoot`</ph> de la collection, et non directement sur la collection.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Cela garantit un bon fonctionnement des collections dérivées d’autres objets.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
          <target state="translated">Plus particulièrement, il maintient la synchronisation est assurée avec les autres threads qui pourraient modifier simultanément la collection.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
          <target state="translated">Notez que certaines implémentations de <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> peut retourner le <ph id="ph2">&lt;xref:System.Array&gt;</ph> lui-même.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>The following code example shows how to lock an array during the entire enumeration by using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant montre comment verrouiller un tableau pendant l’ensemble de l’énumération à l’aide de la <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Returns the index of the last occurrence of a value in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or in a portion of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Retourne l'index de la dernière occurrence d'une valeur dans un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel ou dans une partie de <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à rechercher.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Recherche l'objet spécifié et retourne l'index de la dernière occurrence dans l'ensemble du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Index de la dernière occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dans le <ph id="ph2">&lt;paramref name="array" /&gt;</ph> entier, s'il existe ; sinon, la limite inférieure du tableau -1.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">Unidimensionnel <ph id="ph1">&lt;xref:System.Array&gt;</ph> recherche est effectuée vers l’arrière à partir du dernier élément du premier élément.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Les éléments sont comparés à la valeur spécifiée à l’aide de la <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le <ph id="ph1">`Equals`</ph> implémentation de ce type est utilisée.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Étant donné que la plupart des tableaux ont une limite inférieure de zéro, cette méthode retourne généralement-1 si <ph id="ph1">`value`</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">Dans les rares cas où la limite inférieure du tableau est égale à <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">`value`</ph> n’est trouvé, cette méthode retourne <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, qui est <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">Dans le .NET Framework version 2.0, cette méthode utilise le <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> méthodes de la <ph id="ph3">&lt;xref:System.Array&gt;</ph> pour déterminer si le <ph id="ph4">&lt;xref:System.Object&gt;</ph> spécifié par le <ph id="ph5">`value`</ph> paramètre existe.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> méthodes de la <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> lui-même.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph2">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> méthodes de le <ph id="ph2">`item`</ph> paramètre sur les objets dans la collection.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">L’exemple de code suivant montre comment déterminer l’index de la dernière occurrence d’un élément spécifié dans un tableau.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à rechercher.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The starting index of the backward search.</source>
          <target state="translated">Index de départ de la recherche vers le haut.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Recherche l'objet spécifié et retourne l'index de la dernière occurrence dans la plage d'éléments du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui s'étend du premier élément jusqu'à l'index spécifié.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Index de la dernière occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dans la plage d'éléments de <ph id="ph2">&lt;paramref name="array" /&gt;</ph> qui s'étend du premier élément jusqu'à <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, s'il existe ; sinon, la limite inférieure du tableau -1.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">Unidimensionnel <ph id="ph1">&lt;xref:System.Array&gt;</ph> est effectuée vers l’arrière commençant à <ph id="ph2">`startIndex`</ph> et jusqu’au premier élément.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Les éléments sont comparés à la valeur spécifiée à l’aide de la <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le <ph id="ph1">`Equals`</ph> implémentation de ce type est utilisée.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Étant donné que la plupart des tableaux ont une limite inférieure de zéro, cette méthode retourne généralement-1 si <ph id="ph1">`value`</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">Dans les rares cas où la limite inférieure du tableau est égale à <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">`value`</ph> n’est trouvé, cette méthode retourne <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, qui est <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le nombre d’éléments à partir du début de <ph id="ph3">`array`</ph> à <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">Dans le .NET Framework version 2.0, cette méthode utilise le <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> méthodes de la <ph id="ph3">&lt;xref:System.Array&gt;</ph> pour déterminer si le <ph id="ph4">&lt;xref:System.Object&gt;</ph> spécifié par le <ph id="ph5">`value`</ph> paramètre existe.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> méthodes de la <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> lui-même.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">L’exemple de code suivant montre comment déterminer l’index de la dernière occurrence d’un élément spécifié dans un tableau.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> est en dehors de la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à rechercher.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The starting index of the backward search.</source>
          <target state="translated">Index de départ de la recherche vers le haut.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Recherche l'objet spécifié et retourne l'index de la dernière occurrence dans la plage d'éléments du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui contient le nombre d'éléments spécifié et se termine à l'index spécifié.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that contains the number of elements specified in <ph id="ph3">&lt;paramref name="count" /&gt;</ph> and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Index de la dernière occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dans la plage d'éléments de <ph id="ph2">&lt;paramref name="array" /&gt;</ph> qui contient le nombre d'éléments spécifié dans <ph id="ph3">&lt;paramref name="count" /&gt;</ph> et se termine à <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, si cette occurrence existe ; sinon, la limite inférieure du tableau -1.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Unidimensionnel <ph id="ph1">&lt;xref:System.Array&gt;</ph> est effectuée vers l’arrière commençant à <ph id="ph2">`startIndex`</ph> et se terminant à <ph id="ph3">`startIndex`</ph> moins <ph id="ph4">`count`</ph> + 1, si <ph id="ph5">`count`</ph> est supérieur à 0.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Les éléments sont comparés à la valeur spécifiée à l’aide de la <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the<ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le<ph id="ph1">`Equals`</ph> implémentation de ce type est utilisée.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Étant donné que la plupart des tableaux ont une limite inférieure de zéro, cette méthode retourne généralement-1 si <ph id="ph1">`value`</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">Dans les rares cas où la limite inférieure du tableau est égale à <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">`value`</ph> n’est trouvé, cette méthode retourne <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, qui est <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">Dans le .NET Framework version 2.0, cette méthode utilise le <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> méthodes de la <ph id="ph3">&lt;xref:System.Array&gt;</ph> pour déterminer si le <ph id="ph4">&lt;xref:System.Object&gt;</ph> spécifié par le <ph id="ph5">`value`</ph> paramètre existe.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> méthodes de la <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> lui-même.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">L’exemple de code suivant montre comment déterminer l’index de la dernière occurrence d’un élément spécifié dans un tableau.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method is a backward search; therefore, <ph id="ph2">`count`</ph> must be less than or equal to (<ph id="ph3">`startIndex`</ph> minus the lower bound of the array plus 1).</source>
          <target state="translated">Notez que la <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> méthode est une recherche vers l’arrière ; par conséquent, <ph id="ph2">`count`</ph> doit être inférieur ou égal à (<ph id="ph3">`startIndex`</ph> -la limite inférieure du tableau + 1).</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> n’est pas compris dans la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne spécifient pas une section valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Recherche l'objet spécifié et retourne l'index de la dernière occurrence dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> entier.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Index de base zéro de la dernière occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dans le <ph id="ph2">&lt;paramref name="array" /&gt;</ph> entier, si cette occurrence existe ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> recherche est effectuée vers l’arrière à partir du dernier élément du premier élément.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Les éléments sont comparés à la valeur spécifiée à l’aide de la <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le <ph id="ph1">`Equals`</ph> implémentation de ce type est utilisée.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre les trois surcharges génériques de la <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et l’emplacement d’index 5.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> surcharge de méthode recherche l’intégralité de la fin du tableau et la deuxième occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau vers l’arrière en commençant par l’emplacement d’index 3 et en continuant vers le début du tableau et recherche la première occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher une plage de quatre entrées, en commençant à l’emplacement d’index 4 et en poursuivant vers le bas (autrement dit, il recherche les éléments aux emplacements 4, 3, 2 et 1) ; cette recherche retourne -1, car il n’existe aucune instance de la recherche chaîne dans cette plage.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Index de début de base zéro de la recherche vers le haut.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Recherche l'objet spécifié et retourne l'index de la dernière occurrence dans la plage d'éléments du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui s'étend du premier élément jusqu'à l'index spécifié.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Index de base zéro de la dernière occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dans la plage d'éléments du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> qui s'étend du premier élément jusqu'à <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, s'il existe ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> est effectuée vers l’arrière commençant à <ph id="ph2">`startIndex`</ph> et jusqu’au premier élément.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Les éléments sont comparés à la valeur spécifiée à l’aide de la <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le <ph id="ph1">`Equals`</ph> implémentation de ce type est utilisée.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le nombre d’éléments à partir du début de <ph id="ph3">`array`</ph> à <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre les trois surcharges génériques de la <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et l’emplacement d’index 5.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> surcharge de méthode recherche l’intégralité de la fin du tableau et la deuxième occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau vers l’arrière en commençant par l’emplacement d’index 3 et en continuant vers le début du tableau et recherche la première occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher une plage de quatre entrées, en commençant à l’emplacement d’index 4 et en poursuivant vers le bas (autrement dit, il recherche les éléments aux emplacements 4, 3, 2 et 1) ; cette recherche retourne -1, car il n’existe aucune instance de la recherche chaîne dans cette plage.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> n’est pas compris dans la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à explorer.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet à rechercher dans <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Index de début de base zéro de la recherche vers le haut.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Recherche l'objet spécifié et retourne l'index de la dernière occurrence dans la plage d'éléments du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> qui contient le nombre d'éléments spécifié et se termine à l'index spécifié.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that contains the number of elements specified in <ph id="ph3">&lt;paramref name="count" /&gt;</ph> and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Index de base zéro de la dernière occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dans la plage d'éléments du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> qui contient le nombre d'éléments spécifié dans <ph id="ph3">&lt;paramref name="count" /&gt;</ph> et se termine à <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, s'il existe ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> est effectuée vers l’arrière commençant à <ph id="ph2">`startIndex`</ph> et se terminant à <ph id="ph3">`startIndex`</ph> moins <ph id="ph4">`count`</ph> + 1, si <ph id="ph5">`count`</ph> est supérieur à 0.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Les éléments sont comparés à la valeur spécifiée à l’aide de la <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le <ph id="ph1">`Equals`</ph> implémentation de ce type est utilisée.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre les trois surcharges génériques de la <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et l’emplacement d’index 5.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> surcharge de méthode recherche l’intégralité de la fin du tableau et la deuxième occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher le tableau vers l’arrière en commençant par l’emplacement d’index 3 et en continuant vers le début du tableau et recherche la première occurrence de la chaîne.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Enfin, le <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge de méthode est utilisée pour rechercher une plage de quatre entrées, en commençant à l’emplacement d’index 4 et en poursuivant vers le bas (autrement dit, il recherche les éléments aux emplacements 4, 3, 2 et 1) ; cette recherche retourne -1, car il n’existe aucune instance de la recherche chaîne dans cette plage.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> n’est pas compris dans la plage d’index valides pour <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne spécifient pas une section valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="P:System.Array.Length">
          <source>Gets the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient le nombre total d’éléments dans toutes les dimensions du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>The total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; zero if there are no elements in the array.</source>
          <target state="translated">Le nombre total d’éléments dans toutes les dimensions de la <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; zéro si le tableau ne contient aucun élément.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>The following example uses the                                 <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property to get the total number of elements in an array.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> propriété à obtenir le nombre total d’éléments dans un tableau.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>It also uses the                                 <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> method to determine the number of elements in each dimension of a multidimensional array.</source>
          <target state="translated">Elle utilise également la <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthode pour déterminer le nombre d’éléments dans chaque dimension d’un tableau multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="P:System.Array.Length">
          <source>The array is multidimensional and contains more than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> elements.</source>
          <target state="translated">Le tableau est multidimensionnel et contient plus de <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> éléments.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="P:System.Array.LongLength">
          <source>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient un entier 64 bits qui représente le nombre total d’éléments dans toutes les dimensions du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.LongLength">
          <source>A 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Entier 64 bits qui représente le nombre total d'éléments dans toutes les dimensions de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.LongLength">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="P:System.Array.Rank">
          <source>Gets the rank (number of dimensions) of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient le rang (nombre de dimensions) de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="P:System.Array.Rank">
          <source>For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on.</source>
          <target state="translated">Par exemple, un tableau unidimensionnel retourne 1, un tableau bidimensionnel retourne 2, etc.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>The rank (number of dimensions) of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Rang (nombre de dimensions) de <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>For example, the Visual Basic code</source>
          <target state="translated">Par exemple, le code Visual Basic</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>and the C# code</source>
          <target state="translated">et le code c#</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>create an array of three dimensions with a <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property whose value is 3.</source>
          <target state="translated">créer un tableau de trois dimensions avec un <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> propriété dont la valeur est 3.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>A jagged array (an array of arrays) is a one-dimensional array; the value of its <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property is 1.</source>
          <target state="translated">Un tableau en escalier (tableau de tableaux) est un tableau unidimensionnel. la valeur de son <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> propriété est 1.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>The following example initializes a one-dimensional array, a two-dimensional array, and a jagged array, and retrieves the <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property of each.</source>
          <target state="translated">L’exemple suivant initialise un tableau unidimensionnel, un tableau à deux dimensions et un tableau en escalier et récupère le <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> propriété de chacun.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The one-dimensional, zero-based array to resize, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> to create a new array with the specified size.</source>
          <target state="translated">Tableau unidimensionnel de base zéro à redimensionner, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> pour créer un tableau avec la taille spécifiée.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The size of the new array.</source>
          <target state="translated">Taille du nouveau tableau.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>Changes the number of elements of a one-dimensional array to the specified new size.</source>
          <target state="translated">Modifie le nombre d'éléments d'un tableau unidimensionnel avec la nouvelle taille spécifiée.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>This method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one.</source>
          <target state="translated">Cette méthode alloue un nouveau tableau avec la taille spécifiée, copie les éléments à partir de l’ancien tableau vers le nouveau, puis remplace l’ancien tableau par la nouvelle.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source><ph id="ph1">`array`</ph> must be a one-dimensional array.</source>
          <target state="translated"><ph id="ph1">`array`</ph> doit être un tableau unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`array`</ph> is <ph id="ph2">`null`</ph>, this method creates a new array with the specified size.</source>
          <target state="translated">Si <ph id="ph1">`array`</ph> est <ph id="ph2">`null`</ph>, cette méthode crée un nouveau tableau avec la taille spécifiée.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is greater than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and all the elements are copied from the old array to the new one.</source>
          <target state="translated">Si <ph id="ph1">`newSize`</ph> est supérieure à la <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> de l’ancien tableau, un nouveau tableau est alloué et tous les éléments sont copiés depuis l’ancien tableau vers le nouveau.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is less than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and elements are copied from the old array to the new one until the new one is filled; the rest of the elements in the old array are ignored.</source>
          <target state="translated">Si <ph id="ph1">`newSize`</ph> est inférieure à la <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> de l’ancien tableau, un nouveau tableau est alloué et les éléments sont copiés depuis l’ancien tableau vers le nouveau jusqu'à ce que le nouveau soit rempli ; le reste des éléments de l’ancien tableau sont ignorés.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is equal to the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, this method does nothing.</source>
          <target state="translated">Si <ph id="ph1">`newSize`</ph> est égal à la <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> de l’ancien tableau, cette méthode ne fait rien.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`newSize`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`newSize`</ph>.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Resize%2A&gt;</ph> method resizes a one-dimensional array only.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Resize%2A&gt;</ph> méthode redimensionne un tableau unidimensionnel uniquement.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class does not include a method for resizing multi-dimensional arrays.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array&gt;</ph> ne s’applique pas une méthode pour le redimensionnement des tableaux multidimensionnels.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>To do this, you must either provide your own code or call a special-purpose method in a third-party library.</source>
          <target state="translated">Pour ce faire, vous devez fournir votre propre code ou appeler une méthode spéciale dans une bibliothèque tierce.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The following code illustrates one possible implementation for a method that resizes an array of <bpt id="p1">*</bpt>n<ept id="p1">*</ept> dimensions.</source>
          <target state="translated">Le code suivant illustre une implémentation possible pour une méthode qui se redimensionne un tableau de <bpt id="p1">*</bpt>n<ept id="p1">*</ept> dimensions.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The following example shows how resizing affects the array.</source>
          <target state="translated">L’exemple suivant montre comment le redimensionnement affecte le tableau.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="newSize" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newSize" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Reverses the order of the elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or in a portion of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Inverse l'ordre des éléments dans un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel ou dans une partie de <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to reverse.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à inverser.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source>Reverses the sequence of the elements in the entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Inverse l'ordre des éléments dans l'intégralité du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
          <target state="translated">Après un appel à cette méthode, l’élément au niveau <ph id="ph1">`myArray[i]`</ph>, où <ph id="ph2">`i`</ph> est un index dans le tableau, la déplace vers <ph id="ph3">`myArray[j]`</ph>, où <ph id="ph4">`j`</ph> est égal à <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>As the following example shows, the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
          <target state="translated">Comme le montre l’exemple suivant, la <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> méthode peut être utilisée pour annuler un tableau en escalier.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>It initializes a jagged array with one element for each month of the current year in the current culture's calendar.</source>
          <target state="translated">Elle initialise un tableau en escalier avec un élément pour chaque mois de l’année en cours dans le calendrier de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>Each element contains an array with as many elements as that month has days.</source>
          <target state="translated">Chaque élément contient un tableau avec autant d’éléments que ce mois a jours.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>The example displays the contents of the array, calls the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method, and then displays the contents of the reversed array.</source>
          <target state="translated">L’exemple affiche le contenu du tableau, appels le <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> (méthode), puis affiche le contenu du tableau inversé.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>The following code example shows how to reverse the sort of the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment annuler le tri des valeurs dans une <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to reverse.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à inverser.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the section to reverse.</source>
          <target state="translated">Index de départ de la section à inverser.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the section to reverse.</source>
          <target state="translated">Nombre d'éléments contenus dans la section à inverser.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>Reverses the sequence of the elements in a range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Inverse l'ordre des éléments dans la plage d'éléments d'un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
          <target state="translated">Après un appel à cette méthode, l’élément au niveau <ph id="ph1">`myArray[i]`</ph>, où <ph id="ph2">`i`</ph> est un index dans le tableau, la déplace vers <ph id="ph3">`myArray[j]`</ph>, où <ph id="ph4">`j`</ph> est égal à <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> méthode peut être utilisée pour annuler un tableau en escalier.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to reverse the sort of the values in a range of elements in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment annuler le tri des valeurs dans une plage d’éléments dans un <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure d’<ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Sets the specified element in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to the specified value.</source>
          <target state="translated">Affecte la valeur spécifiée à l'élément déterminé dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nouvelle valeur de l'élément spécifié.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 32 bits qui représente la position de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Affecte une valeur à l'élément à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">L'index est spécifié en tant qu'entier 32 bits.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si la valeur de <ph id="ph3">`index`</ph> est hors limites.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> est utilisée pour affecter <ph id="ph2">`null`</ph> à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement une dimension.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Le cast automatique de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en type d'élément du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours est impossible.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est en dehors de la plage d'index valide pour le <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The new value for the specified element.</source>
          <target state="translated">Nouvelle valeur de l'élément spécifié.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</source>
          <target state="translated">Tableau unidimensionnel d'entiers 32 bits qui représentent les index spécifiant la position de l'élément à définir.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Affecte une valeur à l'élément à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The indexes are specified as an array of 32-bit integers.</source>
          <target state="translated">Les index sont spécifiés sous la forme d'un tableau d'entiers 32 bits.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans <ph id="ph1">`indices`</ph> doit être égal au nombre de dimensions dans le <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Tous les éléments dans le <ph id="ph1">`indices`</ph> tableau doit spécifier collectivement la position de l’élément souhaité dans les données multidimensionnelles <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si une des valeurs dans le <ph id="ph3">`indices`</ph> tableau est hors limites.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> est utilisée pour affecter <ph id="ph2">`null`</ph> à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Le nombre de dimensions dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours n'est pas égal au nombre d'éléments dans <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Le cast automatique de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en type d'élément du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours est impossible.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Tous les éléments de <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> sont en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nouvelle valeur de l'élément spécifié.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 64 bits qui représente la position de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Affecte une valeur à l'élément à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">L'index est spécifié en tant qu'entier 64 bits.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si la valeur de <ph id="ph3">`index`</ph> est hors limites.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> est utilisée pour affecter <ph id="ph2">`null`</ph> à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement une dimension.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Le cast automatique de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en type d'élément du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours est impossible.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est en dehors de la plage d'index valide pour le <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The new value for the specified element.</source>
          <target state="translated">Nouvelle valeur de l'élément spécifié.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</source>
          <target state="translated">Tableau unidimensionnel d'entiers 64 bits qui représentent les index spécifiant la position de l'élément à définir.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Affecte une valeur à l'élément à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The indexes are specified as an array of 64-bit integers.</source>
          <target state="translated">Les index sont spécifiés sous la forme d'un tableau d'entiers 64 bits.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans <ph id="ph1">`indices`</ph> doit être égal au nombre de dimensions dans le <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Tous les éléments dans le <ph id="ph1">`indices`</ph> tableau doit spécifier collectivement la position de l’élément souhaité dans les données multidimensionnelles <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si une des valeurs dans le <ph id="ph3">`indices`</ph> tableau est hors limites.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> est utilisée pour affecter <ph id="ph2">`null`</ph> à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Le nombre de dimensions dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours n'est pas égal au nombre d'éléments dans <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Le cast automatique de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en type d'élément du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours est impossible.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Tous les éléments de <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> sont en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nouvelle valeur de l'élément spécifié.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 32 bits qui représente l'index de la première dimension de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 32 bits qui représente l'index de la seconde dimension de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Affecte une valeur à l'élément à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à deux dimensions.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Les index sont spécifiés en tant qu'entiers 32 bits.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si un des index est hors limites.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> est utilisée pour affecter <ph id="ph2">`null`</ph> à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement deux dimensions.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Le cast automatique de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en type d'élément du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours est impossible.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> est en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nouvelle valeur de l'élément spécifié.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 64 bits qui représente l’index de la première dimension de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 64 bits qui représente l’index de la deuxième dimension de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Affecte une valeur à l'élément à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à deux dimensions.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Les index sont spécifiés en tant qu'entiers 64 bits.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si un des index est hors limites.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> est utilisée pour affecter <ph id="ph2">`null`</ph> à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement deux dimensions.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Le cast automatique de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en type d'élément du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours est impossible.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> est en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nouvelle valeur de l'élément spécifié.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 32 bits qui représente l'index de la première dimension de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 32 bits qui représente l'index de la seconde dimension de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 32 bits qui représente l'index de la troisième dimension de l'élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Affecte une valeur à l'élément à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à trois dimensions.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Les index sont spécifiés en tant qu'entiers 32 bits.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si un des index est hors limites.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> est utilisée pour affecter <ph id="ph2">`null`</ph> à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement trois dimensions.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Le cast automatique de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en type d'élément du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours est impossible.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> est en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nouvelle valeur de l'élément spécifié.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 64 bits qui représente l’index de la première dimension de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 64 bits qui représente l’index de la deuxième dimension de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Entier 64 bits qui représente l’index de la troisième dimension de l’élément <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à définir.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Affecte une valeur à l'élément à la position spécifiée du <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à trois dimensions.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Les index sont spécifiés en tant qu'entiers 64 bits.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> méthodes peuvent déterminer si un des index est hors limites.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les conversions, consultez <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> est utilisée pour affecter <ph id="ph2">`null`</ph> à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement trois dimensions.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Le cast automatique de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en type d'élément du <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> en cours est impossible.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> est en dehors de la plage d'index valide pour la dimension correspondante du <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Sorts the elements in a one-dimensional array.</source>
          <target state="translated">Trie les éléments dans un tableau unidimensionnel.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à trier.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>Sorts the elements in an entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Trie les éléments dans l'intégralité d'un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à l'aide de l'implémentation de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de chaque élément de <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Chaque élément de <ph id="ph1">`array`</ph> doit implémenter la <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface afin de pouvoir faire des comparaisons avec tous les autres éléments de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est la <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">L’exemple de code suivant montre comment trier les valeurs dans une <ph id="ph1">&lt;xref:System.Array&gt;</ph> à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Notez que le résultat peut varier en fonction d’actuel <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Un ou plusieurs éléments de <ph id="ph1">&lt;paramref name="array" /&gt;</ph> n'implémentent pas l'interface <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui contient les clés à trier.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui contient les éléments correspondant à chaque clé dans <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour trier uniquement <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated">Trie une paire d'objets <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnels (l'un contient les clés et l'autre, les éléments correspondants) en fonction des clés du premier <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'implémentation de <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> de chaque clé.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque clé dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> possède un élément correspondant le <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est repositionnée de la même façon.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est trié selon la disposition des clés correspondantes dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Chaque clé dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> doit implémenter la <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface afin de pouvoir faire des comparaisons avec toutes les autres clés.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Vous pouvez trier s’il existe plusieurs éléments clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est la <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph5">`keys`</ph>.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">L’exemple suivant montre comment trier deux tableaux associés où le premier tableau contient les clés et le second contient les valeurs.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Les tris sont effectués à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Notez que le résultat peut varier en fonction d’actuel <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la longueur de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> est supérieure à celle de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Un ou plusieurs éléments de <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> n’implémentent pas l’interface <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The one-dimensional array to sort.</source>
          <target state="translated">Tableau unidimensionnel à trier.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The implementation to use when comparing elements.</source>
          <target state="translated">Implémentation à utiliser pendant la comparaison d'éléments.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser l’implémentation de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Sorts the elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Trie les éléments d'un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à l'aide de l'objet <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, chaque élément de <ph id="ph3">`array`</ph> doit implémenter la <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface afin de pouvoir faire des comparaisons avec tous les autres éléments de <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est la <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">Le .NET Framework inclut prédéfinis <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implémentations répertoriés dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implémentation</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Compare deux objets, mais effectue une comparaison respectant la casse des chaînes.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Compare deux objets en utilisant les conventions de tri de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Compare deux objets en utilisant les conventions de tri de la culture dite indifférente.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Compare deux objets de type <ph id="ph1">`T`</ph> à l’aide d’ordre de tri par défaut du type.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Vous pouvez prennent également en charge les comparaisons personnalisées en fournissant une instance de votre propre <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implémentation à la <ph id="ph2">`comparer`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
          <target state="translated">L’exemple fait cela en définissant un <ph id="ph1">`ReverseComparer`</ph> classe qui inverse l’ordre de tri par défaut pour les instances d’un type et effectue la comparaison de chaînes sans respecter la casse.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The following example sorts the values in a string arrayby using the default comparer.</source>
          <target state="translated">L’exemple suivant trie les valeurs dans un arrayby de chaîne à l’aide du comparateur par défaut.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>It also defines a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation named <ph id="ph2">`ReverseComparer`</ph> that reverses an object's default sort order while performing a case-insensitive string comparison.</source>
          <target state="translated">Il définit également une personnalisée <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implémentation nommée <ph id="ph2">`ReverseComparer`</ph> qui inverse l’ordre de tri par défaut d’un objet lors de l’exécution d’une comparaison de chaînes sans respecter la casse.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Note that the output might vary depending on the current culture.</source>
          <target state="translated">Notez que la sortie peut varier en fonction de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph> et un ou plusieurs éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph> n'implémentent pas l'interface <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L’implémentation de <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a provoqué une erreur pendant le tri.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Le .NET Framework 4 et versions antérieures utilisé uniquement l’algorithme de tri rapide.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception et lève un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception à l’appelant.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, il est possible que les opérations de tri précédemment a levé <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne détectent pas un comparateur non valide.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La plupart des cas, cela s’applique aux tableaux avec moins de 16 éléments.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui contient les clés à trier.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui contient les éléments correspondant à chaque clé dans <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour trier uniquement <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implémentation de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> à utiliser pendant la comparaison d'éléments.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser l’implémentation de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Trie une paire d'objets <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnels (l'un contient les clés et l'autre, les éléments correspondants) en fonction des clés du premier <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'objet <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque clé dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> possède un élément correspondant le <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est repositionnée de la même façon.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est trié selon la disposition des clés correspondantes dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, chaque clé dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> doit implémenter la <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface afin de pouvoir faire des comparaisons avec toutes les autres clés.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Vous pouvez trier s’il existe plusieurs éléments clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">Le .NET Framework inclut prédéfinis <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implémentations répertoriés dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implémentation</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Compare deux objets, mais effectue une comparaison respectant la casse des chaînes.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Compare deux objets en utilisant les conventions de tri de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Compare deux objets en utilisant les conventions de tri de la culture dite indifférente.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Compare deux objets de type <ph id="ph1">`T`</ph> à l’aide d’ordre de tri par défaut du type.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Vous pouvez prennent également en charge les comparaisons personnalisées en fournissant une instance de votre propre <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implémentation à la <ph id="ph2">`comparer`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The example does this by defining an <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
          <target state="translated">L’exemple fait cela en définissant un <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implémentation qui inverse l’ordre de tri par défaut et effectue la comparaison de chaînes sans respecter la casse.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est la <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph5">`keys`</ph>.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">L’exemple suivant montre comment trier deux tableaux associés où le premier tableau contient les clés et le second contient les valeurs.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Les tris sont effectués à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Notez que le résultat peut varier en fonction d’actuel <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la longueur de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> est supérieure à celle de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L’implémentation de <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a provoqué une erreur pendant le tri.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>, et un ou plusieurs éléments de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> n’implémentent pas l’interface <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Le .NET Framework 4 et versions antérieures utilisé uniquement l’algorithme de tri rapide.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception et lève un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception à l’appelant.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previouslythrew <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, becausethe insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, il est possible qu’opérations de tri que previouslythrew <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne détectent pas un comparateur non valide.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La plupart des cas, cela s’applique aux tableaux avec moins de 16 éléments.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à trier.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Index de départ de la plage à trier.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Nombre d'éléments à trier dans la plage.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Trie les éléments d'une plage d'éléments d'un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à l'aide de l'implémentation de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de chaque élément de <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Chaque élément dans la plage spécifiée d’éléments dans <ph id="ph1">`array`</ph> doit implémenter la <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface afin de pouvoir faire des comparaisons avec tous les autres éléments de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">L’exemple de code suivant montre comment trier les valeurs dans une <ph id="ph1">&lt;xref:System.Array&gt;</ph> à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Notez que le résultat peut varier en fonction d’actuel <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure d’<ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Un ou plusieurs éléments de <ph id="ph1">&lt;paramref name="array" /&gt;</ph> n'implémentent pas l'interface <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui contient les clés à trier.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui contient les éléments correspondant à chaque clé dans <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour trier uniquement <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Index de départ de la plage à trier.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Nombre d'éléments à trier dans la plage.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated">Trie une plage d'éléments dans une paire d'objets <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnels (l'un contient les clés et l'autre, les éléments correspondants) en fonction des clés du premier <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'implémentation de <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> de chaque clé.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque clé dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> possède un élément correspondant le <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est repositionnée de la même façon.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est trié selon la disposition des clés correspondantes dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Chaque clé de la plage spécifiée d’éléments dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> doit implémenter la <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface afin de pouvoir faire des comparaisons avec toutes les autres clés.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Vous pouvez trier s’il existe plusieurs éléments clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">L’exemple de code suivant montre comment trier deux tableaux associés où le premier tableau contient les clés et le second contient les valeurs.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Les tris sont effectués à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Notez que le résultat peut varier en fonction d’actuel <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure d’<ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la longueur de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> est supérieure à celle de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n’est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph>, et <ph id="ph3">&lt;paramref name="index" /&gt;</ph> et <ph id="ph4">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Un ou plusieurs éléments de <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> n’implémentent pas l’interface <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à trier.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Index de départ de la plage à trier.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Nombre d'éléments à trier dans la plage.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implémentation de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> à utiliser pendant la comparaison d'éléments.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser l’implémentation de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Trie les éléments d'une plage d'éléments d'un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à l'aide de l'objet <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, chaque élément dans la plage spécifiée d’éléments dans <ph id="ph3">`array`</ph> doit implémenter la <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface afin de pouvoir faire des comparaisons avec tous les autres éléments de <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">Le .NET Framework inclut prédéfinis <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implémentations répertoriés dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implémentation</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Compare deux objets, mais effectue une comparaison respectant la casse des chaînes.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Compare deux objets en utilisant les conventions de tri de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Compare deux objets en utilisant les conventions de tri de la culture dite indifférente.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Compare deux objets de type <ph id="ph1">`T`</ph> à l’aide d’ordre de tri par défaut du type.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Vous pouvez prennent également en charge les comparaisons personnalisées en fournissant une instance de votre propre <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implémentation à la <ph id="ph2">`comparer`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
          <target state="translated">L’exemple fait cela en définissant un <ph id="ph1">`ReverseComparer`</ph> classe qui inverse l’ordre de tri par défaut pour les instances d’un type et effectue la comparaison de chaînes sans respecter la casse.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">L’exemple de code suivant montre comment trier les valeurs dans une <ph id="ph1">&lt;xref:System.Array&gt;</ph> à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Notez que le résultat peut varier en fonction d’actuel <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure d’<ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L’implémentation de <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a provoqué une erreur pendant le tri.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph> et un ou plusieurs éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph> n'implémentent pas l'interface <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Le .NET Framework 4 et versions antérieures utilisé uniquement l’algorithme de tri rapide.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception et lève un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception à l’appelant.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, il est possible que les opérations de tri précédemment a levé <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne détectent pas un comparateur non valide.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La plupart des cas, cela s’applique aux tableaux avec moins de 16 éléments.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui contient les clés à trier.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui contient les éléments correspondant à chaque clé dans <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour trier uniquement <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Index de départ de la plage à trier.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Nombre d'éléments à trier dans la plage.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implémentation de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> à utiliser pendant la comparaison d'éléments.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> pour utiliser l’implémentation de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Trie une plage d'éléments dans une paire d'objets <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnels (l'un contient les clés et l'autre, les éléments correspondants) en fonction des clés du premier <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'objet <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque clé dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> possède un élément correspondant le <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est repositionnée de la même façon.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est trié selon la disposition des clés correspondantes dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, chaque clé de la plage spécifiée d’éléments dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> doit implémenter la <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface afin de pouvoir faire des comparaisons avec toutes les autres clés.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Vous pouvez trier s’il existe plusieurs éléments clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">Le .NET Framework inclut prédéfinis <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implémentations répertoriés dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implémentation</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Compare deux objets, mais effectue une comparaison respectant la casse des chaînes.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Compare deux objets en utilisant les conventions de tri de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Compare deux objets en utilisant les conventions de tri de la culture dite indifférente.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Compare deux objets de type <ph id="ph1">`T`</ph> à l’aide d’ordre de tri par défaut du type.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Vous pouvez prennent également en charge les comparaisons personnalisées en fournissant une instance de votre propre <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implémentation à la <ph id="ph2">`comparer`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The example does this by defining a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
          <target state="translated">L’exemple fait cela en définissant un personnalisé <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implémentation qui inverse l’ordre de tri par défaut et effectue la comparaison de chaînes sans respecter la casse.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">L’exemple de code suivant montre comment trier deux tableaux associés où le premier tableau contient les clés et le second contient les valeurs.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Les tris sont effectués à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Notez que le résultat peut varier en fonction d’actuel <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure d’<ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la limite inférieure de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ne correspond pas à la limite inférieure de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la longueur de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> est supérieure à celle de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n’est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph>, et <ph id="ph3">&lt;paramref name="index" /&gt;</ph> et <ph id="ph4">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L’implémentation de <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a provoqué une erreur pendant le tri.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>, et un ou plusieurs éléments de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> n’implémentent pas l’interface <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Le .NET Framework 4 et versions antérieures utilisé uniquement l’algorithme de tri rapide.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception et lève un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception à l’appelant.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, il est possible que les opérations de tri précédemment a levé <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne détectent pas un comparateur non valide.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La plupart des cas, cela s’applique aux tableaux avec moins de 16 éléments.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à trier.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>Sorts the elements in an entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Trie les éléments dans l'intégralité d'un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'implémentation de l'interface générique <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> de chaque élément de <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Chaque élément de <ph id="ph1">`array`</ph> doit implémenter la <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interface générique afin de pouvoir faire des comparaisons avec tous les autres éléments de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est la <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> surcharge de méthode générique et le <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> surcharge de méthode générique.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>An array of strings is created, in no particular order.</source>
          <target state="translated">Un tableau de chaînes est créé, dans aucun ordre particulier.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Le tableau est affiché, trié et affiche de nouveau.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Les appels à la <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> les méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Si vous utilisez la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> surcharge de méthode générique est ensuite utilisée pour rechercher des deux chaînes, qui n’est pas dans le tableau et l’autre qui est.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Le tableau et la valeur de retour de la <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> méthode sont passés à la <ph id="ph2">`ShowWhere`</ph> une méthode générique, qui affiche la valeur d’index si la chaîne est trouvée, sinon les éléments de la chaîne de recherche se situant entre s’il s’agissait du tableau.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">L’index est négatif si la chaîne n’est pas n tableau, donc la <ph id="ph1">`ShowWhere`</ph> méthode accepte le complément de bits (le ~ opérateur en c# et Visual C++, <ph id="ph2">`Xor`</ph> -1 en Visual Basic) pour obtenir l’index du premier élément dans la liste qui est supérieure à la recherche de String NG.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Un ou plusieurs éléments de <ph id="ph1">&lt;paramref name="array" /&gt;</ph> n'implémentent pas l'interface générique <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-base <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à trier.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Implémentation de l'interface générique <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> à utiliser lors de la comparaison d'éléments, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> pour utiliser l'implémentation de l'interface générique <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Sorts the elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Trie les éléments dans un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel à l'aide de l'interface générique <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, chaque élément de <ph id="ph3">`array`</ph> doit implémenter la <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> interface générique afin de pouvoir faire des comparaisons avec tous les autres éléments de <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est la <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge de méthode générique et le <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge de méthode générique.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L’exemple de code définit un autre comparateur pour les chaînes nommées <ph id="ph1">`ReverseCompare`</ph>, qui implémente le <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> dans Visual C++) interface générique.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Le comparateur appelle la <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> méthode, en inversant l’ordre des comparateurs afin que les chaînes triées de haut en bas au lieu de faible à élevé.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Le tableau est affiché, trié et affiche de nouveau.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Les tableaux doivent être triées pour pouvoir utiliser le <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Les appels à la <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> les méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Si vous utilisez la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge de méthode générique est ensuite utilisée pour rechercher des deux chaînes, qui n’est pas dans le tableau et l’autre qui est.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Le tableau et la valeur de retour de la <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> méthode sont passés à la <ph id="ph2">`ShowWhere`</ph> une méthode générique, qui affiche la valeur d’index si la chaîne est trouvée, sinon les éléments de la chaîne de recherche se situant entre s’il s’agissait du tableau.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">L’index est négatif si la chaîne n’est pas n tableau, donc la <ph id="ph1">`ShowWhere`</ph> méthode accepte le complément de bits (le ~ opérateur en c# et Visual C++, <ph id="ph2">`Xor`</ph> -1 en Visual Basic) pour obtenir l’index du premier élément dans la liste qui est supérieure à la recherche de String NG.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph> et un ou plusieurs éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph> n'implémentent pas l'interface générique <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L’implémentation de <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a provoqué une erreur pendant le tri.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Le .NET Framework 4 et versions antérieures utilisé uniquement l’algorithme de tri rapide.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception et lève un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception à l’appelant.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, il est possible que les opérations de tri précédemment a levé <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne détectent pas un comparateur non valide.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La plupart des cas, cela s’applique aux tableaux avec moins de 16 éléments.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à trier.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph> to use when comparing elements.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph> à utiliser pendant la comparaison d'éléments.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Sorts the elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph>.</source>
          <target state="translated">Trie les éléments dans un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'objet <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This method uses introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est la <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> method overload.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The code example defines an alternative comparison method for strings, named <ph id="ph1">`CompareDinosByLength`</ph>.</source>
          <target state="translated">L’exemple de code définit une autre méthode de comparaison des chaînes, nommée <ph id="ph1">`CompareDinosByLength`</ph>.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This method works as follows: First, the comparandsare tested for<ph id="ph1">`null`</ph>, and a null reference is treated as less than a non-null.</source>
          <target state="translated">Cette méthode fonctionne comme suit : tout d’abord, le comparandsare testé pour<ph id="ph1">`null`</ph>, et une référence null est traitée comme inférieure à une valeur non null.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Second, the string lengths are compared, and the longer string is deemed to be greater.</source>
          <target state="translated">En second lieu, les longueurs de chaîne sont comparées, et la plus longue chaîne est jugée supérieure.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Third, if the lengths are equal, ordinary string comparison is used.</source>
          <target state="translated">Troisièmement, si les longueurs sont égales, la comparaison de chaînes ordinaire est utilisé.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>A array of strings is created and populated with four strings, in no particular order.</source>
          <target state="translated">Un tableau de chaînes est créé et rempli avec quatre chaînes, dans aucun ordre particulier.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The list also includes an empty string and a null reference.</source>
          <target state="translated">La liste inclut également une chaîne vide et une référence null.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The list is displayed, sorted using a <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> generic delegate representing the <ph id="ph2">`CompareDinosByLength`</ph> method, and displayed again.</source>
          <target state="translated">La liste est affichée, trié à l’aide un <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> délégué générique représentant le <ph id="ph2">`CompareDinosByLength`</ph> (méthode) et affiche à nouveau.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L’implémentation de <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> a provoqué une erreur pendant le tri.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Le .NET Framework 4 et versions antérieures utilisé uniquement l’algorithme de tri rapide.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception et lève un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception à l’appelant.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, il est possible que les opérations de tri précédemment a levé <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne détectent pas un comparateur non valide.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La plupart des cas, cela s’applique aux tableaux avec moins de 16 éléments.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à trier.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Index de départ de la plage à trier.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Nombre d'éléments à trier dans la plage.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Trie les éléments d'une plage d'éléments d'un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'implémentation de l'interface générique <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> de chaque élément de <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Chaque élément dans la plage spécifiée d’éléments dans <ph id="ph1">`array`</ph> doit implémenter la <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interface générique afin de pouvoir faire des comparaisons avec tous les autres éléments de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload for sorting a range in an array.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge de méthode générique et le <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> la surcharge de méthode générique pour le tri d’une plage dans un tableau.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L’exemple de code définit un autre comparateur pour les chaînes nommées <ph id="ph1">`ReverseCompare`</ph>, qui implémente le <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> dans Visual C++) interface générique.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Le comparateur appelle la <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> méthode, en inversant l’ordre des comparateurs afin que les chaînes triées de haut en bas au lieu de faible à élevé.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</source>
          <target state="translated">L’exemple de code crée et affiche un tableau de noms de dinosaure, composé de trois herbivores suivis par trois carnivores (tyrannosaures, pour être précis).</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload is used to sort the last three elements of the array, which is then displayed.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge de méthode générique est utilisée pour trier les trois derniers éléments du tableau, qui sont ensuite affichées.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is used with <ph id="ph2">`ReverseCompare`</ph> to sort the last three elements in reverse order.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge de méthode générique est utilisée avec <ph id="ph2">`ReverseCompare`</ph> pour trier les trois derniers éléments dans l’ordre inverse.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The thoroughly confused dinosaurs are displayed again.</source>
          <target state="translated">Dinosaures entièrement désordonnés sont affichent à nouveau.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Les appels à la <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> les méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Si vous utilisez la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Un ou plusieurs éléments de <ph id="ph1">&lt;paramref name="array" /&gt;</ph> n'implémentent pas l'interface générique <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à trier.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Index de départ de la plage à trier.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Nombre d'éléments à trier dans la plage.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Implémentation de l'interface générique <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> à utiliser lors de la comparaison d'éléments, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> pour utiliser l'implémentation de l'interface générique <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Trie les éléments dans une plage d'éléments d'un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'interface générique <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, chaque élément dans la plage spécifiée d’éléments dans <ph id="ph3">`array`</ph> doit implémenter la <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> interface générique afin de pouvoir faire des comparaisons avec tous les autres éléments de <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload for sorting a range in an array.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge de méthode générique et le <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> la surcharge de méthode générique pour le tri d’une plage dans un tableau.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L’exemple de code définit un autre comparateur pour les chaînes nommées <ph id="ph1">`ReverseCompare`</ph>, qui implémente le <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> dans Visual C++) interface générique.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Le comparateur appelle la <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> méthode, en inversant l’ordre des comparateurs afin que les chaînes triées de haut en bas au lieu de faible à élevé.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</source>
          <target state="translated">L’exemple de code crée et affiche un tableau de noms de dinosaure, composé de trois herbivores suivis par trois carnivores (tyrannosaures, pour être précis).</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload is used to sort the last three elements of the array, which is then displayed.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge de méthode générique est utilisée pour trier les trois derniers éléments du tableau, qui sont ensuite affichées.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is used with <ph id="ph2">`ReverseCompare`</ph> to sort the last three elements in reverse order.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge de méthode générique est utilisée avec <ph id="ph2">`ReverseCompare`</ph> pour trier les trois derniers éléments dans l’ordre inverse.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The thoroughly confused dinosaurs are displayed again.</source>
          <target state="translated">Dinosaures entièrement désordonnés sont affichent à nouveau.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Les appels à la <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> et <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> les méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Si vous utilisez la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L’implémentation de <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a provoqué une erreur pendant le tri.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph> et un ou plusieurs éléments de <ph id="ph3">&lt;paramref name="array" /&gt;</ph> n'implémentent pas l'interface générique <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Le .NET Framework 4 et versions antérieures utilisé uniquement l’algorithme de tri rapide.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception et lève un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception à l’appelant.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, il est possible que les opérations de tri précédemment a levé <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne détectent pas un comparateur non valide.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La plupart des cas, cela s’applique aux tableaux avec moins de 16 éléments.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Type des éléments du tableau des clés.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Type des éléments du tableau des éléments.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel de base zéro qui contient les clés à trier.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel de base zéro qui contient les éléments correspondant aux clés dans <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> pour trier uniquement <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Sorts a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each key.</source>
          <target state="translated">Trie une paire d'objets <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> (l'un contient les clés et l'autre, les éléments correspondants) en fonction des clés du premier <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'implémentation de l'interface générique <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> de chaque clé.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque clé dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> possède un élément correspondant le <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est repositionnée de la même façon.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est trié selon la disposition des clés correspondantes dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Chaque clé dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> doit implémenter la <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> interface générique afin de pouvoir faire des comparaisons avec toutes les autres clés.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Vous pouvez trier s’il existe plusieurs éléments clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est la <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, et <ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> des surcharges de méthode générique, pour le tri de paires de tableaux qui représentent les clés et valeurs.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L’exemple de code définit un autre comparateur pour les chaînes nommées <ph id="ph1">`ReverseCompare`</ph>, qui implémente le <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> dans Visual C++) interface générique.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Le comparateur appelle la <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> méthode, en inversant l’ordre des comparateurs afin que les chaînes triées de haut en bas au lieu de faible à élevé.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">L’exemple de code crée et affiche un tableau de noms de dinosaure (les clés) et un tableau d’entiers représentant la longueur maximale de chaque dinosaure en mètres (les valeurs).</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Les tableaux sont ensuite triés et affiche plusieurs fois :</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> surcharge est utilisée pour trier les deux tableaux dans l’ordre des noms dinosaure dans le premier tableau.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge et une instance de <ph id="ph2">`ReverseCompare`</ph> sont utilisées pour inverser l’ordre de tri des tableaux associés.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux dans l’ordre inverse.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Les appels aux méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type des deux premiers arguments.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Si vous utilisez la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la limite inférieure de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ne correspond pas à la limite inférieure de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la longueur de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> est supérieure à celle de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Un ou plusieurs éléments de <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> n’implémentent pas l’interface générique <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Type des éléments du tableau des clés.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Type des éléments du tableau des éléments.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel de base zéro qui contient les clés à trier.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel de base zéro qui contient les éléments correspondant aux clés dans <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> pour trier uniquement <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Implémentation de l'interface générique <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> à utiliser lors de la comparaison d'éléments, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> pour utiliser l'implémentation de l'interface générique <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Sorts a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Trie une paire d'objets <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> (l'un contient les clés et l'autre, les éléments correspondants) en fonction des clés du premier <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'interface générique <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque clé dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> possède un élément correspondant le <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est repositionnée de la même façon.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est trié selon la disposition des clés correspondantes dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, chaque clé dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> doit implémenter la <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> interface générique afin de pouvoir faire des comparaisons avec toutes les autres clés.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Vous pouvez trier s’il existe plusieurs éléments clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est la <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, [<ph id="ph2">\]</ph>, TValue<ph id="ph3">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;,<ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, [<ph id="ph2">\]</ph>, TValue<ph id="ph3">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt;,<ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, et <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> des surcharges de méthode générique, pour le tri de paires de tableaux qui représentent les clés et valeurs.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L’exemple de code définit un autre comparateur pour les chaînes nommées <ph id="ph1">`ReverseCompare`</ph>, qui implémente le <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> dans Visual C++) interface générique.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Le comparateur appelle la <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> méthode, en inversant l’ordre des comparateurs afin que les chaînes triées de haut en bas au lieu de faible à élevé.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">L’exemple de code crée et affiche un tableau de noms de dinosaure (les clés) et un tableau d’entiers représentant la longueur maximale de chaque dinosaure en mètres (les valeurs).</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Les tableaux sont ensuite triés et affiche plusieurs fois :</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> surcharge est utilisée pour trier les deux tableaux dans l’ordre des noms dinosaure dans le premier tableau.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; overload and an instance of <ph id="ph3">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Le [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; surcharge et une instance de <ph id="ph3">`ReverseCompare`</ph> sont utilisées pour inverser l’ordre de tri des tableaux associés.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux dans l’ordre inverse.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Les appels aux méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type des deux premiers arguments.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Si vous utilisez la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la limite inférieure de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ne correspond pas à la limite inférieure de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la longueur de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> est supérieure à celle de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L’implémentation de <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a provoqué une erreur pendant le tri.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>, et un ou plusieurs éléments de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> n’implémentent pas l’interface générique <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Le .NET Framework 4 et versions antérieures utilisé uniquement l’algorithme de tri rapide.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception et lève un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception à l’appelant.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, il est possible que les opérations de tri précédemment a levé <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne détectent pas un comparateur non valide.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La plupart des cas, cela s’applique aux tableaux avec moins de 16 éléments.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Type des éléments du tableau des clés.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Type des éléments du tableau des éléments.</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel de base zéro qui contient les clés à trier.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel de base zéro qui contient les éléments correspondant aux clés dans <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> pour trier uniquement <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Index de départ de la plage à trier.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Nombre d'éléments à trier dans la plage.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each key.</source>
          <target state="translated">Trie une plage d'éléments dans une paire d'objets <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnels (l'un contient les clés et l'autre, les éléments correspondants) en fonction des clés du premier <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'implémentation d'interface générique <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> de chaque clé.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque clé dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> possède un élément correspondant le <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est repositionnée de la même façon.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est trié selon la disposition des clés correspondantes dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Chaque clé de la plage spécifiée d’éléments dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> doit implémenter la <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> interface générique afin de pouvoir faire des comparaisons avec toutes les autres clés.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Vous pouvez trier s’il existe plusieurs éléments clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés.</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, [<ph id="ph3">\]</ph>, TValue<ph id="ph4">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;, and <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, [<ph id="ph3">\]</ph>, TValue<ph id="ph4">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 &gt;, et <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharges de méthode générique, pour le tri de paires de tableaux qui représentent les clés et valeurs.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L’exemple de code définit un autre comparateur pour les chaînes nommées <ph id="ph1">`ReverseCompare`</ph>, qui implémente le <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> dans Visual C++) interface générique.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Le comparateur appelle la <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> méthode, en inversant l’ordre des comparateurs afin que les chaînes triées de haut en bas au lieu de faible à élevé.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">L’exemple de code crée et affiche un tableau de noms de dinosaure (les clés) et un tableau d’entiers représentant la longueur maximale de chaque dinosaure en mètres (les valeurs).</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Les tableaux sont ensuite triés et affiche plusieurs fois :</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> surcharge est utilisée pour trier les deux tableaux dans l’ordre des noms dinosaure dans le premier tableau.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge et une instance de <ph id="ph2">`ReverseCompare`</ph> sont utilisées pour inverser l’ordre de tri des tableaux associés.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt; overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Le [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 &gt; surcharge est utilisée pour trier les trois derniers éléments des deux tableaux.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux dans l’ordre inverse.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Les appels aux méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type des deux premiers arguments.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Si vous utilisez la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure de <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la limite inférieure de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ne correspond pas à la limite inférieure de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la longueur de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> est supérieure à celle de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n’est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph>, et <ph id="ph3">&lt;paramref name="index" /&gt;</ph> et <ph id="ph4">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Un ou plusieurs éléments de <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> n’implémentent pas l’interface générique <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Type des éléments du tableau des clés.</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Type des éléments du tableau des éléments.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel de base zéro qui contient les clés à trier.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel de base zéro qui contient les éléments correspondant aux clés dans <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> pour trier uniquement <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Index de départ de la plage à trier.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Nombre d'éléments à trier dans la plage.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Implémentation de l'interface générique <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> à utiliser lors de la comparaison d'éléments, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> pour utiliser l'implémentation de l'interface générique <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> de chaque élément.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Trie une plage d'éléments dans une paire d'objets <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnels (l'un contient les clés et l'autre, les éléments correspondants) en fonction des clés du premier <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> à l'aide de l'interface générique <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Chaque clé dans le <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> possède un élément correspondant le <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est repositionnée de la même façon.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> est trié selon la disposition des clés correspondantes dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> est <ph id="ph2">`null`</ph>, chaque clé de la plage spécifiée d’éléments dans le <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> doit implémenter la <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> interface générique afin de pouvoir faire des comparaisons avec toutes les autres clés.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Vous pouvez trier s’il existe plusieurs éléments clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Si le tri n’est pas terminé, les résultats sont indéfinis.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Cette méthode utilise l’algorithme de tri approfondie (introsort) comme suit :</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Si la taille de la partition est inférieur à 16 éléments, il utilise un <bpt id="p1">[</bpt>tri d’insertion<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si le nombre de partitions est supérieure à 2 * journal<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, où <bpt id="p2">*</bpt>N<ept id="p2">*</ept> correspond à la plage du tableau d’entrée, il utilise un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Sinon, il utilise un <bpt id="p1">[</bpt>tri rapide<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithme.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre n’est pas conservée.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En revanche, un tri stable conserve l’ordre des éléments qui sont identiques.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Pour les groupes qui sont triés à l’aide d’algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (<ph id="ph1">`n`</ph> journal <ph id="ph2">`n`</ph>) opération, où <ph id="ph3">`n`</ph> est <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and [<ph id="ph4">\]</ph>, TValue<ph id="ph5">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, et [<ph id="ph4">\]</ph>, TValue<ph id="ph5">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; des surcharges de méthode générique, pour le tri de paires de tableaux qui représentent les clés et valeurs.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph>(<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L’exemple de code définit un autre comparateur pour les chaînes nommées <ph id="ph1">`ReverseCompare`</ph>, qui implémente le <ph id="ph2">`IComparer&lt;string&gt;`</ph>(<ph id="ph3">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> dans Visual C++) interface générique.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Le comparateur appelle la <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> méthode, en inversant l’ordre des comparateurs afin que les chaînes triées de haut en bas au lieu de faible à élevé.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">L’exemple de code crée et affiche un tableau de noms de dinosaure (les clés) et un tableau d’entiers représentant la longueur maximale de chaque dinosaure en mètres (les valeurs).</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Les tableaux sont ensuite triés et affiche plusieurs fois :</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> surcharge est utilisée pour trier les deux tableaux dans l’ordre des noms dinosaure dans le premier tableau.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> surcharge et une instance de <ph id="ph2">`ReverseCompare`</ph> sont utilisées pour inverser l’ordre de tri des tableaux associés.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Le [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; surcharge est utilisée pour trier les trois derniers éléments des deux tableaux dans l’ordre inverse.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Les appels aux méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type des deux premiers arguments.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Si vous utilisez la <bpt id="p1">[</bpt>Ildasm.exe (désassembleur IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à la limite inférieure de <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la limite inférieure de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ne correspond pas à la limite inférieure de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n'est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph> et la longueur de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> est supérieure à celle de <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> n’est pas <ph id="ph2">&lt;see langword="null" /&gt;</ph>, et <ph id="ph3">&lt;paramref name="index" /&gt;</ph> et <ph id="ph4">&lt;paramref name="length" /&gt;</ph> ne spécifient pas une plage valide dans <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L’implémentation de <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> a provoqué une erreur pendant le tri.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Par exemple, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>, et un ou plusieurs éléments de <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> n’implémentent pas l’interface générique <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Le .NET Framework 4 et versions antérieures utilisé uniquement l’algorithme de tri rapide.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception et lève un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception à l’appelant.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, il est possible que les opérations de tri précédemment a levé <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne détectent pas un comparateur non valide.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La plupart des cas, cela s’applique aux tableaux avec moins de 16 éléments.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" uid="P:System.Array.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient un objet qui peut être utilisé pour synchroniser l'accès à <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Objet qui peut être utilisé pour synchroniser l'accès à <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>This property implements the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Cette propriété implémente la <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Les classes .NET framework basées sur <ph id="ph1">&lt;xref:System.Array&gt;</ph> fournissent leur propre version synchronisée de la collection à l’aide de la <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Les classes qui utilisent des tableaux peuvent également implémenter leur propre à l’aide de la synchronisation du <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
          <target state="translated">Le code de synchronisation doit effectuer les opérations sur les <ph id="ph1">`SyncRoot`</ph> de la collection, et non directement sur la collection.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Cela garantit un bon fonctionnement des collections dérivées d’autres objets.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
          <target state="translated">Plus particulièrement, il maintient la synchronisation est assurée avec les autres threads qui pourraient modifier simultanément la collection.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
          <target state="translated">Notez que certaines implémentations de <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> peut retourner le <ph id="ph2">&lt;xref:System.Array&gt;</ph> lui-même.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>The following code example shows how to lock an array during the entire enumeration by using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple de code suivant montre comment verrouiller un tableau pendant l’ensemble de l’énumération à l’aide de la <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>Gets the number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obtient le nombre d'éléments contenus dans le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>The number of elements contained in the collection.</source>
          <target state="translated">Nombre d’éléments contenus dans la collection.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>The object to be added to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Objet à ajouter à <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Calling this method always throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> exception.</source>
          <target state="translated">L’appel de cette méthode lève toujours une exception <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Adding a value to an array is not supported.</source>
          <target state="translated">L'ajout d'une valeur à un tableau n'est pas pris en charge.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>No value is returned.</source>
          <target state="translated">Aucune valeur n'est retournée.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Ordinarily, an <ph id="ph1">&lt;xref:System.Collections.IList.Add%2A?displayProperty=nameWithType&gt;</ph> implementation adds a member to a collection.</source>
          <target state="translated">En règle générale, un <ph id="ph1">&lt;xref:System.Collections.IList.Add%2A?displayProperty=nameWithType&gt;</ph> implémentation ajoute un membre à une collection.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>However, because arrays have a fixed size (the <ph id="ph1">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property always returns <ph id="ph2">`true`</ph>), this method always throws a <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
          <target state="translated">Toutefois, étant donné que les tableaux ont une taille fixe (la <ph id="ph1">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> propriété retourne toujours <ph id="ph2">`true`</ph>), cette méthode lève toujours une <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> est de taille fixe.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Clear">
          <source>Removes all items from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Supprime tous les éléments de <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Clear">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Clear">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>The object to locate in the current list.</source>
          <target state="translated">Objet à rechercher dans la liste active.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>The element to locate can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">L'élément à trouver peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph> pour les types référence.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>Determines whether an element is in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Détermine si le <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> contient un élément.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> existe dans <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>The object to locate in the current list.</source>
          <target state="translated">Objet à rechercher dans la liste active.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>Determines the index of a specific item in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Détermine l'index d'un élément spécifique d'<ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>The index of value if found in the list; otherwise, -1.</source>
          <target state="translated">Index de valeur s'il figure dans la liste ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The index at which <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be inserted.</source>
          <target state="translated">Index au niveau duquel <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> doit être inséré.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The object to insert.</source>
          <target state="translated">Objet à insérer.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>Inserts an item to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> at the specified index.</source>
          <target state="translated">Insère un élément dans <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> à l'index spécifié.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is not a valid index in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> n'est pas un index valide dans <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> est de taille fixe.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is null reference in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> est une référence null dans <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The index of the element to get or set.</source>
          <target state="translated">Index de l'élément à obtenir ou à définir.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>Gets or sets the element at the specified index.</source>
          <target state="translated">Obtient ou définit l'élément au niveau de l'index spécifié.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The element at the specified index.</source>
          <target state="translated">Élément au niveau de l'index spécifié.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.ICollection.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est supérieur ou égal à <ph id="ph2">&lt;see cref="P:System.Collections.ICollection.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> en cours ne possède pas exactement une dimension.</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The object to remove from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Objet à supprimer de <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Supprime la première occurrence d'un objet spécifique de <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> est de taille fixe.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The index of the element to remove.</source>
          <target state="translated">Index de l'élément à supprimer.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>Removes the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> item at the specified index.</source>
          <target state="translated">Supprime l'élément <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> au niveau de l'index spécifié.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>index is not a valid index in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">index n'est pas un index valide dans <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> est de taille fixe.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">Objet à comparer à l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>An object that compares the current object and <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Objet qui compare l’objet actuel et <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</source>
          <target state="translated">Détermine si l’objet collection actuel précède, se situe à la même position que, ou suit un autre objet dans l’ordre de tri.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>An integer that indicates the relationship of the current collection object to other, as shown in the following table.</source>
          <target state="translated">Entier qui indique la relation de l'objet de collection actuel par rapport aux autres objets, comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valeur de retour</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance precedes <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> L’instance active précède <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance and <ph id="ph3">&lt;paramref name="other" /&gt;</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> L’instance active et <ph id="ph3">&lt;paramref name="other" /&gt;</ph> sont égaux.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance follows <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> L’instance active suit <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralComparable&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.IStructuralComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">Objet à comparer à l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>An object that determines whether the current instance and <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept> are equal.</source>
          <target state="translated">Objet qui détermine si l’instance active et <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept> sont égaux.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>Determines whether an object is equal to the current instance.</source>
          <target state="translated">Détermine si un objet est identique à l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the two objects are equal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si les deux objets sont égaux ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>An object that computes the hash code of the current object.</source>
          <target state="translated">Objet qui calcule le code de hachage de l'objet actif.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>Returns a hash code for the current instance.</source>
          <target state="translated">Retourne un code de hachage pour l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>The hash code for the current instance.</source>
          <target state="translated">Code de hachage de l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Array&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Type des éléments du tableau.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to check against the conditions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> de base zéro unidimensionnel à vérifier par rapport aux conditions.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The predicate that defines the conditions to check against the elements.</source>
          <target state="translated">Le prédicat qui définit les conditions à vérifier par rapport aux éléments.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>Determines whether every element in the array matches the conditions defined by the specified predicate.</source>
          <target state="translated">Détermine si chaque élément dans le tableau correspond aux conditions définies par le prédicat spécifié.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if every element in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> matches the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si chaque élément dans <ph id="ph2">&lt;paramref name="array" /&gt;</ph> correspond aux conditions définies par le prédicat spécifié ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>If there are no elements in the array, the return value is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Si le tableau ne contient pas d'élément, la valeur de retour est <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns<ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> est un délégué à une méthode qui retourne<ph id="ph2">`true`</ph> si l’objet passé à elle correspond aux conditions définies dans ce délégué.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when the delegate returns <ph id="ph3">`false`</ph> for any element.</source>
          <target state="translated">Les éléments de <ph id="ph1">`array`</ph> sont passés individuellement à la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, et le traitement est interrompu lorsque le délégué retourne <ph id="ph3">`false`</ph> pour n’importe quel élément.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> de <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The following example determines whether the last character of each element in a string array is a number.</source>
          <target state="translated">L’exemple suivant détermine si le dernier caractère de chaque élément dans un tableau de chaînes est un nombre.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>It creates two string arrays.</source>
          <target state="translated">Il crée deux tableaux de chaînes.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The first arrayincludes both strings that end with alphabetic characters and strings that end with numeric characters.The second array consists only of strings that end with numeric characters.</source>
          <target state="translated">La première arrayincludes à la fois des chaînes qui se terminent par des caractères alphabétiques et des chaînes qui se terminent par des caractères numériques. Le deuxième tableau se compose uniquement de chaînes qui se terminent par des caractères numériques.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The example also defines an <ph id="ph1">`EndWithANumber`</ph> method whose signature matches the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">L’exemple définit également un <ph id="ph1">`EndWithANumber`</ph> méthode dont la signature correspond à la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The example passes each array to the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method along with a delegate that represents the <ph id="ph2">`EndsWithANumber`</ph> method.</source>
          <target state="translated">L’exemple passe chaque tableau à la <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> (méthode), ainsi que d’un délégué qui représente le <ph id="ph2">`EndsWithANumber`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The following example is similar to the first, except that it passes the string array to the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method along with  a lambda expression that determines whether a particular array element ends with the string representation of a number.</source>
          <target state="translated">L’exemple suivant est similaire à la première, sauf qu’elle transmet le tableau de chaînes à la <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> méthode avec une expression lambda qui détermine si un élément de tableau particulier se termine par la représentation sous forme de chaîne d’un nombre.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>In both cases, the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method returns <ph id="ph2">`false`</ph> as soon as it encounters the first array element that does not end in a number.</source>
          <target state="translated">Dans les deux cas, le <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> méthode retourne <ph id="ph2">`false`</ph> dès qu’il rencontre le premier élément du tableau qui ne se termine pas par un nombre.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>Otherwise, it returns <ph id="ph1">`true`</ph> after iterating all the elements in the array.</source>
          <target state="translated">Sinon, elle retourne <ph id="ph1">`true`</ph> après l’itération de tous les éléments du tableau.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>As both examples show, in C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">Comme le montrent les deux exemples, en c# et Visual Basic, il n’est pas nécessaire de créer le <ph id="ph1">`Predicate&lt;string&gt;`</ph> déléguer (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explicitement.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>