<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0173b6c93fb425317fee9f82a66537f25bb42b31" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37728431" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un générateur de nombres pseudo-aléatoires. Il s’agit d’un périphérique qui produit une séquence de nombres conformes à certaines exigences statistiques liées à l’aspect aléatoire.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nombres pseudo-aléatoires sont choisies avec une probabilité égale à partir d’un ensemble fini de nombres. Les numéros choisis ne sont pas complètement aléatoires, car un algorithme mathématique est utilisé pour les sélectionner, mais ils sont suffisamment aléatoires pour des raisons pratiques. L’implémentation actuelle de la <xref:System.Random> classe repose sur une version modifiée de soustraction de nombres générateur aléatoires de Knuth. Pour plus d’informations, consultez E. D. Knuth. *L’Art de la programmation informatique, Volume 2 : Seminumerical Algorithms*. Addison-Wesley, Reading, MA, troisième édition, 1997.  
  
 Pour générer un nombre aléatoire sécurisé par chiffrement, tel que celui qui convient pour la création d’un mot de passe aléatoire, utilisez la <xref:System.Security.Cryptography.RNGCryptoServiceProvider> classe ou dérivez une classe de <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 Dans cette rubrique :  
  
 [L’instanciation du Générateur de nombres aléatoire](#Instantiate)   
 [Éviter plusieurs instanciations](#Multiple)   
 [La sécurité de thread et de la classe System.Random](#ThreadSafety)   
 [Génération de différents types de nombres aléatoires](#Functionality)   
 [En remplaçant votre propre algorithme](#Overriding)   
 [Comment utiliser System.Random pour...](#Operations)   
 [Récupérer la même séquence de valeurs aléatoires](#Same)  
 [Récupérer les séquences uniques de valeurs aléatoires](#Unique)  
 [Récupérer des nombres entiers dans une plage spécifiée](#Range)  
 [Récupérer des entiers avec un nombre spécifié de chiffres](#Digits)  
 [Récupérer des valeurs à virgule flottante dans une plage spécifiée](#Floats)  
 [Générer des valeurs booléennes aléatoire](#Boolean)  
 [Générer des entiers 64 bits aléatoires](#Long)  
 [Récupérer des octets dans une plage spécifiée](#Bytes)  
 [Récupérer un élément d’un tableau ou une collection de manière aléatoire](#Array)  
 [Récupérer un élément unique à partir d’un tableau ou une collection](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>L’instanciation du Générateur de nombres aléatoire  
 Vous instanciez le Générateur de nombres aléatoires en fournissant une valeur de départ (une valeur de départ pour l’algorithme de génération de nombres pseudo-aléatoires) à un <xref:System.Random.%23ctor%2A> constructeur de classe.  Vous pouvez fournir la valeur de départ explicitement ou implicitement :  
  
-   Le <xref:System.Random.%23ctor%28System.Int32%29> constructeur utilise une valeur de départ explicite que vous fournissez.  
  
-   Le <xref:System.Random.%23ctor> constructeur utilise l’horloge système pour fournir une valeur de départ. Il s’agit de la méthode la plus courante de l’instanciation du Générateur de nombres aléatoires.  
  
 Si la même valeur de départ est utilisée pour distinct <xref:System.Random> objets, ils généreront la même série de nombres aléatoires. Cela peut être utile pour la création d’une suite de tests qui traite les valeurs aléatoires, ou pour relire les jeux qui obtiennent leurs données à partir de nombres aléatoires. Toutefois, notez que <xref:System.Random> objets dans les processus qui s’exécutent sous différentes versions du .NET Framework peuvent retourner différentes séries de nombres aléatoires même si elles sont instanciées avec des valeurs de départ identique.  
  
 Pour produire différentes séquences de nombres aléatoires, vous pouvez rendre la valeur de départ dépendant du temps, produisant ainsi une autre série avec chaque nouvelle instance de <xref:System.Random>. Paramétré <xref:System.Random.%23ctor%28System.Int32%29> constructeur peut prendre un <xref:System.Int32> valeur basée sur le nombre de graduations dans l’heure actuelle, tandis que sans paramètre <xref:System.Random.%23ctor> constructeur utilise l’horloge système pour générer sa valeur initiale. Toutefois, étant donné que l’horloge a la résolution finie, l’utilisation du constructeur sans paramètre pour créer différents <xref:System.Random> objets successivement crée des générateurs de nombres aléatoires qui produisent des séquences identiques de nombres aléatoires. L’exemple suivant illustre comment deux <xref:System.Random> objets sont instanciés successivement génèrent une série identique de nombres aléatoires. Sur la plupart des systèmes Windows, <xref:System.Random> les objets créés au sein de 15 millisecondes d’eux sont susceptibles d’avoir les mêmes valeurs initiales.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Pour éviter ce problème, créez un seul <xref:System.Random> objet au lieu de plusieurs objets.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Éviter plusieurs instanciations  
 L’initialisation de deux générateurs de nombres aléatoires dans une boucle serrée ou en succession rapide crée deux générateurs de nombres aléatoires qui peuvent produire des séquences identiques de nombres aléatoires. Dans la plupart des cas, cela n’est pas intention du développeur et peut entraîner des problèmes de performances, car l’instanciation et initialisation d’un générateur de nombres aléatoires sont un processus relativement coûteux.  
  
 À la fois pour améliorer les performances et d’éviter de créer par inadvertance les générateurs de nombres aléatoires distincts qui génèrent des séquences numériques identiques, nous vous recommandons de créer un <xref:System.Random> objet pour générer des nombres aléatoires au fil du temps, au lieu de créer nouvelle <xref:System.Random> objets pour générer un nombre aléatoire.  
  
 Toutefois, la <xref:System.Random> classe n’est pas thread-safe. Si vous appelez <xref:System.Random> méthodes à partir de plusieurs threads, suivez les instructions figurant dans la section suivante.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>La sécurité de thread et de la classe System.Random  
 Au lieu de l’instanciation de l’individu <xref:System.Random> objets, nous vous recommandons de créer un seul <xref:System.Random> instance pour générer tous les nombres aléatoires nécessaires à votre application. Toutefois, <xref:System.Random> objets ne sont pas thread-safe. Si votre application appelle <xref:System.Random> méthodes à partir de plusieurs threads, vous devez utiliser un objet de synchronisation pour vérifier qu’un seul thread peut accéder le Générateur de nombres aléatoires à la fois. Si vous ne vous assurer que le <xref:System.Random> objet est accessible de manière thread-safe, les appels aux méthodes qui retournent des nombres aléatoires retournent 0.  
  
 L’exemple suivant utilise le langage c# [lock, instruction](~/docs/csharp/language-reference/keywords/lock-statement.md) et Visual Basic [instruction SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) pour vous assurer qu’un seul générateur de nombres aléatoires est accessible par 11 threads de manière thread-safe. Chaque thread génère des nombres aléatoires de 2 millions, compte le nombre de nombres aléatoires et calcule leur somme, puis met à jour les totaux de tous les threads quand il a terminé l’exécution.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 L’exemple vérifie la cohérence de thread comme suit :  
  
-   Le <xref:System.ThreadStaticAttribute> attribut est utilisé pour définir des variables locales de thread qui effectuent le suivi du nombre total de nombres aléatoires et leur somme pour chaque thread.  
  
-   Un verrou (le `lock` instruction en langage c# et le `SyncLock` instruction en Visual Basic) protège l’accès aux variables pour le nombre total et la somme de tous les nombres aléatoires sur tous les threads.  
  
-   Un sémaphore (le <xref:System.Threading.CountdownEvent> objet) permet de s’assurer que le thread principal se bloque jusqu'à ce que tous les autres threads terminent.  
  
-   L’exemple vérifie si le Générateur de nombres aléatoires est endommagé en déterminant si les deux appels consécutifs à des méthodes de génération de nombres aléatoires retournent 0. Si l’altération est détectée, l’exemple utilise le <xref:System.Threading.CancellationTokenSource> objet pour signaler que tous les threads doivent être annulées.  
  
-   Avant de générer chaque nombre aléatoire, chaque thread vérifie l’état de la <xref:System.Threading.CancellationToken> objet. Si l’annulation est demandée, l’exemple appelle la <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> méthode pour annuler le thread.  
  
 L’exemple suivant est identique à la première, sauf qu’elle utilise un <xref:System.Threading.Tasks.Task> objet et une expression lambda au lieu de <xref:System.Threading.Thread> objets.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Elle diffère du premier exemple comme suit :  
  
-   Les variables pour suivre le nombre de nombres aléatoires et leur somme dans chaque tâche sont locales à la tâche, il est donc inutile d’utiliser le <xref:System.ThreadStaticAttribute> attribut.  
  
-   La méthode statique <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> méthode est utilisée pour vous assurer que le thread principal ne termine pas avant que toutes les tâches soient terminées. Il n’est pas nécessaire pour le <xref:System.Threading.CountdownEvent> objet.  
  
-   L’exception qui résulte de l’annulation de tâche est présentée dans le <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> (méthode). Dans l’exemple précédent, il est géré par chaque thread.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Génération de différents types de nombres aléatoires  
 Le Générateur de nombres aléatoires fournit des méthodes qui vous permettent de générer les types suivants de nombres aléatoires :  
  
-   Une série de <xref:System.Byte> valeurs. Vous déterminez le nombre de valeurs d’octets en passant un tableau initialisé avec le nombre d’éléments que vous voulez que la méthode pour revenir à la <xref:System.Random.NextBytes%2A> (méthode). L’exemple suivant génère 20 octets.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Un entier unique. Vous pouvez choisir si vous souhaitez un entier compris entre 0 et une valeur maximale (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) en appelant le <xref:System.Random.Next> (méthode), un entier compris entre 0 et une valeur spécifique en appelant le <xref:System.Random.Next%28System.Int32%29> (méthode), ou un entier au sein d’une plage de valeurs en appelant le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>(méthode). Dans les surcharges paramétrables, la valeur maximale spécifiée est exclusive ; Autrement dit, le nombre maximal réel généré est une inférieure à la valeur spécifiée.  
  
     L’exemple suivant appelle la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> méthode permettant de générer 10 nombres aléatoires compris entre -10 et 10. Notez que le deuxième argument à la méthode spécifie la limite supérieure exclusive de la plage de valeurs aléatoires retourné par la méthode. En d’autres termes, le plus grand entier que la méthode peut retourner une est inférieure à cette valeur.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Seule valeur à virgule flottante comprise entre 0,0 et inférieur à 1,0 en appelant le <xref:System.Random.NextDouble%2A> (méthode). La limite supérieure exclusive du nombre aléatoire retourné par la méthode est 1, par conséquent, sa limite supérieure réelle est 0.99999999999999978. L’exemple suivant génère des nombres à virgule flottante aléatoires 10.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  Le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> méthode vous permet de spécifier la plage du nombre aléatoire retourné. Toutefois, le `maxValue` paramètre, qui spécifie la plage supérieure retournés numéro, est exclusif, pas un inclus, valeur. Cela signifie que l’appel de méthode `Next(0, 100)` retourne une valeur comprise entre 0 et 99 et non entre 0 et 100.  
  
 Vous pouvez également utiliser le <xref:System.Random> classe pour des tâches telles que la génération [valeurs t : System.Boolean aléatoires](#Boolean), génération [à virgule flottante aléatoire des valeurs avec une plage de 0 à 1](#Floats), génération [entiers 64 bits aléatoires](#Long), et [au hasard récupérer un élément unique à partir d’un tableau ou une collection](#UniqueArray). Pour celles-ci et d’autres tâches courantes, consultez le [utilisation System.Random pour...](#Operations) section.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>En remplaçant votre propre algorithme  
 Vous pouvez implémenter votre propre générateur de nombres aléatoires en héritant de la <xref:System.Random> classe et en fournissant votre algorithme de génération de nombres aléatoires. Pour fournir votre propre algorithme, vous devez substituer la <xref:System.Random.Sample%2A> (méthode), qui implémente l’algorithme de génération de nombres aléatoires. Vous devez également substituer la <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, et <xref:System.Random.NextBytes%2A> méthodes pour vous assurer qu’ils appellent votre substituée <xref:System.Random.Sample%2A> (méthode). Vous n’êtes pas obligé de substituer le <xref:System.Random.Next%28System.Int32%29> et <xref:System.Random.NextDouble%2A> méthodes.  
  
 Pour obtenir un exemple qui dérive de la <xref:System.Random> classe et modifie son générateur de nombres pseudo-aléatoires par défaut, consultez le <xref:System.Random.Sample%2A> page de référence.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Comment utiliser System.Random pour...  
 Les sections suivantes décrivent et fournissent des exemples de code pour certaines des méthodes que vous souhaiterez peut-être utiliser des nombres aléatoires dans votre application.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Récupérer la même séquence de valeurs aléatoires  
 Parfois, vous souhaitez générer la même séquence de nombres aléatoires dans les scénarios de test de logiciel et dans le jeu. Test avec la même séquence de nombres aléatoires vous permet de détecter les régressions et confirmer les correctifs de bogues. À l’aide de la même séquence de nombre aléatoire dans les jeux vous permet de relire les jeux précédentes.  
  
 Vous pouvez générer la même séquence de nombres aléatoires grâce à la même valeur de départ pour le <xref:System.Random.%23ctor%28System.Int32%29> constructeur. La valeur de départ fournit une valeur de départ pour l’algorithme de génération de nombres pseudo-aléatoires. L’exemple suivant utilise 100100 comme une valeur de départ arbitraire pour instancier le <xref:System.Random> objet, affiche 20 valeurs à virgule flottante aléatoire et conserve la valeur de départ. Elle restaure la valeur de départ, instancie un nouveau générateur de nombres aléatoires et affiche les valeurs à virgule flottante mêmes aléatoire de 20.  Notez que l’exemple peut produire des différentes séquences de nombres aléatoires de s’exécuter sur des versions différentes du .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Récupérer des séquences de nombres aléatoires uniques  
 En fournissant des valeurs initiales différentes aux instances de la <xref:System.Random> classe force chaque générateur de nombres aléatoires produire une autre séquence de valeurs. Vous pouvez fournir une valeur de départ explicitement en appelant le <xref:System.Random.%23ctor%28System.Int32%29> constructeur, ou implicitement en appelant le <xref:System.Random.%23ctor> constructeur. La plupart des développeurs appeler le constructeur sans paramètre, qui utilise l’horloge système. L’exemple suivant utilise cette approche pour instancier deux <xref:System.Random> instances. Chaque instance s’affiche une série de 10 entiers aléatoires.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Toutefois, en raison de sa résolution finie, l’horloge système ne détecte pas les différences de temps inférieure à environ 15 millisecondes. Par conséquent, si votre code appelle la <xref:System.Random.%23ctor> surcharge pour instancier deux <xref:System.Random> objets à la suite, vous proposent pouvez par inadvertance les objets avec les mêmes valeurs initiales. Pour voir cela dans l’exemple précédent, commentez la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> appel de méthode et de compilation et réexécutez l’exemple.  
  
 Pour éviter ce problème, nous recommandons que vous instanciez une seule <xref:System.Random> de l’objet au lieu de plusieurs. Toutefois, étant donné que <xref:System.Random> n’est pas thread-safe, vous devez utiliser un périphérique de synchronisation si vous accédez à un <xref:System.Random> une instance à partir de plusieurs threads ; pour plus d’informations, consultez [aléatoire de la sécurité de classe et thread](#ThreadSafety) plus haut dans cette rubrique. Alternativement, vous pouvez utiliser un mécanisme de délai, tel que le <xref:System.Threading.Thread.Sleep%2A> méthode utilisée dans l’exemple précédent, afin d’éviter les instanciations éloignés de plus de 15 millisecondes.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Récupérer des nombres entiers dans une plage spécifiée  
 Vous pouvez récupérer des nombres entiers dans une plage spécifiée en appelant le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> (méthode), ce qui vous permet de spécifier à la fois inférieure et la limite supérieure des nombres que vous souhaitez que le Générateur de nombres aléatoires à retourner. La limite supérieure est exclusif, pas un inclus, valeur. Autrement dit, il n’est pas inclus dans la plage de valeurs retournées par la méthode. L’exemple suivant utilise cette méthode pour générer des entiers aléatoires compris entre -10 et 10. Notez qu’il spécifie 11, qui est supérieure à la valeur souhaitée, en tant que la valeur de la `maxValue` argument dans l’appel de méthode.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Récupérer des entiers avec un nombre spécifié de chiffres  
 Vous pouvez appeler la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> méthode pour récupérer des nombres avec un nombre spécifié de chiffres. Par exemple, pour récupérer des nombres avec quatre chiffres (autrement dit, les nombres allant de 1000 à 9999), vous appelez le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> méthode avec un `minValue` valeur de 1000 et un `maxValue` valeur métrique 10.000, comme le montre l’exemple suivant.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Récupérer des valeurs à virgule flottante dans une plage spécifiée  
 Le <xref:System.Random.NextDouble%2A> méthode retourne les valeurs à virgule flottante aléatoire de cette plage entre 0 et inférieur à 1. Toutefois, vous aurez souvent besoin de générer des valeurs aléatoires dans une autre plage.  
  
 Si l’intervalle entre les valeurs souhaitées minimales et maximales est 1, vous pouvez ajouter la différence entre l’intervalle de départ souhaitée et la valeur 0 au nombre retourné par la <xref:System.Random.NextDouble%2A> (méthode). L’exemple suivant effectue ceci pour générer 10 nombres aléatoires entre -1 et 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Pour générer des nombres à virgule flottante aléatoire dont la limite inférieure est 0, mais limite supérieure est supérieure à 1 (ou, dans le cas des nombres négatifs, dont la limite inférieure est inférieur à -1 et limite supérieure est 0), multipliez le nombre aléatoire par la limite différente de zéro. L’exemple suivant effectue cette pour générer des nombres à virgule flottante aléatoire de 20 millions de cette plage de 0 à <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Dans affiche également la distribution des valeurs aléatoires générées par la méthode.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Pour générer des nombres à virgule flottante aléatoire entre deux valeurs arbitraires, comme le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> fait de la méthode pour les entiers, utilisez la formule suivante :  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 L’exemple suivant génère des nombres aléatoires de 1 million qui vont de 10.0 à 11.0 et affiche leur distribution.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Générer des valeurs booléennes aléatoire  
 Le <xref:System.Random> classe ne fournit des méthodes qui génèrent <xref:System.Boolean> valeurs. Toutefois, vous pouvez définir votre propre classe ou une méthode pour ce faire. L’exemple suivant définit une classe, `BooleanGenerator`, avec une méthode unique, `NextBoolean`. Le `BooleanGenerator` classe stocke un <xref:System.Random> objet sous la forme d’une variable privée. Le `NextBoolean` les appels de méthode le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode et passe le résultat à la <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> (méthode). Notez que 2 est utilisée comme argument pour spécifier la limite supérieure du nombre aléatoire. Dans la mesure où il s’agit d’une valeur exclusive, l’appel de méthode retourne 0 ou 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Au lieu de créer une classe distincte pour générer aléatoire <xref:System.Boolean> valeurs, l’exemple pouvez simplement définir une méthode unique. Dans ce cas, toutefois, le <xref:System.Random> objet doit avoir été défini en tant que variable de niveau classe afin d’éviter l’instanciation d’un nouvel <xref:System.Random> instance dans chaque appel de méthode. Dans Visual Basic, l’instance aléatoire peut être défini comme un [statique](~/docs/visual-basic/language-reference/modifiers/static.md) variable dans le `NextBoolean` (méthode).  L’exemple suivant fournit une implémentation.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Générer des entiers 64 bits aléatoires  
 Les surcharges de la <xref:System.Random.Next%2A> méthode retournent des entiers 32 bits. Toutefois, dans certains cas, vous souhaiterez utiliser des entiers 64 bits. Vous pouvez procéder comme suit :  
  
1.  Appelez le <xref:System.Random.NextDouble%2A> valeur de point de méthode pour récupérer un flottante double précision.  
  
2.  Multiplier cette valeur par <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 L’exemple suivant utilise cette technique pour générer des entiers longs aléatoire de 20 millions et les classe en 10 groupes égaux. Elle évalue ensuite la distribution des nombres aléatoires en comptant le nombre de chaque groupe de 0 à <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Comme le montre la sortie de l’exemple, les nombres sont réparties plus ou moins dans la plage d’un entier long.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Une autre technique qu’utilise une manipulation de bits ne génère pas des nombres véritablement aléatoires. Cette technique appelle <xref:System.Random.Next> pour générer deux entiers, décale vers la gauche un en 32 bits et ORs utilisez-les. Cette technique présente deux limitations :  
  
1.  Étant donné que le bit 31 est le bit de signe, la valeur de bit 31 de l’entier long qui en résulte est toujours 0.  Ce désagrément peut être résolu en générant un aléatoire 0 ou 1,-décalage vers la gauche il 31 bits et ORing avec l’entier long aléatoire d’origine.  
  
2.  Plus sérieusement, étant donné que la probabilité que la valeur retournée par <xref:System.Random.Next> est égal à 0, il y a peu, le cas échéant des nombres aléatoires dans la plage 0 x 0-0x00000000FFFFFFFF.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Récupérer des octets dans une plage spécifiée  
 Les surcharges de la <xref:System.Random.Next%2A> méthode permettent de spécifier la plage de nombres aléatoires, mais la <xref:System.Random.NextBytes%2A> n’est pas le cas de méthode. L’exemple suivant implémente un `NextBytes` méthode qui vous permet de spécifier la plage d’octets retournés. Il définit un `Random2` classe qui dérive de <xref:System.Random> et overloads son `NextBytes` (méthode).  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 Le `NextBytes(Byte[], Byte, Byte)` méthode encapsule un appel à la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> (méthode) et spécifie la valeur minimale et une supérieure à la valeur maximale (dans ce cas, 0 et 101) que nous voulons retournés dans le tableau d’octets. Étant donné que nous sommes persuadés que les valeurs entières retourné par la <xref:System.Random.Next%2A> méthode se trouvent dans la plage de la <xref:System.Byte> type de données, nous pouvons en toute sécurité convertissez-les (en c#) ou les convertir (en Visual Basic) à partir d’entiers en octets.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Récupérer un élément d’un tableau ou une collection de manière aléatoire  
 Nombres aléatoires servent souvent d’index pour récupérer des valeurs à partir de tableaux ou collections. Pour récupérer une valeur d’index aléatoire, vous pouvez appeler la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> méthode et l’utilisation de la limite inférieure du tableau en tant que la valeur de son `minValue` argument et égale à celle de la limite supérieure du tableau en tant que la valeur de son `maxValue` argument. Pour un tableau de base zéro, cela équivaut à son <xref:System.Array.Length%2A> propriété, ou supérieure à la valeur retournée par la <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> (méthode). L’exemple suivant récupère aléatoirement le nom d’une ville aux États-Unis à partir d’un tableau de villes.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Récupérer un élément unique à partir d’un tableau ou une collection  
 Un générateur de nombres aléatoires permettre toujours retourner des valeurs en double. Comme la plage de numéros devient plus petite ou le nombre de valeurs générées devient plus grand, la probabilité de doublons augmente. Si les valeurs aléatoires doivent être uniques, des numéros sont générés pour compenser les doublons, ce qui entraîne des performances médiocres de plus en plus.  
  
 Il existe un certain nombre de techniques pour gérer ce scénario. Une solution courante consiste à créer un tableau ou une collection qui contient les valeurs à récupérer et un tableau parallèle qui contient des nombres à virgule flottante aléatoire. Le deuxième tableau est rempli avec des nombres aléatoires au moment du premier tableau est créé, et le <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> méthode est utilisée pour trier le premier tableau en utilisant les valeurs dans le tableau parallèle.  
  
 Par exemple, si vous développez un jeu Solitaire, vous souhaitez vous assurer que chaque carte est utilisée une seule fois. Au lieu de générer des nombres aléatoires pour récupérer une carte et suivi si cette carte a déjà été traitée, vous pouvez créer un tableau parallèle de nombres aléatoires qui peuvent être utilisées pour trier le jeu. Une fois que le jeu est trié, votre application peut conserver un pointeur pour indiquer l’index de la carte suivante sur le pont.  
  
 L'exemple suivant illustre cette approche. Il définit un `Card` classe qui représente une carte à jouer et un `Dealer` classe qui traite un jeu de cartes de lire de façon aléatoire. Le `Dealer` constructeur de classe remplit deux tableaux : un `deck` tableau qui a une portée de classe et qui représente toutes les cartes dans un local et le pont ; `order` tableau qui a le même nombre d’éléments que le `deck` de tableau et est rempli avec généré de façon aléatoire <xref:System.Double> valeurs.  Le <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> méthode est ensuite appelée pour trier les `deck` tableau basé sur les valeurs dans le `order` tableau.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 L’exemple suivant crée un générateur de nombres aléatoires unique et appelle son <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, et <xref:System.Random.NextDouble%2A> méthodes pour générer des séquences de nombres aléatoires dans des plages différentes.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 L’exemple suivant génère un entier aléatoire compris qu’il utilise en tant qu’index pour récupérer une valeur de chaîne à partir d’un tableau.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Dans le .NET Framework 1.0 et 1.1, une implémentation minimale d’une classe dérivée de <see cref="T:System.Random" /> requise remplaçant le <see cref="M:System.Random.Sample" /> méthode pour définir un algorithme de nouveaux ou modifié pour la génération de nombres aléatoires. La classe dérivée peut ensuite s’appuyer sur l’implémentation de classe de base de la <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, et <see cref="M:System.Random.NextDouble" /> méthodes à appeler l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> (méthode).  Dans le .NET Framework 2.0 et versions ultérieur, le comportement de la <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, et <see cref="M:System.Random.NextBytes(System.Byte[])" /> méthodes ont été modifiés afin que ces méthodes n’appellent pas nécessairement l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> (méthode). Par conséquent, les classes dérivées de <see cref="T:System.Random" /> qui ciblent .NET Framework 2.0 et version ultérieure doit également substituer ces trois méthodes.</para>
    </block>
    <block subset="none" type="usage">
      <para>L’implémentation du Générateur de nombres aléatoires dans le <see cref="T:System.Random" /> classe n’est pas garantie que restent les mêmes entre les versions principales du .NET Framework. Par conséquent, vous ne doit pas supposer que la même valeur de départ entraîne la même séquence pseudo-aléatoire comprise dans les différentes versions du .NET Framework.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Random" />, à l'aide d'une valeur initiale par défaut qui est fonction du temps.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de départ par défaut est dérivée de l’horloge système et a la résolution finie. Par conséquent, différents <xref:System.Random> les objets qui sont créés successivement par un appel au constructeur par défaut ont des valeurs initiales par défaut identiques et, par conséquent, produira des ensembles identiques de nombres aléatoires. Ce problème peut être évité en utilisant un seul <xref:System.Random> objet pour générer tous les nombres aléatoires. Vous pouvez également contourner il en modifiant la valeur de départ retournée par l’horloge système, puis en fournissant explicitement cette nouvelle valeur de départ pour le <xref:System.Random.%23ctor%28System.Int32%29> constructeur. Pour plus d’informations, consultez le <xref:System.Random.%23ctor%28System.Int32%29> constructeur.  
  
 Appelez ce constructeur si vous souhaitez que votre générateur de nombres aléatoires pour générer une séquence aléatoire de nombres. Pour générer une séquence fixe de nombres aléatoires qui seront les mêmes pour les générateurs de nombres aléatoires différents, appelez le <xref:System.Random.%23ctor%28System.Int32%29> constructeur avec une valeur de départ fixe. Cela <xref:System.Random> surcharge de constructeur est fréquemment utilisée lorsque vous testez des applications qui utilisent des nombres aléatoires.  
  
 Une fois que vous avez instancié le Générateur de nombres aléatoires, vous appelez individuels <xref:System.Random> méthodes, telles que <xref:System.Random.Next> ou <xref:System.Random.NextDouble>, afin de générer des nombres aléatoires.  
  
   
  
## Examples  
 L’exemple suivant utilise le constructeur par défaut pour instancier trois <xref:System.Random> objets et affiche une série de cinq entiers aléatoires pour chacun. Étant donné que les deux premiers <xref:System.Random> objets sont créés successivement, ils sont instanciés à l’aide des mêmes valeurs initiales basées sur l’horloge système et, par conséquent, ils produisent une séquence identique de nombres aléatoires. En revanche, le constructeur par défaut de la troisième <xref:System.Random> objet est appelé après un délai de deux secondes généré en appelant le <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> (méthode). Étant donné que cela génère une valeur initiale différente pour la troisième <xref:System.Random> de l’objet, il génère une autre séquence de nombres aléatoires.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Nombre utilisé pour calculer la valeur de départ de la séquence de nombres pseudo-aléatoires. Si un nombre négatif est spécifié, la valeur absolue du nombre est utilisée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Random" /> à l'aide de la valeur initiale spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En fournissant une valeur de départ identique à différents <xref:System.Random> objets provoque chaque instance produire des séquences identiques de nombres aléatoires. Cela se fait souvent quand vous testez les applications qui s’appuient sur les générateurs de nombres aléatoires.  
  
 Si votre application nécessite différentes séquences de nombres aléatoires, appelez ce constructeur à plusieurs reprises avec différentes valeurs initiales. Pour produire une valeur de départ unique consiste à rendre dépendant du temps. Par exemple, dériver la valeur de départ de l’horloge système, comme le <xref:System.Random.%23ctor> est la surcharge. Toutefois, l’horloge système peut-être pas une résolution suffisante pour fournir différents appels de ce constructeur avec une valeur initiale différente. Il en résulte des générateurs de nombres aléatoires qui génèrent des séquences identiques de nombres pseudo-aléatoires, comme illustré par les deux premiers <xref:System.Random> objets dans l’exemple suivant. Pour éviter ce problème, appliquez un algorithme pour différencier la valeur de départ dans chaque appel, ou à la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode permet de garantir que vous chaque constructeur avec une valeur initiale différente.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Une autre option consiste à instancier un seul <xref:System.Random> de l’objet que vous utilisez pour générer tous les nombres aléatoires dans votre application. Il en résulte des performances légèrement meilleures, étant donné que l’instanciation d’un générateur de nombres aléatoires est relativement coûteuse.  
  
   
  
## Examples  
 L’exemple suivant crée <xref:System.Random> objets avec le constructeur de classe qui prend un paramètre initial et génère une séquence de valeurs de type double et d’entiers aléatoires. L’exemple montre que la même séquence est générée lorsque le <xref:System.Random> objet est créé à nouveau avec le paramètre de constructeur et la valeur initiale.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un nombre aléatoire entier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un nombre aléatoire entier non négatif.</summary>
        <returns>Entier signé 32 bits supérieur ou égal à 0 et inférieur à <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> génère un nombre aléatoire dont la valeur est comprise entre 0 et inférieur à <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Pour générer un nombre aléatoire dont la valeur est comprise entre 0 à un autre nombre positif, utilisez la <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> surcharge de méthode. Pour générer un nombre aléatoire dans une plage différente, utilisez la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple suivant effectue des appels répétés à la <xref:System.Random.Next%2A> méthode permettant de générer un nombre spécifique de nombres aléatoires demandées par l’utilisateur. Le <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> méthode est utilisée pour obtenir des commentaires des clients.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 L’exemple suivant dérive une classe de <xref:System.Random> pour générer une séquence de nombres aléatoires dont la distribution diffère de la distribution uniforme générée par la <xref:System.Random.Sample%2A> méthode de la classe de base. Ce paramètre remplace le <xref:System.Random.Sample%2A> méthode fournisse la distribution de nombres aléatoires et substitue la <xref:System.Random.Next%2A?displayProperty=nameWithType> méthode à utiliser la série de nombres aléatoires.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>En commençant par le .NET Framework version 2.0, si vous dérivez une classe de <see cref="T:System.Random" /> et remplacer le <see cref="M:System.Random.Sample" /> (méthode), la distribution fournie par l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> méthode n’est pas utilisée dans les appels à la classe de base implémentation de la <see cref="M:System.Random.Next" /> (méthode). Au lieu de cela, la distribution uniforme retournée par la base de <see cref="T:System.Random" /> classe est utilisée. Ce comportement améliore les performances globales de la <see cref="T:System.Random" /> classe. Pour modifier ce comportement pour appeler le <see cref="M:System.Random.Sample" /> méthode dans la classe dérivée, vous devez également substituer la <see cref="M:System.Random.Next" /> (méthode).</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Limite supérieure (exclusive) du nombre aléatoire à générer. La valeur <c>maxValue</c> doit être supérieure ou égale à 0.</param>
        <summary>Retourne un nombre aléatoire entier non négatif, inférieur au nombre maximal spécifié.</summary>
        <returns>Entier signé 32 bits supérieur ou égal à 0 et inférieur à <paramref name="maxValue" />, autrement dit la plage des valeurs de retour inclut généralement 0, mais pas <paramref name="maxValue" />. Toutefois, si <paramref name="maxValue" /> est égal à 0, <paramref name="maxValue" /> est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Random.Next%28System.Int32%29> surcharge retourne entiers aléatoires cette plage de 0 à `maxValue` – 1. Toutefois, si `maxValue` est 0, la méthode retourne 0.  
  
   
  
## Examples  
 L’exemple suivant génère des entiers aléatoires avec différentes surcharges de la <xref:System.Random.Next%2A> (méthode).  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 L’exemple suivant génère un entier aléatoire compris qu’il utilise en tant qu’index pour récupérer une valeur de chaîne à partir d’un tableau. Étant donné que l’index le plus élevé du tableau est une inférieure à sa longueur, la valeur de la <xref:System.Array.Length%2A?displayProperty=nameWithType> propriété est fournie comme un le `maxValue` paramètre.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> est inférieur à 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Limite inférieure (incluse) du nombre aléatoire retourné.</param>
        <param name="maxValue">Limite supérieure (exclusive) du nombre aléatoire retourné. La valeur <c>maxValue</c> doit être supérieure ou égale à la valeur <c>minValue</c>.</param>
        <summary>Retourne un entier aléatoire qui se trouve dans une plage spécifiée.</summary>
        <returns>Entier signé 32 bits supérieur ou égal à <paramref name="minValue" /> et inférieur à <paramref name="maxValue" /> ; autrement dit, la plage des valeurs de retour inclut <paramref name="minValue" /> mais pas <paramref name="maxValue" />. Si <paramref name="minValue" /> est égal à <paramref name="maxValue" />, <paramref name="minValue" /> est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> surcharge retourne entiers aléatoires comprises entre `minValue` à `maxValue` – 1. Toutefois, si `maxValue` est égal à `minValue`, la méthode retourne `minValue`.  
  
 Contrairement à d’autres surcharges de la <xref:System.Random.Next%2A> (méthode), qui retournent des valeurs uniquement non négatives, cette méthode peut retourner un entier aléatoire négatif.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode permettant de générer des entiers aléatoires avec trois plages distinctes. Notez que la sortie exacte de l’exemple dépend de la valeur de départ fourni par le système passée à la <xref:System.Random> constructeur de classe.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 L’exemple suivant génère un entier aléatoire compris qu’il utilise en tant qu’index pour récupérer une valeur de chaîne à partir d’un tableau. Étant donné que l’index le plus élevé du tableau est une inférieure à sa longueur, la valeur de la <xref:System.Array.Length%2A?displayProperty=nameWithType> propriété est fournie comme un le `maxValue` paramètre.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> est supérieur à <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides">
          <para>En commençant par le .NET Framework version 2.0, si vous dérivez une classe de <see cref="T:System.Random" /> et remplacer le <see cref="M:System.Random.Sample" /> (méthode), la distribution fournie par l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> méthode n’est pas utilisée dans les appels à la classe de base implémentation de la <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> surcharge de méthode si la différence entre la <paramref name="minValue" /> et <paramref name="maxValue" /> paramètres est supérieure à <see cref="F:System.Int32.MaxValue" />. Au lieu de cela, la distribution uniforme retournée par la base de <see cref="T:System.Random" /> classe est utilisée. Ce comportement améliore les performances globales de la <see cref="T:System.Random" /> classe. Pour modifier ce comportement pour appeler le <see cref="M:System.Random.Sample" /> méthode dans la classe dérivée, vous devez également substituer la <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> surcharge de méthode.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau d'octets contenant des nombres aléatoires.</param>
        <summary>Remplit les éléments d'un tableau d'octets spécifié à l'aide de nombres aléatoires.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque élément du tableau d’octets est défini sur un nombre aléatoire supérieur ou égal à 0 et inférieur ou égal à <xref:System.Byte.MaxValue>.  
  
 Par exemple, pour générer un nombre aléatoire sécurisé par chiffrement adapté à la création d’un mot de passe aléatoire, utilisez une méthode comme <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Random.NextBytes%2A> méthode pour remplir un tableau d’octets avec des valeurs d’octets aléatoires.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> est <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>En commençant par le .NET Framework version 2.0, si vous dérivez une classe de <see cref="T:System.Random" /> et remplacer le <see cref="M:System.Random.Sample" /> (méthode), la distribution fournie par l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> méthode n’est pas utilisée dans les appels à la classe de base implémentation de la <see cref="M:System.Random.NextBytes(System.Byte[])" /> (méthode). Au lieu de cela, la distribution uniforme retournée par la base de <see cref="T:System.Random" /> classe est utilisée. Ce comportement améliore les performances globales de la <see cref="T:System.Random" /> classe. Pour modifier ce comportement pour appeler le <see cref="M:System.Random.Sample" /> méthode dans la classe dérivée, vous devez également substituer la <see cref="M:System.Random.NextBytes(System.Byte[])" /> (méthode).</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un nombre aléatoire à virgule flottante supérieur ou égal à 0,0 et inférieur à 1,0.</summary>
        <returns>Nombre à virgule flottante double précision supérieur ou égal à 0,0 et inférieur à 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La limite supérieure réelle du nombre aléatoire retourné par cette méthode est 0.99999999999999978.  
  
 Pour récupérer des valeurs à virgule flottante aléatoire dans une plage autre que 0,0 et 1,0, consultez la section « Extraire des valeurs à virgule flottante dans une plage spécifiée » de la <xref:System.Random> rubrique de la classe.  
  
 Cette méthode est la version publique de la méthode protégée, <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Random.NextDouble%2A> méthode permettant de générer des séquences de type Double aléatoires.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 L’exemple suivant appelle la <xref:System.Random.NextDouble%2A> méthode permettant de générer aléatoire de 100 nombres et affiche leur distribution en fréquence.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un nombre aléatoire à virgule flottante compris entre 0,0 et 1,0.</summary>
        <returns>Nombre à virgule flottante double précision supérieur ou égal à 0,0 et inférieur à 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour produire une distribution aléatoire différente ou un principe de générateur de nombres aléatoires différent, dérivez une classe de la <xref:System.Random> classe et substituer les <xref:System.Random.Sample%2A> (méthode).  
  
> [!IMPORTANT]
>  Le <xref:System.Random.Sample%2A> méthode est `protected`, ce qui signifie qu’il est accessible uniquement dans la <xref:System.Random> classe et ses classes dérivées. Pour générer un nombre aléatoire compris entre 0 et 1 à partir d’un <xref:System.Random> d’une instance, appelez le <xref:System.Random.NextDouble%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant dérive une classe de <xref:System.Random> et remplace le <xref:System.Random.Sample%2A> méthode permettant de générer une distribution de nombres aléatoires. Cette distribution est différente de la distribution uniforme générée par la <xref:System.Random.Sample%2A> méthode de la classe de base.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>En commençant par le .NET Framework version 2.0, si vous dérivez une classe de <see cref="T:System.Random" /> et remplacer le <see cref="M:System.Random.Sample" /> (méthode), la distribution fournie par l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> méthode n’est pas utilisée dans les appels à la classe de base implémentation des méthodes suivantes : - le <see cref="M:System.Random.NextBytes(System.Byte[])" /> (méthode).  -Le <see cref="M:System.Random.Next" /> (méthode).  -Le <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> (méthode), si (<paramref name="maxValue" /> - <paramref name="minValue" />) est supérieur à <see cref="F:System.Int32.MaxValue" />.  Au lieu de cela, la distribution uniforme fournie par la base de <see cref="T:System.Random" /> classe est utilisée. Ce comportement améliore les performances globales de la <see cref="T:System.Random" /> classe. Pour modifier ce comportement pour appeler l’implémentation de la <see cref="M:System.Random.Sample" /> méthode dans la classe dérivée, vous devez également substituer le comportement de ces trois membres. L’exemple fournit une illustration.</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>