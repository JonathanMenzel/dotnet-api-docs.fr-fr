<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="db0be843724a3e5db9bde798d384dd7ecf5a6c0f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429192" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un générateur de nombres pseudo-aléatoires. Il s’agit d’un périphérique qui produit une séquence de nombres conformes à certaines exigences statistiques liées à l’aspect aléatoire.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nombres pseudo-aléatoires sont choisies avec une probabilité égale à partir d’un jeu de nombres fini. Les nombres choisis ne sont pas complètement aléatoires, car un algorithme mathématique est utilisé pour les sélectionner, mais elles sont suffisamment aléatoires pour des raisons pratiques. L’implémentation actuelle de la <xref:System.Random> classe est basée sur une version modifiée de soustraction de nombres générateur aléatoires de Knuth. Pour plus d’informations, consultez D. e Knuth. *L’Art de la programmation et Volume 2 : algorithmes Seminumerical*. Addison-Wesley, Reading, MA, troisième édition, 1997.  
  
 Pour générer un nombre aléatoire sécurisé par chiffrement, tel que celui qui convient pour la création d’un mot de passe aléatoire, utilisez la <xref:System.Security.Cryptography.RNGCryptoServiceProvider> classe ou dériver une classe de <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 Dans cette rubrique :  
  
 [L’instanciation du Générateur de nombres aléatoires](#Instantiate)   
 [Éviter plusieurs instanciations](#Multiple)   
 [La sécurité de classe et de thread System.Random](#ThreadSafety)   
 [Génération de différents types de nombres aléatoires](#Functionality)   
 [En remplaçant votre propre algorithme](#Overriding)   
 [Comment utilisez-vous System.Random à...](#Operations)   
 [Récupérer la même séquence de valeurs aléatoires](#Same)  
 [Récupérer des séquences uniques de valeurs aléatoires](#Unique)  
 [Récupérer des nombres entiers dans une plage spécifiée](#Range)  
 [Récupérer des entiers avec un nombre spécifié de chiffres](#Digits)  
 [Récupérer des valeurs à virgule flottante dans une plage spécifiée](#Floats)  
 [Générer des valeurs booléennes aléatoires](#Boolean)  
 [Générer des entiers aléatoires 64 bits](#Long)  
 [Récupérer des octets dans une plage spécifiée](#Bytes)  
 [Récupérer un élément d’un tableau ou une collection de manière aléatoire](#Array)  
 [Récupérer un élément unique d’un tableau ou d’une collection](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>L’instanciation du Générateur de nombres aléatoires  
 Vous instanciez le Générateur de nombres aléatoires en fournissant une valeur de départ (valeur de départ de l’algorithme de génération de nombres pseudo-aléatoires) à un <xref:System.Random.%23ctor%2A> constructeur de classe.  Vous pouvez fournir la valeur de départ explicitement ou implicitement :  
  
-   Le <xref:System.Random.%23ctor%28System.Int32%29> constructeur utilise une valeur de départ explicite que vous fournissez.  
  
-   Le <xref:System.Random.%23ctor> constructeur utilise l’horloge système pour fournir une valeur de départ. Il s’agit de la méthode la plus courante de l’instanciation du Générateur de nombres aléatoires.  
  
 Si la même valeur de départ est utilisée pour différentes <xref:System.Random> des objets, ils génèrent la même série de nombres aléatoires. Cela peut être utile pour la création d’une suite de tests qui traite les valeurs aléatoires, ou pour relire les jeux qui dérivent leurs données de nombres aléatoires. Toutefois, notez que <xref:System.Random> objets de processus qui s’exécutent sous différentes versions du .NET Framework peuvent retourner différentes séries de nombres aléatoires même s’ils sont instanciés avec les mêmes valeurs initiales.  
  
 Pour produire différentes séquences de nombres aléatoires, vous pouvez rendre la valeur initiale dépendant du temps, ainsi produisant une autre série avec chaque nouvelle instance de <xref:System.Random>. Paramétré <xref:System.Random.%23ctor%28System.Int32%29> constructeur peut prendre un <xref:System.Int32> valeur en fonction du nombre de graduations dans l’heure actuelle, tandis que sans paramètre <xref:System.Random.%23ctor> constructeur utilise l’horloge système pour générer sa valeur initiale. Toutefois, étant donné que l’horloge a la résolution finie, l’utilisation du constructeur sans paramètre pour créer différents <xref:System.Random> objets successivement crée des générateurs de nombres aléatoires qui produisent des séquences identiques de nombres aléatoires. L’exemple suivant illustre comment deux <xref:System.Random> objets sont instanciés successivement génèrent une série identique de nombres aléatoires. La plupart des systèmes Windows, <xref:System.Random> les objets créés dans les 15 millisecondes d’un autre sont susceptibles d’avoir les mêmes valeurs initiales.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Pour éviter ce problème, créez un seul <xref:System.Random> objet au lieu de plusieurs objets.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Éviter plusieurs instanciations  
 L’initialisation de deux générateurs de nombres aléatoires dans une boucle serrée ou de suite crée deux générateurs de nombres aléatoires qui peuvent produire des séquences identiques de nombres aléatoires. Dans la plupart des cas, cette intention de développeur n’est pas et peut entraîner des problèmes de performances, car l’instanciation et initialisation d’un générateur de nombres aléatoires sont un processus relativement coûteux.  
  
 À la fois pour améliorer les performances et pour éviter de créer par inadvertance des générateurs de nombres aléatoires distincts qui génèrent des séquences numériques identiques, nous vous recommandons de créer un <xref:System.Random> objet pour générer des nombres aléatoires au fil du temps, au lieu de créer nouvelle <xref:System.Random> objets pour générer un nombre aléatoire.  
  
 Toutefois, la <xref:System.Random> classe n’est pas thread-safe. Si vous appelez <xref:System.Random> méthodes à partir de plusieurs threads, suivez les instructions figurant dans la section suivante.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>La sécurité de classe et de thread System.Random  
 Au lieu de l’instanciation de l’individu <xref:System.Random> des objets, nous vous recommandons de créer un seul <xref:System.Random> instance à générer tous les nombres aléatoires requises par votre application. Toutefois, <xref:System.Random> objets ne sont pas thread-safe. Si votre application appelle <xref:System.Random> méthodes à partir de plusieurs threads, vous devez utiliser un objet de synchronisation pour vous assurer que qu’un seul thread peut accéder au Générateur de nombres aléatoires à la fois. Si vous ne vous assurer que le <xref:System.Random> objet est accessible de manière thread-safe, les appels aux méthodes qui retournent des nombres aléatoires retournent 0.  
  
 L’exemple suivant utilise le langage c# [lock, instruction](~/docs/csharp/language-reference/keywords/lock-statement.md) et Visual Basic [SyncLock, instruction](~/docs/visual-basic/language-reference/statements/synclock-statement.md) pour vous assurer qu’un générateur de nombres aléatoires unique est accessible par les 11 threads de manière thread-safe. Chaque thread génère des nombres aléatoires de 2 millions, compte le nombre de nombres aléatoires et calcule leur somme, puis met à jour les totaux de tous les threads en fin d’exécution.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 L’exemple vérifie la sécurité des threads de plusieurs manières :  
  
-   Le <xref:System.ThreadStaticAttribute> attribut est utilisé pour définir des variables locales de thread qui effectuent le suivi du nombre total de nombres aléatoires et leur somme pour chaque thread.  
  
-   Un verrou (le `lock` instruction en c# et la `SyncLock` instruction en Visual Basic) protège l’accès aux variables pour le nombre total et la somme de tous les nombres aléatoires sur tous les threads.  
  
-   Un sémaphore (le <xref:System.Threading.CountdownEvent> objet) permet de s’assurer que le thread principal se bloque jusqu'à ce que tous les autres threads terminent.  
  
-   L’exemple vérifie si le Générateur de nombres aléatoires est endommagé en déterminant si les deux appels consécutifs à des méthodes de génération de nombres aléatoires retournent 0. Si l’altération est détectée, l’exemple utilise le <xref:System.Threading.CancellationTokenSource> objet pour signaler que tous les threads doivent être annulées.  
  
-   Avant de générer chaque nombre aléatoire, chaque thread vérifie l’état de la <xref:System.Threading.CancellationToken> objet. Si l’annulation est demandée, l’exemple appelle la <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> méthode pour annuler le thread.  
  
 L’exemple suivant est identique à la première, sauf qu’elle utilise un <xref:System.Threading.Tasks.Task> objet et une expression lambda à la place de <xref:System.Threading.Thread> objets.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Il diffère du premier exemple de plusieurs manières :  
  
-   Les variables pour suivre le nombre de nombres aléatoires et leur somme dans chaque tâche sont locales à la tâche, il est donc inutile d’utiliser le <xref:System.ThreadStaticAttribute> attribut.  
  
-   La méthode statique <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> méthode est utilisée pour vous assurer que le thread principal ne se termine avant que toutes les tâches soient terminées. Il est inutile du <xref:System.Threading.CountdownEvent> objet.  
  
-   L’exception qui résulte de l’annulation de tâches est visible dans le <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> (méthode). Dans l’exemple précédent, elle est gérée par chaque thread.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Génération de différents types de nombres aléatoires  
 Le Générateur de nombres aléatoires fournit des méthodes qui vous permettent de générer les types suivants de nombres aléatoires :  
  
-   Une série de <xref:System.Byte> valeurs. Vous déterminez le nombre de valeurs d’octets en passant un tableau initialisé selon le nombre d’éléments que vous souhaitez que la méthode pour retourner à la <xref:System.Random.NextBytes%2A> (méthode). L’exemple suivant génère 20 octets.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Un entier unique. Vous pouvez choisir si vous souhaitez un entier compris entre 0 et une valeur maximale (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) en appelant le <xref:System.Random.Next> (méthode), un entier compris entre 0 et une valeur spécifique en appelant le <xref:System.Random.Next%28System.Int32%29> (méthode), ou un entier compris dans une plage de valeurs en appelant le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>(méthode). Dans les surcharges paramétrables, la valeur maximale spécifiée est exclusive ; Autrement dit, le nombre maximal généré est un inférieur à la valeur spécifiée.  
  
     L’exemple suivant appelle la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> méthode permettant de générer des nombres aléatoires compris entre -10 et 10 10. Notez que le deuxième argument à la méthode spécifie la limite supérieure exclusive de la plage de valeurs aléatoires retourné par la méthode. En d’autres termes, le plus grand entier que la méthode peut retourner une est inférieure à cette valeur.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Une valeur unique à virgule flottante comprise entre 0,0 et inférieur à 1,0 en appelant le <xref:System.Random.NextDouble%2A> (méthode). La limite supérieure exclusive du nombre aléatoire retourné par la méthode est 1, par conséquent, sa limite supérieure réelle est 0.99999999999999978. L’exemple suivant génère des nombres à virgule flottante aléatoires 10.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  Le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> méthode vous permet de spécifier la plage de nombres aléatoires retourné. Toutefois, le `maxValue` paramètre, qui spécifie la plage supérieure retournées numérique, est exclusif, pas un inclus, valeur. Cela signifie que l’appel de méthode `Next(0, 100)` retourne une valeur comprise entre 0 et 99 et non entre 0 et 100.  
  
 Vous pouvez également utiliser le <xref:System.Random> classe pour des tâches telles que la génération de [des valeurs aléatoires t : System.Boolean](#Boolean), génération [à virgule flottante aléatoire des valeurs avec une plage de 0 à 1](#Floats), génération [entiers 64 bits aléatoires](#Long), et [récupération aléatoirement d’un élément unique à partir d’un tableau ou une collection](#UniqueArray). Pour celles-ci et d’autres tâches courantes, consultez le [utilisation System.Random à...](#Operations) section.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>En remplaçant votre propre algorithme  
 Vous pouvez implémenter votre propre générateur de nombres aléatoires en héritant de la <xref:System.Random> classe et en fournissant votre algorithme de génération de nombres aléatoires. Pour fournir votre propre algorithme, vous devez substituer la <xref:System.Random.Sample%2A> (méthode), qui implémente l’algorithme de génération de nombres aléatoires. Vous devez également substituer la <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, et <xref:System.Random.NextBytes%2A> méthodes pour vous assurer qu’ils appellent votre substituée <xref:System.Random.Sample%2A> (méthode). Vous n’êtes pas obligé de remplacer le <xref:System.Random.Next%28System.Int32%29> et <xref:System.Random.NextDouble%2A> méthodes.  
  
 Pour obtenir un exemple qui dérive de la <xref:System.Random> classe et modifie son générateur de nombres pseudo-aléatoires par défaut, consultez le <xref:System.Random.Sample%2A> page de référence.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Comment utilisez-vous System.Random à...  
 Les sections suivantes décrivent et fournissent des exemples de code pour les méthodes que vous souhaiterez peut-être utiliser des nombres aléatoires dans votre application.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Récupérer la même séquence de valeurs aléatoires  
 Parfois, vous souhaitez générer la même séquence de nombres aléatoires dans les scénarios de test de logiciel et dans le jeu. Test avec la même séquence de nombres aléatoires permet de vous permet de détecter les régressions et confirmer les correctifs de bogues. À l’aide de la même séquence de nombre aléatoire dans les jeux permet de relire les jeux précédentes.  
  
 Vous pouvez générer la même séquence de nombres aléatoires grâce à la même valeur de départ pour le <xref:System.Random.%23ctor%28System.Int32%29> constructeur. La valeur de départ fournit une valeur de départ pour l’algorithme de génération de nombres pseudo-aléatoires. L’exemple suivant utilise 100100 comme une valeur de départ arbitraire pour instancier le <xref:System.Random> objet affiche 20 valeurs à virgule flottante aléatoires et persiste la valeur de départ. Elle restaure la valeur de départ, instancie un nouveau générateur de nombres aléatoires et affiche les mêmes 20 valeurs à virgule flottante aléatoires.  Notez que l’exemple peut produire plusieurs séquences de nombres aléatoires de s’exécuter sur différentes versions du .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Récupérer des séquences uniques de nombres aléatoires  
 En fournissant des valeurs initiales différentes aux instances de la <xref:System.Random> classe entraîne chaque générateur de nombres aléatoires produire une autre séquence de valeurs. Vous pouvez fournir une valeur de départ explicitement en appelant le <xref:System.Random.%23ctor%28System.Int32%29> constructeur, ou implicitement en appelant le <xref:System.Random.%23ctor> constructeur. La plupart des développeurs appeler le constructeur sans paramètre, qui utilise l’horloge système. L’exemple suivant utilise cette approche pour instancier deux <xref:System.Random> instances. Chaque instance affiche une série de 10 entiers aléatoires.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Toutefois, en raison de sa résolution finie, l’horloge système ne détecte pas les différences de temps inférieure à environ 15 millisecondes. Par conséquent, si votre code appelle la <xref:System.Random.%23ctor> surcharge pour instancier deux <xref:System.Random> objets à la suite, vous susceptibles par inadvertance de fournir les objets avec les mêmes valeurs initiales. Pour le voir dans l’exemple précédent, commentez le <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> appel de méthode et de compilation et d’exécuter à nouveau l’exemple.  
  
 Pour éviter cela, nous vous recommandons d’instancier une seule <xref:System.Random> de l’objet au lieu de plusieurs. Toutefois, étant donné que <xref:System.Random> n’est pas thread-safe, vous devez utiliser un périphérique de synchronisation si vous accédez à un <xref:System.Random> une instance à partir de plusieurs threads ; pour plus d’informations, consultez [aléatoire de la sécurité de classe et de thread](#ThreadSafety) plus haut dans cette rubrique. Ou bien, vous pouvez utiliser un mécanisme de délai, telles que la <xref:System.Threading.Thread.Sleep%2A> méthode utilisée dans l’exemple précédent, afin d’éviter les instanciations éloignés de plus de 15 millisecondes.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Récupérer des nombres entiers dans une plage spécifiée  
 Vous pouvez récupérer des nombres entiers dans une plage spécifiée en appelant le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> (méthode), ce qui vous permet de spécifier la limite inférieure et la limite supérieure des nombres que vous souhaitez que le Générateur de nombres aléatoires à retourner. La limite supérieure est exclusif, pas un inclus, valeur. Autrement dit, il n’est pas inclus dans la plage de valeurs retournées par la méthode. L’exemple suivant utilise cette méthode pour générer des entiers aléatoires compris entre -10 et 10. Notez qu’il spécifie 11, qui est supérieure à la valeur souhaitée, en tant que la valeur de la `maxValue` argument dans l’appel de méthode.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Récupérer des entiers avec un nombre spécifié de chiffres  
 Vous pouvez appeler la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> méthode pour récupérer des nombres avec un nombre de chiffres spécifié. Par exemple, pour récupérer les nombres avec quatre chiffres (autrement dit, les nombres allant de 1000 à 9999), vous appelez le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> méthode avec un `minValue` valeur de 1000 et un `maxValue` valeur de 10 000, comme le montre l’exemple suivant.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Récupérer des valeurs à virgule flottante dans une plage spécifiée  
 Le <xref:System.Random.NextDouble%2A> méthode retourne les valeurs à virgule flottante aléatoires de cette plage entre 0 et inférieur à 1. Toutefois, vous souhaiterez souvent générer des valeurs aléatoires dans une autre plage.  
  
 Si l’intervalle entre les valeurs souhaitées minimales et maximales est 1, vous pouvez ajouter la différence entre l’intervalle de départ souhaitée et la valeur 0 au nombre retourné par le <xref:System.Random.NextDouble%2A> (méthode). L’exemple suivant procède ainsi pour générer des nombres aléatoires 10 entre -1 et 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Pour générer des nombres à virgule flottante aléatoires dont la limite inférieure est 0, mais limite supérieure est supérieure à 1 (ou, dans le cas des nombres négatifs, dont la limite inférieure est inférieure à -1 et limite supérieure est égale à 0), multipliez le nombre aléatoire par la limite différente de zéro. L’exemple suivant fait cela pour générer des nombres à virgule flottante aléatoires de 20 millions de cette plage de 0 à <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Dans affiche également la distribution des valeurs aléatoires générées par la méthode.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Pour générer des nombres à virgule flottante aléatoires comprise entre deux valeurs arbitraires, comme le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> méthode fait pour les entiers, utilisez la formule suivante :  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 L’exemple suivant génère des nombres aléatoires de 1 million qui vont à partir de 10.0 pour 11.0 et affiche leur distribution.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Générer des valeurs booléennes aléatoires  
 Le <xref:System.Random> classe ne fournit des méthodes qui génèrent <xref:System.Boolean> valeurs. Toutefois, vous pouvez définir votre propre classe ou une méthode pour ce faire. L’exemple suivant définit une classe, `BooleanGenerator`, avec une méthode unique, `NextBoolean`. Le `BooleanGenerator` classe stocke un <xref:System.Random> objet comme une variable privée. Le `NextBoolean` les appels de méthode le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> (méthode) et passe le résultat à la <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> (méthode). Notez que 2 est utilisée comme argument pour spécifier la limite supérieure du nombre aléatoire. Dans la mesure où il s’agit d’une valeur exclusive, l’appel de méthode retourne 0 ou 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Au lieu de créer une classe distincte pour générer aléatoire <xref:System.Boolean> valeurs, l’exemple peut simplement ont défini une seule méthode. Dans ce cas, toutefois, le <xref:System.Random> objet doit avoir été défini en tant que variable de niveau classe pour éviter l’instanciation d’un nouvel <xref:System.Random> instance dans chaque appel de méthode. En Visual Basic, l’instance aléatoire peut être défini comme un [statique](~/docs/visual-basic/language-reference/modifiers/static.md) variable dans le `NextBoolean` (méthode).  L’exemple suivant fournit une implémentation.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Générer des entiers aléatoires 64 bits  
 Les surcharges de la <xref:System.Random.Next%2A> méthode retournent des entiers 32 bits. Toutefois, dans certains cas, vous souhaiterez travailler avec des entiers de 64 bits. Vous pouvez procéder comme suit :  
  
1.  Appelez le <xref:System.Random.NextDouble%2A> valeur du point de méthode pour récupérer un flottante double précision.  
  
2.  Multiplier cette valeur <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 L’exemple suivant utilise cette technique pour générer des entiers aléatoires long de 20 millions et les classe dans 10 groupes égaux. Elle évalue ensuite la distribution des nombres aléatoires en comptant le nombre de chaque groupe de 0 à <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Comme le montre la sortie de l’exemple, les nombres sont réparties plus ou moins dans la plage d’un entier long.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Une autre technique qu’utilise une manipulation de bits ne génère pas des nombres véritablement aléatoires. Cette technique appelle <xref:System.Random.Next> pour générer deux entiers, décale vers la gauche un par 32 bits et ORs ensemble. Cette technique présente deux limitations :  
  
1.  Étant donné que le bit 31 est le bit de signe, la valeur de bit 31 de l’entier long résultant est toujours 0.  Ce peut être résolu en générant aléatoire égal à 0 ou 1, le décalage à gauche de 31 bits et réunion à l’entier long aléatoire d’origine.  
  
2.  Plus sérieusement, car la probabilité que la valeur retournée par <xref:System.Random.Next> est égal à 0, il y a quelques si les nombres aléatoires dans la plage 0 x 0-0x00000000FFFFFFFF.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Récupérer des octets dans une plage spécifiée  
 Les surcharges de la <xref:System.Random.Next%2A> méthode permettent de spécifier la plage de nombres aléatoires, mais la <xref:System.Random.NextBytes%2A> n’est pas le cas de méthode. L’exemple suivant implémente un `NextBytes` méthode qui vous permet de spécifier la plage d’octets retournés. Il définit un `Random2` classe qui dérive de <xref:System.Random> et les surcharges de sa `NextBytes` (méthode).  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 Le `NextBytes(Byte[], Byte, Byte)` méthode encapsule un appel à la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> (méthode) et spécifie la valeur minimale et une supérieure à la valeur maximale (dans ce cas, 0 et 101) que nous voulons retournés dans le tableau d’octets. Étant donné que nous assurer que les valeurs entières retournées par la <xref:System.Random.Next%2A> méthode sont dans la plage de la <xref:System.Byte> type de données, nous pouvons en toute sécurité les casté (en c#) ou convertir (en Visual Basic) à partir d’entiers en octets.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Récupérer un élément d’un tableau ou une collection de manière aléatoire  
 Nombres aléatoires servent souvent d’index pour récupérer les valeurs à partir des tableaux ou collections. Pour récupérer une valeur d’index aléatoires, vous pouvez appeler la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> méthode et l’utilisation de la limite inférieure du tableau en tant que la valeur de sa `minValue` argument et supérieure à la limite supérieure du tableau en tant que la valeur de son `maxValue` argument. Pour un tableau de base zéro, cela est équivalent à sa <xref:System.Array.Length%2A> propriété, ou supérieure à la valeur retournée par le <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> (méthode). L’exemple suivant récupère aléatoirement le nom d’une ville aux États-Unis à partir d’un tableau de villes.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Récupérer un élément unique d’un tableau ou d’une collection  
 Un générateur de nombres aléatoires permettre toujours retourner des valeurs en double. Lorsque la plage de numéros devient plus petite ou le nombre de valeurs générées devient plus grand, la probabilité de doublons se développe. Si des valeurs aléatoires doivent être uniques, des numéros sont générés pour compenser les doublons, ce qui entraîne des performances médiocres de plus en plus.  
  
 Il existe un certain nombre de techniques pour gérer ce scénario. Une solution courante consiste à créer un tableau ou collection qui contient les valeurs à récupérer et un tableau parallèle qui contient les nombres à virgule flottante aléatoires. Le deuxième tableau est rempli avec des nombres aléatoires au moment le premier tableau est créé, et le <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> méthode est utilisée pour trier le premier tableau en utilisant les valeurs dans le tableau en parallèle.  
  
 Par exemple, si vous développez un jeu de Solitaire, vous souhaitez vous assurer que chaque carte est utilisée qu’une seule fois. Au lieu de générer des nombres aléatoires pour récupérer une carte et suivi si cette carte a déjà été traitée, vous pouvez créer un tableau parallèle de nombres aléatoires qui peuvent être utilisés pour trier le pont. Une fois que le pont est trié, votre application peut gérer un pointeur pour indiquer l’index de la carte suivante sur le pont.  
  
 L'exemple suivant illustre cette approche. Il définit un `Card` classe qui représente une carte à jouer et un `Dealer` classe qui traite un jeu de cartes mélangés. Le `Dealer` constructeur de classe remplit deux tableaux : un `deck` tableau qui a une portée de classe et qui représente toutes les cartes dans le pont et un local `order` tableau qui a le même nombre d’éléments que le `deck` de tableau et est rempli avec généré de façon aléatoire <xref:System.Double> valeurs.  Le <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> méthode est alors appelée pour trier les `deck` tableau basé sur les valeurs dans le `order` tableau.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 L’exemple suivant crée un générateur de nombres aléatoires unique et appelle son <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, et <xref:System.Random.NextDouble%2A> pour générer des séquences de nombres aléatoires dans des plages différentes méthodes.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 L’exemple suivant génère un entier aléatoire qu’il utilise en tant qu’index pour récupérer une valeur de chaîne d’un tableau.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Dans le .NET Framework 1.0 et 1.1, une implémentation minimale d’une classe dérivée de <see cref="T:System.Random" /> requis la substitution de la <see cref="M:System.Random.Sample" /> méthode pour définir un algorithme de nouvel ou modifié pour la génération de nombres aléatoires. La classe dérivée pouvait alors reposer sur l’implémentation de classe de base de la <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, et <see cref="M:System.Random.NextDouble" /> méthodes à appeler l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> (méthode).  Dans le .NET Framework 2.0 et versions ultérieur, le comportement de la <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, et <see cref="M:System.Random.NextBytes(System.Byte[])" /> méthodes ont été modifiés afin que ces méthodes n’appellent pas nécessairement l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> (méthode). Par conséquent, les classes dérivées de <see cref="T:System.Random" /> qui ciblent le .NET Framework 2.0 et version ultérieure doit également substituer ces trois méthodes.</para>
    </block>
    <block subset="none" type="usage">
      <para>L’implémentation du Générateur de nombres aléatoires dans le <see cref="T:System.Random" /> classe restent les mêmes sur les versions principales du .NET Framework n’est pas garanti. Par conséquent, vous ne doit pas supposer que la même valeur de départ entraîne la même séquence pseudo-aléatoire dans les différentes versions du .NET Framework.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Random" />, à l'aide d'une valeur initiale par défaut qui est fonction du temps.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de départ par défaut est dérivée de l’horloge système et a la résolution finie. Par conséquent, différents <xref:System.Random> les objets qui sont créés successivement par un appel au constructeur par défaut ont des valeurs initiales par défaut identiques et, par conséquent, produira des ensembles identiques de nombres aléatoires. Ce problème peut être évité en utilisant un seul <xref:System.Random> objet pour générer tous les nombres aléatoires. Vous pouvez également contourner en modifiant la valeur de départ retournée par l’horloge système, puis en fournissant explicitement cette nouvelle valeur de départ pour le <xref:System.Random.%23ctor%28System.Int32%29> constructeur. Pour plus d’informations, consultez le <xref:System.Random.%23ctor%28System.Int32%29> constructeur.  
  
 Appeler ce constructeur si vous souhaitez que le Générateur de nombres aléatoires pour générer une séquence aléatoire de nombres. Pour générer une séquence fixe de nombres aléatoires qui seront identiques pour différents générateurs de nombres aléatoires, appelez le <xref:System.Random.%23ctor%28System.Int32%29> constructeur avec une valeur de départ fixe. Cela <xref:System.Random> surcharge de constructeur est fréquemment utilisée lorsque vous testez les applications qui utilisent des nombres aléatoires.  
  
 Une fois que vous avez instancié le Générateur de nombres aléatoires, vous appelez individuels <xref:System.Random> méthodes, telles que <xref:System.Random.Next> ou <xref:System.Random.NextDouble>, afin de générer des nombres aléatoires.  
  
   
  
## Examples  
 L’exemple suivant utilise le constructeur par défaut pour instancier trois <xref:System.Random> objets et affiche une séquence de cinq entiers aléatoires pour chacun. Étant donné que les deux premières <xref:System.Random> objets sont créés successivement, ils sont instanciés à l’aide des mêmes valeurs initiales basées sur l’horloge système et, par conséquent, ils produisent une séquence identique de nombres aléatoires. En revanche, le constructeur par défaut du troisième <xref:System.Random> objet est appelé après un délai de deux secondes généré en appelant le <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> (méthode). Étant donné que cela génère une valeur initiale différente pour la troisième <xref:System.Random> de l’objet, il génère une séquence différente de nombres aléatoires.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Nombre utilisé pour calculer la valeur de départ de la séquence de nombres pseudo-aléatoires. Si un nombre négatif est spécifié, la valeur absolue du nombre est utilisée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Random" /> à l'aide de la valeur initiale spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En fournissant une valeur de départ identiques pour différents <xref:System.Random> objets provoque chaque instance produire des séquences identiques de nombres aléatoires. Cela se produit souvent lorsque vous testez des applications qui s’appuient sur les générateurs de nombres aléatoires.  
  
 Si votre application nécessite différentes séquences de nombres aléatoires, appeler ce constructeur à plusieurs reprises avec différentes valeurs initiales. Pour produire une valeur de départ unique est dépendant du temps. Par exemple, dériver la valeur de départ de l’horloge système, comme le <xref:System.Random.%23ctor> surcharge est. Toutefois, l’horloge système peut-être pas une résolution suffisante pour fournir différents appels de ce constructeur avec une valeur initiale différente. Cela entraîne des générateurs de nombres aléatoires qui génèrent des séquences identiques de nombres pseudo-aléatoires, comme illustré dans les deux premières <xref:System.Random> objets dans l’exemple suivant. Pour éviter ce problème, appliquez un algorithme pour différencier la valeur de départ dans chaque appel ou appelez le <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> pour s’assurer que vous fournissez chaque constructeur avec une valeur initiale différente.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Une autre option consiste à instancier une seule <xref:System.Random> de l’objet que vous utilisez pour générer tous les nombres aléatoires dans votre application. Il en résulte légèrement meilleures performances, étant donné que l’instanciation d’un générateur de nombres aléatoires est relativement coûteuse.  
  
   
  
## Examples  
 L’exemple suivant crée <xref:System.Random> objets avec le constructeur de classe qui prend un paramètre initial et génère une séquence de valeurs de type double et d’entiers aléatoires. L’exemple montre que la même séquence est générée lorsque le <xref:System.Random> objet est créé à nouveau avec le paramètre de constructeur et la valeur initiale.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un nombre aléatoire entier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un nombre aléatoire entier non négatif.</summary>
        <returns>Entier signé 32 bits supérieur ou égal à 0 et inférieur à <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> génère un nombre aléatoire dont la valeur est comprise entre 0 et inférieur à <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Pour générer un nombre aléatoire dont la valeur varie de 0 à un autre nombre positif, utilisez la <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> surcharge de méthode. Pour générer un nombre aléatoire dans une plage différente, utilisez la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple suivant passe des appels répétés à la <xref:System.Random.Next%2A> méthode pour générer un nombre spécifique de nombres aléatoires demandées par l’utilisateur. Le <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> méthode est utilisée pour obtenir des commentaires des clients.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 L’exemple suivant dérive une classe de <xref:System.Random> pour générer une séquence de nombres aléatoires dont la distribution diffère de la distribution uniforme générée par la <xref:System.Random.Sample%2A> méthode de la classe de base. Il remplace le <xref:System.Random.Sample%2A> méthode pour fournir la distribution de nombres aléatoires et substitue le <xref:System.Random.Next%2A?displayProperty=nameWithType> méthode à utiliser la série de nombres aléatoires.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>En commençant avec le .NET Framework version 2.0, si vous dérivez une classe de <see cref="T:System.Random" /> et remplacez le <see cref="M:System.Random.Sample" /> (méthode), la distribution fournie par l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> méthode n’est pas utilisée dans les appels à la classe de base implémentation de la <see cref="M:System.Random.Next" /> (méthode). Au lieu de cela, la distribution uniforme retournée par la base de <see cref="T:System.Random" /> classe est utilisée. Ce comportement permet d’améliorer les performances globales de la <see cref="T:System.Random" /> classe. Pour modifier ce comportement pour appeler le <see cref="M:System.Random.Sample" /> méthode dans la classe dérivée, vous devez également substituer la <see cref="M:System.Random.Next" /> (méthode).</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Limite supérieure (exclusive) du nombre aléatoire à générer. La valeur <c>maxValue</c> doit être supérieure ou égale à 0.</param>
        <summary>Retourne un nombre aléatoire entier non négatif, inférieur au nombre maximal spécifié.</summary>
        <returns>Entier signé 32 bits supérieur ou égal à 0 et inférieur à <paramref name="maxValue" />, autrement dit la plage des valeurs de retour inclut généralement 0, mais pas <paramref name="maxValue" />. Toutefois, si <paramref name="maxValue" /> est égal à 0, <paramref name="maxValue" /> est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Random.Next%28System.Int32%29> surcharge retourne des entiers aléatoires de cette plage de 0 à `maxValue` – 1. Toutefois, si `maxValue` est 0, la méthode retourne 0.  
  
   
  
## Examples  
 L’exemple suivant génère des entiers aléatoires avec différentes surcharges de la <xref:System.Random.Next%2A> (méthode).  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 L’exemple suivant génère un entier aléatoire qu’il utilise en tant qu’index pour récupérer une valeur de chaîne d’un tableau. Étant donné que l’index le plus élevé du tableau est une inférieure à sa longueur, la valeur de la <xref:System.Array.Length%2A?displayProperty=nameWithType> propriété est fournie comme un le `maxValue` paramètre.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> est inférieur à 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Limite inférieure (incluse) du nombre aléatoire retourné.</param>
        <param name="maxValue">Limite supérieure (exclusive) du nombre aléatoire retourné. La valeur <c>maxValue</c> doit être supérieure ou égale à la valeur <c>minValue</c>.</param>
        <summary>Retourne un entier aléatoire qui se trouve dans une plage spécifiée.</summary>
        <returns>Entier signé 32 bits supérieur ou égal à <paramref name="minValue" /> et inférieur à <paramref name="maxValue" /> ; autrement dit, la plage des valeurs de retour inclut <paramref name="minValue" /> mais pas <paramref name="maxValue" />. Si <paramref name="minValue" /> est égal à <paramref name="maxValue" />, <paramref name="minValue" /> est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> surcharge retourne des entiers aléatoires comprises entre `minValue` à `maxValue` – 1. Toutefois, si `maxValue` est égal à `minValue`, la méthode retourne `minValue`.  
  
 Contrairement à d’autres surcharges de la <xref:System.Random.Next%2A> (méthode), qui retournent des valeurs uniquement non négatives, cette méthode peut retourner un entier aléatoire négatif.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour générer des entiers aléatoires avec trois plages distinctes. Notez que la sortie exacte de l’exemple dépend de la valeur de départ de système passée à la <xref:System.Random> constructeur de classe.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 L’exemple suivant génère un entier aléatoire qu’il utilise en tant qu’index pour récupérer une valeur de chaîne d’un tableau. Étant donné que l’index le plus élevé du tableau est une inférieure à sa longueur, la valeur de la <xref:System.Array.Length%2A?displayProperty=nameWithType> propriété est fournie comme un le `maxValue` paramètre.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> est supérieur à <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides">
          <para>En commençant avec le .NET Framework version 2.0, si vous dérivez une classe de <see cref="T:System.Random" /> et remplacez le <see cref="M:System.Random.Sample" /> (méthode), la distribution fournie par l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> méthode n’est pas utilisée dans les appels à la classe de base implémentation de la <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> surcharge de méthode si la différence entre la <paramref name="minValue" /> et <paramref name="maxValue" /> paramètres est supérieur à <see cref="F:System.Int32.MaxValue" />. Au lieu de cela, la distribution uniforme retournée par la base de <see cref="T:System.Random" /> classe est utilisée. Ce comportement permet d’améliorer les performances globales de la <see cref="T:System.Random" /> classe. Pour modifier ce comportement pour appeler le <see cref="M:System.Random.Sample" /> méthode dans la classe dérivée, vous devez également substituer la <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> surcharge de méthode.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau d'octets contenant des nombres aléatoires.</param>
        <summary>Remplit les éléments d'un tableau d'octets spécifié à l'aide de nombres aléatoires.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque élément du tableau d’octets est défini sur un nombre aléatoire supérieur ou égal à 0 et inférieur ou égal à <xref:System.Byte.MaxValue>.  
  
 Par exemple, pour générer un nombre aléatoire sécurisé par chiffrement approprié pour la création d’un mot de passe aléatoire, utilisez une méthode telle que <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la <xref:System.Random.NextBytes%2A> méthode pour remplir un tableau d’octets avec des valeurs d’octet aléatoires.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> est <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>En commençant avec le .NET Framework version 2.0, si vous dérivez une classe de <see cref="T:System.Random" /> et remplacez le <see cref="M:System.Random.Sample" /> (méthode), la distribution fournie par l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> méthode n’est pas utilisée dans les appels à la classe de base implémentation de la <see cref="M:System.Random.NextBytes(System.Byte[])" /> (méthode). Au lieu de cela, la distribution uniforme retournée par la base de <see cref="T:System.Random" /> classe est utilisée. Ce comportement permet d’améliorer les performances globales de la <see cref="T:System.Random" /> classe. Pour modifier ce comportement pour appeler le <see cref="M:System.Random.Sample" /> méthode dans la classe dérivée, vous devez également substituer la <see cref="M:System.Random.NextBytes(System.Byte[])" /> (méthode).</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un nombre aléatoire à virgule flottante supérieur ou égal à 0,0 et inférieur à 1,0.</summary>
        <returns>Nombre à virgule flottante double précision supérieur ou égal à 0,0 et inférieur à 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La limite supérieure réelle du nombre aléatoire retourné par cette méthode est 0.99999999999999978.  
  
 Pour récupérer des valeurs à virgule flottante aléatoires dans une plage entre 0,0 et 1,0, consultez la section « Extraire des valeurs à virgule flottante dans une plage spécifiée » de la <xref:System.Random> rubrique de la classe.  
  
 Cette méthode est la version publique de la méthode protégée, <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Random.NextDouble%2A> méthode pour générer des séquences de type Double aléatoires.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 L’exemple suivant appelle la <xref:System.Random.NextDouble%2A> méthode permettant de générer aléatoire de 100 nombres et affiche la fréquence distribution.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un nombre aléatoire à virgule flottante compris entre 0,0 et 1,0.</summary>
        <returns>Nombre à virgule flottante double précision supérieur ou égal à 0,0 et inférieur à 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour produire une distribution aléatoire différente ou un principe de générateur de nombres aléatoires différent, dérivez une classe de la <xref:System.Random> classe et substituer la <xref:System.Random.Sample%2A> (méthode).  
  
> [!IMPORTANT]
>  Le <xref:System.Random.Sample%2A> méthode est `protected`, ce qui signifie qu’il est accessible uniquement dans la <xref:System.Random> classe et ses classes dérivées. Pour générer un nombre aléatoire compris entre 0 et 1 dans un <xref:System.Random> de l’instance, appelez le <xref:System.Random.NextDouble%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant dérive une classe de <xref:System.Random> et remplace le <xref:System.Random.Sample%2A> méthode permettant de générer une distribution de nombres aléatoires. Cette distribution est différente de la distribution uniforme générée par la <xref:System.Random.Sample%2A> méthode de la classe de base.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>En commençant avec le .NET Framework version 2.0, si vous dérivez une classe de <see cref="T:System.Random" /> et remplacez le <see cref="M:System.Random.Sample" /> (méthode), la distribution fournie par l’implémentation de classe dérivée de la <see cref="M:System.Random.Sample" /> méthode n’est pas utilisée dans les appels à la classe de base implémentation des méthodes suivantes : - le <see cref="M:System.Random.NextBytes(System.Byte[])" /> (méthode).  -La <see cref="M:System.Random.Next" /> (méthode).  -La <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> (méthode), si (<paramref name="maxValue" /> - <paramref name="minValue" />) est supérieur à <see cref="F:System.Int32.MaxValue" />.  Au lieu de cela, la distribution uniforme fournie par la base de <see cref="T:System.Random" /> classe est utilisée. Ce comportement permet d’améliorer les performances globales de la <see cref="T:System.Random" /> classe. Pour modifier ce comportement pour appeler l’implémentation de la <see cref="M:System.Random.Sample" /> méthode dans la classe dérivée, vous devez également substituer le comportement de ces trois membres. L’exemple fournit une illustration.</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>