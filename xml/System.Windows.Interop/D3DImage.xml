<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="D3DImage.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac567a591e7f26a5181b8d03d81e8af4ab098e8eb98.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67a591e7f26a5181b8d03d81e8af4ab098e8eb98</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.Interop.D3DImage">
          <source>An <ph id="ph1">&lt;see cref="T:System.Windows.Media.ImageSource" /&gt;</ph> that displays a user-created Direct3D surface.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Media.ImageSource" /&gt;</ph> qui affiche une surface Direct3D créée par l'utilisateur.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class to host Direct3D content in a Windows Presentation Foundation (WPF) application.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> classe pour héberger le contenu Direct3D dans une application Windows Presentation Foundation (WPF).</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> method to change the Direct3D content displayed by the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph>.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> méthode pour modifier le contenu Direct3D affiché par le <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method to assign a Direct3D surface to a <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph>.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> méthode pour attribuer une surface Direct3D à un <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> method to track updates to the Direct3D surface.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> méthode pour effectuer le suivi des mises à jour à la surface Direct3D.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> method to display the changed areas.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> méthode pour afficher les zones modifiées.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class manages two display buffers, which are called the <bpt id="p1">*</bpt>back buffer<ept id="p1">*</ept> and the <bpt id="p2">*</bpt>front buffer<ept id="p2">*</ept>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> classe gère deux mémoires tampons d’affichage, qui sont appelés les <bpt id="p1">*</bpt>mémoire tampon d’arrière-plan<ept id="p1">*</ept> et <bpt id="p2">*</bpt>tampon d’affichage<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>The back buffer is your Direct3D surface.</source>
          <target state="translated">La mémoire tampon d’arrière-plan est votre surface Direct3D.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Changes to the back buffer are copied forward to the front buffer when you call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> method, where it is displayed on the hardware.</source>
          <target state="translated">Modifications apportées à la mémoire tampon d’arrière-plan sont copiées en avant dans le tampon d’affichage lorsque vous appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> méthode, où il est affiché sur le matériel.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Occasionally, the front buffer becomes unavailable.</source>
          <target state="translated">Parfois, le tampon d’affichage n’est plus disponible.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities.</source>
          <target state="translated">Ce manque de disponibilité peut résulter de verrouillage de l’écran, les applications Direct3D exclusives plein écran, changement d’utilisateur ou autres activités du système.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>When this occurs, your WPF application is notified by handling the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event.</source>
          <target state="translated">Lorsque cela se produit, votre application WPF est notifiée en gérant le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.</source>
          <target state="translated">Comment votre application répond à la mémoire tampon avant de devenir indisponibles dépend de l’activation à revenir au rendu logiciel WPF.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> méthode a une surcharge qui accepte un paramètre qui spécifie si les WPF revient au rendu logiciel.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Responding to an Unavailable Front Buffer when WPF Does not Fall Back to Software Rendering</source>
          <target state="translated">Répondre à un tampon d’affichage non disponible lorsque WPF ne passe pas à un logiciel de rendu</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>When you call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> overload or call the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> overload with the <ph id="ph3">`enableSoftwareFallback`</ph> parameter set to <ph id="ph4">`false`</ph>, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed.</source>
          <target state="translated">Lorsque vous appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> surcharge ou appelez le <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> surcharger avec la <ph id="ph3">`enableSoftwareFallback`</ph> paramètre la valeur <ph id="ph4">`false`</ph>, le système de rendu libère sa référence à la mémoire tampon d’arrière-plan lorsque le tampon d’affichage n’est plus disponible et que rien n’est affiché.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>When the front buffer is available again, the rendering system raises the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to notify your WPF application.</source>
          <target state="translated">Lorsque le tampon d’affichage est à nouveau disponible, le système de rendu déclenche le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> événement pour avertir votre application WPF.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>You can create an event handler for the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to restart rendering again with a valid Direct3D surface.</source>
          <target state="translated">Vous pouvez créer un gestionnaire d’événements pour le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> événement pour redémarrer le rendu avec une surface Direct3D valide.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>To restart rendering, you must call <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph>.</source>
          <target state="translated">Pour redémarrer le rendu, vous devez appeler <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Responding to an Unavailable Front Buffer when WPF Falls Back to Software Rendering</source>
          <target state="translated">Répondre à un tampon d’affichage non disponible lors de WPF revient au rendu logiciel</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>When you call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> overload with the <ph id="ph2">`enableSoftwareFallback`</ph> parameter set to <ph id="ph3">`true`</ph>, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <ph id="ph4">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> when the front buffer is available again.</source>
          <target state="translated">Lorsque vous appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> surcharger avec la <ph id="ph2">`enableSoftwareFallback`</ph> paramètre la valeur <ph id="ph3">`true`</ph>, le système de rendu conserve sa référence à la mémoire tampon d’arrière-plan lorsque le tampon d’affichage n’est plus disponible, il est donc inutile d’appeler <ph id="ph4">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> lors de l’avant mémoire tampon est à nouveau disponible.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>There may be situations where the user’s device becomes unavailable.</source>
          <target state="translated">Il peut arriver lorsque le périphérique l’utilisateur n’est plus disponible.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>When that occurs, call <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> to release WPF’s reference to the back buffer.</source>
          <target state="translated">Lorsque cela se produit, appelez <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> pour libérer la référence de WPF à la mémoire tampon d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>If you need to reset your device, call <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> with the <ph id="ph2">`backBuffer`</ph> parameter set to <ph id="ph3">`null`</ph>, and then call <ph id="ph4">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> again with <ph id="ph5">`backBuffer`</ph> set to a valid Direct3D surface.</source>
          <target state="translated">Si vous devez réinitialiser votre appareil, appelez <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> avec la <ph id="ph2">`backBuffer`</ph> paramètre la valeur <ph id="ph3">`null`</ph>, puis appelez <ph id="ph4">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> avec <ph id="ph5">`backBuffer`</ph> défini sur une surface Direct3D valide.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Performance depends greatly on the settings of the Direct3D surface.</source>
          <target state="translated">Les performances dépendent considérablement les paramètres de la surface Direct3D.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>For more information, see <bpt id="p1">[</bpt>Performance Considerations for Direct3D9 and WPF Interoperability<ept id="p1">](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>considérations sur les performances de Direct3D9 et interopérabilité WPF<ept id="p1">](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md)</ept>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class does not display Direct3D content when WPF renders in software, such as over a Remote Desktop connection, unless you call <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> and specify <ph id="ph3">`true`</ph> for the <ph id="ph4">`enableSoftwareFallback`</ph> parameter.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> classe n’affiche pas le contenu Direct3D lorsque WPF est rendu dans le logiciel, telles que via une connexion Bureau à distance, sauf si vous appelez <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> et spécifiez <ph id="ph3">`true`</ph> pour la <ph id="ph4">`enableSoftwareFallback`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>The following code example shows how to declare a <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> in XAML.</source>
          <target state="translated">L’exemple de code suivant montre comment déclarer un <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> en XAML.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>You must map the <ph id="ph1">&lt;xref:System.Windows.Interop&gt;</ph> namespace, because it is not included in the default XAML namespaces.</source>
          <target state="translated">Vous devez mapper le <ph id="ph1">&lt;xref:System.Windows.Interop&gt;</ph> espace de noms, car il n’est pas inclus dans les espaces de noms XAML par défaut.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>For more information, see <bpt id="p1">[</bpt>Walkthrough: Hosting Direct3D9 Content in WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>procédure pas à pas : hébergement de contenu Direct3D9 dans WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>for access to unmanaged resources.</source>
          <target state="translated">Pour accéder aux ressources non managées.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Interop.D3DImage">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="T:System.Windows.Interop.D3DImage">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.#ctor">
          <source>The default display resolution is 1/96th inch.</source>
          <target state="translated">La résolution d’affichage par défaut est 1/96e de pouce.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.#ctor">
          <source>for access to unmanaged resources.</source>
          <target state="translated">Pour accéder aux ressources non managées.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.#ctor">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.#ctor">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)">
          <source>The display resolution on the x-axis.</source>
          <target state="translated">Résolution d'affichage sur l'axe X.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)">
          <source>The display resolution on the y-axis.</source>
          <target state="translated">Résolution d'affichage sur l'axe Y.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> class with the specified display resolution.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> avec la résolution d'affichage spécifiée.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)">
          <source>The default display resolution is 1/96th inch.</source>
          <target state="translated">La résolution d’affichage par défaut est 1/96e de pouce.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)">
          <source><ph id="ph1">&lt;paramref name="dpiX" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dpiY" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dpiX" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="dpiY" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)">
          <source>for access to unmanaged resources.</source>
          <target state="translated">Pour accéder aux ressources non managées.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Windows.Int32Rect" /&gt;</ph> that represents the area that changed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Int32Rect" /&gt;</ph> qui représente la zone qui a été modifiée.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>Specifies the area of the back buffer that changed.</source>
          <target state="translated">Spécifie la zone de la mémoire tampon d'arrière-plan qui a été modifiée.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> method to indicate changes your code has made to the back buffer.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> méthode pour indiquer les modifications apportées par votre code à la mémoire tampon d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>To be rendered, the changed area on the back buffer must have a corresponding changed area on the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph>.</source>
          <target state="translated">Pour être rendue, la zone modifiée sur la mémoire tampon d’arrière-plan doit avoir une zone modifiée correspondante le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> methods before calling the <ph id="ph3">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> method.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> méthodes avant d’appeler le <ph id="ph3">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> method to copy the changed areas to the front buffer.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> méthode pour copier les zones modifiées dans le tampon d’affichage.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>After a few calls to the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> method, the changed areas are merged into a single area.</source>
          <target state="translated">Après quelques appels à la <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> (méthode), les zones modifiées sont fusionnées dans une seule zone.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>This means you must have valid data outside of the changed areas.</source>
          <target state="translated">Cela signifie que vous devez disposer des données valides en dehors des zones modifiées.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>The following code example shows how to call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> method to specify the changed region in the back buffer.</source>
          <target state="translated">L’exemple de code suivant montre comment appeler le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> méthode pour spécifier la région modifiée dans la mémoire tampon d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>For more information, see <bpt id="p1">[</bpt>Walkthrough: Hosting Direct3D9 Content in WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>procédure pas à pas : hébergement de contenu Direct3D9 dans WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>The bitmap has not been locked by a call to the <ph id="ph1">&lt;see cref="M:System.Windows.Interop.D3DImage.Lock" /&gt;</ph> or <ph id="ph2">&lt;see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" /&gt;</ph> methods.</source>
          <target state="translated">La bitmap n'a pas été verrouillée par un appel à la méthode <ph id="ph1">&lt;see cref="M:System.Windows.Interop.D3DImage.Lock" /&gt;</ph> ou <ph id="ph2">&lt;see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>The back buffer has not been assigned by a call to the <ph id="ph1">&lt;see cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" /&gt;</ph> method.</source>
          <target state="translated">La mémoire tampon d'arrière-plan n'a pas été assignée par un appel à la méthode <ph id="ph1">&lt;see cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>One or more of the following conditions is true.</source>
          <target state="translated">Une ou plusieurs des conditions suivantes sont vraies.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source><ph id="ph1">&lt;paramref name="dirtyRect.X" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dirtyRect.X" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 0</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source><ph id="ph1">&lt;paramref name="dirtyRect.Y" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dirtyRect.Y" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 0</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source><ph id="ph1">&lt;paramref name="dirtyRect.Width" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 0 or <ph id="ph3">&lt;paramref name="dirtyRect.Width" /&gt;</ph> <ph id="ph4">&amp;gt;</ph> <ph id="ph5">&lt;see cref="P:System.Windows.Interop.D3DImage.PixelWidth" /&gt;</ph><ph id="ph6">&lt;paramref name="dirtyRect.Height" /&gt;</ph> <ph id="ph7">&amp;lt;</ph> 0 or <ph id="ph8">&lt;paramref name="dirtyRect.Height" /&gt;</ph> <ph id="ph9">&amp;gt;</ph> <ph id="ph10">&lt;see cref="P:System.Windows.Interop.D3DImage.PixelHeight" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dirtyRect.Width" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 0 ou <ph id="ph3">&lt;paramref name="dirtyRect.Width" /&gt;</ph> <ph id="ph4">&amp;gt;</ph> <ph id="ph5">&lt;see cref="P:System.Windows.Interop.D3DImage.PixelWidth" /&gt;</ph><ph id="ph6">&lt;paramref name="dirtyRect.Height" /&gt;</ph> <ph id="ph7">&amp;lt;</ph> 0 ou <ph id="ph8">&lt;paramref name="dirtyRect.Height" /&gt;</ph> <ph id="ph9">&amp;gt;</ph> <ph id="ph10">&lt;see cref="P:System.Windows.Interop.D3DImage.PixelHeight" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>for access to unmanaged resources.</source>
          <target state="translated">Pour accéder aux ressources non managées.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.Clone">
          <source>Creates a modifiable clone of this <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> object, making deep copies of this object's values.</source>
          <target state="translated">Crée un clone modifiable de cet objet <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>, en créant des copies intégrales des valeurs de l'objet.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.Clone">
          <source>When copying dependency properties, this method copies resource references and data bindings (which may no longer resolve), but not animations or their current values.</source>
          <target state="translated">Lors de la copie de propriétés de dépendance, cette méthode copie les références de ressources et les liaisons de données (même si elles ne peuvent plus être résolues), mais pas les animations ni leurs valeurs actuelles.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.Clone">
          <source>A modifiable clone of the current object.</source>
          <target state="translated">Clone modifiable de l'objet actif.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.Clone">
          <source>The cloned object's <ph id="ph1">&lt;see cref="P:System.Windows.Freezable.IsFrozen" /&gt;</ph> property will be <ph id="ph2">&lt;see langword="false" /&gt;</ph> even if the source's <ph id="ph3">&lt;see cref="P:System.Windows.Freezable.IsFrozen" /&gt;</ph> property was <ph id="ph4">&lt;see langword="true." /&gt;</ph></source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.Windows.Freezable.IsFrozen" /&gt;</ph> de l’objet cloné sera <ph id="ph2">&lt;see langword="false" /&gt;</ph>, même si la propriété <ph id="ph3">&lt;see cref="P:System.Windows.Freezable.IsFrozen" /&gt;</ph> de la source était <ph id="ph4">&lt;see langword="true." /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Clone">
          <source>This method is used to produce modifiable copies of frozen <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph> objects (or any <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph> object).</source>
          <target state="translated">Cette méthode est utilisée pour générer des copies modifiables de figé <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph> objets (ou n’importe quel <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph> objet).</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Clone">
          <source>For convenience, this method shadows the inherited version with a strongly typed implementation.</source>
          <target state="translated">Pour des raisons pratiques, cette méthode occulte la version héritée avec une implémentation fortement typée.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Clone">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)">
          <source>The object to clone.</source>
          <target state="translated">Objet à cloner.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)">
          <source>Makes the instance a clone (deep copy) of the specified <ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph> using base (non-animated) property values.</source>
          <target state="translated">Fait de l’instance un clone (copie complète) du <ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph> spécifié utilisant des valeurs de propriété (non animée) de base.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CloneCurrentValue">
          <source>Creates a modifiable clone of this <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> object, making deep copies of this object's current values.</source>
          <target state="translated">Crée un clone modifiable de cet objet <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>, en effectuant une copie complète des valeurs actuelles de cet objet.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CloneCurrentValue">
          <source>Resource references, data bindings, and animations are not copied, but their current values are copied.</source>
          <target state="translated">Contrairement à leurs valeurs actuelles, les références de ressources, les liaisons de données et les animations ne sont pas copiées.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CloneCurrentValue">
          <source>A modifiable clone of the current object.</source>
          <target state="translated">Clone modifiable de l'objet actif.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CloneCurrentValue">
          <source>The cloned object's <ph id="ph1">&lt;see cref="P:System.Windows.Freezable.IsFrozen" /&gt;</ph> property will be <ph id="ph2">&lt;see langword="false" /&gt;</ph> even if the source's <ph id="ph3">&lt;see cref="P:System.Windows.Freezable.IsFrozen" /&gt;</ph> property was <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">La valeur de la propriété <ph id="ph1">&lt;see cref="P:System.Windows.Freezable.IsFrozen" /&gt;</ph> de l'objet cloné est <ph id="ph2">&lt;see langword="false" /&gt;</ph>, même si la valeur de la propriété <ph id="ph3">&lt;see cref="P:System.Windows.Freezable.IsFrozen" /&gt;</ph> de la source était <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.CloneCurrentValue">
          <source>This method is used to produce modifiable copies of frozen <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph> objects (or any <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph> object).</source>
          <target state="translated">Cette méthode est utilisée pour générer des copies modifiables de figé <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph> objets (ou n’importe quel <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph> objet).</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.CloneCurrentValue">
          <source>For convenience, this method shadows the inherited version with a strongly typed implementation.</source>
          <target state="translated">Pour des raisons pratiques, cette méthode occulte la version héritée avec une implémentation fortement typée.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.CloneCurrentValue">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph> to be cloned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph> à cloner.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)">
          <source>Makes the instance a modifiable clone (deep copy) of the specified <ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph> using current property values.</source>
          <target state="translated">Fait de l’instance un clone (copie complète) modifiable du <ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph> spécifié à l’aide des valeurs de propriété actuelles.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CopyBackBuffer">
          <source>Creates a software copy of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>.</source>
          <target state="translated">Crée une copie logicielle du <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CopyBackBuffer">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Media.Imaging.BitmapSource" /&gt;</ph> that is a software copy of the current state of the back buffer; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the back buffer cannot be read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Media.Imaging.BitmapSource" /&gt;</ph> qui est une copie logicielle de l'état actuel de la mémoire tampon d'arrière-plan ; sinon, <ph id="ph2">&lt;see langword="null" /&gt;</ph> si la mémoire tampon d'arrière-plan ne peut pas être lue.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.CopyBackBuffer">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A&gt;</ph> method is called by clients such as the printing system and the <ph id="ph2">&lt;xref:System.Windows.Media.Imaging.RenderTargetBitmap&gt;</ph> class.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A&gt;</ph> méthode est appelée par les clients, tels que le système d’impression et la <ph id="ph2">&lt;xref:System.Windows.Media.Imaging.RenderTargetBitmap&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.CopyBackBuffer">
          <source>Optionally override the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A&gt;</ph> method to implement custom logic and return a different <ph id="ph2">&lt;xref:System.Windows.Media.Imaging.BitmapSource&gt;</ph>.</source>
          <target state="translated">Vous pouvez également remplacer le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A&gt;</ph> méthode pour implémenter une logique personnalisée et retourner une autre <ph id="ph2">&lt;xref:System.Windows.Media.Imaging.BitmapSource&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.CopyBackBuffer">
          <source>For example, you can return a placeholder <ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapSource&gt;</ph> if the default <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A&gt;</ph> implementation returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Par exemple, vous pouvez retourner un espace réservé <ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapSource&gt;</ph> si la valeur par défaut <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A&gt;</ph> implémentation retourne <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.CopyBackBuffer">
          <source>for access to unmanaged resources.</source>
          <target state="translated">Pour accéder aux ressources non managées.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.CopyBackBuffer">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.CopyBackBuffer">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CreateInstanceCore">
          <source>When implemented in a derived class, creates a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> derived class.</source>
          <target state="translated">Une fois implémentée dans une classe dérivée, initialise une nouvelle instance de la classe dérivée <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.CreateInstanceCore">
          <source>The new instance.</source>
          <target state="translated">Nouvelle instance.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.CreateInstanceCore">
          <source>If you derive from the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class, you must override the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A&gt;</ph> method to enable correct cloning.</source>
          <target state="translated">Si vous dérivez de la <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> (classe), vous devez substituer la <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A&gt;</ph> méthode pour activer un clonage correct.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.CreateInstanceCore">
          <source>The default implementation performs a <ph id="ph1">`return new D3DImage()`</ph>, which will not be correct if the instance is a different class.</source>
          <target state="translated">L’implémentation par défaut effectue un <ph id="ph1">`return new D3DImage()`</ph>, qui ne sera pas correct si l’instance est une autre classe.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.Finalize">
          <source>Frees resources and performs other cleanup operations before the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> is reclaimed by garbage collection.</source>
          <target state="translated">Libère les ressources et exécute d’autres opérations de nettoyage avant la récupération du <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> par la garbage collection.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Finalize">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode se substitue à <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Finalize">
          <source>Application code should not call this method; an object's <ph id="ph1">`Finalize`</ph> method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method.</source>
          <target state="translated">Code d’application ne doit pas appeler cette méthode ; d’un objet <ph id="ph1">`Finalize`</ph> méthode est appelée automatiquement lors du garbage collection, à moins que la finalisation par le garbage collector a été désactivée par un appel à la <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Finalize">
          <source>For more information, see <bpt id="p1">[</bpt>Finalize Methods and Destructors<ept id="p1">](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70)</ept>, <bpt id="p2">[</bpt>Cleaning Up Unmanaged Resources<ept id="p2">](~/docs/standard/garbage-collection/unmanaged.md)</ept>, and <bpt id="p3">[</bpt>Overriding the Finalize Method<ept id="p3">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>destructeurs et méthodes Finalize<ept id="p1">](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70)</ept>, <bpt id="p2">[</bpt>de nettoyage des ressources non managées<ept id="p2">](~/docs/standard/garbage-collection/unmanaged.md)</ept>, et <bpt id="p3">[</bpt>substitution de la méthode Finalize<ept id="p3">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Finalize">
          <source>for access to unmanaged resources.</source>
          <target state="translated">Pour accéder aux ressources non managées.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Finalize">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Finalize">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)">
          <source>Has no effect.</source>
          <target state="translated">N'a aucun effet.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)">
          <source>Makes the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> unmodifiable or determines whether it can be made unmodifiable.</source>
          <target state="translated">Rend le <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> non modifiable ou détermine s'il peut être rendu non modifiable.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> in all cases.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> dans tous les cas.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class does not allow freezing because changes are always possible due to front buffer availability.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> classe n’autorise pas le gel car des modifications sont toujours possibles en raison de la disponibilité du tampon d’affichage.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)">
          <source>The instance to copy.</source>
          <target state="translated">Instance à copier.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)">
          <source>Makes the instance a frozen clone of the specified <ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph> using base (non-animated) property values.</source>
          <target state="translated">Convertit l'instance en clone figé du <ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph> spécifié à l'aide des valeurs de propriétés (non-animées) de base.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph> to copy and freeze.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph> à copier et figer.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)">
          <source>Makes the current instance a frozen clone of the specified <ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph>.</source>
          <target state="translated">Convertit l'instance actuelle en un clone figé du <ph id="ph1">&lt;see cref="T:System.Windows.Freezable" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)">
          <source>If the object has animated dependency properties, their current animated values are copied.</source>
          <target state="translated">Si l’objet a des propriétés de dépendance animées, leurs valeurs animées actuelles sont copiées.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="P:System.Windows.Interop.D3DImage.Height">
          <source>Gets the height of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>.</source>
          <target state="translated">Obtient la hauteur du <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.Height">
          <source>The height of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>, in measure units.</source>
          <target state="translated">Hauteur du <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> en unités de mesure.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.Height">
          <source>A measure unit is 1/96th inch.</source>
          <target state="translated">Une unité de mesure est égale à 1/96e de pouce.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.Height">
          <source>The value of <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Height%2A&gt;</ph> can change when a new back buffer is assigned by a call to the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method.</source>
          <target state="translated">La valeur de <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Height%2A&gt;</ph> peut changer lorsqu’une nouvelle mémoire tampon d’arrière-plan est assignée par un appel à la <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>Gets a value that indicates whether a front buffer exists.</source>
          <target state="translated">Obtient une valeur qui indique si un tampon d'affichage existe.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if a front buffer exists; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si un tampon d'affichage existe ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>Occasionally, the front buffer becomes unavailable.</source>
          <target state="translated">Parfois, le tampon d’affichage n’est plus disponible.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities.</source>
          <target state="translated">Ce manque de disponibilité peut résulter de verrouillage de l’écran, les applications Direct3D exclusives plein écran, changement d’utilisateur ou autres activités du système.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>When this occurs, your WPF application is notified by handling the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event.</source>
          <target state="translated">Lorsque cela se produit, votre application WPF est notifiée en gérant le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.</source>
          <target state="translated">Comment votre application répond à la mémoire tampon avant de devenir indisponibles dépend de l’activation à revenir au rendu logiciel WPF.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> méthode a une surcharge qui accepte un paramètre qui spécifie si les WPF revient au rendu logiciel.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>For more information, see the remarks in the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class.</source>
          <target state="translated">Pour plus d’informations, consultez les notes figurant dans la <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>Dependency Property Information</source>
          <target state="translated">Informations sur les propriétés de dépendance</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>Identifier field</source>
          <target state="translated">Champ d’identificateur</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">La valeur des propriétés de métadonnées <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>None</source>
          <target state="translated">Aucun.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>The following code example shows how to check the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A&gt;</ph> property when rendering the composition target.</source>
          <target state="translated">L’exemple de code suivant montre comment vérifier le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A&gt;</ph> propriété lors du rendu de la cible de composition.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable">
          <source>For more information, see <bpt id="p1">[</bpt>Walkthrough: Hosting Direct3D9 Content in WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>procédure pas à pas : hébergement de contenu Direct3D9 dans WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged">
          <source>Occurs when the <ph id="ph1">&lt;see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /&gt;</ph> property changes.</source>
          <target state="translated">Se produit quand la propriété <ph id="ph1">&lt;see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /&gt;</ph> change.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged">
          <source>Handle the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> to be notified when the status of the front buffer changes.</source>
          <target state="translated">Gérer les <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> pour être averti lorsque l’état de la mémoire tampon avant change.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged">
          <source>How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.</source>
          <target state="translated">Comment votre application répond à la mémoire tampon avant de devenir indisponibles dépend de l’activation à revenir au rendu logiciel WPF.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> méthode a une surcharge qui accepte un paramètre qui spécifie si les WPF revient au rendu logiciel.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged">
          <source>For more information, see the remarks in the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class.</source>
          <target state="translated">Pour plus d’informations, consultez les notes figurant dans la <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="F:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifie la propriété de dépendance <ph id="ph1">&lt;see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.Lock">
          <source>Locks the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> and enables operations on the back buffer.</source>
          <target state="translated">Verrouille le <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> et active des opérations sur la mémoire tampon d'arrière-plan.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Lock">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> method to change the back buffer by calling the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> methods.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> méthode pour modifier la mémoire tampon d’arrière-plan en appelant le <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Lock">
          <source>While the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> is locked, your application can also render to the Direct3D surface assigned to the back buffer.</source>
          <target state="translated">Alors que le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> est verrouillé, votre application peut également rendre à la surface Direct3D affectée à la mémoire tampon d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Lock">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> method blocks when the rendering system is reading the back buffer to update the front buffer.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> méthode se bloque lorsque le système de rendu lit la mémoire tampon d’arrière-plan pour mettre à jour le tampon d’affichage.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Lock">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.TryLock%2A&gt;</ph> method to avoid blocking indefinitely.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.TryLock%2A&gt;</ph> méthode pour éviter de bloquer indéfiniment.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Lock">
          <source>The following code example shows how to call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> method to enable updates to the back buffer.</source>
          <target state="translated">L’exemple de code suivant montre comment appeler le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> méthode d’activation des mises à jour de la mémoire tampon d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Lock">
          <source>For more information, see <bpt id="p1">[</bpt>Walkthrough: Hosting Direct3D9 Content in WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>procédure pas à pas : hébergement de contenu Direct3D9 dans WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.Lock">
          <source>The lock count equals <ph id="ph1">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Le nombre de verrous est égal à <ph id="ph1">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="P:System.Windows.Interop.D3DImage.Metadata">
          <source>Gets the metadata associated with the image source.</source>
          <target state="translated">Obtient les métadonnées associées à la source d'image.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.Metadata">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> in all cases.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> dans tous les cas.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="P:System.Windows.Interop.D3DImage.PixelHeight">
          <source>Gets the height of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>, in pixels.</source>
          <target state="translated">Obtient la hauteur du <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> en pixels.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.PixelHeight">
          <source>The height of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>, in pixels.</source>
          <target state="translated">Hauteur du <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> en pixels.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.PixelHeight">
          <source>The value of <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.PixelHeight%2A&gt;</ph> can change when a new back buffer is assigned by a call to the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method.</source>
          <target state="translated">La valeur de <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.PixelHeight%2A&gt;</ph> peut changer lorsqu’une nouvelle mémoire tampon d’arrière-plan est assignée par un appel à la <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.PixelHeight">
          <source>The following code example shows how to use the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.PixelHeight%2A&gt;</ph> property to specify the changed region in the back buffer.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.PixelHeight%2A&gt;</ph> propriété pour spécifier la région modifiée dans la mémoire tampon d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.PixelHeight">
          <source>For more information, see <bpt id="p1">[</bpt>Walkthrough: Hosting Direct3D9 Content in WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>procédure pas à pas : hébergement de contenu Direct3D9 dans WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.Windows.Interop.D3DImage.PixelWidth">
          <source>Gets the width of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>, in pixels.</source>
          <target state="translated">Obtient la largeur du <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> en pixels.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.PixelWidth">
          <source>The width of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>, in pixels.</source>
          <target state="translated">Largeur du <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>, en pixels.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.PixelWidth">
          <source>The value of <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.PixelWidth%2A&gt;</ph> can change when a new back buffer is assigned by a call to the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method.</source>
          <target state="translated">La valeur de <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.PixelWidth%2A&gt;</ph> peut changer lorsqu’une nouvelle mémoire tampon d’arrière-plan est assignée par un appel à la <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.PixelWidth">
          <source>The following code example shows how to use the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.PixelWidth%2A&gt;</ph> property to specify the changed region in the back buffer.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.PixelWidth%2A&gt;</ph> propriété pour spécifier la région modifiée dans la mémoire tampon d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.PixelWidth">
          <source>For more information, see <bpt id="p1">[</bpt>Walkthrough: Hosting Direct3D9 Content in WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>procédure pas à pas : hébergement de contenu Direct3D9 dans WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="T:System.Windows.Interop.D3DImage">
          <source>Assigns a Direct3D surface as the source of the back buffer.</source>
          <target state="translated">Assigne une surface Direct3D comme source de la mémoire tampon d'arrière-plan.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>The type of Direct3D surface.</source>
          <target state="translated">Type de surface Direct3D.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>Must be a valid <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DResourceType" /&gt;</ph>.</source>
          <target state="translated">Doit être un <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DResourceType" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>The Direct3D surface to assign as the back buffer.</source>
          <target state="translated">Surface Direct3D à attribuer comme mémoire tampon d'arrière-plan.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>Assigns a Direct3D surface as the source of the back buffer.</source>
          <target state="translated">Assigne une surface Direct3D comme source de la mémoire tampon d'arrière-plan.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method to assign a Direct3D surface to the back buffer.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> méthode pour attribuer une surface Direct3D à la mémoire tampon d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>Performance depends greatly on the settings of the Direct3D surface.</source>
          <target state="translated">Les performances dépendent considérablement les paramètres de la surface Direct3D.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>For more information, see <bpt id="p1">[</bpt>Performance Considerations for Direct3D9 and WPF Interoperability<ept id="p1">](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>considérations sur les performances de Direct3D9 et interopérabilité WPF<ept id="p1">](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md)</ept>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> overload is identical to calling the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> overload with the <ph id="ph3">`enableSoftwareFallback`</ph> parameter set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> surcharge est identique à l’appel le <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> surcharger avec la <ph id="ph3">`enableSoftwareFallback`</ph> paramètre la valeur <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>When you call <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> or call <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> with the <ph id="ph3">`enableSoftwareFallback`</ph> parameter set to <ph id="ph4">`false`</ph>, the rendering system releases its reference to the back buffer when front buffer becomes unavailable and nothing is displayed.</source>
          <target state="translated">Lorsque vous appelez <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> ou appelez <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> avec la <ph id="ph3">`enableSoftwareFallback`</ph> paramètre la valeur <ph id="ph4">`false`</ph>, le système de rendu libère sa référence à la mémoire tampon d’arrière-plan lorsque le tampon d’affichage n’est plus disponible et que rien ne s’affiche.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>When the front buffer is available again, the rendering system raises the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to notify your WPF application.</source>
          <target state="translated">Lorsque le tampon d’affichage est à nouveau disponible, le système de rendu déclenche le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> événement pour avertir votre application WPF.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>You can create an event handler for the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to restart rendering again with a valid Direct3D surface.</source>
          <target state="translated">Vous pouvez créer un gestionnaire d’événements pour le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> événement pour redémarrer le rendu avec une surface Direct3D valide.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>To restart rendering, you must call <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph>.</source>
          <target state="translated">Pour redémarrer le rendu, vous devez appeler <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>The following list shows the required back buffer settings for the <ph id="ph1">`IDirect3DSurface9`</ph> type.</source>
          <target state="translated">La liste suivante présente les paramètres de la mémoire tampon d’arrière-plan requis pour le <ph id="ph1">`IDirect3DSurface9`</ph> type.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source><ph id="ph1">`D3DFMT_A8R8G8B8`</ph> or <ph id="ph2">`D3DFMT_X8R8G8B8`</ph></source>
          <target state="translated"><ph id="ph1">`D3DFMT_A8R8G8B8`</ph> ou <ph id="ph2">`D3DFMT_X8R8G8B8`</ph></target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>Multisampling is allowed on <ph id="ph1">`IDirect3DSurface9Ex`</ph> surfaces only.</source>
          <target state="translated">L’échantillonnage multiple est autorisée sur <ph id="ph1">`IDirect3DSurface9Ex`</ph> expose uniquement.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>The following code example shows how to call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method to assign a Direct3D surface.</source>
          <target state="translated">L’exemple de code suivant montre comment appeler le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> méthode pour attribuer une surface Direct3D.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>For more information, see <bpt id="p1">[</bpt>Walkthrough: Hosting Direct3D9 Content in WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>procédure pas à pas : hébergement de contenu Direct3D9 dans WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> has not been locked by a call to the <ph id="ph2">&lt;see cref="M:System.Windows.Interop.D3DImage.Lock" /&gt;</ph> or <ph id="ph3">&lt;see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" /&gt;</ph> methods.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> n'a pas été verrouillé par un appel à la méthode <ph id="ph2">&lt;see cref="M:System.Windows.Interop.D3DImage.Lock" /&gt;</ph> ou <ph id="ph3">&lt;see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="backBufferType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Windows.Interop.D3DResourceType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="backBufferType" /&gt;</ph> n’est pas un <ph id="ph2">&lt;see cref="T:System.Windows.Interop.D3DResourceType" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>The creation parameters for <ph id="ph1">&lt;paramref name="backBuffer" /&gt;</ph> do not meet the requirements for the <ph id="ph2">&lt;paramref name="backBufferType" /&gt;</ph>-or-The <ph id="ph3">&lt;paramref name="backBuffer" /&gt;</ph> device is not valid.</source>
          <target state="translated">Les paramètres de création de <ph id="ph1">&lt;paramref name="backBuffer" /&gt;</ph> ne répondent pas aux spécifications pour <ph id="ph2">&lt;paramref name="backBufferType" /&gt;</ph> - ou- Le périphérique <ph id="ph3">&lt;paramref name="backBuffer" /&gt;</ph> n'est pas valide.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>for access to unmanaged resources.</source>
          <target state="translated">Pour accéder aux ressources non managées.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>The type of Direct3D surface.</source>
          <target state="translated">Type de surface Direct3D.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>Must be a valid <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DResourceType" /&gt;</ph>.</source>
          <target state="translated">Doit être un <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DResourceType" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>The Direct3D surface to assign as the back buffer.</source>
          <target state="translated">Surface Direct3D à attribuer comme mémoire tampon d'arrière-plan.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to fall back on software rendering; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour revenir au rendu logiciel ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>Assigns a Direct3D surface as the source of the back buffer.</source>
          <target state="translated">Assigne une surface Direct3D comme source de la mémoire tampon d'arrière-plan.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>When you call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> overload or call the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> overload with the <ph id="ph3">`enableSoftwareFallback`</ph> parameter set to <ph id="ph4">`false`</ph>, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed.</source>
          <target state="translated">Lorsque vous appelez le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> surcharge ou appelez le <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> surcharger avec la <ph id="ph3">`enableSoftwareFallback`</ph> paramètre la valeur <ph id="ph4">`false`</ph>, le système de rendu libère sa référence à la mémoire tampon d’arrière-plan lorsque le tampon d’affichage n’est plus disponible et que rien n’est affiché.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>When the front buffer is available again, the rendering system raises the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to notify your WPF application.</source>
          <target state="translated">Lorsque le tampon d’affichage est à nouveau disponible, le système de rendu déclenche le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> événement pour avertir votre application WPF.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>You can create an event handler for the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to restart rendering again with a valid Direct3D surface.</source>
          <target state="translated">Vous pouvez créer un gestionnaire d’événements pour le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> événement pour redémarrer le rendu avec une surface Direct3D valide.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>To restart rendering, you must call <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph>.</source>
          <target state="translated">Pour redémarrer le rendu, vous devez appeler <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>When you call <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> with the <ph id="ph2">`enableSoftwareFallback`</ph> parameter set to <ph id="ph3">`true`</ph>, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <ph id="ph4">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> when the front buffer is available again.</source>
          <target state="translated">Lorsque vous appelez <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> avec la <ph id="ph2">`enableSoftwareFallback`</ph> paramètre la valeur <ph id="ph3">`true`</ph>, le système de rendu conserve sa référence à la mémoire tampon d’arrière-plan lorsque le tampon d’affichage n’est plus disponible, il est donc inutile d’appeler <ph id="ph4">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> lorsque le tampon d’affichage est disponible à nouveau.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>There may be situations where the user’s device becomes unavailable.</source>
          <target state="translated">Il peut arriver lorsque le périphérique l’utilisateur n’est plus disponible.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>When that occurs, call <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> to release WPF’s reference to the back buffer.</source>
          <target state="translated">Lorsque cela se produit, appelez <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> pour libérer la référence de WPF à la mémoire tampon d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>If you need to reset your device, call <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> with <ph id="ph2">`backBuffer`</ph> set to <ph id="ph3">`null`</ph>, and then call <ph id="ph4">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> again with <ph id="ph5">`backBuffer`</ph> set to a valid Direct3D surface.</source>
          <target state="translated">Si vous devez réinitialiser votre appareil, appelez <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> avec <ph id="ph2">`backBuffer`</ph> la valeur <ph id="ph3">`null`</ph>, puis appelez <ph id="ph4">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> avec <ph id="ph5">`backBuffer`</ph> défini sur une surface Direct3D valide.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>The following list shows the required back buffer settings for the <ph id="ph1">`IDirect3DSurface9`</ph> type.</source>
          <target state="translated">La liste suivante présente les paramètres de la mémoire tampon d’arrière-plan requis pour le <ph id="ph1">`IDirect3DSurface9`</ph> type.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">`D3DFMT_A8R8G8B8`</ph> or <ph id="ph2">`D3DFMT_X8R8G8B8`</ph></source>
          <target state="translated"><ph id="ph1">`D3DFMT_A8R8G8B8`</ph> ou <ph id="ph2">`D3DFMT_X8R8G8B8`</ph></target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)">
          <source>Multisampling is allowed on <ph id="ph1">`IDirect3DSurface9Ex`</ph> surfaces only.</source>
          <target state="translated">L’échantillonnage multiple est autorisée sur <ph id="ph1">`IDirect3DSurface9Ex`</ph> expose uniquement.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)">
          <source>The duration to wait for the lock to be acquired.</source>
          <target state="translated">Durée d'attente avant l'acquisition du verrou.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)">
          <source>Attempts to lock the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> and waits for the specified duration.</source>
          <target state="translated">Tente de verrouiller le <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> et attend pendant la durée spécifiée.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was acquired; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le verrou a été acquis ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="P:System.Windows.Duration.Automatic" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="P:System.Windows.Duration.Automatic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)">
          <source>The lock count equals <ph id="ph1">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Le nombre de verrous est égal à <ph id="ph1">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Windows.Interop.D3DImage.Unlock">
          <source>Decrements the lock count for the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>.</source>
          <target state="translated">Décrémente le nombre de verrous pour le <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Unlock">
          <source>When the lock count for the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> reaches zero, the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> is fully unlocked.</source>
          <target state="translated">Lorsque le nombre de verrous pour le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> atteint zéro, le <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> est entièrement déverrouillé.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Unlock">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> is marked for rendering if the image has changed areas that were specified by previous calls to the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> est marqué pour le rendu si l’image a modifié des zones spécifiées par les appels précédents à la <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Unlock">
          <source>When the changes are committed and rendering occurs, additional calls to the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> method block until the render thread has copied the contents of the back buffer to the front buffer.</source>
          <target state="translated">Lorsque les modifications sont validées et rendu se produit, des appels supplémentaires à la <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> un bloc de méthode jusqu'à ce que le thread de rendu a copié le contenu de la mémoire tampon d’arrière-plan dans le tampon d’affichage.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Unlock">
          <source>This synchronization avoids display artifacts, such as tearing.</source>
          <target state="translated">Cette synchronisation évite les artefacts d’affichage, tels que les erreurs.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Unlock">
          <source>Do not update the Direct3D surface while the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> is unlocked.</source>
          <target state="translated">Ne mettez pas à jour la surface Direct3D lors de la <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> est déverrouillé.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Unlock">
          <source>The following code example shows how to call the <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> method to copy the updated back buffer to the front buffer.</source>
          <target state="translated">L’exemple de code suivant montre comment appeler le <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> méthode pour copier la mémoire tampon d’arrière-plan mise à jour dans le tampon d’affichage.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Interop.D3DImage.Unlock">
          <source>For more information, see <bpt id="p1">[</bpt>Walkthrough: Hosting Direct3D9 Content in WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>procédure pas à pas : hébergement de contenu Direct3D9 dans WPF<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="P:System.Windows.Interop.D3DImage.Width">
          <source>Gets the width of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>.</source>
          <target state="translated">Obtient la largeur du <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.Width">
          <source>The width of the <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph>, in measure units.</source>
          <target state="translated">Largeur du <ph id="ph1">&lt;see cref="T:System.Windows.Interop.D3DImage" /&gt;</ph> en unités de mesure.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.Width">
          <source>A measure unit is 1/96th inch.</source>
          <target state="translated">Une unité de mesure est égale à 1/96e de pouce.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Interop.D3DImage.Width">
          <source>The value of <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Width%2A&gt;</ph> can change when a new back buffer is assigned by a call to the <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method.</source>
          <target state="translated">La valeur de <ph id="ph1">&lt;xref:System.Windows.Interop.D3DImage.Width%2A&gt;</ph> peut changer lorsqu’une nouvelle mémoire tampon d’arrière-plan est assignée par un appel à la <ph id="ph2">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> (méthode).</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>