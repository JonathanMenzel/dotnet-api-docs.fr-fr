<Type Name="ConfigurationSection" FullName="System.Configuration.ConfigurationSection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50b032013ee388f601a901827cebfb8bd035f798" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30380073" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ConfigurationSection : System.Configuration.ConfigurationElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ConfigurationSection extends System.Configuration.ConfigurationElement" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ConfigurationSection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ConfigurationSection&#xA;Inherits ConfigurationElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConfigurationSection abstract : System::Configuration::ConfigurationElement" />
  <AssemblyInfo>
    <AssemblyName>System.Configuration</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.ConfigurationElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente une section dans un fichier de configuration.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez la <xref:System.Configuration.ConfigurationSection> classe pour implémenter un type de section personnalisé. Étendre la <xref:System.Configuration.ConfigurationSection> classe afin de fournir une gestion personnalisée et un accès par programme aux sections de configuration personnalisées. Pour savoir comment utiliser les sections de configuration personnalisées, consultez [Comment : Create Custom Configuration Sections Using ConfigurationSection](http://msdn.microsoft.com/library/febaca98-c727-4017-95ed-82e2fb6cf234).  
  
 Une section enregistre son type de gestion avec une entrée dans le `configSections` élément. Pour obtenir un exemple, consultez l’extrait de fichier de configuration indiqué dans la section exemple.  
  
> [!NOTE]
>  Dans les versions précédentes du .NET Framework, les gestionnaires de section de configuration ont été utilisés pour apporter des modifications aux paramètres de configuration par programme. Désormais, toutes les sections de configuration par défaut sont représentées par les classes qui étendent la <xref:System.Configuration.ConfigurationSection> classe.  
  
   
  
## Examples  
 L’exemple suivant montre comment implémenter une section personnalisée par programme.  
  
 Pour obtenir un exemple complet qui montre comment implémenter et utiliser une section personnalisée implémentée à l’aide du modèle par attributs, consultez <xref:System.Configuration.ConfigurationElement>.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#1)]
 [!code-vb[System.Configuration.ConfigurationSection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#1)]  
  
 L’exemple suivant est un extrait du fichier de configuration, telle qu’elle s’applique à l’exemple précédent.  
  
 ```xml
<?xml version="1.0" encoding="utf-8"?>
  <configuration>  
    <configSections>
      <section name="CustomSection" type="Samples.AspNet. CustomSection, CustomConfigurationSection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" allowDefinition="Everywhere" allowExeDefinition="MachineToApplication" restartOnExternalChanges="true" />
    </configSections>  

    <CustomSection fileName="default.txt" maxUsers="1000" maxIdleTime="00:15:00" /> 
 
  </configuration>
```  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Vous pouvez utiliser un modèle de codage déclaratif (attribué) ou par programmation pour créer des sections de configuration personnalisées :  
  
-   Modèle de programmation. Ce modèle nécessite, pour chaque attribut de section, la création d’une propriété pour obtenir ou définir sa valeur et l’ajouter au jeu de propriétés internes de l’objet sous-jacent <see cref="T:System.Configuration.ConfigurationElement" /> classe de base.  
  
-   Modèle déclaratif. Ce modèle plus simple, également appelé modèle attribué, vous permet de définir un attribut de section à l’aide d’une propriété et de décorant avec des attributs. Le système de configuration ASP.NET sur les types de propriétés et leurs valeurs par défaut, demandez à ces attributs. Avec ces informations, obtenues par réflexion, le système de configuration ASP.NET crée des objets de propriété de la section et exécute l’initialisation requise.  
  
 La <see cref="T:System.Configuration.Configuration" /> classe permet l’accès par programme pour modifier les fichiers de configuration. Vous pouvez accéder à ces fichiers pour lire ou écrire comme suit :  
  
-   Lecture. Vous utilisez <see cref="M:System.Configuration.Configuration.GetSection(System.String)" /> ou <see cref="M:System.Configuration.Configuration.GetSectionGroup(System.String)" /> pour lire les informations de configuration. Notez que l’utilisateur ou le processus qui lit doit avoir les autorisations suivantes :  
  
    -   Autorisation de lecture sur le fichier de configuration au niveau de la hiérarchie de configuration en cours.  
  
    -   Autorisations de lecture sur tous les fichiers de configuration.  
  
     Si votre application a besoin d’un accès en lecture seule à sa propre configuration, il est recommandé d’utiliser le <see cref="Overload:System.Web.Configuration.WebConfigurationManager.GetSection" /> surcharge de méthodes dans le cas des applications Web, ou le <see cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" /> méthode dans le cas des applications clientes.  
  
     Ces méthodes fournissent l’accès aux valeurs de configuration mises en cache pour l’application actuelle, qui offre de meilleures performances que la <see cref="T:System.Configuration.Configuration" /> classe.  
  
 <block subset="none" type="note"><para>  
 Si vous utilisez un mappage statique <see langword="GetSection" /> méthode qui accepte un <paramref name="path" /> paramètre, le <paramref name="path" /> paramètre doit faire référence à l’application dans laquelle le code est en cours d’exécution ; sinon, le paramètre est ignoré et les informations de configuration pour l’en cours d’exécution application est retournée.  
  
</para></block>  
  
-   L’écriture. Vous utilisez une de le <see cref="Overload:System.Configuration.Configuration.Save" /> méthodes permettant d’écrire les informations de configuration. Notez que l’utilisateur ou le processus qui écrit doit avoir les autorisations suivantes :  
  
    -   Autorisation en écriture sur le fichier de configuration et le répertoire au niveau de la hiérarchie de configuration en cours.  
  
    -   Autorisations de lecture sur tous les fichiers de configuration.</para>
    </block>
    <altmember cref="T:System.Configuration.Configuration" />
    <altmember cref="T:System.Configuration.SectionInformation" />
    <altmember cref="T:System.Configuration.ConfigurationElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ConfigurationSection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ConfigurationSection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Configuration.ConfigurationSection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser le <xref:System.Configuration.ConfigurationSection.%23ctor%2A> constructeur, vous devez d’abord définir un type de section personnalisé. Pour obtenir un exemple, consultez la <xref:System.Configuration.ConfigurationSection> vue d’ensemble de la classe.  
  
   
  
## Examples  
 L'exemple suivant illustre comment utiliser le <xref:System.Configuration.ConfigurationSection.%23ctor%2A>. Cet exemple suppose que vous avez créé une section classe personnalisée nommée `CustomSection`. Pour obtenir un exemple d’une telle classe, consultez la <xref:System.Configuration.ConfigurationSection> vue d’ensemble de la classe.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#2)]
 [!code-vb[System.Configuration.ConfigurationSection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeserializeSection">
      <MemberSignature Language="C#" Value="protected internal virtual void DeserializeSection (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void DeserializeSection(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.DeserializeSection(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub DeserializeSection (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void DeserializeSection(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Objet <see cref="T:System.Xml.XmlReader" />, qui lit le fichier de configuration.</param>
        <summary>Lit du XML à partir du fichier de configuration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La désérialisation fait référence à la lecture de données XML à partir d’un fichier de configuration, de leur transformation en données en temps réel et de son stockage dans un objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="reader" /> n'a trouvé aucun élément dans le fichier de configuration.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeObject">
      <MemberSignature Language="C#" Value="protected internal virtual object GetRuntimeObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object GetRuntimeObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.GetRuntimeObject" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetRuntimeObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ GetRuntimeObject();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet personnalisé en cas de substitution dans une classe dérivée.</summary>
        <returns>Objet représentant la section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Configuration.Configuration.GetSection%2A> méthode est appelée au moment de l’exécution, le système de configuration crée d’abord une instance appropriée de la <xref:System.Configuration.ConfigurationSection> de classe, puis retourne l’objet qu’il obtient à partir de la <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A> (méthode).  
  
 Par défaut, <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A> retourne simplement l’objet qui représente le <xref:System.Configuration.ConfigurationSection> à partir de laquelle elle est appelée.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A>.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#4)]
 [!code-vb[System.Configuration.ConfigurationSection#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez remplacer le <see cref="M:System.Configuration.ConfigurationSection.GetRuntimeObject" /> méthode pour retourner un type personnalisé en cours d’exécution.  
  
 Par exemple, pour restreindre la modification à l’exécution des paramètres dans le <see cref="T:System.Configuration.ConfigurationSection" /> (classe), vous pouvez remplacer <see cref="M:System.Configuration.ConfigurationSection.GetRuntimeObject" /> et retourner un type personnalisé qui applique des restrictions sur lequel les paramètres peuvent être modifiés, le cas échéant.  
  
 Si l’objet d’exécution est uniquement interne, l’objet retourné ne peut pas être utilisé en dehors de l’assembly qui le définit. Une façon de créer un objet qui dérive de <see cref="T:System.Configuration.ConfigurationSection" /> et sont accessibles par le code dans votre assembly à exécuter temps consiste à créer un objet d’exécution interne qui a une méthode qui retourne votre <see cref="T:System.Configuration.ConfigurationSection" /> implémentation.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsModified">
      <MemberSignature Language="C#" Value="protected internal override bool IsModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool IsModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.IsModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function IsModified () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool IsModified();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique si cet élément de configuration a été modifié depuis son dernier enregistrement ou chargement lorsqu'il est implémenté dans une classe dérivée.</summary>
        <returns>
          <see langword="true" /> si l'élément a été modifié ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetModified">
      <MemberSignature Language="C#" Value="protected internal override void ResetModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void ResetModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ResetModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub ResetModified ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void ResetModified();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réinitialise la valeur de la méthode <see cref="M:System.Configuration.ConfigurationElement.IsModified" /> à <see langword="false" /> en cas d’implémentation dans une classe dérivée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionInformation">
      <MemberSignature Language="C#" Value="public System.Configuration.SectionInformation SectionInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SectionInformation SectionInformation" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationSection.SectionInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SectionInformation As SectionInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Configuration::SectionInformation ^ SectionInformation { System::Configuration::SectionInformation ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SectionInformation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Configuration.SectionInformation" /> qui contient les fonctionnalités et informations non personnalisables de l'objet <see cref="T:System.Configuration.ConfigurationSection" />.</summary>
        <value>
          <see cref="T:System.Configuration.SectionInformation" /> qui contient les fonctionnalités et informations non personnalisables de <see cref="T:System.Configuration.ConfigurationSection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant indique comment utiliser la propriété <xref:System.Configuration.ConfigurationSection.SectionInformation%2A>.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#3)]
 [!code-vb[System.Configuration.ConfigurationSection#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Configuration.SectionInformation" />
      </Docs>
    </Member>
    <Member MemberName="SerializeSection">
      <MemberSignature Language="C#" Value="protected internal virtual string SerializeSection (System.Configuration.ConfigurationElement parentElement, string name, System.Configuration.ConfigurationSaveMode saveMode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string SerializeSection(class System.Configuration.ConfigurationElement parentElement, string name, valuetype System.Configuration.ConfigurationSaveMode saveMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.SerializeSection(System.Configuration.ConfigurationElement,System.String,System.Configuration.ConfigurationSaveMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SerializeSection (parentElement As ConfigurationElement, name As String, saveMode As ConfigurationSaveMode) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ SerializeSection(System::Configuration::ConfigurationElement ^ parentElement, System::String ^ name, System::Configuration::ConfigurationSaveMode saveMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentElement" Type="System.Configuration.ConfigurationElement" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="saveMode" Type="System.Configuration.ConfigurationSaveMode" />
      </Parameters>
      <Docs>
        <param name="parentElement">Instance de <see cref="T:System.Configuration.ConfigurationElement" /> à utiliser comme parent lors de l'annulation de la fusion.</param>
        <param name="name">Nom de la section à créer.</param>
        <param name="saveMode">Instance de <see cref="T:System.Configuration.ConfigurationSaveMode" /> à utiliser lors de l'écriture dans une chaîne.</param>
        <summary>Crée une chaîne XML contenant un affichage non fusionné de l'objet <see cref="T:System.Configuration.ConfigurationSection" /> sous la forme d'une section unique à écrire dans un fichier.</summary>
        <returns>Chaîne XML contenant un affichage non fusionné de l'objet <see cref="T:System.Configuration.ConfigurationSection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sérialisation fait référence à la transformation de données en temps réel, contenues dans un objet, en format XML et son stockage dans un fichier de configuration.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeElementInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeElementInTargetVersion (System.Configuration.ConfigurationElement element, string elementName, System.Runtime.Versioning.FrameworkName targetFramework);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeElementInTargetVersion(class System.Configuration.ConfigurationElement element, string elementName, class System.Runtime.Versioning.FrameworkName targetFramework) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializeElementInTargetVersion(System.Configuration.ConfigurationElement,System.String,System.Runtime.Versioning.FrameworkName)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeElementInTargetVersion (element As ConfigurationElement, elementName As String, targetFramework As FrameworkName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeElementInTargetVersion(System::Configuration::ConfigurationElement ^ element, System::String ^ elementName, System::Runtime::Versioning::FrameworkName ^ targetFramework);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Configuration.ConfigurationElement" />
        <Parameter Name="elementName" Type="System.String" />
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" />
      </Parameters>
      <Docs>
        <param name="element">Objet <see cref="T:System.Configuration.ConfigurationElement" /> qui est candidat pour la sérialisation.</param>
        <param name="elementName">Nom de l'objet <see cref="T:System.Configuration.ConfigurationElement" /> tel qu'il apparaît au format XML.</param>
        <param name="targetFramework">Version cible du [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Indique si l'élément spécifié doit être sérialisé lorsque la hiérarchie d'objets de configuration est sérialisée pour la version cible spécifiée du [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</summary>
        <returns>
          <see langword="true" /> si <paramref name="element" /> doit être sérialisé ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque section de configuration qui est créée pour le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] et versions ultérieures doivent substituer cette méthode et retourner explicitement `true`, mais uniquement si l’élément spécifié est valide pour la version spécifiée de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Les sections de configuration existants qui ont été créées pour les versions antérieures de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] n’avez pas à être modifié.  
  
 Le type de base contient une implémentation par défaut de cette méthode retourne toujours `true`. Si vous implémentez une section de configuration et vous ne substituez pas cette méthode, par défaut, tous les éléments de configuration contenus dans la section de configuration seront sérialisés pour toutes les versions du framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializePropertyInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializePropertyInTargetVersion (System.Configuration.ConfigurationProperty property, string propertyName, System.Runtime.Versioning.FrameworkName targetFramework, System.Configuration.ConfigurationElement parentConfigurationElement);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializePropertyInTargetVersion(class System.Configuration.ConfigurationProperty property, string propertyName, class System.Runtime.Versioning.FrameworkName targetFramework, class System.Configuration.ConfigurationElement parentConfigurationElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializePropertyInTargetVersion(System.Configuration.ConfigurationProperty,System.String,System.Runtime.Versioning.FrameworkName,System.Configuration.ConfigurationElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializePropertyInTargetVersion (property As ConfigurationProperty, propertyName As String, targetFramework As FrameworkName, parentConfigurationElement As ConfigurationElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializePropertyInTargetVersion(System::Configuration::ConfigurationProperty ^ property, System::String ^ propertyName, System::Runtime::Versioning::FrameworkName ^ targetFramework, System::Configuration::ConfigurationElement ^ parentConfigurationElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Configuration.ConfigurationProperty" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" />
        <Parameter Name="parentConfigurationElement" Type="System.Configuration.ConfigurationElement" />
      </Parameters>
      <Docs>
        <param name="property">Objet <see cref="T:System.Configuration.ConfigurationProperty" /> qui est candidat pour la sérialisation.</param>
        <param name="propertyName">Nom de l'objet <see cref="T:System.Configuration.ConfigurationProperty" /> tel qu'il apparaît au format XML.</param>
        <param name="targetFramework">Version cible du [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <param name="parentConfigurationElement">Élément parent de la propriété.</param>
        <summary>Indique si la propriété spécifiée doit être sérialisée lorsque la hiérarchie d'objets de configuration est sérialisée pour la version cible spécifiée du [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</summary>
        <returns>
          <see langword="true" /> si <paramref name="property" /> doit être sérialisé ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque section de configuration qui est créée pour le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] et versions ultérieures doivent substituer cette méthode et retourner explicitement `true`, mais uniquement si la propriété spécifiée est valide pour la version spécifiée de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Les sections de configuration existants qui ont été créées pour les versions antérieures de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] n’avez pas à être modifié.  
  
 Le type de base contient une implémentation par défaut de cette méthode retourne toujours `true`. Si vous implémentez une section de configuration et vous ne substituez pas cette méthode, par défaut, toutes les propriétés de configuration qui sont contenues dans la section de configuration seront sérialisées pour toutes les versions du framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSectionInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeSectionInTargetVersion (System.Runtime.Versioning.FrameworkName targetFramework);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeSectionInTargetVersion(class System.Runtime.Versioning.FrameworkName targetFramework) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializeSectionInTargetVersion(System.Runtime.Versioning.FrameworkName)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeSectionInTargetVersion (targetFramework As FrameworkName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeSectionInTargetVersion(System::Runtime::Versioning::FrameworkName ^ targetFramework);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" />
      </Parameters>
      <Docs>
        <param name="targetFramework">Version cible du [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Indique si l'instance <see cref="T:System.Configuration.ConfigurationSection" /> actuelle doit être sérialisée lorsque la hiérarchie d'objets de configuration est sérialisée pour la version cible spécifiée du [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</summary>
        <returns>
          <see langword="true" /> si la section actuelle doit être sérialisée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque section de configuration qui est créée pour le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] et versions ultérieures doivent substituer cette méthode et retourner explicitement `true`, mais uniquement si la section de configuration est valide pour la version spécifiée de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Les sections de configuration existants qui ont été créées pour les versions antérieures de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] n’avez pas à être modifié.  
  
 Le type de base contient une implémentation par défaut de cette méthode retourne toujours `true`. Si vous implémentez une section de configuration et vous ne substituez pas cette méthode, par défaut, la section de configuration sera sérialisée pour toutes les versions du framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>