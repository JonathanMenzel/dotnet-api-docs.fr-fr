<Type Name="EventProvider" FullName="System.Diagnostics.Eventing.EventProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2f32615c45696c5c008efcb41847f03582ff84be" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37665914" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventProvider : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventProvider extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Eventing.EventProvider" />
  <TypeSignature Language="VB.NET" Value="Public Class EventProvider&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventProvider : IDisposable" />
  <TypeSignature Language="F#" Value="type EventProvider = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Utilisez cette classe pour écrire des événements.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour consommer des événements écrits à l’aide de la <xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A> et <xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A> méthodes, les événements doivent être définies dans un manifeste ; événements écrits à l’aide de la <xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A> méthode ne requièrent pas de manifeste.  
  
 Événements peuvent contenir les types de données managées suivantes :  
  
-   bool  
  
-   Booléen  
  
-   byte  
  
-   char  
  
-   decimal  
  
-   double  
  
-   float  
  
-   GUID  
  
-   int  
  
-   IntPtr  
  
-   long  
  
-   sbyte  
  
-   short  
  
-   chaîne  
  
-   uint  
  
-   UInt64  
  
 Si un événement dans votre manifeste utilise le `Boolean` type, vous ne peut pas écrire l’élément de données en utilisant un `Boolean` type de données dans votre code managé. Le `Boolean` type dans votre manifeste attend une valeur de 4 octets et un `Boolean` type de données dans le code managé est 1 octet. Au lieu de cela, vous devez utiliser un `int` type de données pour écrire la valeur. Si vous souhaitez consigner un `Boolean` , utilisez le type dans votre manifeste UInt8.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProvider (Guid providerGuid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Guid providerGuid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.#ctor(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (providerGuid As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventProvider(Guid providerGuid);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Eventing.EventProvider : Guid -&gt; System.Diagnostics.Eventing.EventProvider" Usage="new System.Diagnostics.Eventing.EventProvider providerGuid" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="providerGuid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="providerGuid">Guid qui identifie de manière unique le fournisseur.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Diagnostics.Eventing.EventProvider" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inscrit le fournisseur. Pour supprimer l’inscription lorsque terminé, appelez le <xref:System.Diagnostics.Eventing.EventProvider.Close%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientMemoryException">La mémoire n'est pas suffisante pour terminer cette opération.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Les classes de l'espace de noms <see cref="N:System.Diagnostics.Eventing" /> ne fonctionnent que sous Windows Vista.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="providerGuid" /> ne peut pas être Null.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Erreur retournée par le sous-système ETW.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="eventProvider.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime l'inscription du fournisseur du sous-système ETW et diffuse toutes les ressources non managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez appeler cette méthode une fois au lieu d’attendre pour que le système dispose des ressources.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Erreur retournée par le sous-système ETW.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateActivityId">
      <MemberSignature Language="C#" Value="public static Guid CreateActivityId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid CreateActivityId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateActivityId () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid CreateActivityId();" />
      <MemberSignature Language="F#" Value="static member CreateActivityId : unit -&gt; Guid" Usage="System.Diagnostics.Eventing.EventProvider.CreateActivityId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un identificateur d'activité unique pour le fournisseur.</summary>
        <returns>Guid unique que vous utilisez lors de l'appel de la méthode <see cref="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" /> pour définir l'identificateur d'activité pour le fournisseur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s'agit d'une méthode statique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="eventProvider.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par cet objet <see cref="T:System.Diagnostics.Eventing.EventProvider" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="eventProvider.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Ce paramètre est ignoré par cette méthode, car il n’y a aucune ressource non managée.</param>
        <summary>Libère les ressources utilisées par cet objet <see cref="T:System.Diagnostics.Eventing.EventProvider" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~EventProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!EventProvider ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="eventProvider.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère des ressources et effectue un nettoyage interne avant que l’instance ne soit récupérée par le garbage collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteEventError">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Eventing.EventProvider.WriteEventErrorCode GetLastWriteEventError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Diagnostics.Eventing.EventProvider/WriteEventErrorCode GetLastWriteEventError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteEventError () As EventProvider.WriteEventErrorCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Eventing::EventProvider::WriteEventErrorCode GetLastWriteEventError();" />
      <MemberSignature Language="F#" Value="static member GetLastWriteEventError : unit -&gt; System.Diagnostics.Eventing.EventProvider.WriteEventErrorCode" Usage="System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Eventing.EventProvider+WriteEventErrorCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient la dernière erreur associée à une défaillance d'écriture d'un événement.</summary>
        <returns>Utilisez la valeur pour déterminer la cause d'une défaillance d'écriture d'un événement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A>, <xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A>, et <xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A> méthodes cette valeur si elles ne peuvent pas écrire l’événement.  
  
 Il s'agit d'une méthode statique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsEnabled">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si une session a activé le fournisseur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled();" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : unit -&gt; bool" Usage="eventProvider.IsEnabled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine si une session a activé le fournisseur, indépendamment des valeurs de niveau et de mot clé utilisées pour activer le fournisseur.</summary>
        <returns>A la valeur <see langword="true" /> si le fournisseur est activé sur une session ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, un fournisseur n’appelle pas cette méthode pour déterminer si le fournisseur a été activé par une session ; le fournisseur écrit simplement l’événement, et ETW détermine si l’événement est enregistré dans la session. Un fournisseur est utile d’appeler cette fonction si le fournisseur doit effectuer un travail supplémentaire pour générer l’événement. Dans ce cas, appeler cette fonction tout d’abord peut enregistrer les ressources et l’heure.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled (byte level, long keywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled(unsigned int8 level, int64 keywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled(System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled (level As Byte, keywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled(System::Byte level, long keywords);" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : byte * int64 -&gt; bool" Usage="eventProvider.IsEnabled (level, keywords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Byte" />
        <Parameter Name="keywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="level">Niveau de détail inclus dans l'événement.</param>
        <param name="keywords">Masque de bits qui spécifie la catégorie d’événement. Ce masque doit être le même masque de mot clé défini dans le manifeste de l'événement.</param>
        <summary>Détermine si une session demande l'événement spécifié au fournisseur.</summary>
        <returns>A la valeur <see langword="true" /> si une session demande l'événement spécifié ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, un fournisseur n’appelle pas cette méthode pour déterminer si une session a demandé l’événement spécifié ; le fournisseur écrit simplement l’événement, et ETW détermine si l’événement est enregistré dans une session. Un fournisseur est utile d’appeler cette fonction si le fournisseur doit effectuer un travail supplémentaire pour générer l’événement. Dans ce cas, appelez cette fonction tout d’abord pour déterminer si une session a demandé l’événement ou non, peut enregistrer les ressources et l’heure.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetActivityId">
      <MemberSignature Language="C#" Value="public static void SetActivityId (ref Guid id);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetActivityId(valuetype System.Guid&amp; id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetActivityId (ByRef id As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetActivityId(Guid % id);" />
      <MemberSignature Language="F#" Value="static member SetActivityId :  -&gt; unit" Usage="System.Diagnostics.Eventing.EventProvider.SetActivityId id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Guid&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="id">Identificateur d'activité unique que la méthode <see cref="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" /> retourne.</param>
        <summary>Définit l'identificateur d'activité actuel utilisé par les méthodes <see cref="Overload:System.Diagnostics.Eventing.EventProvider.WriteEvent" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’identificateur est stocké dans le contexte de thread.  
  
 Notez que dans la version 3.5 du .NET framework, vous deviez définir la `id` paramètre de cette méthode et la <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> valeur de propriété à la même valeur d’identificateur. Toutefois, dans la version 4.0 du framework, le <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> méthode définit automatiquement l’identificateur d’activité de corrélation pour vous.  
  
 Il s'agit d'une méthode statique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit un événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ces méthodes si vous utilisez un manifeste pour définir vos événements.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * obj[] -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, eventPayload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Instance de <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> qui identifie l'événement à écrire.</param>
        <param name="eventPayload">Tableau d'objets qui contient les données d'événement à écrire. L'objet doit être dans l'ordre spécifié dans le manifeste. Le tableau est limité à 32 objets, dont huit seulement peuvent être des chaînes. La taille maximale des données pour l'événement est limitée à 64 Ko, moins la taille des en-têtes de l'événement. La taille de l'événement est inférieure si la taille de la mémoire tampon de la session est inférieure et si la session inclut des éléments de données étendus à l'événement.  Ce paramètre peut avoir la valeur Null.</param>
        <summary>Écrit un événement. Les données d'événement sont spécifiées comme un tableau d'objets.</summary>
        <returns>A la valeur <see langword="true" /> si l'événement est écrit ; sinon, <see langword="false" />. Si la valeur est « false », appelez la méthode <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> pour déterminer la cause de l'échec.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous appelez le <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> méthode pour spécifier un identificateur d’activité pour l’événement, cette méthode récupère l’identificateur à partir du contexte de thread et l’inclut avec l’événement.  
  
 Si le type d’objet n’est pas pris en charge, la méthode écrit la valeur de l’objet <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode dans la charge utile. Pour obtenir la liste des types d’objets pris en charge, consultez les notes relatives à la <xref:System.Diagnostics.Eventing.EventProvider> classe.  
  
   
  
## Examples  
  
```  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
enum Keyword  
{  
    Read = 0x1,  
    Write = 0x2,  
    Local = 0x4,  
    Remote = 0x8  
}  
  
enum Level  
{  
    Critical = 1,  
    Error,  
    Warning,  
    Information,  
    Verbose  
}  
  
    EventProvider provider = new EventProvider(providerId);  
    EventDescriptor readEvent;  
    string path = @"<PATHGOESHERE>";  
    UInt64 bytesRead = <ASSIGNVALUE>;  
  
    if (provider.IsEnabled(Level.Information, (long)Keyword.Read))  
    {  
        unchecked  
        {  
            readEvent = new EventDescriptor(0x1, 0x0, 0x10, 0x4, 0x0, 0x0, (long)0x8000000000000005);  
        }  
  
        if (!provider.WriteEvent(ref readEvent, new object[] { path, bytesRead }))  
            Console.WriteLine(EventProvider.GetLastWriteEventError());  
    }  
  
    provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="eventPayload" /> contient trop d'objets ou chaînes.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, data As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, System::String ^ data);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * string -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Instance de <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> qui identifie l'événement à écrire.</param>
        <param name="data">Chaîne à écrire en tant que données de l'événement.</param>
        <summary>Écrit un événement. Les données de l'événement sont spécifiées comme une chaîne.</summary>
        <returns>A la valeur <see langword="true" /> si l'événement est écrit ; sinon, <see langword="false" />. Si la valeur est « false », appelez la méthode <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> pour déterminer la cause de l'échec.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous appelez le <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> méthode pour spécifier un identificateur d’activité pour l’événement, cette méthode récupère l’identificateur à partir du contexte de thread et l’inclut avec l’événement.  
  
 La longueur de chaîne maximale est limitée à 64 Ko, moins la taille des en-têtes de l’événement. La taille de l'événement est inférieure si la taille de la mémoire tampon de la session est inférieure et si la session inclut des éléments de données étendus à l'événement.  
  
   
  
## Examples  
  
```  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
EventProvider provider = new EventProvider(providerId);  
EventDescriptor writeEvent;  
  
if (provider.IsEnabled())  
{  
     unchecked  
     {  
          writeEvent = new EventDescriptor(0x2, 0x0, 0x10, 0x3, 0x0, 0x0, (long)0x8000000000000006);  
     }  
  
     if (!provider.WriteEvent(ref writeEvent, "Write event."))  
          Console.WriteLine(EventProvider.GetLastWriteEventError());  
}  
  
provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si <paramref name="data" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteEvent (ByRef eventDescriptor As EventDescriptor, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, int dataCount, IntPtr data);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * int * nativeint -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, dataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Instance de <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> qui identifie l'événement à écrire.</param>
        <param name="dataCount">Taille des données de l’événement sur lesquelles le paramètre <c>data</c> pointe. La taille maximale des données de l'événement est limitée à 64 Ko, moins la taille des en-têtes de l'événement. La taille de l'événement est inférieure si la taille de la mémoire tampon de la session est inférieure et si la session inclut des éléments de données étendus à l'événement.</param>
        <param name="data">Pointeur sur les données de l'événement à écrire.</param>
        <summary>Écrit un événement. Les données de l'événement sont spécifiées comme un bloc de mémoire.</summary>
        <returns>A la valeur <see langword="true" /> si l'événement est écrit ; sinon, <see langword="false" />. Si la valeur est « false », appelez la méthode <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> pour déterminer la cause de l'échec.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous appelez le <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> méthode pour spécifier un identificateur d’activité pour l’événement, cette méthode récupère l’identificateur à partir du contexte de thread et l’inclut avec l’événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteMessageEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit un événement qui contient une chaîne en guise de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces méthodes ne nécessitent pas d’un manifeste pour consommer l’événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage);" />
      <MemberSignature Language="F#" Value="member this.WriteMessageEvent : string -&gt; bool" Usage="eventProvider.WriteMessageEvent eventMessage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventMessage">Chaîne à écrire en tant que données de l'événement.</param>
        <summary>Écrit un événement qui contient une chaîne en guise de données.</summary>
        <returns>A la valeur <see langword="true" /> si l'événement est écrit ; sinon, <see langword="false" />. Si la valeur est « false », appelez la méthode <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> pour déterminer la cause de l'échec.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longueur de chaîne maximale est limitée à 64 Ko, moins la taille des en-têtes de l’événement. La taille de l'événement est inférieure si la taille de la mémoire tampon de la session est inférieure et si la session inclut des éléments de données étendus à l'événement.  
  
   
  
## Examples  
  
```  
if (!provider.WriteMessageEvent("Event string."))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si <paramref name="eventMessage" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage, byte eventLevel, long eventKeywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage, unsigned int8 eventLevel, int64 eventKeywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String, eventLevel As Byte, eventKeywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage, System::Byte eventLevel, long eventKeywords);" />
      <MemberSignature Language="F#" Value="member this.WriteMessageEvent : string * byte * int64 -&gt; bool" Usage="eventProvider.WriteMessageEvent (eventMessage, eventLevel, eventKeywords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
        <Parameter Name="eventLevel" Type="System.Byte" />
        <Parameter Name="eventKeywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="eventMessage">Chaîne à écrire en tant que données de l'événement.</param>
        <param name="eventLevel">Niveau de détail inclus dans l'événement. Si le fournisseur utilise un manifeste pour définir l'événement, définissez cette valeur au même niveau défini dans le manifeste.</param>
        <param name="eventKeywords">Masque de bits qui spécifie la catégorie d’événement. Si le fournisseur utilise un manifeste pour définir l'événement, définissez cette valeur au même masque de mot clé défini dans le manifeste.</param>
        <summary>Écrit un événement qui contient une chaîne en guise de données si la valeur de niveau et de mot clé correspond aux événements demandés par la session.</summary>
        <returns>A la valeur <see langword="true" /> si l'événement est écrit ; sinon, <see langword="false" />. Si la valeur est « false », appelez la méthode <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> pour déterminer la cause de l'échec.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longueur de chaîne maximale est limitée à 64 Ko, moins la taille des en-têtes de l’événement. La taille de l'événement est inférieure si la taille de la mémoire tampon de la session est inférieure et si la session inclut des éléments de données étendus à l'événement.  
  
   
  
## Examples  
  
```  
// Calling this method with level and keyword set to zero is the same  
// as calling WriteMessageEvent(string); the event is always written.  
if (!provider.WriteMessageEvent("Event string.", 0, 0))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
  
// Event is written if the level value of the session is less than or equal to 3, and bit 1 of the session  
// keyword bit-mask is set.  
if (!provider.WriteMessageEvent("Event string.", 3, 2))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si <paramref name="eventMessage" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteTransferEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lie des événements lors du traçage d'événements dans un scénario de bout en bout.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="public bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberSignature Language="F#" Value="member this.WriteTransferEvent :  * Guid * obj[] -&gt; bool" Usage="eventProvider.WriteTransferEvent (eventDescriptor, relatedActivityId, eventPayload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Instance de <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> qui identifie l'événement à écrire.</param>
        <param name="relatedActivityId">Identificateur d'activité du composant précédent. Utilisez ce paramètre pour lier les événements de votre composant aux événements du composant précédent.</param>
        <param name="eventPayload">Tableau d'objets qui contient les données d'événement à écrire. Les données doivent être dans l'ordre spécifié dans le manifeste. Le tableau est limité à 32 objets, dont huit seulement peuvent être des chaînes. La taille maximale des données pour l'événement est limitée à 64 Ko, moins la taille des en-têtes de l'événement. La taille de l'événement est inférieure si la taille de la mémoire tampon de la session est inférieure et si la session inclut des éléments de données étendus à l'événement.</param>
        <summary>Lie des événements lors du traçage d'événements dans un scénario de bout en bout. Les données d'événement sont spécifiées comme un tableau d'objets.</summary>
        <returns>A la valeur <see langword="true" /> si l'événement est écrit ; sinon, <see langword="false" />. Si la valeur est « false », appelez la méthode <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> pour déterminer la cause de l'échec.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode utilise l’ID d’activité défini dans le contexte de thread pour identifier ce composant. Pour définir l’ID d’activité, appelez le <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> (méthode).  
  
 Si vous utilisez le <xref:System.Diagnostics.Trace> (classe), vous n’utilisez pas le <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> méthode pour spécifier l’ID d’activité. Accéder à la place, le <xref:System.Diagnostics.Trace.CorrelationManager%2A> propriété à obtenir le <xref:System.Diagnostics.CorrelationManager> objet. Ensuite, définissez le <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> propriété à l’ID d’activité. Vous devez également définir le `relatedActivityId` à un <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> valeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si <paramref name="eventPayload" /> contient trop d'objets ou chaînes.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="protected bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberSignature Language="F#" Value="member this.WriteTransferEvent :  * Guid * int * nativeint -&gt; bool" Usage="eventProvider.WriteTransferEvent (eventDescriptor, relatedActivityId, dataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Instance de <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> qui identifie l'événement à écrire.</param>
        <param name="relatedActivityId">Identificateur d'activité du composant précédent. Utilisez ce paramètre pour lier les événements de votre composant aux événements du composant précédent.</param>
        <param name="dataCount">Taille des données de l’événement sur lesquelles le paramètre <c>data</c> pointe. La taille maximale des données de l'événement est limitée à 64 Ko, moins la taille des en-têtes de l'événement. La taille de l'événement est inférieure si la taille de la mémoire tampon de la session est inférieure et si la session inclut des éléments de données étendus à l'événement.</param>
        <param name="data">Pointeur sur les données de l'événement à écrire.</param>
        <summary>Lie des événements lors du traçage d'événements dans un scénario de bout en bout. Les données de l'événement sont spécifiées comme un bloc de mémoire.</summary>
        <returns>A la valeur <see langword="true" /> si l'événement est écrit ; sinon, <see langword="false" />. Si la valeur est « false », appelez la méthode <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> pour déterminer la cause de l'échec.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode utilise l’ID d’activité défini dans le contexte de thread pour identifier ce composant. Pour définir l’ID d’activité, appelez le <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>