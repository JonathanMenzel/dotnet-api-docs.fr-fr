<Type Name="DataflowBlock" FullName="System.Threading.Tasks.Dataflow.DataflowBlock">
  <Metadata><Meta Name="ms.openlocfilehash" Value="619c37dae0d34137464488ce19920259b14fa058" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39758896" /></Metadata><TypeSignature Language="C#" Value="public static class DataflowBlock" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit DataflowBlock extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.DataflowBlock" />
  <TypeSignature Language="VB.NET" Value="Public Module DataflowBlock" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataflowBlock abstract sealed" />
  <TypeSignature Language="F#" Value="type DataflowBlock = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit un ensemble de méthodes statiques (Shared en Visual Basic) pour utiliser des blocs de flux de données.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AsObservable&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IObservable&lt;TOutput&gt; AsObservable&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IObservable`1&lt;!!TOutput&gt; AsObservable&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObservable``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsObservable(Of TOutput) (source As ISourceBlock(Of TOutput)) As IObservable(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IObservable&lt;TOutput&gt; ^ AsObservable(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsObservable : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; IObservable&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.AsObservable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IObservable&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Spécifie le type de données contenu dans la source.</typeparam>
        <param name="source">Source à inclure dans un wrapper.</param>
        <summary>Crée une abstraction <see cref="T:System.IObservable`1" /> sur <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
        <returns><see cref="T:System.IObservable`1" /> qui permet aux observateurs de s'abonner à la source.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsObserver&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static IObserver&lt;TInput&gt; AsObserver&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IObserver`1&lt;!!TInput&gt; AsObserver&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObserver``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsObserver(Of TInput) (target As ITargetBlock(Of TInput)) As IObserver(Of TInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IObserver&lt;TInput&gt; ^ AsObserver(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target);" />
      <MemberSignature Language="F#" Value="static member AsObserver : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; -&gt; IObserver&lt;'Input&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.AsObserver target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IObserver&lt;TInput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Spécifie le type d'entrée accepté par le bloc cible.</typeparam>
        <param name="target">Cible à encapsuler.</param>
        <summary>Crée une abstraction <see cref="T:System.IObserver`1" /> sur <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
        <returns>Observateur qui encapsule le bloc cible.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose(Of T1, T2) (source1 As ISourceBlock(Of T1), action1 As Action(Of T1), source2 As ISourceBlock(Of T2), action2 As Action(Of T2)) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Spécifie le type de données contenu dans la première source.</typeparam>
        <typeparam name="T2">Spécifie le type de données contenu dans la deuxième source.</typeparam>
        <param name="source1">Première source.</param>
        <param name="action1">Gestionnaire à exécuter sur les données de la première source.</param>
        <param name="source2">Deuxième source.</param>
        <param name="action2">Gestionnaire à exécuter sur les données de la deuxième source.</param>
        <summary>Surveille deux sources de flux de données, en appelant le gestionnaire fourni pour toute source qui rend les données disponibles en premier.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> qui représente le choix asynchrone. Si les deux sources sont terminées avant d'avoir effectué un choix, la tâche résultante est annulée. Lorsque l'une des sources a des données disponibles et les propage avec succès au choix, la tâche résultante s'achève lorsque le gestionnaire se termine. Si le gestionnaire lève une exception, la tâche se termine à l'état <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> et contiendra l'exception non gérée. Sinon, la tâche se termine avec son <see cref="P:System.Threading.Tasks.Task`1.Result" /> défini sur 0 ou 1 pour représenter la première ou la deuxième source, respectivement.  
  
Cette méthode consommera un seul élément de l'une des deux sources de données, jamais les deux.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="action1" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="source2" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="action2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.DataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::DataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.DataflowBlockOptions -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, dataflowBlockOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.DataflowBlockOptions" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Spécifie le type de données contenu dans la première source.</typeparam>
        <typeparam name="T2">Spécifie le type de données contenu dans la deuxième source.</typeparam>
        <param name="source1">Première source.</param>
        <param name="action1">Gestionnaire à exécuter sur les données de la première source.</param>
        <param name="source2">Deuxième source.</param>
        <param name="action2">Gestionnaire à exécuter sur les données de la deuxième source.</param>
        <param name="dataflowBlockOptions">Options permettant de configurer ce choix.</param>
        <summary>Surveille deux sources de flux de données, en appelant le gestionnaire fourni pour toute source qui rend les données disponibles en premier.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> qui représente le choix asynchrone. Si les deux sources sont terminées avant d'avoir effectué un choix, ou si le <see cref="T:System.Threading.CancellationToken" /> fourni dans le cadre des <paramref name="dataflowBlockOptions" /> est annulé avant d'avoir effectué un choix, la tâche résultante est annulée. Lorsque l'une des sources a des données disponibles et les propage avec succès au choix, la tâche résultante s'achève lorsque le gestionnaire se termine. Si le gestionnaire lève une exception, la tâche se termine à l'état <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> et contiendra l'exception non gérée. Sinon, la tâche se termine avec son <see cref="P:System.Threading.Tasks.Task`1.Result" /> défini sur 0 ou 1 pour représenter la première ou la deuxième source, respectivement.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="action1" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="source2" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="action2" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="dataflowBlockOptions" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2,T3&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt; source3, Action&lt;T3&gt; action3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2, T3&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T3&gt; source3, class System.Action`1&lt;!!T3&gt; action3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2})" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose(Of T1, T2, T3) (source1 As ISourceBlock(Of T1), action1 As Action(Of T1), source2 As ISourceBlock(Of T2), action2 As Action(Of T2), source3 As ISourceBlock(Of T3), action3 As Action(Of T3)) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T3&gt; ^ source3, Action&lt;T3&gt; ^ action3);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T3&gt; * Action&lt;'T3&gt; -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, source3, action3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt;" />
        <Parameter Name="action3" Type="System.Action&lt;T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Spécifie le type de données contenu dans la première source.</typeparam>
        <typeparam name="T2">Spécifie le type de données contenu dans la deuxième source.</typeparam>
        <typeparam name="T3">Spécifie le type de données contenu dans la troisième source.</typeparam>
        <param name="source1">Première source.</param>
        <param name="action1">Gestionnaire à exécuter sur les données de la première source.</param>
        <param name="source2">Deuxième source.</param>
        <param name="action2">Gestionnaire à exécuter sur les données de la deuxième source.</param>
        <param name="source3">Troisième source.</param>
        <param name="action3">Gestionnaire à exécuter sur les données de la troisième source.</param>
        <summary>Surveille trois sources de flux de données, en appelant le gestionnaire fourni pour toute source qui rend les données disponibles en premier.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> qui représente le choix asynchrone. Si toutes les sources sont terminées avant d'avoir effectué un choix, la tâche résultante est annulée. Lorsque l'une des sources a des données disponibles et les propage avec succès au choix, la tâche résultante s'achève lorsque le gestionnaire se termine. Si le gestionnaire lève une exception, la tâche se termine à l'état <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> et contiendra l'exception non gérée. Sinon, la tâche se termine avec son <see cref="P:System.Threading.Tasks.Task`1.Result" /> défini sur l'index de base 0 de la source.  
  
Cette méthode consommera un seul élément de l'une des sources de données, jamais plusieurs.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="action1" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="source2" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="action2" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="source3" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="action3" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2,T3&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt; source3, Action&lt;T3&gt; action3, System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2, T3&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T3&gt; source3, class System.Action`1&lt;!!T3&gt; action3, class System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2},System.Threading.Tasks.Dataflow.DataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T3&gt; ^ source3, Action&lt;T3&gt; ^ action3, System::Threading::Tasks::Dataflow::DataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T3&gt; * Action&lt;'T3&gt; * System.Threading.Tasks.Dataflow.DataflowBlockOptions -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, source3, action3, dataflowBlockOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt;" />
        <Parameter Name="action3" Type="System.Action&lt;T3&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.DataflowBlockOptions" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Spécifie le type de données contenu dans la première source.</typeparam>
        <typeparam name="T2">Spécifie le type de données contenu dans la deuxième source.</typeparam>
        <typeparam name="T3">Spécifie le type de données contenu dans la troisième source.</typeparam>
        <param name="source1">Première source.</param>
        <param name="action1">Gestionnaire à exécuter sur les données de la première source.</param>
        <param name="source2">Deuxième source.</param>
        <param name="action2">Gestionnaire à exécuter sur les données de la deuxième source.</param>
        <param name="source3">Troisième source.</param>
        <param name="action3">Gestionnaire à exécuter sur les données de la troisième source.</param>
        <param name="dataflowBlockOptions">Options permettant de configurer ce choix.</param>
        <summary>Surveille trois sources de flux de données, en appelant le gestionnaire fourni pour toute source qui rend les données disponibles en premier.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> qui représente le choix asynchrone. Si toutes les sources sont terminées avant d'avoir effectué un choix, ou si le <see cref="T:System.Threading.CancellationToken" /> fourni dans le cadre des <paramref name="dataflowBlockOptions" /> est annulé avant d'avoir effectué un choix, la tâche résultante est annulée. Lorsque l'une des sources a des données disponibles et les propage avec succès au choix, la tâche résultante s'achève lorsque le gestionnaire se termine. Si le gestionnaire lève une exception, la tâche se termine à l'état <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> et contiendra l'exception non gérée. Sinon, la tâche se termine avec son <see cref="P:System.Threading.Tasks.Task`1.Result" /> défini sur l'index de base 0 de la source.  
  
Cette méthode consommera un seul élément de l'une des sources de données, jamais plusieurs. Si l'annulation est demandée une fois qu'un élément a été reçu, la demande d'annulation est ignorée, et le gestionnaire approprié est autorisé à s'exécuter.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="action1" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="source2" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="action2" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="source3" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="action3" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="dataflowBlockOptions" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encapsulate&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;TInput,TOutput&gt; Encapsulate&lt;TInput,TOutput&gt; (System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Dataflow.IPropagatorBlock`2&lt;!!TInput, !!TOutput&gt; Encapsulate&lt;TInput, TOutput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate``2(System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function Encapsulate(Of TInput, TOutput) (target As ITargetBlock(Of TInput), source As ISourceBlock(Of TOutput)) As IPropagatorBlock(Of TInput, TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static System::Threading::Tasks::Dataflow::IPropagatorBlock&lt;TInput, TOutput&gt; ^ Encapsulate(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Encapsulate : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;'Input, 'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate (target, source)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;TInput,TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" />
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Spécifie le type d'entrée attendu par la cible.</typeparam>
        <typeparam name="TOutput">Spécifie le type de sortie produit par la source.</typeparam>
        <param name="target">Cible à encapsuler.</param>
        <param name="source">Source à encapsuler.</param>
        <summary>Encapsule une cible et une source dans un propagateur unique.</summary>
        <returns>Cible et source encapsulées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> méthode requiert deux blocs existants : un bloc cible (une instance d’une classe qui implémente <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>) et un bloc source (une instance d’une classe qui implémente <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>). <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> Crée une nouvelle instance d’une classe interne qui se connecte le <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> aux membres de l’interface le `target` paramètre et le <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> aux membres de l’interface le `source` paramètre.  Les deux <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> et <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> dérivent <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>. Achèvement du bloc soit passée explicitement à partir de sources aux cibles. Par conséquent, le <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> et <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> méthodes sont connectés à la cible lors de la <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> propriété est connectée à la source.  Vous devez vous assurer qu’au moment où la cible moitié terminé, la source de moitié obtient terminé de la manière la plus appropriée ; par exemple :  
  
 `target.Completion.ContinueWith(completion => source.Complete());`  
  
 Ou, si vous souhaitez propager le type de saisie semi-automatique, vous pouvez utiliser ce code plus complexe :  
  
```  
target.Completion.ContinueWith(completion => { if (completion.IsFaulted)    
  
((IDataflowBlock)batchBlock).Fault(completion.Exception);   
else   
batchBlock.Complete();   
});  
  
```  
  
 Vous devez fournir explicitement la propagation de messages à partir de la cible à la source. L’avantage de cette connexion explicite est qu’il vous donne la liberté d’effectuer tout traitement sans contrainte entre les deux blocs encapsulés. Vous pouvez le faire que par l’encodage du traitement nécessaire dans les délégués des blocs (si les blocs de prennent des délégués), ou en incorporant un sous-réseau de blocs entre eux. Le plus simple consiste à utiliser un bloc qui prend des délégués ; par exemple, utilisez <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> (le cas échéant), ou un bloc personnalisé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Spécifie le type de données contenu dans la source.</typeparam>
        <param name="source">Source à partir de laquelle effectuer la liaison.</param>
        <param name="target"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> auquel connecter la source.</param>
        <summary>Lie le <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> au <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> spécifié.</summary>
        <returns><see cref="T:System.IDisposable" /> qui, en appelant <see langword="Dispose" />, dissocie la source de la cible.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="target" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target, Predicate&lt;TOutput&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target, class System.Predicate`1&lt;!!TOutput&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput), predicate As Predicate(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target, Predicate&lt;TOutput&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * Predicate&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Spécifie le type de données contenu dans la source.</typeparam>
        <param name="source">Source à partir de laquelle effectuer la liaison.</param>
        <param name="target"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> auquel connecter la source.</param>
        <param name="predicate">Filtre qu'un message doit respecter pour être propagé de la source à la cible.</param>
        <summary>Lie le <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> au <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> spécifié à l’aide du filtre spécifié.</summary>
        <returns><see cref="T:System.IDisposable" /> qui, en appelant <see langword="Dispose" />, dissocie la source de la cible.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="target" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions, Predicate&lt;TOutput&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions, class System.Predicate`1&lt;!!TOutput&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.DataflowLinkOptions,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput), linkOptions As DataflowLinkOptions, predicate As Predicate(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions, Predicate&lt;TOutput&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions * Predicate&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target, linkOptions, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
        <Parameter Name="predicate" Type="System.Predicate&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Spécifie le type de données contenu dans la source.</typeparam>
        <param name="source">Source à partir de laquelle effectuer la liaison.</param>
        <param name="target"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> auquel connecter la source.</param>
        <param name="linkOptions">L'une des valeurs d'énumération qui spécifie comment configurer un lien entre les blocs de flux de données.</param>
        <param name="predicate">Filtre qu'un message doit respecter pour être propagé de la source à la cible.</param>
        <summary>Lie le <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> au <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> spécifié à l’aide du filtre spécifié.</summary>
        <returns><see cref="T:System.IDisposable" /> qui, en appelant <see langword="Dispose" />, dissocie la source de la cible.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> est Null (Nothing en Visual Basic).  
  
- ou - 
<paramref name="target" /> est Null (Nothing en Visual Basic).  
  
- ou - 
<paramref name="linkOptions" /> est Null (Nothing en Visual Basic).  
  
- ou - 
<paramref name="predicate" /> est Null (Nothing en Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="NullTarget&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; NullTarget&lt;TInput&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; NullTarget&lt;TInput&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.NullTarget``1" />
      <MemberSignature Language="VB.NET" Value="Public Function NullTarget(Of TInput) () As ITargetBlock(Of TInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA; static System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ NullTarget();" />
      <MemberSignature Language="F#" Value="static member NullTarget : unit -&gt; System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.NullTarget " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TInput">Type des messages que ce bloc peut accepter.</typeparam>
        <summary>Obtient un bloc cible qui reçoit de façon synchrone tous les messages fournis à ce dernier et les supprime.</summary>
        <returns><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> qui reçoit et dépose ensuite tous les messages transmis.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputAvailableAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OutputAvailableAsync(Of TOutput) (source As ISourceBlock(Of TOutput)) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ OutputAvailableAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member OutputAvailableAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Spécifie le type de données contenu dans la source.</typeparam>
        <param name="source">Source à surveiller.</param>
        <summary>Fournit un <see cref="T:System.Threading.Tasks.Task`1" /> qui surveille de façon asynchrone la source de la sortie disponible.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> qui avertit si une sortie supplémentaire sera disponible et quand. Si, lorsque la tâche se termine, son <see cref="P:System.Threading.Tasks.Task`1.Result" /> a la valeur <see langword="true" />, une sortie supplémentaire sera disponible dans la source (même si un autre consommateur de la source peut récupérer les données).  
  
Si elle retourne <see langword="false" />, une sortie supplémentaire n'est pas et ne sera jamais disponible, en raison d'une source qui se termine avant la disponibilité de la sortie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputAvailableAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ OutputAvailableAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member OutputAvailableAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Spécifie le type de données contenu dans la source.</typeparam>
        <param name="source">Source à surveiller.</param>
        <param name="cancellationToken">Jeton d'annulation utilisé pour annuler l'opération asynchrone.</param>
        <summary>Fournit un <see cref="T:System.Threading.Tasks.Task`1" /> qui surveille de façon asynchrone la source de la sortie disponible.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> qui avertit si une sortie supplémentaire sera disponible et quand. Si, lorsque la tâche se termine, son <see cref="P:System.Threading.Tasks.Task`1.Result" /> a la valeur <see langword="true" />, une sortie supplémentaire sera disponible dans la source (même si un autre consommateur de la source peut récupérer les données). Si elle retourne <see langword="false" />, une sortie supplémentaire n'est pas et ne sera jamais disponible, en raison d'une source qui se termine avant la disponibilité de la sortie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Post&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static bool Post&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Post&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Post``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Post(Of TInput) (target As ITargetBlock(Of TInput), item As TInput) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Post(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item);" />
      <MemberSignature Language="F#" Value="static member Post : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input -&gt; bool" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Post (target, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Spécifie le type de données accepté par le bloc cible.</typeparam>
        <param name="target">Bloc cible.</param>
        <param name="item">Élément qui est proposé à la cible.</param>
        <summary>Publie un élément à <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
        <returns><see langword="true" /> si l'élément a été accepté par le bloc cible ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retournera une fois que le bloc cible a décidé d’accepter ou refuser l’élément, mais à moins que sinon dictées par une sémantique spéciale du bloc cible, il n’attend pas de l’élément à être traitée. Par exemple, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> retournera de <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> dès qu’il a stocké l’élément posté dans sa file d’attente d’entrée). Du point de vue du traitement du bloc, `Post` est asynchrone. Pour la cible bloque ce report de la prise en charge de messages proposés ou pour les blocs qui peuvent effectuer un traitement plus dans leur `Post` implémentation, envisagez d’utiliser <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A>, qui est retournée immédiatement et activera la cible de reporter le message publié et le consommer ultérieurement après `SendAsync` retourne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Receive(Of TOutput) (source As ISourceBlock(Of TOutput)) As TOutput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Le type des données contenues dans la source.</typeparam>
        <param name="source">La source à partir de laquelle recevoir la valeur.</param>
        <summary>Reçoit de façon synchrone une valeur d'une source spécifiée.</summary>
        <returns>La valeur reçue.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun élément n'a pu être accepté par la source.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Le type des données contenues dans la source.</typeparam>
        <param name="source">La source à partir de laquelle recevoir la valeur.</param>
        <param name="cancellationToken">Le jeton à utiliser pour annuler l'opération de réception.</param>
        <summary>Reçoit de façon synchrone une valeur d'une source spécifiée et fournit un jeton pour annuler l'opération.</summary>
        <returns>La valeur reçue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la source proposé avec succès un élément qui a été reçu par cette opération, cet élément est retourné même si une demande d’annulation simultanées se produit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun élément n'a pu être accepté par la source.</exception>
        <exception cref="T:System.OperationCanceledException">L'opération a été annulée avant la réception d'un élément depuis la source.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Receive(Of TOutput) (source As ISourceBlock(Of TOutput), timeout As TimeSpan) As TOutput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Le type des données contenues dans la source.</typeparam>
        <param name="source">La source à partir de laquelle recevoir la valeur.</param>
        <param name="timeout">Intervalle de temps maximum, en millisecondes, à attendre pour que l'exécution synchrone se termine, ou intervalle qui représente -1 milliseconde pour attendre indéfiniment.</param>
        <summary>Reçoit de façon synchrone une valeur d'une source spécifiée, en observant un délai d'attente facultatif.</summary>
        <returns>La valeur reçue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la source proposé avec succès un élément qui a été reçu par cette opération, cet élément est retourné même si un délai d’attente simultanée se produit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d'attente infini.  
  
- ou - 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun élément n'a pu être accepté par la source.</exception>
        <exception cref="T:System.TimeoutException">Le délai d'attente spécifié a expiré avant la réception d'un élément en provenance de la source.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan * System.Threading.CancellationToken -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Le type des données contenues dans la source.</typeparam>
        <param name="source">La source à partir de laquelle recevoir la valeur.</param>
        <param name="timeout">Intervalle de temps maximum, en millisecondes, à attendre pour que l'exécution synchrone se termine, ou intervalle qui représente -1 milliseconde pour attendre indéfiniment.</param>
        <param name="cancellationToken">Le jeton à utiliser pour annuler l'opération de réception.</param>
        <summary>Reçoit de façon synchrone une valeur d'une source spécifiée, en fournissant un jeton pour annuler l'opération et en observant un délai d'attente facultatif.</summary>
        <returns>La valeur reçue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la source proposé avec succès une valeur de l’élément qui a été reçue par cette opération, cette valeur est retournée, même en cas d’une demande d’annulation ou de délai d’attente simultanée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d'attente infini.  
  
- ou - 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun élément n'a pu être accepté par la source.</exception>
        <exception cref="T:System.TimeoutException">Le délai d'attente spécifié a expiré avant la réception d'un élément en provenance de la source.</exception>
        <exception cref="T:System.OperationCanceledException">L'opération a été annulée avant la réception d'un élément depuis la source.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReceiveAsync(Of TOutput) (source As ISourceBlock(Of TOutput)) As Task(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Le type des données contenues dans la source.</typeparam>
        <param name="source">La source à partir de laquelle recevoir la valeur.</param>
        <summary>Reçoit de façon asynchrone une valeur d'une source spécifiée.</summary>
        <returns>Tâche qui représente l'opération de réception asynchrone. Lorsqu'une valeur d'élément est reçue avec succès depuis la source, la tâche retournée est exécutée et son <see cref="P:System.Threading.Tasks.Task`1.Result" /> retourne la valeur reçue. Si la valeur d’un élément ne peut pas être récupérée car la source est vide et terminée, une exception <see cref="T:System.InvalidOperationException" /> est levée dans la tâche retournée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Spécifie le type de données contenu dans la source.</typeparam>
        <param name="source">La source à partir de laquelle recevoir la valeur.</param>
        <param name="cancellationToken">Le jeton à utiliser pour annuler l'opération de réception.</param>
        <summary>Accepte de façon asynchrone une valeur d'une source spécifiée et fournit un jeton pour annuler l'opération.</summary>
        <returns>Tâche qui représente l'opération de réception asynchrone. Lorsqu'une valeur est correctement reçue de la source, la tâche retournée est terminée et son <see cref="P:System.Threading.Tasks.Task`1.Result" /> retourne la valeur. Si une valeur ne peut pas être récupérée parce que l'annulation a été demandée, la tâche retournée est annulée. Si la valeur ne peut pas être récupérée car la source est vide et terminée, une exception <see cref="T:System.InvalidOperationException" /> est levée dans la tâche retournée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReceiveAsync(Of TOutput) (source As ISourceBlock(Of TOutput), timeout As TimeSpan) As Task(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Le type des données contenues dans la source.</typeparam>
        <param name="source">La source à partir de laquelle recevoir la valeur.</param>
        <param name="timeout">Intervalle de temps maximum, en millisecondes, à attendre pour que l'exécution synchrone se termine, ou intervalle qui représente -1 milliseconde pour attendre indéfiniment.</param>
        <summary>Reçoit de façon asynchrone une valeur d'une source spécifiée, en observant un délai d'attente facultatif.</summary>
        <returns>Tâche qui représente l'opération de réception asynchrone. Lorsqu'une valeur est correctement reçue de la source, la tâche retournée est terminée et son <see cref="P:System.Threading.Tasks.Task`1.Result" /> retourne la valeur. Si une valeur ne peut pas être récupérée car le délai d'attente a expiré, la tâche retournée est annulée. Si la valeur ne peut pas être récupérée car la source est vide et terminée, une exception <see cref="T:System.InvalidOperationException" /> est levée dans la tâche retournée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d'attente infini.  
  
- ou - 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Le type des données contenues dans la source.</typeparam>
        <param name="source">La source à partir de laquelle recevoir la valeur.</param>
        <param name="timeout">Intervalle de temps maximum, en millisecondes, à attendre pour que l'exécution synchrone se termine, ou intervalle qui représente -1 milliseconde pour attendre indéfiniment.</param>
        <param name="cancellationToken">Le jeton pouvant être utilisé pour annuler l'opération de réception.</param>
        <summary>Reçoit de façon asynchrone une valeur d'une source spécifiée, en fournissant un jeton pour annuler l'opération et en observant un délai d'attente facultatif.</summary>
        <returns>Tâche qui représente l'opération de réception asynchrone. Lorsqu'une valeur est correctement reçue de la source, la tâche retournée est terminée et son <see cref="P:System.Threading.Tasks.Task`1.Result" /> retourne la valeur. Si une valeur ne peut pas être récupérée parce que le délai d'attente a expiré ou l'annulation a été demandée, la tâche retournée est annulée. Si la valeur ne peut pas être récupérée parce que la source est vide et terminée, une exception <see cref="T:System.InvalidOperationException" /> est levée dans la tâche retournée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d'attente infini.  
  
- ou - 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; SendAsync&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; SendAsync&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SendAsync(Of TInput) (target As ITargetBlock(Of TInput), item As TInput) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ SendAsync(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item);" />
      <MemberSignature Language="F#" Value="static member SendAsync : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync (target, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Spécifie le type des données à publier sur la cible.</typeparam>
        <param name="target">Cible dans laquelle publier les données.</param>
        <param name="item">Élément qui est proposé à la cible.</param>
        <summary>Propose de façon asynchrone un message au bloc de message cible, en autorisant l'ajournement.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> qui représente l'envoi asynchrone. Si la cible accepte et consomme l'élément proposé pendant l'appel à <see cref="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />, au retour de l'appel la <see cref="T:System.Threading.Tasks.Task`1" /> résultante sera terminée et sa propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> retournera la valeur <see langword="true" />. Si la cible refuse l'élément proposé pendant l'appel, au retour de l'appel la <see cref="T:System.Threading.Tasks.Task`1" /> résultante sera terminée et sa propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> retournera la valeur <see langword="false" />. Si la cible diffère l'élément proposé, l'élément sera mis en mémoire tampon jusqu'au moment où la cible le consomme ou le libère. À ce moment-là, la tâche se terminera, avec son <see cref="P:System.Threading.Tasks.Task`1.Result" /> indiquant si le message a été consommé. Si la cible n'essaie jamais de consommer ou de libérer le message, la tâche retournée ne se terminera jamais.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; SendAsync&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; SendAsync&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ SendAsync(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member SendAsync : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync (target, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Spécifie le type des données à publier sur la cible.</typeparam>
        <param name="target">Cible dans laquelle publier les données.</param>
        <param name="item">Élément qui est proposé à la cible.</param>
        <param name="cancellationToken">Jeton d'annulation utilisé pour demander l'annulation de l'opération d'envoi.</param>
        <summary>Propose de façon asynchrone un message au bloc de message cible, en autorisant l'ajournement.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> qui représente l'envoi asynchrone.  Si la cible accepte et consomme l’élément proposé pendant l’appel à SendAsync, au retour de l’appel la <see cref="T:System.Threading.Tasks.Task`1" /> résultante est terminée et sa propriété <c>Result</c> retourne la valeur true.  Si la cible refuse l’élément proposé pendant l’appel, au retour de l’appel la <see cref="T:System.Threading.Tasks.Task`1" /> résultante est terminée et sa propriété <c>Result</c> retourne la valeur false. Si la cible diffère l’élément proposé, l’élément est mis en mémoire tampon jusqu’au moment où la cible le consomme ou le libère. À ce moment-là, la tâche se termine, avec son <c>Result</c> indiquant si le message a été consommé. Si la cible n'essaie jamais de consommer ou de libérer le message, la tâche retournée ne se terminera jamais.  
  
Si l'annulation est demandée avant que la cible n'ait consommé avec succès les données envoyées, la tâche retournée se terminera à l'état d'annulation et les données ne seront plus disponibles pour la cible.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> est Null (Nothing en Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReceive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static bool TryReceive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;TOutput&gt; source, out TOutput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReceive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;!!TOutput&gt; source, [out] !!TOutput&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive``1(System.Threading.Tasks.Dataflow.IReceivableSourceBlock{``0},``0@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryReceive(Of TOutput) (source As IReceivableSourceBlock(Of TOutput), ByRef item As TOutput) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryReceive(System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;TOutput&gt; ^ source, [Runtime::InteropServices::Out] TOutput % item);" />
      <MemberSignature Language="F#" Value="static member TryReceive : System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;'Output&gt; *  -&gt; bool" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive (source, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="item" Type="TOutput" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Spécifie le type de données contenu dans la source.</typeparam>
        <param name="source">Source de réception.</param>
        <param name="item">Élément envoyé à partir de la source.</param>
        <summary>Tente de recevoir de façon synchrone un élément de <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
        <returns><see langword="true" /> si un élément peut être reçu ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’attend pas la source a un élément à fournir.  
  
 Elle retournera un élément était disponible ou non.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>