<Type Name="TcpChannel" FullName="System.Runtime.Remoting.Channels.Tcp.TcpChannel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="32b5828db7b603dda96c6132e1fa1ff4ff90276e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36631790" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TcpChannel : System.Runtime.Remoting.Channels.IChannel, System.Runtime.Remoting.Channels.IChannelReceiver, System.Runtime.Remoting.Channels.IChannelSender, System.Runtime.Remoting.Channels.ISecurableChannel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpChannel extends System.Object implements class System.Runtime.Remoting.Channels.IChannel, class System.Runtime.Remoting.Channels.IChannelReceiver, class System.Runtime.Remoting.Channels.IChannelSender, class System.Runtime.Remoting.Channels.ISecurableChannel" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpChannel&#xA;Implements IChannel, IChannelReceiver, IChannelSender, ISecurableChannel" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpChannel : System::Runtime::Remoting::Channels::IChannel, System::Runtime::Remoting::Channels::IChannelReceiver, System::Runtime::Remoting::Channels::IChannelSender, System::Runtime::Remoting::Channels::ISecurableChannel" />
  <TypeSignature Language="F#" Value="type TcpChannel = class&#xA;    interface IChannelReceiver&#xA;    interface IChannel&#xA;    interface IChannelSender&#xA;    interface ISecurableChannel" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Remoting</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Channels.IChannel</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Channels.IChannelReceiver</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Channels.IChannelSender</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Channels.ISecurableChannel</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit une implémentation de canal qui utilise le protocole TCP pour transmettre des messages.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Canaux de transportent des messages au-delà des limites de la communication à distance (par exemple, entre ordinateurs dans des domaines d’application). Le <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> classe est une classe pratique combinant les fonctionnalités de la <xref:System.Runtime.Remoting.Channels.Tcp.TcpClientChannel> classe et la <xref:System.Runtime.Remoting.Channels.Tcp.TcpServerChannel> classe.  
  
 Les canaux sont utilisés par l’infrastructure .NET Framework remoting pour transporter des appels distants. Lorsqu’un client effectue un appel à un objet distant, l’appel est sérialisé dans un message envoyé par un canal client et reçu par un canal serveur. Il est ensuite désérialisé et traité. Toutes les valeurs retournées sont transmises par le canal du serveur et reçus par le canal client.  
  
 Pour effectuer un traitement supplémentaire des messages, vous pouvez spécifier les implémentations de la <xref:System.Runtime.Remoting.Channels.IClientChannelSinkProvider> et <xref:System.Runtime.Remoting.Channels.IServerChannelSinkProvider> via laquelle tous les messages traitement par le <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> sont passés.  
  
 A <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> objet est associé à des propriétés de configuration qui peuvent être définies au moment de l’exécution, soit dans un fichier de configuration (en appelant la méthode statique <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%2A?displayProperty=nameWithType> (méthode)) ou par programme (en passant un <xref:System.Collections.IDictionary> collection à la <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel.%23ctor%2A> constructeur). Pour plus d’informations sur les propriétés de configuration de canal, consultez [propriétés de Configuration de formateur et de canal](http://msdn.microsoft.com/library/226ecf74-ebbd-4ea0-a701-dcf4441deefe).  
  
> [!NOTE]
>  Si l’ordinateur du serveur est en cours d’exécution Windows 95/98/Me, le serveur <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> ne peut pas être spécifié comme sécurisés.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser un <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> pour configurer un serveur d’accès distant et son client. L’exemple contient trois parties, un serveur, un client et un objet distant utilisé par le serveur et le client.  
  
 L’exemple de code suivant montre un serveur :  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/server.cpp#1)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/server.cs#1)]  
  
 L’exemple de code suivant illustre un client pour ce serveur :  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/client.cpp#10)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/client.cs#10)]  
  
 L’exemple de code suivant montre l’objet distant utilisé par le serveur et le client :  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#20](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/common.cpp#20)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#20](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/common.cs#20)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpChannel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpChannel();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" /> en activant uniquement un canal client et non un canal serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur par défaut initialise tous les champs à leurs valeurs par défaut. Si le constructeur par défaut est utilisé, le canal fonctionne uniquement comme un canal client et n’écoute pas sur tous les ports.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser ce constructeur.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#11](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/client.cpp#11)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#11](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/client.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpChannel (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpChannel(int port);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Remoting.Channels.Tcp.TcpChannel : int -&gt; System.Runtime.Remoting.Channels.Tcp.TcpChannel" Usage="new System.Runtime.Remoting.Channels.Tcp.TcpChannel port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Port sur lequel le canal serveur est à l'écoute.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" /> avec un canal serveur qui écoute sur le port spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour demander au système de la communication à distance de choisir un port ouvert en votre nom, spécifiez le port 0 (zéro). Cela crée un <xref:System.Runtime.Remoting.Channels.Tcp.TcpServerChannel> instance pour écouter les demandes sur le port affecté dynamiquement. Cela est généralement effectué sur le client pour vous assurer qu’un <xref:System.Runtime.Remoting.Channels.Tcp.TcpServerChannel> écoute les méthodes de rappel.  
  
 Si 0 est passé au constructeur le <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> est instancié pour utiliser un port libre.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de cette méthode. Pour demander qu’un port disponible soit assigné dynamiquement, affectez la `port` paramètre à zéro.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ServerActivation#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ServerActivation#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation/VB/server.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpChannel (System.Collections.IDictionary properties, System.Runtime.Remoting.Channels.IClientChannelSinkProvider clientSinkProvider, System.Runtime.Remoting.Channels.IServerChannelSinkProvider serverSinkProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary properties, class System.Runtime.Remoting.Channels.IClientChannelSinkProvider clientSinkProvider, class System.Runtime.Remoting.Channels.IServerChannelSinkProvider serverSinkProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.#ctor(System.Collections.IDictionary,System.Runtime.Remoting.Channels.IClientChannelSinkProvider,System.Runtime.Remoting.Channels.IServerChannelSinkProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (properties As IDictionary, clientSinkProvider As IClientChannelSinkProvider, serverSinkProvider As IServerChannelSinkProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpChannel(System::Collections::IDictionary ^ properties, System::Runtime::Remoting::Channels::IClientChannelSinkProvider ^ clientSinkProvider, System::Runtime::Remoting::Channels::IServerChannelSinkProvider ^ serverSinkProvider);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Remoting.Channels.Tcp.TcpChannel : System.Collections.IDictionary * System.Runtime.Remoting.Channels.IClientChannelSinkProvider * System.Runtime.Remoting.Channels.IServerChannelSinkProvider -&gt; System.Runtime.Remoting.Channels.Tcp.TcpChannel" Usage="new System.Runtime.Remoting.Channels.Tcp.TcpChannel (properties, clientSinkProvider, serverSinkProvider)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.IDictionary" />
        <Parameter Name="clientSinkProvider" Type="System.Runtime.Remoting.Channels.IClientChannelSinkProvider" />
        <Parameter Name="serverSinkProvider" Type="System.Runtime.Remoting.Channels.IServerChannelSinkProvider" />
      </Parameters>
      <Docs>
        <param name="properties">Collection <see cref="T:System.Collections.IDictionary" /> qui spécifie les valeurs des propriétés de configuration devant être utilisées par les canaux client et serveur.</param>
        <param name="clientSinkProvider">Implémentation de <see cref="T:System.Runtime.Remoting.Channels.IClientChannelSinkProvider" /> devant être utilisée par le canal client.</param>
        <param name="serverSinkProvider">Implémentation de <see cref="T:System.Runtime.Remoting.Channels.IServerChannelSinkProvider" /> devant être utilisée par le canal serveur.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" /> avec les propriétés de configuration et les récepteurs spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les propriétés de configuration de canal, consultez [propriétés de Configuration de formateur et de canal](http://msdn.microsoft.com/library/226ecf74-ebbd-4ea0-a701-dcf4441deefe).  
  
> [!NOTE]
>  Si l’ordinateur du serveur est en cours d’exécution Windows 95/98/Me, le serveur <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> ne peut pas être spécifié comme sécurisés.  
  
 Les récepteurs de canal fournissent un point de plug-in qui permet d’accéder aux messages sous-jacents échangés dans le canal, ainsi que le flux utilisé par le mécanisme de transport pour envoyer des messages à un objet distant. Les récepteurs de canal sont également chargés de transporter les messages entre le client et le serveur. Les récepteurs de canal sont liés dans une chaîne, et tous les messages sont transférés par cette chaîne de récepteurs de canal avant que le message est sérialisé puis transporté. Si vous n’avez pas besoin de fonctionnalité de récepteur, définissez la `clientSinkProvider` et `serverSinkProvider` paramètres `null`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser ce constructeur.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel2/CPP/server.cpp#1)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel2/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La mise en forme d'une propriété de canal fourni est incorrecte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChannelData">
      <MemberSignature Language="C#" Value="public object ChannelData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ChannelData" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChannelData As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ChannelData { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChannelData : obj" Usage="System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les données spécifiques de canal.</summary>
        <value>Instance de <see cref="T:System.Runtime.Remoting.Channels.ChannelDataStore" /> contenant les données spécifiques de canal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien qu’il est retourné comme une instance de <xref:System.Object?displayProperty=nameWithType>, la valeur de cette propriété peut être convertie en une instance de <xref:System.Runtime.Remoting.Channels.ChannelDataStore> décrivant le canal auquel le <xref:System.Runtime.Remoting.Channels.Http.HttpServerChannel> est à l’écoute de l’objet.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser cette propriété.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/server.cpp#5)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/server.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChannelName">
      <MemberSignature Language="C#" Value="public string ChannelName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ChannelName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChannelName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ChannelName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChannelName : string" Usage="System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom du canal en cours.</summary>
        <value>
          <see cref="T:System.String" /> contenant le nom du canal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque canal enregistré a un nom unique. Le nom est utilisé pour récupérer un canal spécifique lors de l’appel <xref:System.Runtime.Remoting.Channels.ChannelServices.GetChannel%2A>. Pour définir le <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelName%2A> propriété, affectez la valeur « nom » indexé de propriété dans le dictionnaire passé à la <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel.%23ctor%28System.Collections.IDictionary%2CSystem.Runtime.Remoting.Channels.IClientChannelSinkProvider%2CSystem.Runtime.Remoting.Channels.IServerChannelSinkProvider%29> constructeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser cette propriété.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/server.cpp#3)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/server.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChannelPriority">
      <MemberSignature Language="C#" Value="public int ChannelPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChannelPriority" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChannelPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChannelPriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ChannelPriority : int" Usage="System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelPriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la priorité du canal actuel.</summary>
        <value>Entier qui représente la priorité assignée au canal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment utiliser cette propriété.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/server.cpp#4)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/server.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMessageSink">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessageSink CreateMessageSink (string url, object remoteChannelData, out string objectURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessageSink CreateMessageSink(string url, object remoteChannelData, [out] string&amp; objectURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.CreateMessageSink(System.String,System.Object,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateMessageSink (url As String, remoteChannelData As Object, ByRef objectURI As String) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessageSink ^ CreateMessageSink(System::String ^ url, System::Object ^ remoteChannelData, [Runtime::InteropServices::Out] System::String ^ % objectURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateMessageSink : string * obj *  -&gt; System.Runtime.Remoting.Messaging.IMessageSink&#xA;override this.CreateMessageSink : string * obj *  -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="tcpChannel.CreateMessageSink (url, remoteChannelData, objectURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="remoteChannelData" Type="System.Object" />
        <Parameter Name="objectURI" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="url">URL à laquelle le nouveau récepteur doit délivrer les messages. Peut être <see langword="null" />.</param>
        <param name="remoteChannelData">Objet de données de canal de l'hôte distant auquel le nouveau récepteur doit délivrer les messages. Peut être <see langword="null" />.</param>
        <param name="objectURI">Cette méthode retourne un URI du nouveau récepteur de messages de canal qui remet des messages à l'URL ou à l'objet de données de canal spécifié. Ce paramètre est passé sans être initialisé.</param>
        <summary>Retourne un récepteur de messages de canal qui remet les messages à l'URL ou à l'objet de données de canal spécifié.</summary>
        <returns>Récepteur de messages de canal qui remet les messages à l'URL ou à l'objet de données de canal spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel.CreateMessageSink%2A> méthode retourne un récepteur de messages de canal qui remet des messages à l’objet de données URL ou de canal spécifié. Si le `uri` paramètre est `null`, `remoteChannelData` est utilisé en tant que cible pour le récepteur. Soit le `url` ou `remoteChannelData` les paramètres peuvent être `null`, mais pas les deux.  
  
 Les récepteurs de canal fournissent un point de plug-in qui permet d’accéder aux messages sous-jacents échangés dans le canal, ainsi que le flux utilisé par le mécanisme de transport pour envoyer des messages à un objet distant. Les récepteurs de canal sont liés dans une chaîne de `ChannelSinkProviders` et tous les messages sont transférés par cette chaîne de récepteurs de canal avant que le message est sérialisé puis transporté.  
  
   
  
## Examples  
 L'exemple de code suivant montre comment utiliser cette méthode.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#12](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/client.cpp#12)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#12](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/client.cs#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUrlsForUri">
      <MemberSignature Language="C#" Value="public string[] GetUrlsForUri (string objectURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetUrlsForUri(string objectURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.GetUrlsForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUrlsForUri (objectURI As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetUrlsForUri(System::String ^ objectURI);" />
      <MemberSignature Language="F#" Value="abstract member GetUrlsForUri : string -&gt; string[]&#xA;override this.GetUrlsForUri : string -&gt; string[]" Usage="tcpChannel.GetUrlsForUri objectURI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="objectURI">URI de l'objet pour lequel des URL sont requises.</param>
        <summary>Retourne un tableau de toutes les URL d'un objet doté de l'URI spécifié qui sont hébergées sur <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" /> en cours.</summary>
        <returns>Tableau de toutes les URL d'un objet doté de l'URI spécifié qui sont hébergées sur <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" /> en cours.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée par <xref:System.Runtime.Remoting.Channels.ChannelServices.GetUrlsForObject%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L'exemple de code suivant montre comment utiliser cette méthode.  
  
 [!code-cpp[TcpChannel.GetUrlsForUri#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpChannel.GetUrlsForUri/CPP/class1.cpp#1)]
 [!code-csharp[TcpChannel.GetUrlsForUri#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpChannel.GetUrlsForUri/CS/class1.cs#1)]
 [!code-vb[TcpChannel.GetUrlsForUri#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpChannel.GetUrlsForUri/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecured">
      <MemberSignature Language="C#" Value="public bool IsSecured { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecured" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Channels.Tcp.TcpChannel.IsSecured" />
      <MemberSignature Language="VB.NET" Value="Public Property IsSecured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecured { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsSecured : bool with get, set" Usage="System.Runtime.Remoting.Channels.Tcp.TcpChannel.IsSecured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur Boolean qui indique si le canal actuel est sécurisé.</summary>
        <value>Valeur booléenne qui indique si l'instance actuelle est sécurisée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété ne doive pas être définie explicitement, car elle est suffisante pour définir le paramètre ensureSecurity de <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public string Parse (string url, out string objectURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string Parse(string url, [out] string&amp; objectURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.Parse(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Parse (url As String, ByRef objectURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ Parse(System::String ^ url, [Runtime::InteropServices::Out] System::String ^ % objectURI);" />
      <MemberSignature Language="F#" Value="abstract member Parse : string *  -&gt; string&#xA;override this.Parse : string *  -&gt; string" Usage="tcpChannel.Parse (url, objectURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="objectURI" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="url">URL à partir de laquelle est extrait l'URI de l'objet connu distant.</param>
        <param name="objectURI">Cette méthode retourne un <see cref="T:System.String" /> contenant l'URI de l'objet connu distant. Ce paramètre est passé sans être initialisé.</param>
        <summary>Extrait l'URI du canal et de l'objet connu distant à partir de l'URL spécifiée.</summary>
        <returns>URI du canal en cours.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’URI d’un objet est une valeur qui identifie de façon unique une instance d’objet spécifique.  
  
   
  
## Examples  
 L'exemple de code suivant montre comment utiliser cette méthode.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/server.cpp#6)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/server.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="public void StartListening (object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StartListening(object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartListening (data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void StartListening(System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit&#xA;override this.StartListening : obj -&gt; unit" Usage="tcpChannel.StartListening data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Informations d'initialisation facultatives.</param>
        <summary>Commande au canal en cours de démarrer l'écoute des demandes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessaire d’appeler cette méthode pour commencer à écouter sur un canal qui vient d’être initialisé.  
  
 Utilisez cette méthode pour redémarrer l’écoute sur un canal après le <xref:System.Runtime.Remoting.Channels.Tcp.TcpServerChannel.StopListening%2A> méthode a été appelée.  
  
 Si votre canal utilise un numéro de port affecté dynamiquement, votre numéro de port peut changer lors du redémarrage de l’écoute.  
  
 Le `data` paramètre peut être utilisé pour passer un état d’initialisation spécifique au canal. Si vous ne souhaitez pas passer un état spécifique au canal, la valeur `data` à `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="public void StopListening (object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopListening(object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopListening (data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void StopListening(System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit&#xA;override this.StopListening : obj -&gt; unit" Usage="tcpChannel.StopListening data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Informations d'état facultatives pour le canal.</param>
        <summary>Commande au canal en cours d'arrêter l'écoute des demandes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour arrêter l’écoute sur un canal. Pour redémarrer l’écoute, utilisez la <xref:System.Runtime.Remoting.Channels.Tcp.TcpServerChannel.StartListening%2A> (méthode).  
  
 Si votre canal utilise un numéro de port affecté dynamiquement, votre numéro de port peut changer lors du redémarrage de l’écoute.  
  
 Le `data` paramètre peut être utilisé pour passer un état d’initialisation spécifique au canal. Si vous ne souhaitez pas passer un état spécifique au canal, la valeur `data` à `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>