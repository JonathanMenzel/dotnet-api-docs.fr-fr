<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Regex.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe07fd2ccb43296a43eb9c1de7114e0d688441835233.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fd2ccb43296a43eb9c1de7114e0d688441835233</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Represents an immutable regular expression.</source>
          <target state="translated">Représente une expression régulière immuable.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class represents the .NET Framework's regular expression engine.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> classe représente le moteur des expressions régulières du .NET Framework.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>It can be used to quickly parse large amounts of text to find specific character patterns; to extract, edit, replace, or delete text substrings; and to add the extracted strings to a collection to generate a report.</source>
          <target state="translated">Il peut être utilisé pour analyser rapidement de grandes quantités de texte pour rechercher des modèles de caractères spécifiques ; pour extraire, modifier, remplacer ou supprimer des sous-chaînes de texte ; et d’ajouter les chaînes extraites à une collection pour générer un rapport.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If your primary interest is to validate a string by determining whether it conforms to a particular pattern, you can use the <ph id="ph1">&lt;xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">Si votre intérêt principal est de valider une chaîne en déterminant s’il est conforme à un modèle particulier, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To use regular expressions, you define the pattern that you want to identify in a text stream by using the syntax documented in <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour utiliser des expressions régulières, vous définissez le modèle que vous souhaitez identifier dans un flux de texte à l’aide de la syntaxe documentée dans <bpt id="p1">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Next, you can optionally instantiate a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">Ensuite, vous pouvez éventuellement instancier un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Finally, you call a method that performs some operation, such as replacing text that matches the regular expression pattern, or identifying a pattern match.</source>
          <target state="translated">Enfin, vous appelez une méthode qui effectue une opération, telles que le remplacement de texte qui correspond au modèle d’expression régulière, ou identifier une correspondance de modèle.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For some common regular expression patterns, see <bpt id="p1">[</bpt>Regular Expression Examples<ept id="p1">](~/docs/standard/base-types/regular-expression-examples.md)</ept>.</source>
          <target state="translated">Pour certains modèles d’expressions régulières courants, consultez <bpt id="p1">[</bpt>exemples d’expressions régulières<ept id="p1">](~/docs/standard/base-types/regular-expression-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>There are also a number of online libraries of regular expression patterns, such as the one at <bpt id="p1">[</bpt>Regular-Expressions.info<ept id="p1">](https://www.regular-expressions.info/examples.html)</ept>.</source>
          <target state="translated">Il existe également un nombre de bibliothèques en ligne des modèles d’expressions régulières, tel que celui à <bpt id="p1">[</bpt>Regular-Expressions.info<ept id="p1">](https://www.regular-expressions.info/examples.html)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">&lt;a name="remarks"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> For more information about using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class, see the following sections in this topic:</source>
          <target state="translated"><bpt id="p1">&lt;a name="remarks"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Pour plus d’informations sur l’utilisation de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de classe, consultez les sections suivantes de cette rubrique :</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Regex vs. String Methods<ept id="p1">](#regex_vs_string)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Regex et. Méthodes de chaînes<ept id="p1">](#regex_vs_string)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Static vs. Instance Methods<ept id="p1">](#static_vs_instance)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Ports statiques et. Méthodes d’instance<ept id="p1">](#static_vs_instance)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Performing Regular Expression Operations<ept id="p1">](#regex_ops)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Exécution d’opérations d’Expression régulière<ept id="p1">](#regex_ops)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Defining a Time-Out Value<ept id="p1">](#define_timeout)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Définition d’une valeur de délai d’attente<ept id="p1">](#define_timeout)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about the regular expression language, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> or download and print one of these brochures:</source>
          <target state="translated">Pour plus d'informations sur le langage d'expression régulière, consultez <bpt id="p1">[</bpt>Langage des expressions régulières - Aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> ou téléchargez et imprimez l'une des brochures suivantes :</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Quick Reference in Word (.docx) format<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Aide-mémoire au format Word (.docx)<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Quick Reference in PDF (.pdf) format<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Aide-mémoire au format PDF (.pdf)<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Regex vs. String Methods</source>
          <target state="translated">Regex et. Méthodes de chaînes</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> class includes several search and comparison methods that you can use to perform pattern matching with text.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> classe inclut plusieurs méthodes de recherche et de comparaison que vous pouvez utiliser pour effectuer la mise en correspondance avec le texte.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Contains%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> methods determine whether a string instance contains a specified substring; and the <ph id="ph4">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOfAny%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph7">&lt;xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType&gt;</ph> methods return the starting position of a specified substring in a string.</source>
          <target state="translated">Par exemple, le <ph id="ph1">&lt;xref:System.String.Contains%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A?displayProperty=nameWithType&gt;</ph>, et <ph id="ph3">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> méthodes déterminent si une instance de chaîne contient une sous-chaîne spécifiée ; et le <ph id="ph4">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOfAny%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>, et <ph id="ph7">&lt;xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType&gt;</ph> méthodes retournent la position de départ d’une sous-chaîne spécifiée dans une chaîne.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Use the methods of the <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> class when you are searching for a specific string.</source>
          <target state="translated">Utilisez les méthodes de la <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> classe lorsque vous recherchez une chaîne spécifique.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class when you are searching for a specific pattern in a string.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> classe lorsque vous recherchez un modèle spécifique dans une chaîne.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information and examples, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">Pour plus d’informations et d’exemples, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>À la section Notes<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Static vs. Instance Methods</source>
          <target state="translated">Ports statiques et. Méthodes d’instance</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>After you define a regular expression pattern, you can provide it to the regular expression engine in either of two ways:</source>
          <target state="translated">Après avoir défini un modèle d’expression régulière, vous pouvez le fournir au moteur des expressions régulières de deux manières :</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By instantiating a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object that represents the regular expression.</source>
          <target state="translated">En instanciant un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet qui représente l’expression régulière.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To do this, you pass the regular expression pattern to a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">Pour ce faire, vous passez le modèle d’expression régulière à un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%2A&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable; when you instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with a regular expression, that object's regular expression cannot be changed.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est immuable ; lorsque vous instanciez un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de l’objet avec une expression régulière, que l’expression régulière de l’objet ne peut pas être modifiée.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By supplying both the regular expression and the text to search to a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> method.</source>
          <target state="translated">En fournissant des expressions régulières et le texte à rechercher dans un <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> en Visual Basic) <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This enables you to use a regular expression without explicitly creating a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">Cela vous permet d’utiliser une expression régulière sans créer explicitement un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>All <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> pattern identification methods include both static and instance overloads.</source>
          <target state="translated">Tous les <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> méthodes du modèle d’identification incluent à la fois static et instance surcharges.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The regular expression engine must compile a particular pattern before the pattern can be used.</source>
          <target state="translated">Le moteur des expressions régulières doit compiler un modèle particulier avant de pouvoir utiliser le modèle.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Because <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objects are immutable, this is a one-time procedure that occurs when a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor or a static method is called.</source>
          <target state="translated">Étant donné que <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> les objets sont immuables, il s’agit d’une procédure unique qui se produit lorsqu’un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructeur de classe ou une méthode statique est appelée.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To eliminate the need to repeatedly compile a single regular expression, the regular expression engine caches the compiled regular expressions used in static method calls.</source>
          <target state="translated">Pour éliminer la nécessité de façon répétée compiler une expression régulière unique, le moteur d’expression régulière met en cache les expressions régulières compilées utilisées dans les appels de méthode statique.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>As a result, regular expression pattern-matching methods offer comparable performance for static and instance methods.</source>
          <target state="translated">Par conséquent, méthodes de correspondance d’expression régulière offrent des performances comparables pour statique et les méthodes d’instance.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In the .NET Framework versions 1.0 and 1.1, all compiled regular expressions, whether they were used in instance or static method calls, were cached.</source>
          <target state="translated">Dans les .NET Framework versions 1.0 et 1.1, tout compilé les expressions régulières, s’ils ont été utilisés dans une méthode statique ou d’instance appelle, ont été mis en cache.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Starting with the .NET Framework 2.0, only regular expressions used in static method calls are cached.</source>
          <target state="translated">À compter de .NET Framework 2.0, seules les expressions régulières utilisées dans les appels de méthode statique sont mises en cache.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, caching can adversely affect performance in the following two cases:</source>
          <target state="translated">Toutefois, la mise en cache peut nuire aux performances dans les deux cas suivants :</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When you use static method calls with a large number of regular expressions.</source>
          <target state="translated">Lorsque vous utilisez des appels de méthode statique avec un grand nombre d’expressions régulières.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By default, the regular expression engine caches the 15 most recently used static regular expressions.</source>
          <target state="translated">Par défaut, le moteur d’expression régulière met en cache des fichiers récents expressions régulières statiques 15.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If your application uses more than 15 static regular expressions, some regular expressions must be recompiled.</source>
          <target state="translated">Si votre application utilise plus de 15 expressions régulières statiques, certaines expressions régulières doivent être recompilées.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent this recompilation, you can increase the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Pour empêcher cette recompilation, vous pouvez augmenter la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When you instantiate new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objects with regular expressions that have previously been compiled.</source>
          <target state="translated">Lorsque vous instanciez un nouveau <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objets avec des expressions régulières compilées précédemment.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For example, the following code defines a regular expression to locate duplicated words in a text stream.</source>
          <target state="translated">Par exemple, le code suivant définit une expression régulière pour rechercher des mots en double dans un flux de texte.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Although the example uses a single regular expression, it instantiates a new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object to process each line of text.</source>
          <target state="translated">Bien que l’exemple utilise une expression régulière unique, il instancie une nouvelle <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet à traiter chaque ligne de texte.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This results in the recompilation of the regular expression with each iteration of the loop.</source>
          <target state="translated">Cela entraîne la recompilation de l’expression régulière avec chaque itération de la boucle.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent recompilation, you should instantiate a single <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object that is accessible to all code that requires it, as shown in the following rewritten example.</source>
          <target state="translated">Pour empêcher la recompilation, vous devez instancier une seule <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet qui est accessible à tout le code qui le requiert, comme indiqué dans l’exemple réécrit suivant.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>À la section Notes<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Performing Regular Expression Operations</source>
          <target state="translated">Exécution d’opérations d’Expression régulière</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Whether you decide to instantiate a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object and call its methods or call static methods, the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class offers the following pattern-matching functionality:</source>
          <target state="translated">Si vous décidez d’instancier un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de l’objet et appeler ses méthodes ou appeler des méthodes statiques, la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> classe offre les fonctionnalités de mise en correspondance de modèle suivantes :</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Validation of a match.</source>
          <target state="translated">Validation d’une correspondance.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method to determine whether a match is present.</source>
          <target state="translated">Vous appelez le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> méthode pour déterminer si une correspondance est présente.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Retrieval of a single match.</source>
          <target state="translated">Récupération d’une correspondance unique.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that represents the first match in a string or in part of a string.</source>
          <target state="translated">Vous appelez le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> méthode pour récupérer un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objet qui représente la première correspondance dans une chaîne ou dans la partie d’une chaîne.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Subsequent matches can be retrieved by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Les correspondances suivantes peuvent être récupérés en appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Retrieval of all matches.</source>
          <target state="translated">Récupération de toutes les correspondances.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType&gt;</ph> object that represents all the matches found in a string or in part of a string.</source>
          <target state="translated">Vous appelez le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> méthode pour récupérer un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType&gt;</ph> objet qui représente toutes les correspondances trouvées dans une chaîne ou dans la partie d’une chaîne.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Replacement of matched text.</source>
          <target state="translated">Remplacement de texte correspondant.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> method to replace matched text.</source>
          <target state="translated">Vous appelez le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> méthode pour remplacer le texte correspondant.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The replacement text can also be defined by a regular expression.</source>
          <target state="translated">Le texte de remplacement peut également être défini par une expression régulière.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In addition, some of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> methods include a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> parameter that enables you to programmatically define the replacement text.</source>
          <target state="translated">En outre, certains le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> méthodes incluent un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> paramètre qui vous permet de définir par programme le texte de remplacement.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Creation of a string array that is formed from parts of an input string.</source>
          <target state="translated">Création d’un tableau de chaînes qui est formé à partir des parties d’une chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> method to split an input string at positions that are defined by the regular expression.</source>
          <target state="translated">Vous appelez le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> méthode pour fractionner une chaîne d’entrée aux positions définies par l’expression régulière.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In addition to its pattern-matching methods, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class includes several special-purpose methods:</source>
          <target state="translated">En plus de ses méthodes de correspondance, la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> classe inclut plusieurs méthodes à usage spécial :</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method escapes any characters that may be interpreted as regular expression operators in a regular expression or input string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> méthode échappe les caractères qui peuvent être interprétés comme opérateurs d’expression régulière dans une expression régulière ou une chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method removes these escape characters.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> méthode supprime ces caractères d’échappement.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method creates an assembly that contains predefined regular expressions.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> méthode crée un assembly qui contient des expressions régulières prédéfinies.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The .NET Framework contains examples of these special-purpose assemblies in the <ph id="ph1">&lt;xref:System.Web.RegularExpressions?displayProperty=nameWithType&gt;</ph> namespace.</source>
          <target state="translated">Le .NET Framework contient des exemples de ces assemblys spécial dans le <ph id="ph1">&lt;xref:System.Web.RegularExpressions?displayProperty=nameWithType&gt;</ph> espace de noms.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>À la section Notes<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Defining a Time-Out Value</source>
          <target state="translated">Définition d’une valeur de délai d’attente</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The .NET Framework supports a full-featured regular expression language that provides substantial power and flexibility in pattern matching.</source>
          <target state="translated">Le .NET Framework prend en charge un langage complet d’expression régulière qui fournit la puissance substantielle et la flexibilité dans les critères spéciaux.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, the power and flexibility come at a cost: the risk of poor performance.</source>
          <target state="translated">Toutefois, la puissance et la flexibilité fournies à un coût : le risque de performances médiocres.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Regular expressions that perform poorly are surprisingly easy to create.</source>
          <target state="translated">Expressions régulières qui fonctionne mal sont très faciles à créer.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In some cases, regular expression operations that rely on excessive backtracking can appear to stop responding when they process text that nearly matches the regular expression pattern.</source>
          <target state="translated">Dans certains cas, les opérations d’expression régulière qui reposent sur une rétroaction excessive peuvent apparaître pour cesser de répondre lorsqu’elles traitent le texte correspondant presque au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about the .NET Framework regular expression engine, see <bpt id="p1">[</bpt>Details of Regular Expression Behavior<ept id="p1">](~/docs/standard/base-types/details-of-regular-expression-behavior.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le moteur des expressions régulières .NET Framework, consultez <bpt id="p1">[</bpt>détails du comportement des expressions régulières<ept id="p1">](~/docs/standard/base-types/details-of-regular-expression-behavior.md)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about excessive backtracking, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur une rétroaction excessive, consultez <bpt id="p1">[</bpt>rétroaction<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, you can define a time-out interval for regular expression matches.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, vous pouvez définir un intervalle de délai d’attente pour les correspondances d’expression régulière.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the regular expression engine cannot identify a match within this time interval, the matching operation throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si le moteur d’expression régulière ne peut pas identifier une correspondance dans cet intervalle de temps, l’opération de correspondance lève une <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In most cases, this prevents the regular expression engine from wasting processing power by trying to match text that nearly matches the regular expression pattern.</source>
          <target state="translated">Dans la plupart des cas, cela empêche le moteur d’expression régulière ne consomme de la puissance de traitement en essayant de faire correspondre du texte qui correspond presque au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>It also could indicate, however, that the timeout interval has been set too low, or that the current machine load has caused an overall degradation in performance.</source>
          <target state="translated">Il également peut indiquer, toutefois, que l’intervalle de délai d’attente a été défini trop bas ou que la charge actuelle de la machine a provoqué une dégradation globale des performances.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>How you handle the exception depends on the cause of the exception.</source>
          <target state="translated">Manière dont vous gérez l’exception dépend de la cause de l’exception.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the exception occurs because the time-out interval is set too low or because of excessive machine load, you can increase the time-out interval and retry the matching operation.</source>
          <target state="translated">Si l’exception se produit parce que le délai d’attente a une valeur trop faible ou en raison de la charge des machines excessive, vous pouvez augmenter l’intervalle de délai d’attente et recommencez l’opération de correspondance.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the exception occurs because the regular expression relies on excessive backtracking, you can assume that a match does not exist, and, optionally, you can log information that will help you modify the regular expression pattern.</source>
          <target state="translated">Si l’exception se produit parce que l’expression régulière repose sur une rétroaction excessive, vous pouvez supposer qu’une correspondance n’existe pas, et, si vous le souhaitez, vous pouvez enregistrer les informations qui vous aideront à modifier le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You can set a time-out interval by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor when you instantiate a regular expression object.</source>
          <target state="translated">Vous pouvez définir un intervalle de délai d’attente en appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructeur lorsque vous instanciez un objet d’expression régulière.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For static methods, you can set a time-out interval by calling an overload of a matching method that has a <ph id="ph1">`matchTimeout`</ph> parameter.</source>
          <target state="translated">Pour les méthodes statiques, vous pouvez définir un intervalle de délai d’attente en appelant une surcharge d’une méthode correspondante qui a un <ph id="ph1">`matchTimeout`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If you do not set a time-out value explicitly, the default time-out value  is determined as follows:</source>
          <target state="translated">Si vous ne définissez pas explicitement une valeur de délai d’attente, la valeur de délai d’attente par défaut est déterminée comme suit :</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By using the application-wide time-out value, if one exists.</source>
          <target state="translated">En utilisant le délai d’attente de l’application la valeur, s’il existe.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This can be any time-out value that applies to the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is instantiated or the static method call is made.</source>
          <target state="translated">Cela peut être toute valeur de délai d’attente qui s’applique au domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est instancié ou l’appel de méthode statique est effectué.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You can set the application-wide time-out value by calling the <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> method to assign the string representation of a <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> value to the "REGEX_DEFAULT_MATCH_TIMEOUT" property.</source>
          <target state="translated">Vous pouvez définir la valeur de délai d’attente de l’application en appelant le <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> méthode pour attribuer la représentation sous forme de chaîne d’un <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> valeur à la propriété « REGEX_DEFAULT_MATCH_TIMEOUT ».</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By using the value <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>, if no application-wide time-out value has been set.</source>
          <target state="translated">À l’aide de la valeur <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>, si aucune valeur de délai d’attente de l’application n’a été définie.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>We recommend that you set a time-out value in all regular expression pattern-matching operations.</source>
          <target state="translated">Nous vous recommandons de définir une valeur de délai d’attente dans toutes les opérations de mise en correspondance de modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>meilleures pratiques des Expressions régulières<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>À la section Notes<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The following example uses a regular expression to check for repeated occurrences of words in a string.</source>
          <target state="translated">L’exemple suivant utilise une expression régulière pour vérifier les occurrences répétées de mots dans une chaîne.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The regular expression <ph id="ph1">`\b(?&lt;word&gt;\w+)\s+(\k&lt;word&gt;)\b`</ph> can be interpreted as shown in the following table.</source>
          <target state="translated">L’expression régulière <ph id="ph1">`\b(?&lt;word&gt;\w+)\s+(\k&lt;word&gt;)\b`</ph> peut être interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Start the match at a word boundary.</source>
          <target state="translated">Démarrer la correspondance à la limite d’un mot.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match one or more word characters up to a word boundary.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques jusqu'à une limite de mot.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Name this captured group <ph id="ph1">`word`</ph>.</source>
          <target state="translated">Nommer ce groupe capturé <ph id="ph1">`word`</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match one or more white-space characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères d’espace blanc.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the captured group that is named <ph id="ph1">`word`</ph>.</source>
          <target state="translated">Correspond au groupe capturé nommé <ph id="ph1">`word`</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match a word boundary.</source>
          <target state="translated">Mettre en correspondance la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The following example illustrates the use of a regular expression to check whether a string either represents a currency value or has the correct format to represent a currency value.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation d’une expression régulière pour vérifier si une chaîne représente une valeur monétaire ou a le format correct pour représenter une valeur monétaire.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In this case, the regular expression is built dynamically from the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> properties for the user's current culture.</source>
          <target state="translated">Dans ce cas, l’expression régulière est construite dynamiquement à partir de la <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>, et <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> propriétés de la culture actuelle de l’utilisateur.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the system's current culture is en-US, the resulting regular expression is <ph id="ph1">`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`</ph>.</source>
          <target state="translated">Si le système actuel de le culture est en-US, l’expression régulière qui en résulte est <ph id="ph1">`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This regular expression can be interpreted as shown in the following table.</source>
          <target state="translated">Cette expression régulière peut être interprétée comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Start at the beginning of the string.</source>
          <target state="translated">Commencer au début de la chaîne.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Correspond à zéro, un ou plusieurs espaces blancs.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one occurrence of either the positive sign or the negative sign.</source>
          <target state="translated">Mettre en correspondance zéro ou une occurrence d’un signe positif ou le signe négatif.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Mettre en correspondance zéro ou un espace blanc.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one occurrence of the dollar sign.</source>
          <target state="translated">Mettre en correspondance zéro ou une occurrence du signe dollar.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Mettre en correspondance zéro ou un espace blanc.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or more decimal digits.</source>
          <target state="translated">Met en correspondance zéro ou plusieurs chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one decimal point symbol.</source>
          <target state="translated">Mettre en correspondance zéro ou un symbole de virgule décimale.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match two decimal digits zero or one time.</source>
          <target state="translated">Correspond zéro ou une fois à deux chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the pattern of integral and fractional digits separated by a decimal point symbol at least one time.</source>
          <target state="translated">Correspond au modèle de chiffres intégraux et fractionnaires séparés par un symbole de virgule décimale d’au moins une fois.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the end of the string.</source>
          <target state="translated">Correspond à la fin de la chaîne.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In this case, the regular expression assumes that a valid currency string does not contain group separator symbols, and that it has either no fractional digits or the number of fractional digits defined by the current culture's <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph> property.</source>
          <target state="translated">Dans ce cas, l’expression régulière suppose qu’une chaîne de devise valide ne contient pas de symboles de séparateur de groupes, et qu’il possède pas de chiffres fractionnaires ou le nombre de chiffres fractionnaires défini par la culture actuelle <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Because the regular expression in this example is built dynamically, we do not know at design time whether the current culture's currency symbol, decimal sign, or positive and negative signs might be misinterpreted by the regular expression engine as regular expression language operators.</source>
          <target state="translated">Étant donné que l’expression régulière dans cet exemple est construite dynamiquement, nous ne savons pas au moment du design si le symbole monétaire de la culture actuelle, le signe décimal ou signes positifs et négatifs peuvent être mal interprétés par le moteur des expressions régulières comme opérateurs de langage d’expression régulière.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent any misinterpretation, the example passes each dynamically generated string to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method.</source>
          <target state="translated">Pour empêcher toute mauvaise interprétation, l’exemple passe chaque chaîne générée dynamiquement à la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class is immutable (read-only) and thread safe.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> classe est immuable (lecture seule) et thread-safe.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects can be created on any thread and shared between threads.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> les objets peuvent être créés sur n’importe quel thread et partagés entre plusieurs threads.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information, see <bpt id="p1">[</bpt>Thread Safety<ept id="p1">](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>sécurité des threads<ept id="p1">](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor">
          <source>Note that this constructor is protected; it can only be called by classes derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Notez que ce constructeur est protégé ; Il peut être appelé uniquement par les classes dérivées de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> pour l'expression régulière spécifiée.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez la <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> rubriques.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29&gt;</ph> constructor is equivalent to calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor with a value of <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.None&gt;</ph> for the <ph id="ph4">`options`</ph> argument.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29&gt;</ph> constructeur équivaut à appeler le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructeur avec une valeur de <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.None&gt;</ph> pour la <ph id="ph4">`options`</ph> argument.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match pattern you define when you create it.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est immuable, ce qui signifie qu’il peut être utilisé uniquement pour le modèle de correspondance que vous définissez lors de sa création.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">Toutefois, il peut être utilisée n’importe quel nombre de fois sans être recompilé.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>This constructor instantiates a regular expression object that attempts a case-sensitive match of any alphabetical characters defined in <ph id="ph1">`pattern`</ph>.</source>
          <target state="translated">Ce constructeur instancie un objet d’expression régulière qui tente une correspondance qui respecte la casse de tous les caractères alphabétiques définis dans <ph id="ph1">`pattern`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For a case-insensitive match, use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Pour une correspondance de la casse, utilisez le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</source>
          <target state="translated">L’exemple suivant illustre comment utiliser ce constructeur pour instancier une expression régulière qui correspond à tout mot qui commence par les lettres « a » ou « t ».</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Note that the regular expression pattern cannot match the word "The" at the beginning of the text, because comparisons are case-sensitive by default.</source>
          <target state="translated">Notez que le modèle d’expression régulière ne peut pas correspondre le mot « The » au début du texte, car les comparaisons respectent la casse par défaut.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For an example of case-insensitive comparison, see the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor.</source>
          <target state="translated">Pour obtenir un exemple de comparaison respectant la casse, consultez le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>This constructor creates a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object that uses the default time-out value of the application domain in which it is created.</source>
          <target state="translated">Ce constructeur crée un <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objet qui utilise la valeur de délai d’attente par défaut du domaine d’application dans lequel il est créé.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>If a time-out value has not been defined for the application domain,  the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object uses the value <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the operation from timing out. The recommended constructor for creating a <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object is <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, le <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objet utilise la valeur <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche l’expiration du délai de l’opération. Le constructeur recommandé pour la création d’un <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objet est <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object that contains a serialized pattern and <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> information.</source>
          <target state="translated">Objet qui contient un modèle sérialisé et des informations <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination for this serialization.</source>
          <target state="translated">Destination de cette sérialisation.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>(This parameter is not used; specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.)</source>
          <target state="translated">(Ce paramètre n'est pas utilisé ; spécifiez <ph id="ph1">&lt;see langword="null" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class by using serialized data.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> à l'aide de données sérialisées.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The pattern that <ph id="ph1">&lt;paramref name="info" /&gt;</ph> contains is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le modèle contenu par <ph id="ph1">&lt;paramref name="info" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> contains an invalid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> flag.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> contient un indicateur <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> non valide.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that modify the regular expression.</source>
          <target state="translated">Combinaison de bits de valeurs d'énumération qui modifient l'expression régulière.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression, with options that modify the pattern.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> pour l'expression régulière spécifiée, avec des options qui modifient le modèle.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez la <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> rubriques.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match parameters you define when you create it.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est immuable, ce qui signifie qu’il peut être utilisé uniquement pour les paramètres de correspondance que vous définissez lors de sa création.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">Toutefois, il peut être utilisée n’importe quel nombre de fois sans être recompilé.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</source>
          <target state="translated">L’exemple suivant illustre comment utiliser ce constructeur pour instancier une expression régulière qui correspond à tout mot qui commence par les lettres « a » ou « t ».</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Note that the match collection includes the word "The" that begins the text because the <ph id="ph1">`options`</ph> parameter has defined case-insensitive comparisons.</source>
          <target state="translated">Notez que la collection de correspondances contient le mot « The » qui commence le texte, car le <ph id="ph1">`options`</ph> paramètre a défini des comparaisons sans respecter la casse.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> contains an invalid flag.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> contient un indicateur non valide.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This constructor creates a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object that uses the default time-out value of the application domain in which it is created.</source>
          <target state="translated">Ce constructeur crée un <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objet qui utilise la valeur de délai d’attente par défaut du domaine d’application dans lequel il est créé.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object uses the value <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the operation from timing out. The recommended constructor for creating a <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object is <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, le <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objet utilise la valeur <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche l’expiration du délai de l’opération. Le constructeur recommandé pour la création d’un <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objet est <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that modify the regular expression.</source>
          <target state="translated">Combinaison de bits de valeurs d'énumération qui modifient l'expression régulière.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Intervalle de délai d'attente, ou <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> pour indiquer que la méthode ne doit pas expirer.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression, with options that modify the pattern and a value that specifies how long a pattern matching method should attempt a match before it times out.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> pour l'expression régulière spécifiée, avec les options qui modifient le modèle et une valeur qui spécifie la durée pendant laquelle une méthode de modèle doit tenter une correspondance avant son expiration.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez la <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> rubriques.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match pattern that you define when you create it.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est immuable, ce qui signifie qu’il peut être utilisé uniquement pour le modèle de correspondance que vous définissez lors de sa création.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">Toutefois, il peut être utilisée n’importe quel nombre de fois sans être recompilé.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern-matching method should try to find a match before it times out. If no match is found in that time interval, the pattern-matching method throws a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Le <ph id="ph1">`matchTimeout`</ph> paramètre spécifie la durée pendant laquelle un modèle de mise en correspondance de méthode doit effectuer pour trouver une correspondance avant d’expirer. Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode de correspondance lève une <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> remplace la valeur de délai d’attente par défaut défini pour le domaine d’application dans lequel le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The instance pattern-matching methods that observe the <ph id="ph1">`matchTimeout`</ph> time-out interval include the following:</source>
          <target state="translated">Les méthodes de critères spéciaux d’instance observent le <ph id="ph1">`matchTimeout`</ph> délai d’attente sont les suivantes :</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">Définition d’un intervalle de délai d’attente empêche les expressions régulières qui s’appuient sur une rétroaction excessive de semble cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>meilleures pratiques des Expressions régulières<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> et <bpt id="p2">[</bpt>rétroaction<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To set a reasonable time-out interval, consider the following factors:</source>
          <target state="translated">Pour définir un délai raisonnable, tenez compte des facteurs suivants :</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The length and complexity of the regular expression pattern.</source>
          <target state="translated">La longueur et la complexité du modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Longer and more complex regular expressions require more time than shorter and simpler ones.</source>
          <target state="translated">Les expressions régulières plus longtemps et plus complexes nécessitent plus de temps que ceux qui sont plus court et plus simple.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The expected machine load.</source>
          <target state="translated">La charge prévue de l’ordinateur.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Processing takes more time on systems that have high CPU and memory utilization.</source>
          <target state="translated">Le traitement prend plus de temps sur les systèmes qui ont l’utilisation élevée du processeur et de mémoire.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with a time-out value of one second.</source>
          <target state="translated">L’exemple suivant appelle la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructeur pour instancier un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet avec une valeur de délai d’attente d’une seconde.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`(a+)+$`</ph>, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`(a+)+$`</ph>, qui correspond à une ou plusieurs séquences d'un ou plusieurs caractères « a » à la fin d'une ligne, est soumis à une rétroaction excessive.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> is thrown, the example increases the time-out value up to the maximum value of three seconds.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> est levée, l’exemple augmente la valeur de délai d’attente jusqu'à la valeur maximale de trois secondes.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Otherwise, it abandons the attempt to match the pattern.</source>
          <target state="translated">Dans le cas contraire, il abandonne la tentative de mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n’est pas une valeur de <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> est négatif, égal à zéro ou supérieur à environ 24 jours.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Nous vous recommandons de définir la <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> paramètre à une valeur appropriée, comme les deux secondes.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si vous désactivez des délais d’attente en spécifiant <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, le moteur des expressions régulières offre des performances sont légèrement meilleures.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Toutefois, vous devez désactiver les délais d’expiration uniquement dans les conditions suivantes :</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Cela exclut le texte qui a été dynamiquement par les utilisateurs.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Lorsque le modèle d’expression régulière a été soigneusement testé pour s’assurer qu’elle gère efficacement correspond à, non-correspondances et proche correspond.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Gets or sets the maximum number of entries in the current static cache of compiled regular expressions.</source>
          <target state="translated">Obtient ou définit le nombre maximal d'entrées dans le cache statique actuel des expressions régulières compilées.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The maximum number of entries in the static cache.</source>
          <target state="translated">Nombre maximal d'entrées dans le cache statique.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class maintains an internal cache of compiled regular expressions used in static method calls.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> classe conserve un cache interne des expressions régulières compilées utilisées dans les appels de méthode statique.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>If the value specified in a set operation is less than the current cache size, cache entries are discarded until the cache size is equal to the specified value.</source>
          <target state="translated">Si la valeur spécifiée dans une opération ensembliste est inférieure à la taille de cache actuelle, les entrées du cache sont ignorées jusqu'à ce que la taille du cache est égale à la valeur spécifiée.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>By default, the cache holds 15 compiled static regular expressions.</source>
          <target state="translated">Par défaut, le cache conserve 15 expressions régulières statiques compilées.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Your application typically will not have to modify the size of the cache.</source>
          <target state="translated">Votre application sera ont généralement pas modifier la taille du cache.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A&gt;</ph> property only when you want to turn off caching or when you have an unusually large cache.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A&gt;</ph> propriété uniquement lorsque vous souhaitez désactiver la mise en cache ou lorsque vous disposez d’un cache particulièrement volumineuses.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The value in a set operation is less than zero.</source>
          <target state="translated">La valeur d’une opération ensembliste est inférieure à zéro.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>In the .NET Framework prior to the <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, regular expressions used in both static and instance method calls were cached.</source>
          <target state="translated">Dans le .NET Framework antérieures à la <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, des expressions régulières utilisées dans les deux statiques et les appels de méthode d’instance ont été mis en cache.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, only regular expressions used in static method calls are cached.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, uniquement regular expressions utilisées dans les appels de méthode statique sont mises en cache.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capnames">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>Utilisé par un objet généré par la méthode <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>Gets or sets a dictionary that maps named capturing groups to their index values.</source>
          <target state="translated">Obtient ou définit un dictionnaire qui mappe des groupes de capture nommés à leurs valeurs d’index.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>A dictionary that maps named capturing groups to their index values.</source>
          <target state="translated">Dictionnaire qui mappe des groupes de capture nommés à leurs valeurs d’index.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>Note that this property is protected; it can only be accessed from a class derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Notez que cette propriété est protégée ; Il n’est accessible à partir d’une classe dérivée de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>A set operation attempts to convert the value assigned to the property to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object; if this conversion fails, it calls the <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Une opération ensembliste tente de convertir la valeur affectée à la propriété à un <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> de l’objet ; si cette conversion échoue, il appelle le <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>The value assigned to the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.CapNames" /&gt;</ph> property in a set operation is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La valeur affectée à la propriété <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.CapNames" /&gt;</ph> dans une opération ensembliste est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.caps">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>Utilisé par un objet généré par la méthode <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>Gets or sets a dictionary that maps numbered capturing groups to their index values.</source>
          <target state="translated">Obtient ou définit un dictionnaire qui mappe des groupes de capture numérotés à leurs valeurs d’index.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>A dictionary that maps numbered capturing groups to their index values.</source>
          <target state="translated">Dictionnaire qui mappe des groupes de capture numérotés à leurs valeurs d’index.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>Note that this property is protected; it can only be accessed from a class derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Notez que cette propriété est protégée ; Il n’est accessible à partir d’une classe dérivée de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>A set operation attempts to convert the value assigned to the property to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object; if this conversion fails, it calls the <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Une opération ensembliste tente de convertir la valeur affectée à la propriété à un <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> de l’objet ; si cette conversion échoue, il appelle le <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>The value assigned to the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Caps" /&gt;</ph> property in a set operation is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La valeur affectée à la propriété <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Caps" /&gt;</ph> dans une opération ensembliste est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capsize">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>Utilisé par un objet généré par la méthode <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capslist">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>Utilisé par un objet généré par la méthode <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Compiles regular expressions and saves them to disk in a single assembly.</source>
          <target state="translated">Compile les expressions régulières et les enregistre sur le disque dans un assembly unique.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">Tableau qui décrit les expressions régulières à compiler.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The file name of the assembly.</source>
          <target state="translated">Nom de fichier de l’assembly.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects to a named assembly.</source>
          <target state="translated">Compile un ou plusieurs objets <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> spécifiés dans un assembly nommé.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph2">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> méthode génère un assembly .NET Framework dans chaque expression régulière définie dans le <ph id="ph2">`regexinfos`</ph> tableau est représenté par une classe.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">En règle générale, le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> méthode est appelée à partir d’une application distincte qui génère un assembly d’expressions régulières compilées.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">Chaque expression régulière incluse dans l’assembly a les caractéristiques suivantes :</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Il est dérivé le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">Il est attribué le nom qualifié complet qui est défini par le <ph id="ph1">`fullnamespace`</ph> et <ph id="ph2">`name`</ph> paramètres de son <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">Il a la valeur par défaut (ou sans paramètre) constructeur.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">En règle générale, le code qui instancie et utilise l’expression régulière compilée est trouvé dans un assembly ou une application qui est distincte du code qui crée l’assembly.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The following example creates an assembly named RegexLib.dll.</source>
          <target state="translated">L’exemple suivant crée un assembly nommé RegexLib.dll.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The assembly includes two compiled regular expressions.</source>
          <target state="translated">L’assembly inclut deux expressions régulières compilées.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The first, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, matches two identical contiguous words.</source>
          <target state="translated">La première, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, correspond à deux mots contigus identiques.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The second, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, checks whether a string has the correct format to be an email address.</source>
          <target state="translated">La seconde, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, vérifie si une chaîne a le format correct pour être une adresse de messagerie.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</source>
          <target state="translated">L’expression régulière qui vérifie si une chaîne pour des mots en double est ensuite instanciée et utilisée par l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</source>
          <target state="translated">La compilation réussit ce deuxième exemple requiert une référence à RegexLib.dll (assembly créé par le premier exemple) à ajouter au projet.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated">La valeur de la propriété <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> du paramètre <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> est une chaîne vide ou null.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated">Le modèle d'expression régulière d'un ou plusieurs objets de <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contient une syntaxe non valide.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">Si vous développez sur un système qui a <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> ou ses versions intermédiaires est installées, vous ciblez <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, et que vous utilisez la <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> méthode pour créer un assembly qui contient des expressions régulières compilées.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">Essayez d’utiliser l’une des expressions régulières dans la mesure où l’assembly sur un système qui a <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> lève une exception.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">Pour contourner ce problème, vous pouvez procéder de l'une des manières suivantes :</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">Générez l’assembly qui contient les expressions régulières compilées sur un système qui a <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> au lieu de la version ultérieure est installé.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">Au lieu d’appeler <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> et la récupération de l’expression régulière compilée à partir d’un assembly, utilisez soit statique ou d’instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> méthodes avec les <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option lorsque vous instanciez un <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> de l’objet ou appeler une expression régulière méthode de correspondance de modèle.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">Tableau qui décrit les expressions régulières à compiler.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The file name of the assembly.</source>
          <target state="translated">Nom de fichier de l’assembly.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>An array that defines the attributes to apply to the assembly.</source>
          <target state="translated">Tableau qui définit les attributs à appliquer à l'assembly.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects to a named assembly with the specified attributes.</source>
          <target state="translated">Compile un ou plusieurs objets <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> spécifiés dans un assembly nommé avec les attributs spécifiés.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph2">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> méthode génère un assembly .NET Framework dans chaque expression régulière définie dans le <ph id="ph2">`regexinfos`</ph> tableau est représenté par une classe.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">En règle générale, le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> méthode est appelée à partir d’une application distincte qui génère un assembly d’expressions régulières compilées.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">Chaque expression régulière incluse dans l’assembly a les caractéristiques suivantes :</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Il est dérivé le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">Il est attribué le nom qualifié complet qui est défini par le <ph id="ph1">`fullnamespace`</ph> et <ph id="ph2">`name`</ph> paramètres de son <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">Il a la valeur par défaut (ou sans paramètre) constructeur.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">En règle générale, le code qui instancie et utilise l’expression régulière compilée est trouvé dans un assembly ou une application qui est distincte du code qui crée l’assembly.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as <ph id="ph2">`class`</ph> in C# or <ph id="ph3">`Class`</ph>…<ph id="ph4">`End Class`</ph></source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> méthode génère un assembly .NET Framework à partir d’un appel de méthode au lieu d’utiliser le mot clé définition de classe d’un langage particulier (tel que <ph id="ph2">`class`</ph> en c# ou <ph id="ph3">`Class`</ph>...<ph id="ph4">`End Class`</ph></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</source>
          <target state="translated">en Visual Basic), il n’autorise pas les attributs à assigner à l’assembly à l’aide de la syntaxe d’attribut standard du langage de développement .NET Framework.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The <ph id="ph1">`attributes`</ph> parameter provides an alternative method for defining the attributes that apply to the assembly.</source>
          <target state="translated">Le <ph id="ph1">`attributes`</ph> paramètre fournit une autre méthode permettant de définir les attributs qui s’appliquent à l’assembly.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>For each attribute that you want to apply to the assembly, do the following:</source>
          <target state="translated">Pour chaque attribut que vous souhaitez appliquer à l’assembly, procédez comme suit :</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Create an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing the parameter types of the attribute constructor that you want to call.</source>
          <target state="translated">Créer un tableau de <ph id="ph1">&lt;xref:System.Type&gt;</ph> objets représentant les types de paramètre du constructeur d’attribut que vous souhaitez appeler.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Retrieve a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing the attribute class that you want to apply to the new assembly.</source>
          <target state="translated">Récupérer un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objet représentant la classe d’attributs que vous souhaitez appliquer au nouvel assembly.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method of the attribute <ph id="ph2">&lt;xref:System.Type&gt;</ph> object to retrieve a <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object representing the attribute constructor that you want to call.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> (méthode) de l’attribut <ph id="ph2">&lt;xref:System.Type&gt;</ph> objet à récupérer un <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objet représentant le constructeur d’attribut que vous souhaitez appeler.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Pass the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method the array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects that represents the constructor's parameter types.</source>
          <target state="translated">Passez le <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> méthode le tableau de <ph id="ph2">&lt;xref:System.Type&gt;</ph> objets qui représentent les types de paramètre du constructeur.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Create a <ph id="ph1">&lt;xref:System.Object&gt;</ph> array that defines the parameters to pass to the attribute's constructor.</source>
          <target state="translated">Créer un <ph id="ph1">&lt;xref:System.Object&gt;</ph> tableau qui définit les paramètres à passer au constructeur de l’attribut.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Instantiate a <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> object by passing its constructor the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object retrieved in step 3 and the <ph id="ph3">&lt;xref:System.Object&gt;</ph> array created in step 4.</source>
          <target state="translated">Instancier une <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objet en passant à son constructeur le <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objet récupéré à l’étape 3 et <ph id="ph3">&lt;xref:System.Object&gt;</ph> tableau créé à l’étape 4.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>You can then pass an array of these <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects instead of the <ph id="ph2">`attributes`</ph> parameter to the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez ensuite passer un tableau de ces <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objets au lieu du <ph id="ph2">`attributes`</ph> paramètre à la <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The following example creates an assembly named RegexLib.dll and applies the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute to it.</source>
          <target state="translated">L’exemple suivant crée un assembly nommé RegexLib.dll et applique la <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribut.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The assembly includes two compiled regular expressions.</source>
          <target state="translated">L’assembly inclut deux expressions régulières compilées.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The first, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, matches two identical contiguous words.</source>
          <target state="translated">La première, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, correspond à deux mots contigus identiques.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The second, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, checks whether a string has the correct format to be an email address.</source>
          <target state="translated">La seconde, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, vérifie si une chaîne a le format correct pour être une adresse de messagerie.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>You can verify that the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute has been applied to the assembly by examining its manifest with a reflection utility such as ILDasm.</source>
          <target state="translated">Vous pouvez vérifier que le <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribut a été appliqué à l’assembly en examinant son manifeste avec un utilitaire de réflexion tel qu’ILDasm.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</source>
          <target state="translated">L’expression régulière qui vérifie si une chaîne pour des mots en double est ensuite instanciée et utilisée par l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</source>
          <target state="translated">La compilation réussit ce deuxième exemple requiert une référence à RegexLib.dll (assembly créé par le premier exemple) à ajouter au projet.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated">La valeur de la propriété <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> du paramètre <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> est une chaîne vide ou null.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated">Le modèle d'expression régulière d'un ou plusieurs objets de <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contient une syntaxe non valide.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">Si vous développez sur un système qui a <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> ou ses versions intermédiaires est installées, vous ciblez <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, et que vous utilisez la <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> méthode pour créer un assembly qui contient des expressions régulières compilées.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">Essayez d’utiliser l’une des expressions régulières dans la mesure où l’assembly sur un système qui a <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> lève une exception.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">Pour contourner ce problème, vous pouvez procéder de l'une des manières suivantes :</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">Générez l’assembly qui contient les expressions régulières compilées sur un système qui a <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> au lieu de la version ultérieure est installé.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">Au lieu d’appeler <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> et la récupération de l’expression régulière compilée à partir d’un assembly, utilisez soit statique ou d’instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> méthodes avec les <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option lorsque vous instanciez un <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> de l’objet ou appeler une expression régulière méthode de correspondance de modèle.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">Tableau qui décrit les expressions régulières à compiler.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The file name of the assembly.</source>
          <target state="translated">Nom de fichier de l’assembly.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>An array that defines the attributes to apply to the assembly.</source>
          <target state="translated">Tableau qui définit les attributs à appliquer à l'assembly.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The name of the Win32 resource file to include in the assembly.</source>
          <target state="translated">Nom du fichier de ressources Win32 à inclure dans l'assembly.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects and a specified resource file to a named assembly with the specified attributes.</source>
          <target state="translated">Compile un ou plusieurs objets <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> spécifiés et un fichier de ressources spécifié dans un assembly nommé avec les attributs spécifiés.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph3">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated">Le [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName% 2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 &gt; méthode génère un assembly .NET Framework dans chaque expression régulière définie dans le <ph id="ph3">`regexinfos`</ph> tableau est représenté par une classe.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Typically, the [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">En règle générale, le [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 &gt; méthode est appelée à partir d’une application distincte qui génère un assembly d’expressions régulières compilées.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">Chaque expression régulière incluse dans l’assembly a les caractéristiques suivantes :</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">Il est dérivé le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">Il est attribué le nom qualifié complet qui est défini par le <ph id="ph1">`fullnamespace`</ph> et <ph id="ph2">`name`</ph> paramètres de son <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">Il a la valeur par défaut (ou sans paramètre) constructeur.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">En règle générale, le code qui instancie et utilise l’expression régulière compilée est trouvé dans un assembly ou une application qui est distincte du code qui crée l’assembly.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as <ph id="ph2">`class`</ph> in C# or <ph id="ph3">`Class`</ph>…<ph id="ph4">`End Class`</ph></source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> méthode génère un assembly .NET Framework à partir d’un appel de méthode au lieu d’utiliser le mot clé définition de classe d’un langage particulier (tel que <ph id="ph2">`class`</ph> en c# ou <ph id="ph3">`Class`</ph>...<ph id="ph4">`End Class`</ph></target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</source>
          <target state="translated">en Visual Basic), il n’autorise pas les attributs à assigner à l’assembly à l’aide de la syntaxe d’attribut standard du langage de développement .NET Framework.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The <ph id="ph1">`attributes`</ph> parameter provides an alternative method for defining the attributes that apply to the assembly.</source>
          <target state="translated">Le <ph id="ph1">`attributes`</ph> paramètre fournit une autre méthode permettant de définir les attributs qui s’appliquent à l’assembly.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>For each attribute that you want to apply to the assembly, do the following:</source>
          <target state="translated">Pour chaque attribut que vous souhaitez appliquer à l’assembly, procédez comme suit :</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Create an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing the parameter types of the attribute constructor that you want to call.</source>
          <target state="translated">Créer un tableau de <ph id="ph1">&lt;xref:System.Type&gt;</ph> objets représentant les types de paramètre du constructeur d’attribut que vous souhaitez appeler.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Retrieve a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing the attribute class that you want to apply to the new assembly.</source>
          <target state="translated">Récupérer un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objet représentant la classe d’attributs que vous souhaitez appliquer au nouvel assembly.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method of the attribute <ph id="ph2">&lt;xref:System.Type&gt;</ph> object to retrieve a <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object representing the attribute constructor that you want to call.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> (méthode) de l’attribut <ph id="ph2">&lt;xref:System.Type&gt;</ph> objet à récupérer un <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objet représentant le constructeur d’attribut que vous souhaitez appeler.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Pass the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method the array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects that represents the constructor's parameter types</source>
          <target state="translated">Passez le <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> méthode le tableau de <ph id="ph2">&lt;xref:System.Type&gt;</ph> objets qui représentent les types de paramètre du constructeur</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Create a <ph id="ph1">&lt;xref:System.Object&gt;</ph> array that defines the parameters to pass to the attribute's constructor.</source>
          <target state="translated">Créer un <ph id="ph1">&lt;xref:System.Object&gt;</ph> tableau qui définit les paramètres à passer au constructeur de l’attribut.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Instantiate a <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> object by passing its constructor the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object retrieved in step 3 and the <ph id="ph3">&lt;xref:System.Object&gt;</ph> array created in step 4.</source>
          <target state="translated">Instancier une <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objet en passant à son constructeur le <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objet récupéré à l’étape 3 et <ph id="ph3">&lt;xref:System.Object&gt;</ph> tableau créé à l’étape 4.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>You can then pass an array of these <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects instead of the <ph id="ph2">`attributes`</ph> parameter to the [<ph id="ph3">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph4">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method.</source>
          <target state="translated">Vous pouvez ensuite passer un tableau de ces <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objets au lieu du <ph id="ph2">`attributes`</ph> paramètre à la [<ph id="ph3">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph4">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 &gt; méthode.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated">La valeur de la propriété <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> du paramètre <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> est une chaîne vide ou null.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated">Le modèle d'expression régulière d'un ou plusieurs objets de <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contient une syntaxe non valide.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> parameter designates an invalid Win32 resource file.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> désigne un fichier ressource Win32 non valide.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The file designated by the <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> parameter cannot be found.</source>
          <target state="translated">Le fichier désigné par le paramètre <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> est introuvable.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">Si vous développez sur un système qui a <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> ou ses versions intermédiaires est installées, vous ciblez <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, et que vous utilisez la <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> méthode pour créer un assembly qui contient des expressions régulières compilées.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">Essayez d’utiliser l’une des expressions régulières dans la mesure où l’assembly sur un système qui a <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> lève une exception.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">Pour contourner ce problème, vous pouvez procéder de l'une des manières suivantes :</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">Générez l’assembly qui contient les expressions régulières compilées sur un système qui a <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> au lieu de la version ultérieure est installé.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">Au lieu d’appeler <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> et la récupération de l’expression régulière compilée à partir d’un assembly, utilisez soit statique ou d’instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> méthodes avec les <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option lorsque vous instanciez un <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> de l’objet ou appeler une expression régulière méthode de correspondance de modèle.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The input string that contains the text to convert.</source>
          <target state="translated">Chaîne d'entrée qui contient le texte à convertir.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Escapes a minimal set of characters (<ph id="ph1">\\</ph>, *, +, ?, |, {, [, (,), ^, $,., #, and white space) by replacing them with their escape codes.</source>
          <target state="translated">Échappe un ensemble minimal de caractères (<ph id="ph1">\\</ph>, *, +, ?, |, {, [, (,), ^, $,., # et espace blanc) en les remplaçant par leur code d’échappement.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>This instructs the regular expression engine to interpret these characters literally rather than as metacharacters.</source>
          <target state="translated">Cela indique au moteur d'expressions régulières qu'il doit interpréter ces caractères littéralement, et non comme des métacaractères.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>A string of characters with metacharacters converted to their escaped form.</source>
          <target state="translated">Chaîne de caractères dont les métacaractères sont remplacés par leurs codes d'échappement.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> converts a string so that the regular expression engine will interpret any metacharacters that it may contain as character literals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> Convertit une chaîne afin que le moteur des expressions régulières interprète tous les métacaractères qu’elle peut contenir en tant que littéraux de caractère.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>For example, consider a regular expression that is designed to extract comments that are delimited by straight opening and closing brackets ([ and ]) from text.</source>
          <target state="translated">Par exemple, considérez une expression régulière est conçue pour extraire des commentaires qui sont délimitées par des droits crochets ouvrants et fermants ([et]) à partir du texte.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In the following example, the regular expression "[(.*?)]" is interpreted as a character class.</source>
          <target state="translated">Dans l’exemple suivant, l’expression régulière « [(.*?)] » est interprétée comme une classe de caractères.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Rather than matching comments embedded in the input text, the regular expression matches each opening or closing parenthesis, period, asterisk, or question mark.</source>
          <target state="translated">Au lieu de la mise en correspondance les commentaires incorporés dans le texte d’entrée, l’expression régulière correspond à chaque ouverture ou une parenthèse fermante, un période, un astérisque ou un point d’interrogation.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>However, if the opening bracket is escaped by passing it to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method, the regular expression succeeds in matching comments that are embedded in the input string.</source>
          <target state="translated">Toutefois, si le crochet ouvrant est échappé en le passant à la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> méthode, l’expression régulière réussit dans la correspondance des commentaires qui sont incorporés dans la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The following example illustrates this.</source>
          <target state="translated">L'exemple suivant illustre ce comportement.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In a regular expression that is defined by using static text, characters that are to be interpreted literally rather than as metacharacters can be escaped by preceding them with a backslash symbol (<ph id="ph1">\\</ph>) as well as by calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method.</source>
          <target state="translated">Dans une expression régulière qui est définie à l’aide de texte statique, les caractères qui doivent être interprétés littéralement, et non comme des métacaractères peuvent être d’échappement en les faisant précéder d’un symbole de barre oblique inverse (<ph id="ph1">\\</ph>) ainsi que par l’appel de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In a regular expression that is defined dynamically using characters that are not known at design time, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method is particularly important to ensure that the regular expression engine interprets individual characters as literals rather than as metacharacters.</source>
          <target state="translated">Dans une expression régulière qui est définie dynamiquement à l’aide de caractères qui ne sont pas connues au moment du design, appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> méthode est particulièrement important pour garantir que le moteur des expressions régulières interprète les caractères individuels en tant que littéraux plutôt que comme des métacaractères.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If a regular expression pattern includes either the number sign (#) or literal white-space characters, they must be escaped if input text is parsed with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option enabled.</source>
          <target state="translated">Si un modèle d’expression régulière inclut le signe dièse (#) ou des caractères d’espace blanc littéraux, ils doivent être échappés si le texte d’entrée est analysé avec la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option est activée.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>While the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method escapes the straight opening bracket ([) and opening brace ({) characters, it does not escape their corresponding closing characters (] and }).</source>
          <target state="translated">Alors que le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> méthode s’échappe du crochet gauche ([) et l’accolade ouvrante ({}), il n’échappe pas leurs caractères de fermeture correspondants (] et}).</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In most cases, escaping these is not necessary.</source>
          <target state="translated">Dans la plupart des cas, l’échappement n’est pas nécessaire.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If a closing bracket or brace is not preceded by its corresponding opening character, the regular expression engine interprets it literally.</source>
          <target state="translated">Si un crochet fermant ou une accolade n’est pas précédée par son caractère ouvrant correspondant, le moteur des expressions régulières l’interprète littéralement.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If an opening braket or brace is interpreted as a metacharacter, the regular expression engine interprets the first corresponding closing character as a metacharacter.</source>
          <target state="translated">Si une accolade ou un crochet ouvrant est interprétée comme un caractère de remplacement, le moteur des expressions régulières interprète le premier comme caractère fermant correspondant un caractère de remplacement.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If this is not the desired behavior, the closing bracket or brace should be escaped by explicitly prepending the backslash (<ph id="ph1">\\</ph>) character.</source>
          <target state="translated">Si cela n’est pas le comportement souhaité, le crochet fermant ou une accolade doit être échappée en ajoutant explicitement avant la barre oblique inverse (<ph id="ph1">\\</ph>) caractères.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>For an illustration, see the Example section.</source>
          <target state="translated">Pour obtenir une illustration, consultez la section exemple.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The following example extracts comments from text.</source>
          <target state="translated">L’exemple suivant extrait le texte des commentaires.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>It assumes that the comments are delimited by a begin comment symbol and an end comment symbol that is selected by the user.</source>
          <target state="translated">Il part du principe que les commentaires sont délimités par un symbole de commentaire de début et un symbole de commentaire de fin est sélectionné par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Because the comment symbols are to be interpreted literally, they are passed to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method to ensure that they cannot be misinterpreted as metacharacters.</source>
          <target state="translated">Les symboles de commentaire devant être interprétés littéralement, ils sont passés à la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> pour s’assurer qu’ils ne peuvent pas être mal interprétés comme des métacaractères.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In addition, the example explicitly checks whether the end comment symbol entered by the user is a closing bracket (]) or brace (}).</source>
          <target state="translated">En outre, l’exemple vérifie explicitement si le symbole de fin de commentaire entré par l’utilisateur est un crochet fermant (]) ou une accolade (}).</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If it is, a backslash character (<ph id="ph1">\\</ph>) is prepended to the bracket or brace so that it is interpreted literally.</source>
          <target state="translated">Si c’est le cas, une barre oblique inverse (<ph id="ph1">\\</ph>) est ajoutée à l’accolade ou afin qu’il soit interprété littéralement.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Note that the example also uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> collection to display the comment only, rather than the comment together with its opening and closing comment symbols.</source>
          <target state="translated">Notez que l’exemple utilise également la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> collection pour afficher le commentaire uniquement, plutôt que le commentaire et ses symboles ouvrant et fermant.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.factory">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>Utilisé par un objet généré par la méthode <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Returns an array of capturing group names for the regular expression.</source>
          <target state="translated">Retourne un tableau de noms de groupes de captures pour l'expression régulière.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>A string array of group names.</source>
          <target state="translated">Tableau de chaînes des noms de groupes.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The collection of group names contains the set of strings used to name capturing groups in the expression.</source>
          <target state="translated">La collection de noms de groupe contient l’ensemble des chaînes utilisées pour nommer les groupes de capture dans l’expression.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Even if capturing groups are not explicitly named, they are automatically assigned numerical names ("0", "1", "2", "3", and so on).</source>
          <target state="translated">Même si les groupes de capture ne sont pas nommées explicitement, ils reçoivent automatiquement des noms numériques (« 0 », « 1 », « 2 », « 3 » et ainsi de suite).</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The "0" named group represents all text matched by the regular expression pattern.</source>
          <target state="translated">Le « 0 » nommée représente du groupe tout le texte mis en correspondance par le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Numbered groups precede explicitly named groups in the collection, and named groups appear in the order in which they are defined in the regular expression pattern.</source>
          <target state="translated">Les groupes numérotés précèdent les groupes explicitement nommés dans la collection, et les groupes nommés apparaissent dans l’ordre dans lequel ils sont définis dans le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>You can use the <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property on the array returned by this method to determine the number of groups in a regular expression.</source>
          <target state="translated">Vous pouvez utiliser le <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> propriété sur le tableau retourné par cette méthode pour déterminer le nombre de groupes dans une expression régulière.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The following example defines a general-purpose <ph id="ph1">`ShowMatches`</ph> method that displays the names of regular expression groups and their matched text.</source>
          <target state="translated">L’exemple suivant définit une à usage général <ph id="ph1">`ShowMatches`</ph> méthode qui affiche les noms des groupes d’expression régulière et leur texte mis en correspondance.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>In this case, the regular expression pattern <ph id="ph1">`\b(?&lt;FirstWord&gt;\w+)\s?((\w+)\s)*(?&lt;LastWord&gt;\w+)?(?&lt;Punctuation&gt;\p{Po})`</ph> is intended to parse a simple sentence, and to identify its first word, last word, and ending punctuation mark.</source>
          <target state="translated">Dans ce cas, le modèle d’expression régulière <ph id="ph1">`\b(?&lt;FirstWord&gt;\w+)\s?((\w+)\s)*(?&lt;LastWord&gt;\w+)?(?&lt;Punctuation&gt;\p{Po})`</ph> est conçue pour analyser une phrase simple et pour identifier son premier mot, le dernier mot et la marque de fin de signes de ponctuation.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The following table shows how the regular expression pattern is interpreted:</source>
          <target state="translated">Le tableau suivant montre comment le modèle d’expression régulière est interprété :</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`FirstWord`</ph> named group.</source>
          <target state="translated">Il s’agit de la <ph id="ph1">`FirstWord`</ph> groupe nommé.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>\s?</source>
          <target state="translated">\s ?</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or one white-space characters.</source>
          <target state="translated">Mettre en correspondance zéro ou des espaces blancs.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(\w+)</source>
          <target state="translated">(\w+)</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the second capturing group.</source>
          <target state="translated">Il s'agit du deuxième groupe de capture.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>\s</source>
          <target state="translated">\s</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match a white-space character.</source>
          <target state="translated">Mettre en correspondance un espace blanc.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>((\w+)\s)*</source>
          <target state="translated">((\w+)\s)*</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or more occurrences of one or more word characters followed by a white space.</source>
          <target state="translated">Mettre en correspondance zéro ou plusieurs occurrences d’un ou plusieurs caractères alphabétiques suivis par un espace blanc.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the first capturing group.</source>
          <target state="translated">Il s'agit du premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(?<ph id="ph1">\&lt;</ph>LastWord&gt;\w+)?</source>
          <target state="translated">(? <ph id="ph1">\&lt;</ph>LastWord &gt; \w+) ?</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or one occurrence of one or more word characters.</source>
          <target state="translated">Mettre en correspondance zéro ou une occurrence d’un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`LastWord`</ph> named group.</source>
          <target state="translated">Il s’agit de la <ph id="ph1">`LastWord`</ph> groupe nommé.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(?<ph id="ph1">\&lt;</ph>Punctuation&gt;\p{Po})</source>
          <target state="translated">(? <ph id="ph1">\&lt;</ph>Ponctuation &gt; \p{Po})</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match a character whose Unicode category is Punctuation, Other.</source>
          <target state="translated">Mettre en correspondance un caractère dont la catégorie Unicode est le signe de ponctuation autre.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`Punctuation`</ph> named group.</source>
          <target state="translated">Il s’agit de la <ph id="ph1">`Punctuation`</ph> groupe nommé.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Returns an array of capturing group numbers that correspond to group names in an array.</source>
          <target state="translated">Retourne un tableau des numéros de groupes de captures qui correspondent aux noms de groupes d'un tableau.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>An integer array of group numbers.</source>
          <target state="translated">Tableau d'entiers de numéros de groupes.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Both unnamed and named capturing groups can be accessed by number.</source>
          <target state="translated">Les groupes de capture nommés et sans nommés est accessible par un nombre.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Unnamed groups are numbered from left to right starting with 1.</source>
          <target state="translated">Groupes sans nom sont numérotées de gauche à droite en commençant par 1.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>(The capturing group in index 0 (zero) represents the match as a whole.)  Named groups are then numbered from left to right starting with a number that is one greater than the number of unnamed capturing groups.</source>
          <target state="translated">(Le groupe de capture dans l’index 0 (zéro) représente la correspondance dans son ensemble.)  Les groupes nommés sont ensuite numérotés de gauche à droite en commençant avec un nombre qui est supérieur au nombre de sans nom des groupes de capture.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Referencing a group by its number instead of by string name can provide faster access.</source>
          <target state="translated">Faisant référence à un groupe par son numéro et non par nom de chaîne peut fournir un accès plus rapide.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The following example defines a regular expression, <ph id="ph1">`\b((?&lt;word&gt;\w+)\s*)+(?&lt;end&gt;[.?!])`</ph>, that matches a sentence.</source>
          <target state="translated">L’exemple suivant définit une expression régulière, <ph id="ph1">`\b((?&lt;word&gt;\w+)\s*)+(?&lt;end&gt;[.?!])`</ph>, qui correspond à une phrase.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The regular expression includes three capturing groups: an unnamed group that captures an individual word along with a space character that may follow it; a group named <ph id="ph1">`word`</ph> that captures the individual words in the sentence; and a group named <ph id="ph2">`end`</ph> that captures the punctuation that ends the sentence.</source>
          <target state="translated">L’expression régulière comprend trois groupes de capture : un groupe sans nom qui capture un mot individuel avec un caractère d’espace qui peut-être suivre ; un groupe nommé <ph id="ph1">`word`</ph> qui capture les mots individuels de la phrase ; et un groupe nommé <ph id="ph2">`end`</ph> qui capture les signes de ponctuation qui se termine la phrase.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A&gt;</ph> method to get the numbers of all capturing groups, and then displays their captured string.</source>
          <target state="translated">L’exemple appelle la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A&gt;</ph> méthode pour obtenir les numéros de capture de tous les groupes et affiche leur chaîne capturée.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method is used to indicate whether a particular numbered group corresponds to a named group.</source>
          <target state="translated">En outre, le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> méthode est utilisée pour indiquer si un groupe numéroté particulier correspond à un groupe nommé.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière est interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match one or more word characters and assign the matched strings to a group named <ph id="ph1">`word`</ph>.</source>
          <target state="translated">Correspond à un ou plusieurs caractères alphabétiques et affecter les chaînes de mise en correspondance à un groupe nommé <ph id="ph1">`word`</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Correspond à zéro, un ou plusieurs espaces blancs.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Assign the <ph id="ph1">`word`</ph> captured group followed by any captured white-space characters to the first captured group.</source>
          <target state="translated">Affecter le <ph id="ph1">`word`</ph> groupe capturé suivi capturées blancs pour le premier groupe capturé.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match the pattern of one or more word characters followed by any white-space characters one or more times.</source>
          <target state="translated">Correspond au modèle d’un ou plusieurs caractères alphabétiques suivis par les caractères d’espace blanc une ou plusieurs fois.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match a period, question mark, or exclamation point.</source>
          <target state="translated">Mettre en correspondance un point, un point d'interrogation ou un point d'exclamation.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Assign the matched character to the <ph id="ph1">`end`</ph> capturing group.</source>
          <target state="translated">Affectez le caractère correspondant à la <ph id="ph1">`end`</ph> groupe de capture.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The group number to convert to the corresponding group name.</source>
          <target state="translated">Numéro de groupe à convertir en nom de groupe correspondant.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Gets the group name that corresponds to the specified group number.</source>
          <target state="translated">Obtient le nom de groupe qui correspond au numéro de groupe spécifié.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>A string that contains the group name associated with the specified group number.</source>
          <target state="translated">Chaîne qui contient le nom de groupe associé au numéro de groupe spécifié.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If there is no group name that corresponds to <ph id="ph1">&lt;paramref name="i" /&gt;</ph>, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Si aucun nom de groupe ne correspond à <ph id="ph1">&lt;paramref name="i" /&gt;</ph>, la méthode retourne <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</source>
          <target state="translated">Un modèle d’expression régulière peut contenir nommés ou numérotés groupes de capture, qui délimitent des sous-expressions dans une correspondance de modèle.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Numbered groups are delimited by the syntax (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) and are assigned numbers based on their order in the regular expression.</source>
          <target state="translated">Les groupes numérotés sont délimités par la syntaxe (<bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept>) et sont affectés des nombres en fonction de leur position dans l’expression régulière.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Named groups are delimited by the syntax (?<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?'<bpt id="p3">*</bpt>name<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>), where <bpt id="p5">*</bpt>name<ept id="p5">*</ept> is the name by which the subexpression will be identified.</source>
          <target state="translated">Les groupes nommés sont délimités par la syntaxe ( ?<ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>nom<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>sous-expression<ept id="p2">*</ept>) ou ( ? » <bpt id="p3">*</bpt>nom<ept id="p3">*</ept>'<bpt id="p4">*</bpt>sous-expression<ept id="p4">*</ept>), où <bpt id="p5">*</bpt>nom<ept id="p5">*</ept> est le nom par lequel la sous-expression.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</source>
          <target state="translated">(Pour plus d'informations, consultez <bpt id="p1">[</bpt>Constructions de regroupement<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) La <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> méthode identifie les groupes nommés et les groupes numérotés par leur position ordinale dans l’expression régulière.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Ordinal position zero always represents the entire regular expression.</source>
          <target state="translated">La position ordinale zéro représente toujours l’expression régulière entière.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</source>
          <target state="translated">Numérotée tous les groupes sont ensuite comptés avant les groupes nommés, quelle que soit leur position réelle dans le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is the number of a named group, the method returns the name of the group.</source>
          <target state="translated">Si <ph id="ph1">`i`</ph> est le nombre d’un groupe nommé, la méthode retourne le nom du groupe.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is the number of an unnamed group, the method returns the string representation of the number.</source>
          <target state="translated">Si <ph id="ph1">`i`</ph> est le nombre d’un groupe sans nom, la méthode retourne la représentation sous forme de chaîne du nombre.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>For example, if <ph id="ph1">`i`</ph> is 1, the method returns "1".</source>
          <target state="translated">Par exemple, si <ph id="ph1">`i`</ph> est 1, la méthode retourne « 1 ».</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is not the number of a capturing group, the method returns <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`i`</ph> n’est pas le nombre d’un groupe de capture, la méthode retourne <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If a pattern match is found, the value returned by this method can then be used to retrieve the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object that represents the captured group from the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Si une correspondance est trouvée, la valeur retournée par cette méthode peut ensuite être utilisée pour récupérer le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> objet qui représente le groupe capturé à partir de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> est retourné par la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The following example defines a regular expression pattern that matches an address line containing a U.S. city name, state name, and zip code.</source>
          <target state="translated">L’exemple suivant définit un modèle d’expression régulière qui correspond à une ligne d’adresse contenant un nom de ville des États-Unis, le nom de l’état et le code postal.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method to retrieve the names of capturing groups.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> pour récupérer les noms des groupes de capture.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>It then uses these names to retrieve the corresponding captured groups for matches.</source>
          <target state="translated">Il utilise ensuite ces noms pour récupérer les groupes capturés correspondants pour les correspondances.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">Le modèle d’expression régulière est défini par l’expression suivante :</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment le modèle d'expression régulière est interprété.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match one or more alphabetic or white-space character.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs alphabétique ou d’espace blanc.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`city`</ph>.</source>
          <target state="translated">Affecter à ce groupe capturé le nom <ph id="ph1">`city`</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match a comma (,) followed by a white-space character.</source>
          <target state="translated">Mettre en correspondance une virgule (,), suivie d’un caractère d’espace blanc.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match two alphabetic characters.</source>
          <target state="translated">Mettre en correspondance deux caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`state`</ph>.</source>
          <target state="translated">Affecter à ce groupe capturé le nom <ph id="ph1">`state`</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>This group should be followed by a white-space character.</source>
          <target state="translated">Ce groupe doit être suivi d’un caractère d’espace blanc.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match five numeric digits followed by either zero or one occurrence of a hyphen followed by four digits.</source>
          <target state="translated">Correspond à cinq chiffres suivies de zéro ou une occurrence d’un trait d’union suivi de quatre chiffres.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`zip`</ph>.</source>
          <target state="translated">Affecter à ce groupe capturé le nom <ph id="ph1">`zip`</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The group name to convert to the corresponding group number.</source>
          <target state="translated">Nom de groupe à convertir en numéro de groupe correspondant.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Returns the group number that corresponds to the specified group name.</source>
          <target state="translated">Retourne le numéro de groupe qui correspond au nom de groupe spécifié.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The group number that corresponds to the specified group name, or -1 if <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid group name.</source>
          <target state="translated">Numéro de groupe correspondant au nom de groupe spécifié, ou -1 si <ph id="ph1">&lt;paramref name="name" /&gt;</ph> n'est pas un nom de groupe valide.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</source>
          <target state="translated">Un modèle d’expression régulière peut contenir nommés ou numérotés groupes de capture, qui délimitent des sous-expressions dans une correspondance de modèle.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Numbered groups are delimited by the syntax (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) and are assigned numbers based on their order in the regular expression.</source>
          <target state="translated">Les groupes numérotés sont délimités par la syntaxe (<bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept>) et sont affectés des nombres en fonction de leur position dans l’expression régulière.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Named groups are delimited by the syntax (?<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?'<bpt id="p3">*</bpt>name<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>), where <bpt id="p5">*</bpt>name<ept id="p5">*</ept> is the name by which the subexpression will be identified.</source>
          <target state="translated">Les groupes nommés sont délimités par la syntaxe ( ?<ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>nom<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>sous-expression<ept id="p2">*</ept>) ou ( ? » <bpt id="p3">*</bpt>nom<ept id="p3">*</ept>'<bpt id="p4">*</bpt>sous-expression<ept id="p4">*</ept>), où <bpt id="p5">*</bpt>nom<ept id="p5">*</ept> est le nom par lequel la sous-expression.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A&gt;</ph> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</source>
          <target state="translated">(Pour plus d'informations, consultez <bpt id="p1">[</bpt>Constructions de regroupement<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) La <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A&gt;</ph> méthode identifie les groupes nommés et les groupes numérotés par leur position ordinale dans l’expression régulière.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Ordinal position zero always represents the entire regular expression.</source>
          <target state="translated">La position ordinale zéro représente toujours l’expression régulière entière.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</source>
          <target state="translated">Numérotée tous les groupes sont ensuite comptés avant les groupes nommés, quelle que soit leur position réelle dans le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> is the string representation of a group number that is present in the regular expression pattern, the method returns that number.</source>
          <target state="translated">Si <ph id="ph1">`name`</ph> est la représentation sous forme de chaîne d’un numéro de groupe qui est présent dans le modèle d’expression régulière, la méthode retourne ce nombre.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> corresponds to a named capturing group that is present in the regular expression pattern, the method returns its corresponding number.</source>
          <target state="translated">Si <ph id="ph1">`name`</ph> correspond à un jeu nommé groupe qui est présent dans le modèle d’expression régulière de capture, la méthode retourne son numéro correspondant.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The comparison of <ph id="ph1">`name`</ph> with the group name is case-sensitive.</source>
          <target state="translated">La comparaison de <ph id="ph1">`name`</ph> avec le groupe de nom respecte la casse.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> does not correspond to the name of a capturing group or to the string representation of the number of a capturing group, the method returns -1.</source>
          <target state="translated">Si <ph id="ph1">`name`</ph> ne correspond pas au nom d’un groupe de capture ou de la représentation sous forme de chaîne du nombre d’un groupe de capture, la méthode retourne -1.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>Specifies that a pattern-matching operation should not time out.</source>
          <target state="translated">Spécifie qu’une opération de critères spéciaux ne doit pas expirer.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> class constructor and a number of static matching methods use the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constant to indicate that the attempt to find a pattern match should not time out.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> classe constructeur et un nombre d’utilisation de méthodes de correspondance statique le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constante pour indiquer que la tentative de trouver une correspondance de modèle ne doit pas expirer.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>Setting the regular expression engine's time-out value to <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> can cause regular expressions that rely on excessive backtracking to appear to stop responding when processing text that nearly matches the regular expression pattern.</source>
          <target state="translated">Valeur de délai d’attente du moteur des expressions régulières <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> peut entraîner des expressions régulières qui s’appuient sur une rétroaction excessive pour semble cesser de répondre lors du traitement de texte qui correspond presque au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>If you disable time-outs, you should ensure that your regular expression does not rely on excessive backtracking and that it handles text that nearly matches the regular expression pattern.</source>
          <target state="translated">Si vous désactivez des délais d’expiration, vous devez vous assurer que votre expression régulière ne repose pas sur une rétroaction excessive et qu’il gère le texte qui correspond presque au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>For more information about handling backtracking, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion de la rétroaction, consultez <bpt id="p1">[</bpt>rétroaction<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constant can be supplied as the value of the <ph id="ph2">`matchTimeout`</ph> argument of the following members:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constante peut être fournie en tant que la valeur de la <ph id="ph2">`matchTimeout`</ph> argument des membres suivants :</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.InitializeReferences">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>Utilisé par un objet généré par la méthode <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.InitializeReferences">
          <source>References have already been initialized.</source>
          <target state="translated">Les références ont déjà été initialisées.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.internalMatchTimeout">
          <source>The maximum amount of time that can elapse in a pattern-matching operation before the operation times out.</source>
          <target state="translated">Durée maximale pouvant s’écouler lors d’une opération de correspondance de modèle avant que l’opération expire.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Indicates whether the regular expression finds a match in the input string.</source>
          <target state="translated">Indique si l'expression régulière trouve une correspondance dans la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Indicates whether the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor finds a match in a specified input string.</source>
          <target state="translated">Indique si l'expression régulière spécifiée dans le constructeur <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> cherche une correspondance dans une chaîne d'entrée spécifique.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'expression régulière trouve une correspondance ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> méthode est généralement utilisée pour valider une chaîne ou pour vous assurer qu’une chaîne est conforme à un modèle particulier sans récupérer cette chaîne pour une manipulation ultérieure.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez déterminer si une ou plusieurs chaînes correspondent à un modèle d’expression régulière et puis de les récupérer pour une manipulation ultérieure, appel de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> méthode pour déterminer si une chaîne est un numéro de référence valide.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">L’expression régulière suppose que le numéro de référence a un format spécifique qui se compose de trois jeux de caractères séparés par des traits d’union.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Le premier jeu qui contient quatre caractères, doit se composer d’un caractère alphanumérique suivi de deux caractères numériques suivies d’un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">Le deuxième jeu, qui se compose de trois caractères, doit être numérique.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Le troisième jeu, qui se compose de quatre caractères, doit avoir trois caractères numériques suivies d’un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The regular expression pattern is:</source>
          <target state="translated">Le modèle d'expression régulière est le suivant :</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment le modèle d'expression régulière est interprété.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Begin the match at the beginning of the line.</source>
          <target state="translated">Commencer la correspondance au début de la ligne.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Correspond à un caractère alphabétique unique (<ph id="ph1">`a`</ph> via <ph id="ph2">`z`</ph> ou <ph id="ph3">`A`</ph> via <ph id="ph4">`Z`</ph>) ou un caractère numérique.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match two numeric characters.</source>
          <target state="translated">Mettre en correspondance deux caractères numériques.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Correspond à un caractère alphabétique unique (<ph id="ph1">`a`</ph> via <ph id="ph2">`z`</ph> ou <ph id="ph3">`A`</ph> via <ph id="ph4">`Z`</ph>) ou un caractère numérique.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a hyphen.</source>
          <target state="translated">Mettre en correspondance un trait d'union.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Correspond à exactement trois caractères numériques.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Recherchez un trait d’union suivie de trois caractères numériques et mettre en correspondance deux occurrences de ce modèle.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Correspond à un caractère alphabétique unique (<ph id="ph1">`a`</ph> via <ph id="ph2">`z`</ph> ou <ph id="ph3">`A`</ph> via <ph id="ph4">`Z`</ph>) ou un caractère numérique.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>End the match at the end of the line.</source>
          <target state="translated">Terminer la correspondance à la fin de la ligne.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The character position at which to start the search.</source>
          <target state="translated">Position du caractère où la recherche doit commencer.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Indicates whether the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor finds a match in the specified input string, beginning at the specified starting position in the string.</source>
          <target state="translated">Indique si l'expression régulière spécifiée dans le constructeur <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> cherche une correspondance dans la chaîne d'entrée spécifiée, en commençant à la position de départ définie dans la chaîne.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'expression régulière trouve une correspondance ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> méthode est généralement utilisée pour valider une chaîne ou pour vous assurer qu’une chaîne est conforme à un modèle particulier sans récupérer cette chaîne pour une manipulation ultérieure.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez déterminer si une ou plusieurs chaînes correspondent à un modèle d’expression régulière et puis de les récupérer pour une manipulation ultérieure, appel de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> méthode pour déterminer si une chaîne est un numéro de référence valide.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>It searches for a part number that follows a colon (:) character in a string.</source>
          <target state="translated">Il recherche un numéro de référence qui suit un signe deux-points ( :) dans une chaîne.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> method is used to determine the position of the colon character, which is then passed to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> méthode est utilisée pour déterminer la position du caractère deux-points, qui est ensuite transmise à la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">L’expression régulière suppose que le numéro de référence a un format spécifique qui se compose de trois jeux de caractères séparés par des traits d’union.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Le premier jeu qui contient quatre caractères, doit se composer d’un caractère alphanumérique suivi de deux caractères numériques suivies d’un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">Le deuxième jeu, qui se compose de trois caractères, doit être numérique.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Le troisième jeu, qui se compose de quatre caractères, doit avoir trois caractères numériques suivies d’un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The regular expression pattern is:</source>
          <target state="translated">Le modèle d'expression régulière est le suivant :</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment le modèle d'expression régulière est interprété.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Correspond à un caractère alphabétique unique (<ph id="ph1">`a`</ph> via <ph id="ph2">`z`</ph> ou <ph id="ph3">`A`</ph> via <ph id="ph4">`Z`</ph>) ou un caractère numérique.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match two numeric characters.</source>
          <target state="translated">Mettre en correspondance deux caractères numériques.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Correspond à un caractère alphabétique unique (<ph id="ph1">`a`</ph> via <ph id="ph2">`z`</ph> ou <ph id="ph3">`A`</ph> via <ph id="ph4">`Z`</ph>) ou un caractère numérique.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a hyphen.</source>
          <target state="translated">Mettre en correspondance un trait d'union.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Correspond à exactement trois caractères numériques.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Recherchez un trait d’union suivie de trois caractères numériques et mettre en correspondance deux occurrences de ce modèle.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Correspond à un caractère alphabétique unique (<ph id="ph1">`a`</ph> via <ph id="ph2">`z`</ph> ou <ph id="ph3">`A`</ph> via <ph id="ph4">`Z`</ph>) ou un caractère numérique.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>End the match at the end of the line.</source>
          <target state="translated">Terminer la correspondance à la fin de la ligne.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> est inférieur à zéro ou supérieur à la longueur de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string.</source>
          <target state="translated">Indique si l'expression régulière spécifiée cherche une correspondance dans la chaîne d'entrée spécifiée.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'expression régulière trouve une correspondance ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> méthode est généralement utilisée pour valider une chaîne ou pour vous assurer qu’une chaîne est conforme à un modèle particulier sans récupérer cette chaîne pour une manipulation ultérieure.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez déterminer si une ou plusieurs chaînes correspondent à un modèle d’expression régulière et puis de les récupérer pour une manipulation ultérieure, appel de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and calling the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">Statiques <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> méthode est équivalente à la construction d’un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet avec le modèle d’expression régulière spécifié par <ph id="ph3">`pattern`</ph> et en appelant le <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> méthode d’instance.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">Ce modèle d’expression régulière est mis en cache pour la récupération rapide par le moteur d’expression régulière.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> méthode pour déterminer si une chaîne est un numéro de référence valide.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">L’expression régulière suppose que le numéro de référence a un format spécifique qui se compose de trois jeux de caractères séparés par des traits d’union.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Le premier jeu qui contient quatre caractères, doit se composer d’un caractère alphanumérique suivi de deux caractères numériques suivies d’un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">Le deuxième jeu, qui se compose de trois caractères, doit être numérique.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Le troisième jeu, qui se compose de quatre caractères, doit avoir trois caractères numériques suivies d’un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression pattern is:</source>
          <target state="translated">Le modèle d'expression régulière est le suivant :</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment le modèle d'expression régulière est interprété.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Begin the match at the beginning of the line.</source>
          <target state="translated">Commencer la correspondance au début de la ligne.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Correspond à un caractère alphabétique unique (<ph id="ph1">`a`</ph> via <ph id="ph2">`z`</ph> ou <ph id="ph3">`A`</ph> via <ph id="ph4">`Z`</ph>) ou un caractère numérique.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match two numeric characters.</source>
          <target state="translated">Mettre en correspondance deux caractères numériques.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Correspond à un caractère alphabétique unique (<ph id="ph1">`a`</ph> via <ph id="ph2">`z`</ph> ou <ph id="ph3">`A`</ph> via <ph id="ph4">`Z`</ph>) ou un caractère numérique.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a hyphen.</source>
          <target state="translated">Mettre en correspondance un trait d'union.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Correspond à exactement trois caractères numériques.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Recherchez un trait d’union suivie de trois caractères numériques et mettre en correspondance deux occurrences de ce modèle.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">Correspond à un caractère alphabétique unique (<ph id="ph1">`a`</ph> via <ph id="ph2">`z`</ph> ou <ph id="ph3">`A`</ph> via <ph id="ph4">`Z`</ph>) ou un caractère numérique.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>End the match at the end of the line.</source>
          <target state="translated">Terminer la correspondance à la fin de la ligne.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche la méthode d’arriver à expiration, est utilisé.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The recommended static method for verifying a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">La méthode statique recommandée pour vérifier une correspondance de modèle est <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d'expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options.</source>
          <target state="translated">Indique si l'expression régulière spécifiée cherche une correspondance dans la chaîne d'entrée spécifiée, en utilisant les options de correspondance spécifiées.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'expression régulière trouve une correspondance ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> méthode est généralement utilisée pour valider une chaîne ou pour vous assurer qu’une chaîne est conforme à un modèle particulier sans récupérer cette chaîne pour une manipulation ultérieure.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez déterminer si une ou plusieurs chaînes correspondent à un modèle d’expression régulière et puis de les récupérer pour une manipulation ultérieure, appel de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and the regular expression options specified by <ph id="ph4">`options`</ph> and calling the <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">Statiques <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> méthode est équivalente à la construction d’un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet avec le modèle d’expression régulière spécifié par <ph id="ph3">`pattern`</ph> et les options d’expression régulière spécifiées par <ph id="ph4">`options`</ph> et en appelant le <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance méthode.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">Ce modèle d’expression régulière est mis en cache pour la récupération rapide par le moteur d’expression régulière.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> méthode pour déterminer si une chaîne est un numéro de référence valide.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">L’expression régulière suppose que le numéro de référence a un format spécifique qui se compose de trois jeux de caractères séparés par des traits d’union.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Le premier jeu qui contient quatre caractères, doit se composer d’un caractère alphanumérique suivi de deux caractères numériques suivies d’un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">Le deuxième jeu, qui se compose de trois caractères, doit être numérique.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Le troisième jeu, qui se compose de quatre caractères, doit avoir trois caractères numériques suivies d’un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern is:</source>
          <target state="translated">Le modèle d'expression régulière est le suivant :</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment le modèle d'expression régulière est interprété.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">Commencer la correspondance au début de la chaîne.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Correspond à n’importe quel caractère alphabétique unique de <ph id="ph1">`A`</ph> via <ph id="ph2">`Z`</ph>, ou n’importe quel caractère numérique.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match two numeric characters.</source>
          <target state="translated">Mettre en correspondance deux caractères numériques.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Correspond à n’importe quel caractère alphabétique unique de <ph id="ph1">`A`</ph> via <ph id="ph2">`Z`</ph>, ou n’importe quel caractère numérique.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match a hyphen.</source>
          <target state="translated">Mettre en correspondance un trait d'union.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Correspond à exactement trois caractères numériques.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern..</source>
          <target state="translated">Rechercher un trait d’union suivie de trois caractères numériques et mettre en correspondance deux occurrences de ce modèle...</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Correspond à n’importe quel caractère alphabétique unique de <ph id="ph1">`A`</ph> via <ph id="ph2">`Z`</ph>, ou n’importe quel caractère numérique.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at the end of the string.</source>
          <target state="translated">Termine la correspondance à la fin de la chaîne.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> is equivalent to defining the following regular expression:</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> méthode avec la <ph id="ph2">`options`</ph> paramètre la valeur <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> est équivalente à la définition de l’expression régulière suivante :</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For comparison, see the example for the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">Pour la comparaison, consultez l’exemple de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n’est pas une valeur de <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans laquelle elle est appelée.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche la méthode d’arriver à expiration, est utilisé.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for verifying a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">La méthode statique recommandée pour vérifier une correspondance de modèle est <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d'expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Intervalle de délai d'attente, ou <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> pour indiquer que la méthode ne doit pas expirer.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options and time-out interval.</source>
          <target state="translated">Indique si l'expression régulière spécifiée trouve une correspondance dans la chaîne d'entrée spécifiée, en utilisant les options de correspondance et un intervalle de délai d'attente spécifiés.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'expression régulière trouve une correspondance ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> méthode est généralement utilisée pour valider une chaîne ou pour vous assurer qu’une chaîne est conforme à un modèle particulier sans récupérer cette chaîne pour une manipulation ultérieure.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez déterminer si une ou plusieurs chaînes correspondent à un modèle d’expression régulière et puis de les récupérer pour une manipulation ultérieure, appel de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and the regular expression options specified by <ph id="ph4">`options`</ph> and calling the <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">Statiques <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> méthode est équivalente à la construction d’un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet avec le modèle d’expression régulière spécifié par <ph id="ph3">`pattern`</ph> et les options d’expression régulière spécifiées par <ph id="ph4">`options`</ph> et en appelant le <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance méthode.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">Ce modèle d’expression régulière est mis en cache pour la récupération rapide par le moteur d’expression régulière.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">Le <ph id="ph1">`matchTimeout`</ph> paramètre spécifie la manière dont la durée pendant laquelle une recherche de correspondance (méthode) doit effectuer pour trouver une correspondance avant d’expirer. Définition d’un intervalle de délai d’attente empêche les expressions régulières qui s’appuient sur une rétroaction excessive de semble cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>meilleures pratiques des Expressions régulières<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> et <bpt id="p2">[</bpt>rétroaction<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode lève un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> remplace toute valeur de délai d’attente par défaut défini pour le domaine d’application dans laquelle la méthode s’exécute.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> méthode pour déterminer si une chaîne est un numéro de référence valide.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">L’expression régulière suppose que le numéro de référence a un format spécifique qui se compose de trois jeux de caractères séparés par des traits d’union.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Le premier jeu qui contient quatre caractères, doit se composer d’un caractère alphanumérique suivi de deux caractères numériques suivies d’un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">Le deuxième jeu, qui se compose de trois caractères, doit être numérique.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">Le troisième jeu, qui se compose de quatre caractères, doit avoir trois caractères numériques suivies d’un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Matching the regular expression pattern should involve minimal searching through the input string, so the method sets a time-out interval of 500 milliseconds.</source>
          <target state="translated">Mise en correspondance le modèle d’expression régulière doit impliquer minimale effectuer une recherche dans la chaîne d’entrée, la méthode définit un intervalle de délai d’attente de 500 millisecondes.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern is:</source>
          <target state="translated">Le modèle d'expression régulière est le suivant :</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment le modèle d'expression régulière est interprété.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">Commencer la correspondance au début de la chaîne.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Correspond à n’importe quel caractère alphabétique unique de <ph id="ph1">`A`</ph> via <ph id="ph2">`Z`</ph>, ou n’importe quel caractère numérique.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match two numeric characters.</source>
          <target state="translated">Mettre en correspondance deux caractères numériques.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Correspond à n’importe quel caractère alphabétique unique de <ph id="ph1">`A`</ph> via <ph id="ph2">`Z`</ph>, ou n’importe quel caractère numérique.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match a hyphen.</source>
          <target state="translated">Mettre en correspondance un trait d'union.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">Correspond à exactement trois caractères numériques.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">Recherchez un trait d’union suivie de trois caractères numériques et mettre en correspondance deux occurrences de ce modèle.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">Correspond à n’importe quel caractère alphabétique unique de <ph id="ph1">`A`</ph> via <ph id="ph2">`Z`</ph>, ou n’importe quel caractère numérique.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>End the match at the end of the string.</source>
          <target state="translated">Termine la correspondance à la fin de la chaîne.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> is equivalent to defining the following regular expression:</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> méthode avec la <ph id="ph2">`options`</ph> paramètre la valeur <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> est équivalente à la définition de l’expression régulière suivante :</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For comparison, see the example for the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">Pour la comparaison, consultez l’exemple de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n’est pas une valeur de <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> est négatif, égal à zéro ou supérieur à environ 24 jours.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Nous vous recommandons de définir la <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> paramètre à une valeur appropriée, comme les deux secondes.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si vous désactivez des délais d’attente en spécifiant <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, le moteur des expressions régulières offre des performances sont légèrement meilleures.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Toutefois, vous devez désactiver les délais d’expiration uniquement dans les conditions suivantes :</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Cela exclut le texte qui a été dynamiquement par les utilisateurs.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Lorsque le modèle d’expression régulière a été soigneusement testé pour s’assurer qu’elle gère efficacement correspond à, non-correspondances et proche correspond.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Searches an input string for a substring that matches a regular expression pattern and returns the first occurrence as a single <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> object.</source>
          <target state="translated">Recherche dans une chaîne d'entrée une sous-chaîne qui correspond à un modèle d'expression régulière et retourne la première occurrence sous forme d'objet <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> unique.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Searches the specified input string for the first occurrence of the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Recherche dans la chaîne d'entrée spécifiée la première occurrence de l'expression régulière spécifiée dans le constructeur <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objet qui contient des informations sur la correspondance.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière dans une chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les éléments de langage utilisé pour générer un modèle d’expression régulière, consultez <bpt id="p1">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si une correspondance est trouvée, retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propriété contient la sous-chaîne <ph id="ph3">`input`</ph> qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune correspondance n’est trouvée, sa valeur est <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This method returns the first substring in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Cette méthode retourne la première sous-chaîne dans <ph id="ph1">`input`</ph> qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également récupérer toutes les correspondances dans un seul appel de méthode en appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The following example finds regular expression pattern matches in a string, then lists the matched groups, captures, and capture positions.</source>
          <target state="translated">L’exemple suivant recherche le modèle d’expression régulière correspond à dans une chaîne, puis répertorie la mise en correspondance les groupes, captures et positions de capture.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The regular expression pattern <ph id="ph1">`(\w+)\s+(car)`</ph> matches occurrences of the word "car" along with the word that precedes it.</source>
          <target state="translated">Le modèle d’expression régulière <ph id="ph1">`(\w+)\s+(car)`</ph> correspond à des occurrences du mot « car », ainsi que le mot qui précède.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>It is interpreted as shown in the following table.</source>
          <target state="translated">Il est interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">Il s'agit du premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match one or more white-space characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères d’espace blanc.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>(car)</source>
          <target state="translated">(car)</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match the literal string "car".</source>
          <target state="translated">Correspond à la chaîne littérale « car ».</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This is the second capturing group.</source>
          <target state="translated">Il s'agit du deuxième groupe de capture.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The zero-based character position at which to start the search.</source>
          <target state="translated">Position du caractère de base zéro à partir duquel commencer la recherche.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position in the string.</source>
          <target state="translated">Recherche dans la chaîne d'entrée la première occurrence d'une expression régulière, en commençant à la position de départ spécifiée dans la chaîne.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objet qui contient des informations sur la correspondance.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method returns the first substring that matches a regular expression pattern, starting at or after the <ph id="ph2">`startat`</ph> character position, in an input string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière, en commençant à ou après le <ph id="ph2">`startat`</ph> position de caractère, dans une chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les éléments de langage utilisé pour générer un modèle d’expression régulière, consultez <bpt id="p1">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">Le modèle d’expression régulière pour lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> recherche de la méthode est définie par l’appel à un de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructeurs de classe.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les éléments qui peuvent former un modèle d’expression régulière, consultez <bpt id="p1">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can optionally specify a starting position in the string by using the <ph id="ph1">`startat`</ph> parameter.</source>
          <target state="translated">Vous pouvez éventuellement spécifier une position de départ dans la chaîne à l’aide de le <ph id="ph1">`startat`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>When the regular expression engine parses from left to right (the default), the match and the scan move rightward, starting at the character specified in <ph id="ph1">`startat`</ph>.</source>
          <target state="translated">Lorsque le moteur des expressions régulières analyse de gauche à droite (la valeur par défaut), la correspondance et l’analyse de la déplacent vers la droite, en commençant au caractère spécifié dans <ph id="ph1">`startat`</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>When the regular expression engine parses from right to left (when the regular expression pattern is constructed with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option), the match and scan move in the opposite direction and begin with the character at <ph id="ph2">`startat`</ph> -1.</source>
          <target state="translated">Quand le moteur des expressions régulières analyse de droite à gauche (lorsque le modèle d’expression régulière est construit avec les <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option), la correspondance et l’analyse dans la direction opposée et commencent par le caractère situé à <ph id="ph2">`startat`</ph> -1.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you do not specify a starting position, the search begins at the default <ph id="ph1">`startat`</ph> position.</source>
          <target state="translated">Si vous ne spécifiez pas une position de départ, la recherche commence à la valeur par défaut <ph id="ph1">`startat`</ph> position.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If the regular expression searches from left to right, the default <ph id="ph1">`startat`</ph> position is at the left end of <ph id="ph2">`input`</ph>; if it searches from right to left, the default <ph id="ph3">`startat`</ph> position is at the right end of <ph id="ph4">`input`</ph>.</source>
          <target state="translated">Si l’expression régulière recherche de gauche à droite, la valeur par défaut <ph id="ph1">`startat`</ph> position est à l’extrémité gauche du <ph id="ph2">`input`</ph>; si elle cherche de droite à gauche, la valeur par défaut <ph id="ph3">`startat`</ph> position est à l’extrémité droite du <ph id="ph4">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you want to restrict a match so that it begins at a particular character position in the string and the regular expression engine does not scan the remainder of the string for a match, anchor the regular expression with a <ph id="ph1">`\G`</ph> (at the left for a left-to-right pattern, or at the right for a right-to-left pattern).</source>
          <target state="translated">Si vous souhaitez restreindre une correspondance afin qu’elle commence à une position de caractère particulier dans la chaîne et le moteur des expressions régulières n’analyse pas le reste de la chaîne pour une correspondance, ancrez l’expression régulière avec un <ph id="ph1">`\G`</ph> (à gauche de gauche à droite modèle, ou à droite pour un modèle de droite à gauche).</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>This restricts the match so it must start exactly at <ph id="ph1">`startat`</ph>.</source>
          <target state="translated">Ceci limite la correspondance afin qu’elle commence exactement à <ph id="ph1">`startat`</ph>.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si une correspondance est trouvée, retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propriété contient la sous-chaîne <ph id="ph3">`input`</ph> qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune correspondance n’est trouvée, sa valeur est <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>This method returns the first substring found at or after the <ph id="ph1">`startat`</ph> character position in <ph id="ph2">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Cette méthode retourne la première sous-chaîne trouvée sur ou après le <ph id="ph1">`startat`</ph> position de caractère dans <ph id="ph2">`input`</ph> qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également récupérer toutes les correspondances dans un seul appel de méthode en appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exeeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établi pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> est inférieur à zéro ou supérieur à la longueur de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Searches the specified input string for the first occurrence of the specified regular expression.</source>
          <target state="translated">Recherche dans la chaîne d'entrée spécifiée la première occurrence de l'expression régulière spécifiée.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objet qui contient des informations sur la correspondance.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière dans une chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les éléments de langage utilisé pour générer un modèle d’expression régulière, consultez <bpt id="p1">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Statiques <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> méthode est équivalente à la construction d’un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de l’objet avec le modèle d’expression régulière spécifié et l’appel de l’instance <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>In this case, the regular expression engine caches the regular expression pattern.</source>
          <target state="translated">Dans ce cas, le moteur d’expression régulière met en cache le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si une correspondance est trouvée, retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propriété contient la sous-chaîne <ph id="ph3">`input`</ph> qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune correspondance n’est trouvée, sa valeur est <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>This method returns the first substring in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Cette méthode retourne la première sous-chaîne dans <ph id="ph1">`input`</ph> qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également récupérer toutes les correspondances dans un seul appel de méthode en appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method to find the first word that contains at least one <ph id="ph2">`z`</ph> character, and then calls the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method to find any additional matches.</source>
          <target state="translated">L’exemple suivant appelle la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> méthode pour rechercher le premier mot qui contient au moins un <ph id="ph2">`z`</ph> caractères, puis appelle la <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> procédé à aucune autre correspondance trouvée.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w*z+\w*\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\b\w*z+\w*\b`</ph> est interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match one or more occurrences of the <ph id="ph1">`z`</ph> character.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs occurrences de la <ph id="ph1">`z`</ph> caractère.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans laquelle elle est appelée.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche la méthode d’arriver à expiration, est utilisé.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The recommended static method for retrieving a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">La méthode statique recommandée pour la récupération d’une correspondance de modèle est <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The zero-based character position in the input string that defines the leftmost position to be searched.</source>
          <target state="translated">Position du caractère de base zéro dans la chaîne d'entrée qui définit la position la plus à gauche à parcourir.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The number of characters in the substring to include in the search.</source>
          <target state="translated">Nombre de caractères dans la sous-chaîne à inclure dans la recherche.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position and searching only the specified number of characters.</source>
          <target state="translated">Recherche dans la chaîne d'entrée la première occurrence d'une expression régulière, en commençant à la position de départ spécifiée et en recherchant uniquement le nombre spécifié de caractères.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objet qui contient des informations sur la correspondance.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method returns the first substring that matches a regular expression pattern in a portion of an input string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière dans une partie d’une chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les éléments de langage utilisé pour générer un modèle d’expression régulière, consultez <bpt id="p1">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">Le modèle d’expression régulière pour lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> recherche de la méthode est définie par l’appel à un de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructeurs de classe.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les éléments qui peuvent former un modèle d’expression régulière, consultez <bpt id="p1">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method searches the portion of <ph id="ph2">`input`</ph> defined by the <ph id="ph3">`beginning`</ph> and <ph id="ph4">`length`</ph> parameters for the regular expression pattern.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> méthode recherche dans la partie de <ph id="ph2">`input`</ph> définie par le <ph id="ph3">`beginning`</ph> et <ph id="ph4">`length`</ph> paramètres pour le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">`beginning`</ph> always defines the index of the leftmost character to include in the search, and <ph id="ph2">`length`</ph> defines the maximum number of characters to search.</source>
          <target state="translated"><ph id="ph1">`beginning`</ph> toujours définit l’index du caractère à l’extrême gauche à inclure dans la recherche, et <ph id="ph2">`length`</ph> définit le nombre maximal de caractères à rechercher.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>Together, they define the range of the search.</source>
          <target state="translated">Ensemble, ils définissent la plage de la recherche.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If the search proceeds from left to right (the default), the regular expression engine searches from the character at index <ph id="ph1">`beginning`</ph> to the character at index <ph id="ph2">`beginning`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1.</source>
          <target state="translated">Si la recherche se poursuit à partir de la gauche vers la droite (la valeur par défaut), le moteur d’expression régulière recherche à partir du caractère à l’index <ph id="ph1">`beginning`</ph> à caractère à l’index <ph id="ph2">`beginning`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If the regular expression engine was instantiated by using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option so that the search proceeds from right to left, the regular expression engine searches from the character at index <ph id="ph2">`beginning`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1 to the character at index <ph id="ph5">`beginning`</ph>.</source>
          <target state="translated">Si le moteur d’expression régulière a été instancié à l’aide de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option pour que la recherche se poursuit de droite à gauche, les recherches de moteur d’expression régulière à partir du caractère à l’index <ph id="ph2">`beginning`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1 pour le caractère à l’index <ph id="ph5">`beginning`</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>This method returns the first match that it finds within this range.</source>
          <target state="translated">Cette méthode retourne la première correspondance qu’il trouve dans cette plage.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si une correspondance est trouvée, retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propriété contient la sous-chaîne <ph id="ph3">`input`</ph> qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune correspondance n’est trouvée, sa valeur est <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out value when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas une valeur de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph> est inférieur à zéro ou supérieur à la longueur de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro ou supérieur à la longueur de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph><ph id="ph2">&lt;see langword="+" /&gt;</ph><ph id="ph3">&lt;paramref name="length" /&gt;</ph><ph id="ph4">&lt;see langword="–1" /&gt;</ph> identifies a position that is outside the range of <ph id="ph5">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph><ph id="ph2">&lt;see langword="+" /&gt;</ph><ph id="ph3">&lt;paramref name="length" /&gt;</ph><ph id="ph4">&lt;see langword="–1" /&gt;</ph> identifie un emplacement situé en dehors de la plage de <ph id="ph5">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d'expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options.</source>
          <target state="translated">Recherche dans la chaîne d'entrée la première occurrence de l'expression régulière spécifiée, en utilisant les options de correspondance spécifiées.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objet qui contient des informations sur la correspondance.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière dans une chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les éléments de langage utilisé pour générer un modèle d’expression régulière, consultez <bpt id="p1">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor and calling the instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Statiques <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> méthode est équivalente à la construction d’un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de l’objet avec la <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructeur et l’appel de l’instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si une correspondance est trouvée, retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propriété contient la sous-chaîne <ph id="ph3">`input`</ph> qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune correspondance n’est trouvée, sa valeur est <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method returns the first substring found in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Cette méthode retourne la première sous-chaîne trouvée dans <ph id="ph1">`input`</ph> qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également récupérer toutes les correspondances dans un seul appel de méthode en appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example defines a regular expression that matches words beginning with the letter "a".</source>
          <target state="translated">L’exemple suivant définit une expression régulière qui correspond aux mots qui commencent par la lettre « a ».</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>It uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> option to ensure that the regular expression locates words beginning with both an uppercase "a" and a lowercase "a".</source>
          <target state="translated">Elle utilise le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> option pour vous assurer que l’expression régulière recherche de mots qui commencent avec les deux en majuscules, minuscules « a » et un « a ».</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\ba\w*\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\ba\w*\b`</ph> est interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the character "a".</source>
          <target state="translated">Le caractère « a ».</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n'est pas une combinaison d'opérations de bits des valeurs <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans laquelle elle est appelée.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche la méthode d’arriver à expiration, est utilisé.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for retrieving a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">La méthode statique recommandée pour la récupération d’une correspondance de modèle est <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d'expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Intervalle de délai d'attente, ou <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> pour indiquer que la méthode ne doit pas expirer.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options and time-out interval.</source>
          <target state="translated">Recherche dans la chaîne d'entrée la première occurrence de l'expression régulière spécifiée, en utilisant les options de correspondance et l'intervalle de délai d'attente spécifiés.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>An object that contains information about the match.</source>
          <target state="translated">Objet qui contient des informations sur la correspondance.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière dans une chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les éléments de langage utilisé pour générer un modèle d’expression régulière, consultez <bpt id="p1">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor and calling the instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Statiques <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> méthode est équivalente à la construction d’un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de l’objet avec la <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructeur et l’appel de l’instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Si une correspondance est trouvée, retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propriété contient la sous-chaîne <ph id="ph3">`input`</ph> qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune correspondance n’est trouvée, sa valeur est <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This method returns the first substring found in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">Cette méthode retourne la première sous-chaîne trouvée dans <ph id="ph1">`input`</ph> qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également récupérer toutes les correspondances dans un seul appel de méthode en appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">Le <ph id="ph1">`matchTimeout`</ph> paramètre spécifie la manière dont la durée pendant laquelle une recherche de correspondance (méthode) doit effectuer pour trouver une correspondance avant d’expirer. Définition d’un intervalle de délai d’attente empêche les expressions régulières qui s’appuient sur une rétroaction excessive de semble cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>meilleures pratiques des Expressions régulières<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> et <bpt id="p2">[</bpt>rétroaction<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode lève un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> remplace toute valeur de délai d’attente par défaut défini pour le domaine d’application dans laquelle la méthode s’exécute.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n'est pas une combinaison d'opérations de bits des valeurs <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> est négatif, égal à zéro ou supérieur à environ 24 jours.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Un dépassement du délai d’attente s’est produit.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Nous vous recommandons de définir la <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> paramètre à une valeur appropriée, comme les deux secondes.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si vous désactivez des délais d’attente en spécifiant <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, le moteur des expressions régulières offre des performances sont légèrement meilleures.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Toutefois, vous devez désactiver les délais d’expiration uniquement dans les conditions suivantes :</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Cela exclut le texte qui a été dynamiquement par les utilisateurs.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Lorsque le modèle d’expression régulière a été soigneusement testé pour s’assurer qu’elle gère efficacement correspond à, non-correspondances et proche correspond.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Searches an input string for all occurrences of a regular expression and returns all the matches.</source>
          <target state="translated">Recherche dans une chaîne d'entrée toutes les occurrences d'une expression régulière et retourne toutes les correspondances.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When a match attempt is repeated by calling the <ph id="ph1">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /&gt;</ph> method, the regular expression engine gives empty matches special treatment.</source>
          <target state="translated">Lorsqu’une tentative de correspondance est répétée en appelant le <ph id="ph1">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /&gt;</ph> (méthode), le moteur des expressions régulières donne correspondances vides un traitement spécial.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Usually, the regular expression engine begins the search for the next match exactly where the previous match left off.</source>
          <target state="translated">En règle générale, le moteur des expressions régulières commence la recherche de la correspondance suivante exactement où la correspondance précédente s’est arrêté.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, after an empty match, the regular expression engine advances by one character before trying the next match.</source>
          <target state="translated">Toutefois, après une correspondance vide, le moteur des expressions régulières avance d’un caractère avant d’essayer la correspondance suivante.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This behavior guarantees that the regular expression engine will progress through the string.</source>
          <target state="translated">Ce comportement garantit que le moteur des expressions régulières doit suivre la chaîne.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Otherwise, because an empty match does not result in any forward movement, the next match would start in exactly the same place as the previous match, and it would match the same empty string repeatedly.</source>
          <target state="translated">Sinon, étant donné que les déplacements vers l’avant n’entraîne pas une correspondance vide, la correspondance suivante commencerait exactement la même position que la correspondance précédente et elle correspondrait à plusieurs reprises la même chaîne vide.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In the following example, the regular expression pattern <bpt id="p1">&lt;c&gt;</bpt>a*<ept id="p1">&lt;/c&gt;</ept> searches for zero or more occurrences of the letter "a" in the string "abaabb".</source>
          <target state="translated">Dans l’exemple suivant, le modèle d’expression régulière <bpt id="p1">&lt;c&gt;</bpt>un *<ept id="p1">&lt;/c&gt;</ept> recherche zéro ou plusieurs occurrences de la lettre « a » dans la chaîne « abaabb ».</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>As the output from the example shows, the resulting <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph> object contains six <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects.</source>
          <target state="translated">Comme la sortie de l’exemple, résultant <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph> objet contient six <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The first match attempt finds the first "a".</source>
          <target state="translated">La première tentative de correspondance recherche le premier « a ».</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The second match starts exactly where the first match ends, before the first b; it finds zero occurrences of "a" and returns an empty string.</source>
          <target state="translated">La deuxième correspondance démarre exactement où la première correspondance prend fin, avant le premier b ; il trouve aucune occurrence de « a » et retourne une chaîne vide.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The third match does not begin exactly where the second match ended, because the second match returned an empty string.</source>
          <target state="translated">La troisième correspondance ne commence pas exactement où la deuxième correspondance s’est terminée, car la deuxième correspondance a retourné une chaîne vide.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Instead, it begins one character later, after the first "b".</source>
          <target state="translated">Au lieu de cela, il commence un caractère plus tard, après le premier « b ».</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The third match finds two occurrences of "a" and returns "aa".</source>
          <target state="translated">La troisième correspondance trouve deux occurrences de « a » et retourne « aa ».</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The fourth match attempt begins where the third match ended, before the second "b", and returns an empty string.</source>
          <target state="translated">La quatrième correspondance commence là où s’est terminée la troisième, avant le deuxième « b » et retourne une chaîne vide.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The fifth match attempt again advances one character so that it begins before the third "b" and returns an empty string.</source>
          <target state="translated">La cinquième tentative de correspondance avance un caractère afin qu’il commence avant le troisième « b » et retourne une chaîne vide.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The sixth match begins after the last "b" and returns an empty string again.</source>
          <target state="translated">La sixième correspondance commence après le dernier « b » et retourne une chaîne vide à nouveau.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Searches the specified input string for all occurrences of a regular expression.</source>
          <target state="translated">Recherche dans la chaîne d'entrée spécifiée toutes les occurrences d'une expression régulière.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Collection des objets <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> trouvés par la recherche.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Si aucune correspondance n’est trouvée, la méthode retourne un objet de collection vide.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> méthode est similaire à la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> (méthode), à ceci près qu’elle retourne des informations sur toutes les correspondances trouvées dans la chaîne d’entrée, au lieu d’une correspondance unique.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Il est équivalent au code suivant :</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The collection includes only matches and terminates at the first non-match.</source>
          <target state="translated">La collection inclut uniquement les correspondances et se termine à la première non-correspondance.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">Le modèle d’expression régulière pour lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> recherche de la méthode est définie par l’appel à un de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructeurs de classe.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les éléments qui peuvent former un modèle d’expression régulière, consultez <bpt id="p1">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> méthode utilise l’évaluation tardive pour remplir retourné <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">L’accès à des membres de ce regroupement comme <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> provoque la collection à remplir immédiatement.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Pour tirer parti de l’évaluation tardive, vous devez itérer la collection à l’aide d’une construction comme <ph id="ph1">`foreach`</ph> en c# et <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>in Visual Basic.</source>
          <target state="translated">en Visual Basic.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">En raison de son évaluation différée, appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> méthode ne lève pas une <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property is not <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> and a matching operation exceeds the time-out interval.</source>
          <target state="translated">Toutefois, l’exception est levée lorsqu’une opération est effectuée sur le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet retourné par cette méthode, si le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> propriété n’est pas <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> et une opération de correspondance dépasse le délai d’attente.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method to identify any words in a sentence that end in "es".</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> méthode pour identifier tout mot dans une phrase qui se termine par « es ».</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\b\w+es\b`</ph> est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Match the literal string "es".</source>
          <target state="translated">Correspond à la chaîne littérale « es ».</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The character position in the input string at which to start the search.</source>
          <target state="translated">Position du caractère dans la chaîne d'entrée à partir duquel commencer la recherche.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Searches the specified input string for all occurrences of a regular expression, beginning at the specified starting position in the string.</source>
          <target state="translated">Recherche dans la chaîne d'entrée spécifiée toutes les occurrences d'une expression régulière, en commençant à la position de démarrage spécifiée dans la chaîne.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Collection des objets <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> trouvés par la recherche.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Si aucune correspondance n’est trouvée, la méthode retourne un objet de collection vide.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The  <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method is similar to the  <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> méthode est similaire à la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> (méthode), à ceci près qu’elle retourne des informations sur toutes les correspondances trouvées dans la chaîne d’entrée, au lieu d’une correspondance unique.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Il est équivalent au code suivant :</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">Le modèle d’expression régulière pour lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> recherche de la méthode est définie par l’appel à un de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructeurs de classe.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les éléments qui peuvent former un modèle d’expression régulière, consultez <bpt id="p1">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> méthode utilise l’évaluation tardive pour remplir retourné <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">L’accès à des membres de ce regroupement comme <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> provoque la collection à remplir immédiatement.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Pour tirer parti de l’évaluation tardive, vous devez itérer la collection à l’aide d’une construction comme <ph id="ph1">`foreach`</ph> en c# et <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>in Visual Basic.</source>
          <target state="translated">en Visual Basic.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">En raison de son évaluation différée, appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> méthode ne lève pas une <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property is not <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> and a matching operation exceeds the time-out interval..</source>
          <target state="translated">Toutefois, l’exception est levée lorsqu’une opération est effectuée sur le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet retourné par cette méthode, si le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> propriété n’est pas <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> et une opération de correspondance dépasse le délai d’attente...</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method to find the first word in a sentence that ends in "es", and then calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method to identify any additional words that end in "es".</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> méthode pour rechercher le premier mot d’une phrase qui se termine par « es », puis appelle la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> méthode pour identifier des mots supplémentaires qui se terminent par « es ».</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\b\w+es\b`</ph> est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Match the literal string "es".</source>
          <target state="translated">Correspond à la chaîne littérale « es ».</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> est inférieur à zéro ou supérieur à la longueur de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Searches the specified input string for all occurrences of a specified regular expression.</source>
          <target state="translated">Recherche dans la chaîne d'entrée spécifiée toutes les occurrences d'une expression régulière spécifiée.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Collection des objets <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> trouvés par la recherche.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Si aucune correspondance n’est trouvée, la méthode retourne un objet de collection vide.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> méthode est similaire à la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> (méthode), à ceci près qu’elle retourne des informations sur toutes les correspondances trouvées dans la chaîne d’entrée, au lieu d’une correspondance unique.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Il est équivalent au code suivant :</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">La méthode statique <ph id="ph1">`Matches`</ph> méthodes sont équivalentes à construire un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de l’objet avec le modèle d’expression régulière spécifié et en appelant la méthode d’instance <ph id="ph3">`Matches`</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> méthode utilise l’évaluation tardive pour remplir retourné <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">L’accès à des membres de ce regroupement comme <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> provoque la collection à remplir immédiatement.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Pour tirer parti de l’évaluation tardive, vous devez itérer la collection à l’aide d’une construction comme <ph id="ph1">`foreach`</ph> en c# et <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>in Visual Basic.</source>
          <target state="translated">en Visual Basic.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">En raison de son évaluation différée, appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> méthode ne lève pas une <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</source>
          <target state="translated">Toutefois, l’exception est levée lorsqu’une opération est effectuée sur le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet retourné par cette méthode, si un intervalle de délai d’attente est défini par la propriété « REGEX_DEFAULT_MATCH_TIMEOUT » du domaine d’application actuel et une opération de correspondance dépasse ce délai d’attente.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method to identify any word in a sentence that ends in "es".</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> méthode pour identifier tout mot dans une phrase qui se termine par « es ».</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\b\w+es\b`</ph> est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Match the literal string "es".</source>
          <target state="translated">Correspond à la chaîne littérale « es ».</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans laquelle elle est appelée.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche la méthode d’arriver à expiration, est utilisé.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The recommended static method for retrieving multiple pattern matches is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you specify the time-out interval.</source>
          <target state="translated">La méthode statique recommandée pour la récupération de plusieurs modèle correspond est <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, ce qui vous permet de spécifier l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that specify options for matching.</source>
          <target state="translated">Combinaison de bits de valeurs d'énumération qui spécifient des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options.</source>
          <target state="translated">Recherche dans la chaîne d'entrée spécifiée toutes les occurrences d'une expression régulière spécifique, en utilisant les options de correspondance spécifiées.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Collection des objets <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> trouvés par la recherche.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Si aucune correspondance n’est trouvée, la méthode retourne un objet de collection vide.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> méthode est similaire à la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> (méthode), à ceci près qu’elle retourne des informations sur toutes les correspondances trouvées dans la chaîne d’entrée, au lieu d’une correspondance unique.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Il est équivalent au code suivant :</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">La méthode statique <ph id="ph1">`Matches`</ph> méthodes sont équivalentes à construire un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de l’objet avec le modèle d’expression régulière spécifié et en appelant la méthode d’instance <ph id="ph3">`Matches`</ph>.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> méthode utilise l’évaluation tardive pour remplir retourné <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">L’accès à des membres de ce regroupement comme <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> provoque la collection à remplir immédiatement.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Pour tirer parti de l’évaluation tardive, vous devez itérer la collection à l’aide d’une construction comme <ph id="ph1">`foreach`</ph> en c# et <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>in Visual Basic.</source>
          <target state="translated">en Visual Basic.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">En raison de son évaluation différée, appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> méthode ne lève pas une <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</source>
          <target state="translated">Toutefois, l’exception est levée lorsqu’une opération est effectuée sur le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet retourné par cette méthode, si un intervalle de délai d’attente est défini par la propriété « REGEX_DEFAULT_MATCH_TIMEOUT » du domaine d’application actuel et une opération de correspondance dépasse ce délai d’attente.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method to identify any word in a sentence that ends in "es", and then calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to perform a case-insensitive comparison of the pattern with the input string.</source>
          <target state="translated">L’exemple suivant appelle la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> méthode pour identifier tout mot dans une phrase qui se termine par « es », puis appelle la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> méthode pour effectuer une comparaison respectant la casse du modèle avec la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>As the output shows, the two methods return different results.</source>
          <target state="translated">Comme le montre la sortie, les deux méthodes retournent des résultats différents.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\b\w+es\b`</ph> est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the literal string "es".</source>
          <target state="translated">Correspond à la chaîne littérale « es ».</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n'est pas une combinaison d'opérations de bits des valeurs <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans laquelle elle est appelée.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche la méthode d’arriver à expiration, est utilisé.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for retrieving multiple pattern matches is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">La méthode statique recommandée pour la récupération de plusieurs modèle correspond est <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that specify options for matching.</source>
          <target state="translated">Combinaison de bits de valeurs d'énumération qui spécifient des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Intervalle de délai d'attente, ou <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> pour indiquer que la méthode ne doit pas expirer.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options and time-out interval.</source>
          <target state="translated">Recherche dans la chaîne d'entrée spécifiée toutes les occurrences d'une expression régulière spécifiée, en utilisant les options de correspondance et l'intervalle de délai d'attente spécifiés.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">Collection des objets <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> trouvés par la recherche.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">Si aucune correspondance n’est trouvée, la méthode retourne un objet de collection vide.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> méthode est similaire à la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> (méthode), à ceci près qu’elle retourne des informations sur toutes les correspondances trouvées dans la chaîne d’entrée, au lieu d’une correspondance unique.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Il est équivalent au code suivant :</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">La méthode statique <ph id="ph1">`Matches`</ph> méthodes sont équivalentes à construire un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de l’objet avec le modèle d’expression régulière spécifié et en appelant la méthode d’instance <ph id="ph3">`Matches`</ph>.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> méthode utilise l’évaluation tardive pour remplir retourné <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">L’accès à des membres de ce regroupement comme <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> provoque la collection à remplir immédiatement.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Pour tirer parti de l’évaluation tardive, vous devez itérer la collection à l’aide d’une construction comme <ph id="ph1">`foreach`</ph> en c# et <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>in Visual Basic.</source>
          <target state="translated">en Visual Basic.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">En raison de son évaluation différée, appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> méthode ne lève pas une <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, an exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a matching operation exceeds this time-out interval specified by the<ph id="ph2">`matchTimeout`</ph> parameter.</source>
          <target state="translated">Toutefois, une exception est levée lorsqu’une opération est effectuée sur le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet retourné par cette méthode, si une opération de correspondance dépasse ce délai d’attente spécifié par le<ph id="ph2">`matchTimeout`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to perform a case-sensitive comparison that matches any word in a sentence that ends in "es".</source>
          <target state="translated">L’exemple suivant appelle la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> méthode pour effectuer une comparaison respectant la casse qui correspond à n’importe quel mot d’une phrase qui se termine par « es ».</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to perform a case-insensitive comparison of the pattern with the input string.</source>
          <target state="translated">Il appelle ensuite la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> méthode pour effectuer une comparaison respectant la casse du modèle avec la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In both cases, the time-out interval is set to one second.</source>
          <target state="translated">Dans les deux cas, l’intervalle de délai d’expiration est définie à une seconde.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>As the output shows, the two methods return different results.</source>
          <target state="translated">Comme le montre la sortie, les deux méthodes retournent des résultats différents.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\b\w+es\b`</ph> est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the literal string "es".</source>
          <target state="translated">Correspond à la chaîne littérale « es ».</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n'est pas une combinaison d'opérations de bits des valeurs <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> est négatif, égal à zéro ou supérieur à environ 24 jours.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Nous vous recommandons de définir la <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> paramètre à une valeur appropriée, comme les deux secondes.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si vous désactivez des délais d’attente en spécifiant <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, le moteur des expressions régulières offre des performances sont légèrement meilleures.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Toutefois, vous devez désactiver les délais d’expiration uniquement dans les conditions suivantes :</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Cela exclut le texte qui a été dynamiquement par les utilisateurs.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Lorsque le modèle d’expression régulière a été soigneusement testé pour s’assurer qu’elle gère efficacement correspond à, non-correspondances et proche correspond.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>Gets the time-out interval of the current instance.</source>
          <target state="translated">Obtient l'intervalle du délai d'attente de l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>The maximum time interval that can elapse in a pattern-matching operation before a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /&gt;</ph> is thrown, or <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> if time-outs are disabled.</source>
          <target state="translated">Intervalle de temps maximum par défaut qui peut s'écouler lors d'une opération de correspondance de modèles avant qu'une <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /&gt;</ph> soit levée, ou <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> si les délais d'attente sont désactivés.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property defines the approximate maximum time interval for a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance to execute a single matching operation before the operation times out. The regular expression engine throws a <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception during its next timing check after the time-out interval has elapsed.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> propriété définit l’intervalle de temps maximale approximative un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance pour exécuter une seule opération de correspondance avant l’expiration de l’opération. Le moteur des expressions régulières lève une <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception lors de sa prochaine vérification de minutage après l’intervalle de délai d’attente est écoulé.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>This prevents the regular expression engine from processing input strings that require excessive backtracking.</source>
          <target state="translated">Cela empêche le moteur d’expression régulière de traiter les chaînes d’entrée qui nécessitent une rétroaction excessive.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>For more information, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Best Practices for Regular Expressions<ept id="p2">](~/docs/standard/base-types/best-practices.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>rétroaction<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept> et <bpt id="p2">[</bpt>meilleures pratiques des Expressions régulières<ept id="p2">](~/docs/standard/base-types/best-practices.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>This property is read-only.</source>
          <target state="translated">Cette propriété est en lecture seule.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>You can set its value explicitly for an individual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object by calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor; and you can set its value for all <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> matching operations in an application domain by calling the <ph id="ph4">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> method and providing a <ph id="ph5">&lt;xref:System.TimeSpan&gt;</ph> value for the "REGEX_DEFAULT_MATCH_TIMEOUT" property, as the following example illustrates.</source>
          <target state="translated">Vous pouvez définir sa valeur explicitement une personne <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet en appelant le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur et que vous pouvez définir sa valeur pour tous les <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> correspondance des opérations dans un domaine d’application en appelant le <ph id="ph4">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> (méthode) et en fournissant un <ph id="ph5">&lt;xref:System.TimeSpan&gt;</ph> valeur pour la propriété « REGEX_DEFAULT_MATCH_TIMEOUT », comme l’illustre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>If you do not explicitly set a time-out interval, the default value <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> is used, and matching operations do not time out.</source>
          <target state="translated">Si vous ne définissez pas explicitement un intervalle de délai d’attente, la valeur par défaut <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> est utilisées et de correspondance des opérations n’expirent pas.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>Gets the options that were passed into the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Obtient les options passées dans le constructeur <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>One or more members of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> enumeration that represent options that were passed to the <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor</source>
          <target state="translated">Un ou plusieurs membres de l'énumération <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> qui représente les options qui ont été passées au constructeur <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>The value of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> property consists of one or more members of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> enumeration.</source>
          <target state="translated">La valeur de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> propriété est constituée d’un ou plusieurs membres de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>If no options were defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor, its value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si aucune option n’a été définie dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructeur de classe, sa valeur est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>The available options are discussed in detail in the <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](~/docs/standard/base-types/regular-expression-options.md)</ept> topic.</source>
          <target state="translated">Les options disponibles sont présentées en détail dans les <bpt id="p1">[</bpt>Options des expressions régulières<ept id="p1">](~/docs/standard/base-types/regular-expression-options.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> property does not reflect inline options defined in the regular expression pattern itself.</source>
          <target state="translated">Notez que le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> propriété ne reflète pas les options inline définies dans l’expression régulière de modèle lui-même.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> is the base class of regular expressions created by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> est la classe de base des expressions régulières créée par le <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>These compiled regular expressions use the base class implementation of the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property.</source>
          <target state="translated">Ces expressions régulières compilées utilisent l’implémentation de classe de base de la <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>If called from a derived class, the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property returns the options that were passed to the <ph id="ph2">&lt;paramref name="options" /&gt;</ph> parameter of the <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> class constructor that was used to define the regular expression.</source>
          <target state="translated">Si elle est appelée à partir d’une classe dérivée, la <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> propriété retourne les options qui ont été passées à la <ph id="ph2">&lt;paramref name="options" /&gt;</ph> paramètre de la <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> constructeur de classe qui a été utilisé pour définir l’expression régulière.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.pattern">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>Utilisé par un objet généré par la méthode <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>In a specified input string, replaces strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">Dans la chaîne d'entrée spécifiée, remplace les chaînes qui correspondent à un modèle d'expression régulière par une chaîne de remplacement spécifique.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The replacement string.</source>
          <target state="translated">Chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">Dans une chaîne d’entrée spécifiée, remplace toutes les chaînes qui correspondent à un modèle d’expression régulière par une chaîne de remplacement spécifiée.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">La recherche de correspondances commence au début de la <ph id="ph1">`input`</ph> chaîne.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">L’expression régulière est le modèle défini par le constructeur d’actuel <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated">Le <ph id="ph1">`replacement`</ph> paramètre spécifie la chaîne qui doit remplacer chaque correspondance dans <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> peut être constitué de n’importe quelle combinaison de texte littéral et <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Par exemple, le modèle de remplacement <ph id="ph1">`a*${test}b`</ph> insère la chaîne « un * » suivie de la sous-chaîne mise en correspondance par le <ph id="ph2">`test`</ph> groupe de capture, le cas échéant, suivie de la chaîne « b ».</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Les substitutions sont les éléments de langage d’expression régulière seulement reconnues dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Tous les autres éléments de langage d’expression régulière, notamment <bpt id="p1">[</bpt>caractère d’échappement<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, sont autorisés dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`\s+`</ph>, that matches one or more white-space characters.</source>
          <target state="translated">L’exemple suivant définit une expression régulière, <ph id="ph1">`\s+`</ph>, qui correspond à un ou plusieurs caractères d’espace blanc.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The replacement string, " ", replaces them with a single space character.</source>
          <target state="translated">La chaîne de remplacement, « », les remplace par un espace unique.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`(\p{Sc}\s?)?(\d+\.?((?&lt;=\.)\d+)?)(?(1)|\s?\p{Sc})?`</ph>, and a replacement pattern, <ph id="ph2">`$2`</ph>, that removes either a leading or a trailing currency symbol from a numeric value.</source>
          <target state="translated">L’exemple suivant définit une expression régulière, <ph id="ph1">`(\p{Sc}\s?)?(\d+\.?((?&lt;=\.)\d+)?)(?(1)|\s?\p{Sc})?`</ph>et un modèle de remplacement, <ph id="ph2">`$2`</ph>, qui supprime au début ou un symbole de devise à droite d’une valeur numérique.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The regular expression is interpreted as shown in the following table.</source>
          <target state="translated">L'expression régulière est interprétée comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match a currency symbol.</source>
          <target state="translated">Mettre en correspondance un symbole monétaire.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">`{Sc}`</ph> denotes any character that is a member of the Unicode Symbol, Currency category.</source>
          <target state="translated"><ph id="ph1">`{Sc}`</ph> désigne n’importe quel caractère qui est membre du symbole Unicode, catégorie de devise.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Mettre en correspondance zéro ou un espace blanc.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one occurrence of the combination of a currency symbol followed by zero or one white-space character.</source>
          <target state="translated">Mettre en correspondance zéro ou une occurrence de la combinaison d’un symbole monétaire suivi par zéro ou un caractère d’espace blanc.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">Il s'agit du premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one occurrence of a period (used as a decimal separator character).</source>
          <target state="translated">Mettre en correspondance zéro ou une occurrence d’une période (utilisée comme un séparateur décimal).</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If a period is the previous character, match one or more decimal digits.</source>
          <target state="translated">Si une période est le caractère précédent, correspond à un ou plusieurs chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This pattern can be matched either zero or one time.</source>
          <target state="translated">Ce modèle peut être mis en correspondance zéro ou une fois.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match the pattern of one or more decimal digits followed by an optional period and additional decimal digits.</source>
          <target state="translated">Correspond au modèle d’un ou plusieurs chiffres décimaux, suivi d’un point facultatif et de chiffres décimaux supplémentaires.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This is the second capturing group.</source>
          <target state="translated">Il s'agit du deuxième groupe de capture.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29&gt;</ph> method replaces the entire match with the value of this captured group.</source>
          <target state="translated">L’appel à la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29&gt;</ph> méthode remplace la correspondance entière avec la valeur de ce groupe capturé.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If the first captured group exists, match an empty string.</source>
          <target state="translated">Si le premier groupe capturé existe, correspond à une chaîne vide.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Otherwise, match zero or one white-space character followed by a currency symbol.</source>
          <target state="translated">Dans le cas contraire, mettre en correspondance zéro ou un espace blanc suivi d’un symbole de devise.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">Dans la chaîne d'entrée spécifiée, remplace toutes les chaînes qui correspondent à une expression régulière spécifiée par une chaîne retournée par un délégué <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf qu'une chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Impossible de spécifier facilement la chaîne de remplacement par un modèle de remplacement d’expression régulière.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">La chaîne de remplacement résulte d’un traitement effectué sur la chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Résultats de la chaîne de remplacement d’un traitement conditionnel.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">La méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> méthode et passer chaque <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objet retourné <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection pour le <ph id="ph4">`evaluator`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">L’expression régulière est le modèle défini par le constructeur d’actuel <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">Le <ph id="ph1">`evaluator`</ph> paramètre correspond au délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The following code example displays an original string, matches each word in the original string, converts the first character of each match to uppercase, then displays the converted string.</source>
          <target state="translated">L’exemple de code suivant affiche une chaîne d’origine, met en correspondance chaque mot dans la chaîne d’origine, convertit le premier caractère de chaque correspondance en majuscule, puis affiche la chaîne convertie.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The replacement string.</source>
          <target state="translated">Chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The maximum number of times the replacement can occur.</source>
          <target state="translated">Nombre maximal d’occurrences du remplacement.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">Dans une chaîne d’entrée spécifiée, remplace le nombre maximal spécifié de chaînes qui correspondent à un modèle d’expression régulière par une chaîne de remplacement spécifiée.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">La recherche de correspondances commence au début de la <ph id="ph1">`input`</ph> chaîne.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The regular expression is the pattern that is defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">L’expression régulière est le modèle qui est défini par le constructeur pour actuel <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is negative, replacements continue to the end of the string.</source>
          <target state="translated">Si <ph id="ph1">`count`</ph> est négatif, les remplacements continuent jusqu'à la fin de la chaîne.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> exceeds the number of matches, all matches are replaced.</source>
          <target state="translated">Si <ph id="ph1">`count`</ph> dépasse le nombre de correspondances, toutes les correspondances sont remplacées.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace the first <ph id="ph2">`count`</ph> matches in <ph id="ph3">`input`</ph>.</source>
          <target state="translated">Le <ph id="ph1">`replacement`</ph> paramètre spécifie la chaîne qui doit remplacer le premier <ph id="ph2">`count`</ph> correspond dans <ph id="ph3">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> peut être constitué de n’importe quelle combinaison de texte littéral et <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Par exemple, le modèle de remplacement <ph id="ph1">`a*${test}b`</ph> insère la chaîne « un * » suivie de la sous-chaîne mise en correspondance par le <ph id="ph2">`test`</ph> groupe de capture, le cas échéant, suivie de la chaîne « b ».</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Les substitutions sont les éléments de langage d’expression régulière seulement reconnues dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Tous les autres éléments de langage d’expression régulière, notamment <bpt id="p1">[</bpt>caractère d’échappement<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, sont autorisés dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The following example replaces the first five occurrences of duplicated characters with a single character.</source>
          <target state="translated">L’exemple suivant remplace les cinq premières occurrences de caractères dupliqués par un caractère unique.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`(\w)\1`</ph> matches consecutive occurrences of a single character and assigns the first occurrence to the first capturing group.</source>
          <target state="translated">Le modèle d’expression régulière <ph id="ph1">`(\w)\1`</ph> correspond à des occurrences consécutives d’un caractère unique et affecte la première occurrence au premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured group.</source>
          <target state="translated">Le modèle de remplacement <ph id="ph1">`$1`</ph> remplace la correspondance entière par le premier groupe capturé.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement string.</source>
          <target state="translated">Chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">Dans la chaîne d'entrée spécifiée, remplace toutes les chaînes qui correspondent à l'expression régulière spécifiée par une chaîne de remplacement spécifiée.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> n'a pas de correspondance dans l'instance actuelle, la méthode retourne l'instance actuelle sans modification.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">La méthode statique <ph id="ph1">`Replace`</ph> méthodes sont équivalentes à construire un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de l’objet avec le modèle d’expression régulière spécifié et en appelant la méthode d’instance <ph id="ph3">`Replace`</ph>.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">La recherche de correspondances commence au début de la <ph id="ph1">`input`</ph> chaîne.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated">Le <ph id="ph1">`replacement`</ph> paramètre spécifie la chaîne qui doit remplacer chaque correspondance dans <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> peut être constitué de n’importe quelle combinaison de texte littéral et <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Par exemple, le modèle de remplacement <ph id="ph1">`a*${test}b`</ph> insère la chaîne « un * » suivie de la sous-chaîne mise en correspondance par le <ph id="ph2">`test`</ph> groupe de capture, le cas échéant, suivie de la chaîne « b ».</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Les substitutions sont les éléments de langage d’expression régulière seulement reconnues dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Tous les autres éléments de langage d’expression régulière, notamment <bpt id="p1">[</bpt>caractère d’échappement<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, sont autorisés dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`\s+`</ph>, that matches one or more white-space characters.</source>
          <target state="translated">L’exemple suivant définit une expression régulière, <ph id="ph1">`\s+`</ph>, qui correspond à un ou plusieurs caractères d’espace blanc.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement string, " ", replaces them with a single space character.</source>
          <target state="translated">La chaîne de remplacement, « », les remplace par un espace unique.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> méthode pour remplacer les noms d’ordinateur et le lecteur locales dans un chemin d’accès UNC avec un chemin d’accès du fichier local.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer, and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">L’expression régulière utilise le <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propriété à inclure le nom de l’ordinateur local et le <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> méthode pour inclure les noms des lecteurs logiques.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">Pour exécuter l’exemple, vous devez remplacer la chaîne littérale « Monordinateur » avec le nom de votre ordinateur local.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">Le modèle d’expression régulière est défini par l’expression suivante :</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment le modèle d'expression régulière est interprété.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">Correspondance de deux des barres obliques inverses consécutives (<ph id="ph1">`\`</ph>) caractères.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">Étant donné que le caractère de barre oblique inverse est interprété comme caractère d’échappement, chaque barre oblique inverse doit être échappé avec une autre barre oblique.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Perform a case-insensitive match of the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Effectuer une correspondance de la casse de la chaîne retournée par la <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">Correspond à la période (<ph id="ph1">`.`</ph>) suivi par un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">Cette correspondance peut se produire zéro ou plusieurs fois.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">La sous-expression mise en correspondance n’est pas capturée.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">Correspond à une barre oblique inverse (<ph id="ph1">`\`</ph>) caractères.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Perform a case-insensitive match of the character class that consists of the individual drive lettters.</source>
          <target state="translated">Effectuer une correspondance de la casse de la classe de caractères comprenant les lettres de lecteur individuelles.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">Cette correspondance est la première sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">Correspond au symbole dollar (<ph id="ph1">`$`</ph>) caractères.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">Le modèle de remplacement <ph id="ph1">`$1`</ph> remplace la correspondance entière par la première sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">Autrement dit, il remplace le nom d’ordinateur et le lecteur UNC avec la lettre de lecteur.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> est <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans laquelle elle est appelée.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche la méthode d’arriver à expiration, est utilisé.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The recommended static method for replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">La méthode statique recommandée pour remplacer une correspondance de modèle est <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">Dans la chaîne d'entrée spécifiée, remplace toutes les chaînes qui correspondent à une expression régulière spécifiée par une chaîne retournée par un délégué <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf qu'une chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> n'a pas de correspondance dans l'instance actuelle, la méthode retourne l'instance actuelle sans modification.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Impossible de spécifier facilement la chaîne de remplacement par un modèle de remplacement d’expression régulière.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">La chaîne de remplacement résulte d’un traitement effectué sur la chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Résultats de la chaîne de remplacement d’un traitement conditionnel.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">La méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> méthode et passer chaque <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objet retourné <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection pour le <ph id="ph4">`evaluator`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">Le <ph id="ph1">`evaluator`</ph> paramètre correspond au délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">L’exemple suivant utilise une expression régulière pour extraire les mots individuels d’une chaîne, puis utilise une <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> délégué à appeler une méthode nommée <ph id="ph2">`WordScramble`</ph> qui brouille les lettres individuelles dans le mot.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">Pour ce faire, le <ph id="ph1">`WordScramble`</ph> méthode crée un tableau qui contient les caractères de la correspondance.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">Il crée également un tableau parallèle qu’il remplit avec des nombres à virgule flottante aléatoires.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Les tableaux sont triés en appelant le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> (méthode) et le tableau trié est fourni en tant qu’argument à une <ph id="ph2">&lt;xref:System.String&gt;</ph> constructeur de classe.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">Cette chaîne nouvellement créée est ensuite retournée par le <ph id="ph1">`WordScramble`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">Le modèle d’expression régulière <ph id="ph1">`\w+`</ph> correspond à un ou plusieurs caractères alphabétiques ; le moteur des expressions régulières continue à ajouter des caractères à la correspondance jusqu'à ce qu’il rencontre un caractère non alphabétique, comme un caractère d’espace blanc.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> est <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans laquelle elle est appelée.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche la méthode d’arriver à expiration, est utilisé.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The recommended static method for evaluating and replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">La méthode statique recommandée pour l’évaluation et le remplacement d’une correspondance de modèle est <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The maximum number of times the replacement will occur.</source>
          <target state="translated">Nombre maximal de fois où le remplacement aura lieu.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">Dans la chaîne d'entrée spécifiée, remplace le nombre maximal spécifié de chaînes qui correspondent à un modèle d'expression régulière par une chaîne retournée par un délégué <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf qu'une chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Impossible de spécifier facilement la chaîne de remplacement par un modèle de remplacement d’expression régulière.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">La chaîne de remplacement résulte d’un traitement effectué sur la chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Résultats de la chaîne de remplacement d’un traitement conditionnel.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method and passing the first <ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph5">`evaluator`</ph> delegate.</source>
          <target state="translated">La méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> méthode et en passant la première <ph id="ph2">`count`</ph> <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objets retourné <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection pour le <ph id="ph5">`evaluator`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">L’expression régulière est le modèle défini par le constructeur d’actuel <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">Le <ph id="ph1">`evaluator`</ph> paramètre correspond au délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The following example uses a regular expression to deliberately misspell half of the words in a list.</source>
          <target state="translated">L’exemple suivant utilise une expression régulière pour faire mal orthographié délibérément la moitié des mots dans une liste.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It uses the regular expression <ph id="ph1">`\w*(ie|ei)\w*`</ph> to match words that include the characters "ie" or "ei".</source>
          <target state="translated">Il utilise l’expression régulière <ph id="ph1">`\w*(ie|ei)\w*`</ph> de rechercher des mots qui incluent les caractères « ie » ou « AE ».</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It passes the first half of the matching words to the <ph id="ph1">`ReverseLetter`</ph> method, which, in turn, uses the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to reverse "i" and "e" in the matched string.</source>
          <target state="translated">Elle passe la première moitié des mots correspondants à la <ph id="ph1">`ReverseLetter`</ph> (méthode), qui, à son tour, utilise le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> méthode à l’inverse des « i » et « e » dans la chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The remaining words remain unchanged.</source>
          <target state="translated">Les mots restants restent inchangés.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression <ph id="ph1">`\w*(ie|ei)\w*`</ph> is defined as shown in the following table.</source>
          <target state="translated">L'expression régulière <ph id="ph1">`\w*(ie|ei)\w*`</ph> est définie comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match zero or more word characters.</source>
          <target state="translated">Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match either "ie" or "ei".</source>
          <target state="translated">Mettre en correspondance « ie » ou « AE ».</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match zero or more word characters.</source>
          <target state="translated">Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`([ie])([ie])`</ph> in the <ph id="ph2">`ReverseLetter`</ph> method matches the first "i" or "e" in the diphthong "ie" or "ei" and assigns the letter to the first capturing group.</source>
          <target state="translated">Le modèle d’expression régulière <ph id="ph1">`([ie])([ie])`</ph> dans le <ph id="ph2">`ReverseLetter`</ph> méthode correspond à la première « i » ou « e » dans la diphtongue « ie » ou « AE » et assigne la lettre au premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It matches the second "i" or "e" and assigns the letter to the second capturing group.</source>
          <target state="translated">Il correspond à la deuxième « i » ou « e » et affecte la lettre au deuxième groupe de capture.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The two characters are then reversed by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> method with the replacement pattern <ph id="ph2">`$2$1`</ph>.</source>
          <target state="translated">Les deux caractères sont inversés puis en appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> méthode avec le modèle de remplacement <ph id="ph2">`$2$1`</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The replacement string.</source>
          <target state="translated">Chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Maximum number of times the replacement can occur.</source>
          <target state="translated">Nombre maximal d’occurrences du remplacement.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The character position in the input string where the search begins.</source>
          <target state="translated">Position du caractère dans la chaîne d’entrée où la recherche commence.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">Dans une sous-chaîne d’entrée spécifiée, remplace un nombre maximal spécifié de chaînes qui correspondent à un modèle d’expression régulière par une chaîne de remplacement spécifiée.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The search for matches starts in the <ph id="ph1">`input`</ph> string at the position specified by the <ph id="ph2">`startat`</ph> parameter.</source>
          <target state="translated">La recherche de correspondances démarre dans le <ph id="ph1">`input`</ph> chaîne à la position spécifiée par la <ph id="ph2">`startat`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">L’expression régulière est le modèle défini par le constructeur d’actuel <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is negative, replacements continue to the end of the string.</source>
          <target state="translated">Si <ph id="ph1">`count`</ph> est négatif, les remplacements continuent jusqu'à la fin de la chaîne.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> exceeds the number of matches, all matches are replaced.</source>
          <target state="translated">Si <ph id="ph1">`count`</ph> dépasse le nombre de correspondances, toutes les correspondances sont remplacées.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated">Le <ph id="ph1">`replacement`</ph> paramètre spécifie la chaîne qui doit remplacer chaque correspondance dans <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> peut être constitué de n’importe quelle combinaison de texte littéral et <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Par exemple, le modèle de remplacement <ph id="ph1">`a*${test}b`</ph> insère la chaîne « un * » suivie de la sous-chaîne mise en correspondance par le <ph id="ph2">`test`</ph> groupe de capture, le cas échéant, suivie de la chaîne « b ».</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Les substitutions sont les éléments de langage d’expression régulière seulement reconnues dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Tous les autres éléments de langage d’expression régulière, notamment <bpt id="p1">[</bpt>caractère d’échappement<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, sont autorisés dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The following example double-spaces all but the first line of a string.</source>
          <target state="translated">L’exemple suivant applique un interligne double tous sauf la première ligne d’une chaîne.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>It defines a regular expression pattern, <ph id="ph1">`^.*$`</ph>, that matches a line of text, calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method to match the first line of the string, and uses the <ph id="ph3">`Match.Index`</ph> and <ph id="ph4">`Match.Count`</ph> properties to determine the starting position of the second line.</source>
          <target state="translated">Il définit un modèle d’expression régulière, <ph id="ph1">`^.*$`</ph>, qui correspond à une ligne de texte, appelle la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> méthode pour correspondre à la première ligne de la chaîne et utilise le <ph id="ph3">`Match.Index`</ph> et <ph id="ph4">`Match.Count`</ph> propriétés afin de déterminer la position de départ de la seconde ligne.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`^.*$`</ph> is defined as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`^.*$`</ph> est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match the start of a line.</source>
          <target state="translated">Mettre en correspondance le début d’une ligne.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>(Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object was instantiated by using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; otherwise, this character class would only match the beginning of the input string.)</source>
          <target state="translated">(Notez que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet a été instancié à l’aide de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option ; sinon, cette classe de caractères correspondrait à uniquement le début de la chaîne d’entrée.)</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match any character zero or more times.</source>
          <target state="translated">Correspond à n’importe quel caractère zéro ou plusieurs fois.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match the end of a line.</source>
          <target state="translated">Correspond à la fin d’une ligne.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>(Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object was instantiated by using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; otherwise, this character class would only match the beginning of the input string.)</source>
          <target state="translated">(Notez que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet a été instancié à l’aide de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option ; sinon, cette classe de caractères correspondrait à uniquement le début de la chaîne d’entrée.)</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The replacement string (<ph id="ph1">`vbCrLf + "$&amp;"`</ph> in Visual Basic, <ph id="ph2">`"\n$&amp;"`</ph> in C#) adds a new line before the matched string.</source>
          <target state="translated">La chaîne de remplacement (<ph id="ph1">`vbCrLf + "$&amp;"`</ph> en Visual Basic, <ph id="ph2">`"\n$&amp;"`</ph> en c#) ajoute une nouvelle ligne avant la chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Note that <ph id="ph1">`\n`</ph> in the C# example is interpreted as the newline character by the C# compiler; it does not represent a regular expression character escape.</source>
          <target state="translated">Notez que <ph id="ph1">`\n`</ph> en c# exemple est interprété comme le caractère de saut de ligne par le compilateur c# ; il ne représente pas un caractère d’échappement d’expression régulière.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> est inférieur à zéro ou supérieur à la longueur de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string.</source>
          <target state="translated">Chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">Dans la chaîne d'entrée spécifiée, remplace toutes les chaînes qui correspondent à l'expression régulière spécifiée par une chaîne de remplacement spécifiée.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">Les options spécifiées modifient l'opération correspondante.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> n'a pas de correspondance dans l'instance actuelle, la méthode retourne l'instance actuelle sans modification.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">La méthode statique <ph id="ph1">`Replace`</ph> méthodes sont équivalentes à construire un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de l’objet avec le modèle d’expression régulière spécifié et en appelant la méthode d’instance <ph id="ph3">`Replace`</ph>.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">Si vous spécifiez <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> pour la <ph id="ph2">`options`</ph> de paramètre, la recherche de correspondances commence à la fin de la chaîne d’entrée et les déplace vers la gauche ; sinon, la recherche commence au début de la chaîne d’entrée et déplacé vers la droite.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated">Le <ph id="ph1">`replacement`</ph> paramètre spécifie la chaîne qui doit remplacer chaque correspondance dans <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> peut être constitué de n’importe quelle combinaison de texte littéral et <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Par exemple, le modèle de remplacement <ph id="ph1">`a*${test}b`</ph> insère la chaîne « un * » suivie de la sous-chaîne mise en correspondance par le <ph id="ph2">`test`</ph> groupe de capture, le cas échéant, suivie de la chaîne « b ».</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Les substitutions sont les éléments de langage d’expression régulière seulement reconnues dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Tous les autres éléments de langage d’expression régulière, notamment <bpt id="p1">[</bpt>caractère d’échappement<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, sont autorisés dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> méthode pour remplacer les noms d’ordinateur et le lecteur locales dans un chemin d’accès UNC avec un chemin d’accès du fichier local.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer, and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">L’expression régulière utilise le <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propriété à inclure le nom de l’ordinateur local et le <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> méthode pour inclure les noms des lecteurs logiques.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>All regular expression string comparisons are case-insensitive.</source>
          <target state="translated">Toutes les comparaisons de chaînes d’expression régulière respectent la casse.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">Pour exécuter l’exemple, vous devez remplacer la chaîne littérale « Monordinateur » avec le nom de votre ordinateur local.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">Le modèle d’expression régulière est défini par l’expression suivante :</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment le modèle d'expression régulière est interprété.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">Correspondance de deux des barres obliques inverses consécutives (<ph id="ph1">`\`</ph>) caractères.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">Étant donné que le caractère de barre oblique inverse est interprété comme caractère d’échappement, chaque barre oblique inverse doit être échappé avec une autre barre oblique.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Correspond à la chaîne retournée par la <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">Correspond à la période (<ph id="ph1">`.`</ph>) suivi par un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">Cette correspondance peut se produire zéro ou plusieurs fois.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">La sous-expression mise en correspondance n’est pas capturée.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">Correspond à une barre oblique inverse (<ph id="ph1">`\`</ph>) caractères.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the character class that consists of the individual drive letters.</source>
          <target state="translated">Correspond à la classe de caractères qui se compose de lettres de lecteur individuelles.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">Cette correspondance est la première sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">Correspond au symbole dollar (<ph id="ph1">`$`</ph>) caractères.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">Le modèle de remplacement <ph id="ph1">`$1`</ph> remplace la correspondance entière par la première sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">Autrement dit, il remplace le nom d’ordinateur et le lecteur UNC avec la lettre de lecteur.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> est <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n'est pas une combinaison d'opérations de bits des valeurs <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans laquelle elle est appelée.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche la méthode d’arriver à expiration, est utilisé.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">La méthode statique recommandée pour remplacer une correspondance de modèle est <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">Dans la chaîne d'entrée spécifiée, remplace toutes les chaînes qui correspondent à une expression régulière spécifiée par une chaîne retournée par un délégué <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">Les options spécifiées modifient l'opération correspondante.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf qu'une chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> n'a pas de correspondance dans l'instance actuelle, la méthode retourne l'instance actuelle sans modification.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match in if any of the following conditions is true:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Impossible de spécifier facilement la chaîne de remplacement par un modèle de remplacement d’expression régulière.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">La chaîne de remplacement résulte d’un traitement effectué sur la chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Résultats de la chaîne de remplacement d’un traitement conditionnel.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">La méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> méthode et passer chaque <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objet retourné <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection pour le <ph id="ph4">`evaluator`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">Le <ph id="ph1">`evaluator`</ph> paramètre correspond au délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">Si vous spécifiez <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> pour la <ph id="ph2">`options`</ph> de paramètre, la recherche de correspondances commence à la fin de la chaîne d’entrée et les déplace vers la gauche ; sinon, la recherche commence au début de la chaîne d’entrée et déplacé vers la droite.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">L’exemple suivant utilise une expression régulière pour extraire les mots individuels d’une chaîne, puis utilise une <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> délégué à appeler une méthode nommée <ph id="ph2">`WordScramble`</ph> qui brouille les lettres individuelles dans le mot.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">Pour ce faire, le <ph id="ph1">`WordScramble`</ph> méthode crée un tableau qui contient les caractères de la correspondance.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">Il crée également un tableau parallèle qu’il remplit avec des nombres à virgule flottante aléatoires.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Les tableaux sont triés en appelant le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> (méthode) et le tableau trié est fourni en tant qu’argument à une <ph id="ph2">&lt;xref:System.String&gt;</ph> constructeur de classe.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">Cette chaîne nouvellement créée est ensuite retournée par le <ph id="ph1">`WordScramble`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">Le modèle d’expression régulière <ph id="ph1">`\w+`</ph> correspond à un ou plusieurs caractères alphabétiques ; le moteur des expressions régulières continue à ajouter des caractères à la correspondance jusqu'à ce qu’il rencontre un caractère non alphabétique, comme un caractère d’espace blanc.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method includes the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option so that the comment in the regular expression pattern <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> is ignored by the regular expression engine.</source>
          <target state="translated">L’appel à la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> méthode inclut la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option afin que le commentaire dans le modèle d’expression régulière <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> est ignoré par le moteur d’expression régulière.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> est <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n'est pas une combinaison d'opérations de bits des valeurs <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The maximum number of times the replacement will occur.</source>
          <target state="translated">Nombre maximal de fois où le remplacement aura lieu.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The character position in the input string where the search begins.</source>
          <target state="translated">Position du caractère dans la chaîne d’entrée où la recherche commence.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">Dans la sous-chaîne d'entrée spécifiée, remplace le nombre maximal spécifié de chaînes qui correspondent à un modèle d'expression régulière par une chaîne retournée par un délégué <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf qu'une chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Impossible de spécifier facilement la chaîne de remplacement par un modèle de remplacement d’expression régulière.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">La chaîne de remplacement résulte d’un traitement effectué sur la chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">Résultats de la chaîne de remplacement d’un traitement conditionnel.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method and passing the first <ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph5">`evaluator`</ph> delegate.</source>
          <target state="translated">La méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> méthode et en passant la première <ph id="ph2">`count`</ph> <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objets retourné <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection pour le <ph id="ph5">`evaluator`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">L’expression régulière est le modèle défini par le constructeur d’actuel <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">Le <ph id="ph1">`evaluator`</ph> paramètre correspond au délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> est inférieur à zéro ou supérieur à la longueur de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The replacement string.</source>
          <target state="translated">Chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Intervalle de délai d'attente, ou <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> pour indiquer que la méthode ne doit pas expirer.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">Dans la chaîne d'entrée spécifiée, remplace toutes les chaînes qui correspondent à l'expression régulière spécifiée par une chaîne de remplacement spécifiée.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">Les paramètres supplémentaires spécifient les options qui modifient l'opération et l'intervalle de délai d'attente correspondants si aucune correspondance n'est trouvée.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> n'a pas de correspondance dans l'instance actuelle, la méthode retourne l'instance actuelle sans modification.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">La méthode statique <ph id="ph1">`Replace`</ph> méthodes sont équivalentes à construire un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> de l’objet avec le modèle d’expression régulière spécifié et en appelant la méthode d’instance <ph id="ph3">`Replace`</ph>.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">Si vous spécifiez <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> pour la <ph id="ph2">`options`</ph> de paramètre, la recherche de correspondances commence à la fin de la chaîne d’entrée et les déplace vers la gauche ; sinon, la recherche commence au début de la chaîne d’entrée et déplacé vers la droite.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated">Le <ph id="ph1">`replacement`</ph> paramètre spécifie la chaîne qui doit remplacer chaque correspondance dans <ph id="ph2">`input`</ph>.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> peut être constitué de n’importe quelle combinaison de texte littéral et <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">Par exemple, le modèle de remplacement <ph id="ph1">`a*${test}b`</ph> insère la chaîne « un * » suivie de la sous-chaîne mise en correspondance par le <ph id="ph2">`test`</ph> groupe de capture, le cas échéant, suivie de la chaîne « b ».</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">Les substitutions sont les éléments de langage d’expression régulière seulement reconnues dans un modèle de remplacement.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">Tous les autres éléments de langage d’expression régulière, notamment <bpt id="p1">[</bpt>caractère d’échappement<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, sont autorisés dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">Le <ph id="ph1">`matchTimeout`</ph> paramètre spécifie la manière dont la durée pendant laquelle une recherche de correspondance (méthode) doit effectuer pour trouver une correspondance avant d’expirer. Définition d’un intervalle de délai d’attente empêche les expressions régulières qui s’appuient sur une rétroaction excessive de semble cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>meilleures pratiques des Expressions régulières<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> et <bpt id="p2">[</bpt>rétroaction<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode lève un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> remplace toute valeur de délai d’attente par défaut défini pour le domaine d’application dans laquelle la méthode s’exécute.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> méthode pour remplacer les noms d’ordinateur et le lecteur locales dans un chemin d’accès UNC avec un chemin d’accès du fichier local.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">L’expression régulière utilise le <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propriété à inclure le nom de l’ordinateur local et le <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> méthode pour inclure les noms des lecteurs logiques.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>All regular expression string comparisons are case-insensitive, and any single replacement operation times out if a match cannot be found in 0.5 second.</source>
          <target state="translated">Toutes les comparaisons de chaînes d’expression régulière respectent pas la casse, et toute opération de remplacement seule expire si une correspondance ne peut pas être trouvée dans 0,5 seconde.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">Pour exécuter l’exemple, vous devez remplacer la chaîne littérale « Monordinateur » avec le nom de votre ordinateur local.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">Le modèle d’expression régulière est défini par l’expression suivante :</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment le modèle d'expression régulière est interprété.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">Correspondance de deux des barres obliques inverses consécutives (<ph id="ph1">`\`</ph>) caractères.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">Étant donné que le caractère de barre oblique inverse est interprété comme caractère d’échappement, chaque barre oblique inverse doit être échappé avec une autre barre oblique.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Correspond à la chaîne retournée par la <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">Correspond à la période (<ph id="ph1">`.`</ph>) suivi par un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">Cette correspondance peut se produire zéro ou plusieurs fois.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">La sous-expression mise en correspondance n’est pas capturée.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">Correspond à une barre oblique inverse (<ph id="ph1">`\`</ph>) caractères.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the character class that consists of the individual drive letters.</source>
          <target state="translated">Correspond à la classe de caractères qui se compose de lettres de lecteur individuelles.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">Cette correspondance est la première sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">Correspond au symbole dollar (<ph id="ph1">`$`</ph>) caractères.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">Le modèle de remplacement <ph id="ph1">`$1`</ph> remplace la correspondance entière par la première sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">Autrement dit, il remplace le nom d’ordinateur et le lecteur UNC avec la lettre de lecteur.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> est <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n'est pas une combinaison d'opérations de bits des valeurs <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> est négatif, égal à zéro ou supérieur à environ 24 jours.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Un dépassement du délai d’attente s’est produit.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Nous vous recommandons de définir la <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> paramètre à une valeur appropriée, comme les deux secondes.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si vous désactivez des délais d’attente en spécifiant <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, le moteur des expressions régulières offre des performances sont légèrement meilleures.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Toutefois, vous devez désactiver les délais d’expiration uniquement dans les conditions suivantes :</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Cela exclut le texte qui a été dynamiquement par les utilisateurs.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Lorsque le modèle d’expression régulière a été soigneusement testé pour s’assurer qu’elle gère efficacement correspond à, non-correspondances et proche correspond.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">Chaîne dans laquelle une correspondance doit être recherchée.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of enumeration values that provide options for matching.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Intervalle de délai d'attente, ou <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> pour indiquer que la méthode ne doit pas expirer.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In a specified input string, replaces all substrings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">Dans la chaîne d'entrée spécifiée, remplace toutes les sous-chaînes qui correspondent à une expression régulière spécifiée par une chaîne retournée par un délégué <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">Les paramètres supplémentaires spécifient les options qui modifient l'opération et l'intervalle de délai d'attente correspondants si aucune correspondance n'est trouvée.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> n'a pas de correspondance dans l'instance actuelle, la méthode retourne l'instance actuelle sans modification.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">Si la chaîne de remplacement ne peut pas être facilement spécifiée par un modèle de remplacement d’expression régulière.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string results from some processing performed on the matched string.</source>
          <target state="translated">Si la chaîne de remplacement résulte d’une opération de traitement effectuée sur la chaîne correspondante.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string results from conditional processing.</source>
          <target state="translated">Si la chaîne de remplacement résulte d’un traitement conditionnel.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">La méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> méthode et passer chaque <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objet retourné <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection pour le <ph id="ph4">`evaluator`</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated">Le <ph id="ph1">`evaluator`</ph> paramètre correspond au délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">Si vous spécifiez <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> pour la <ph id="ph2">`options`</ph> de paramètre, la recherche de correspondances commence à la fin de la chaîne d’entrée et les déplace vers la gauche ; sinon, la recherche commence au début de la chaîne d’entrée et déplacé vers la droite.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to "stop responding when they process input that contains near matches.</source>
          <target state="translated">Le <ph id="ph1">`matchTimeout`</ph> paramètre spécifie la manière dont la durée pendant laquelle une recherche de correspondance (méthode) doit effectuer pour trouver une correspondance avant d’expirer. Définition d’un intervalle de délai d’attente empêche les expressions régulières qui s’appuient sur une rétroaction excessive d’apparaître à « cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>meilleures pratiques des Expressions régulières<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> et <bpt id="p2">[</bpt>rétroaction<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode lève un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> remplace toute valeur de délai d’attente par défaut défini pour le domaine d’application dans laquelle la méthode s’exécute.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">Étant donné que la méthode retourne <ph id="ph1">`input`</ph> inchangé, si aucune correspondance, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">L’exemple suivant utilise une expression régulière pour extraire les mots individuels d’une chaîne, puis utilise une <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> délégué à appeler une méthode nommée <ph id="ph2">`WordScramble`</ph> qui brouille les lettres individuelles dans le mot.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">Pour ce faire, le <ph id="ph1">`WordScramble`</ph> méthode crée un tableau qui contient les caractères de la correspondance.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">Il crée également un tableau parallèle qu’il remplit avec des nombres à virgule flottante aléatoires.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Les tableaux sont triés en appelant le <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> (méthode) et le tableau trié est fourni en tant qu’argument à une <ph id="ph2">&lt;xref:System.String&gt;</ph> constructeur de classe.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">Cette chaîne nouvellement créée est ensuite retournée par le <ph id="ph1">`WordScramble`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">Le modèle d’expression régulière <ph id="ph1">`\w+`</ph> correspond à un ou plusieurs caractères alphabétiques ; le moteur des expressions régulières continue à ajouter des caractères à la correspondance jusqu'à ce qu’il rencontre un caractère non alphabétique, comme un caractère d’espace blanc.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method includes the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option so that the comment in the regular expression pattern <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> is ignored by the regular expression engine.</source>
          <target state="translated">L’appel à la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> méthode inclut la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option afin que le commentaire dans le modèle d’expression régulière <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> est ignoré par le moteur d’expression régulière.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> est <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n'est pas une combinaison d'opérations de bits des valeurs <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> est négatif, égal à zéro ou supérieur à environ 24 jours.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Un dépassement du délai d’attente s’est produit.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Nous vous recommandons de définir la <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> paramètre à une valeur appropriée, comme les deux secondes.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si vous désactivez des délais d’attente en spécifiant <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, le moteur des expressions régulières offre des performances sont légèrement meilleures.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Toutefois, vous devez désactiver les délais d’expiration uniquement dans les conditions suivantes :</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Cela exclut le texte qui a été dynamiquement par les utilisateurs.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Lorsque le modèle d’expression régulière a été soigneusement testé pour s’assurer qu’elle gère efficacement correspond à, non-correspondances et proche correspond.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source>Gets a value that indicates whether the regular expression searches from right to left.</source>
          <target state="translated">Obtient une valeur qui indique si l'expression régulière cherche de droite à gauche.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression searches from right to left; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'expression régulière cherche de droite à gauche ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.RightToLeft%2A&gt;</ph> is <ph id="ph2">`true`</ph> if the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance was created with the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> option.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.RightToLeft%2A&gt;</ph> est <ph id="ph2">`true`</ph> si le <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance a été créée avec la <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> option.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.roptions">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>Utilisé par un objet généré par la méthode <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression match.</source>
          <target state="translated">Fractionne une chaîne d'entrée en tableau de sous-chaînes aux positions définies par une correspondance d'expression régulière.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The string to split.</source>
          <target state="translated">Chaîne à fractionner.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Fractionne une chaîne d'entrée en un tableau de sous-chaînes, aux positions définies par un modèle d'expression régulière spécifié dans le constructeur <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>An array of strings.</source>
          <target state="translated">Tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> méthodes sont similaires à la <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> (méthode), à ceci près que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">La chaîne est fractionnée autant de fois que possible.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If no delimiter is found, the return value contains one element whose value is the original input string.</source>
          <target state="translated">Si aucun délimiteur n’est trouvé, la valeur de retour contient un élément dont la valeur est la chaîne d’entrée d’origine.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Si plusieurs correspondances sont adjacentes, une chaîne vide est insérée dans le tableau.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</source>
          <target state="translated">Par exemple, le fractionnement d’une chaîne sur un trait d’union unique, le tableau retourné inclure une chaîne vide à la position où deux traits d’union sont trouvés, comme le montre le code suivant.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">Si une correspondance est trouvée au début ou à la fin de la chaîne d’entrée, une chaîne vide est incluse au début ou à la fin du tableau retourné.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`\d+`</ph> to split an input string on numeric characters.</source>
          <target state="translated">L’exemple suivant utilise le modèle d’expression régulière <ph id="ph1">`\d+`</ph> pour fractionner une chaîne d’entrée sur des caractères numériques.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Étant donné que la chaîne commence et se termine par la mise en correspondance des caractères numériques, la valeur du premier et le dernier élément du tableau retourné est <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Si des parenthèses de capture sont utilisées dans un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, tout texte capturée est inclus dans le tableau de chaînes résultant.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Par exemple, si vous fractionnez la chaîne « plum-poire » sur un trait d’union placé dans les parenthèses de capture, le tableau retourné inclut un élément de chaîne qui contient le trait d’union.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">Dans le .NET Framework 1.0 et 1.1, si une correspondance est introuvable dans le premier jeu de parenthèses, de texte capturé à partir des autres parenthèses de capture n’est pas inclus dans le tableau retourné.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">À compter de .NET Framework 2.0, tout le texte capturé est également ajouté au tableau retourné.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Par exemple, le code suivant utilise deux jeux de parenthèses de capture pour extraire les éléments d’une date, y compris les séparateurs de date, d’une chaîne de date.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">Le premier jeu de parenthèses de capture capture le trait d’union, et le deuxième capture la barre oblique.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Si l’exemple de code est compilé et exécuté sous .NET Framework 1.0 ou 1.1, il exclut les barres obliques ; s’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, il les inclut.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%29&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si l’expression régulière peut correspondre à la chaîne vide, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%29&gt;</ph> fractionne la chaîne dans un tableau de chaînes de caractères unique puisque le délimiteur de chaîne vide se retrouve à chaque emplacement.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example:</source>
          <target state="translated">Exemple :</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Note that the returned array also includes an empty string at the beginning and end of the array.</source>
          <target state="translated">Notez que le tableau retourné inclut également une chaîne vide au début et à la fin du tableau.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de fractionnement dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The string to be split.</source>
          <target state="translated">Chaîne à fractionner.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The maximum number of times the split can occur.</source>
          <target state="translated">Nombre maximal de fois où le fractionnement peut avoir lieu.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Fractionne une chaîne d'entrée spécifiée un nombre de fois maximal spécifié en un tableau de sous-chaînes, aux positions définies par une expression régulière spécifiée dans le constructeur <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>An array of strings.</source>
          <target state="translated">Tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> méthodes sont similaires à la <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> (méthode), à ceci près que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter specifies the maximum number of substrings into which the <ph id="ph2">`input`</ph> string can be split; the last string contains the unsplit remainder of the string.</source>
          <target state="translated">Le <ph id="ph1">`count`</ph> paramètre spécifie le nombre maximal de sous-chaînes dans lesquelles la <ph id="ph2">`input`</ph> le fractionnement de chaîne ; la dernière chaîne contient la fractionnée de la chaîne.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>A <ph id="ph1">`count`</ph> value of zero provides the default behavior of splitting as many times as possible.</source>
          <target state="translated">A <ph id="ph1">`count`</ph> la valeur zéro fournit le comportement par défaut du fractionnement autant de fois que possible.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If multiple matches are adjacent to one another or if a match is found at the beginning or end of <ph id="ph1">`input`</ph>, and the number of matches found is at least two less than <ph id="ph2">`count`</ph>, an empty string is inserted into the array.</source>
          <target state="translated">Si plusieurs correspondances sont adjacentes à un autre, ou si une correspondance est trouvée au début ou à la fin de <ph id="ph1">`input`</ph>, et le nombre de correspondances trouvées est au moins deux inférieur à <ph id="ph2">`count`</ph>, une chaîne vide est insérée dans le tableau.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>That is, empty strings that result from adjacent matches or from matches at the beginning or end of the input string are counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Autrement dit, les chaînes vides qui résultent de correspondances adjacentes ou de correspondances au début ou à la fin de la chaîne d’entrée sont comptés pour déterminer si le nombre de mises en correspondance de sous-chaînes égal <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>In the following example, the regular expression <ph id="ph1">`/d+`</ph> is used to split an input string that includes one or more decimal digits into a maximum of three substrings.</source>
          <target state="translated">Dans l’exemple suivant, l’expression régulière <ph id="ph1">`/d+`</ph> est utilisé pour fractionner une chaîne d’entrée qui inclut un ou plusieurs chiffres décimaux en un maximum de trois sous-chaînes.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Because the beginning of the input string matches the regular expression pattern, the first array element contains <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, the second contains the first set of alphabetic characters in the input string, and the third contains the remainder of the string that follows the third match.</source>
          <target state="translated">Comme le début de la chaîne d’entrée correspond au modèle d’expression régulière, le premier élément du tableau contient <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, le deuxième contient le premier jeu de caractères alphabétiques dans la chaîne d’entrée et le troisième contient le reste de la chaîne qui suit la correspondance de tiers.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</source>
          <target state="translated">Si des parenthèses de capture sont utilisées dans une expression régulière, n’importe quel texte capturé est inclus dans le tableau de chaînes de fractionnement.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, any array elements that contain captured text are not counted in determining whether the number of matches has reached <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Toutefois, les éléments du tableau qui contiennent le texte capturé ne sont pas comptés pour déterminer si le nombre de correspondances a atteint <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For example, splitting the string "apple-apricot-plum-pear-banana" into a maximum of four substrings results in a seven-element array, as the following code shows.</source>
          <target state="translated">Par exemple, si la chaîne « apple-apricot-plum-poire-banana » en un maximum de quatre résultats sous-chaînes dans un tableau de sept éléments, comme le code suivant montre.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>In the .NET Framework 1.0 and 1.1, only captured text from the first set of capturing parentheses is included in the returned array.</source>
          <target state="translated">Dans le .NET Framework 1.0 et 1.1, seul le texte capturé à partir du premier jeu de parenthèses de capture est inclus dans le tableau retourné.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Starting with the .NET Framework 2.0, all captured text is added to the returned array.</source>
          <target state="translated">À compter de .NET Framework 2.0, tout le texte capturé est ajouté au tableau retourné.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, elements in the returned array that contain captured text are not counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Toutefois, les éléments dans le tableau retourné qui contiennent le texte capturé ne sont pas comptés pour déterminer si le nombre de mises en correspondance de sous-chaînes égal <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For example, in the following code, a regular expression uses two sets of capturing parentheses to extract the elements of a date from a date string.</source>
          <target state="translated">Par exemple, dans le code suivant, une expression régulière utilise deux jeux de parenthèses de capture pour extraire les éléments d’une date à partir d’une chaîne de date.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">Le premier jeu de parenthèses de capture capture le trait d’union, et le deuxième capture la barre oblique.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> method then specifies a maximum of two elements in the returned array.</source>
          <target state="translated">L’appel à la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> méthode spécifie ensuite un maximum de deux éléments dans le tableau retourné.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, the method returns a two-element string array.</source>
          <target state="translated">Si l’exemple de code est compilé et exécuté sous .NET Framework 1.0 ou 1.1, la méthode retourne un tableau de chaînes de deux éléments.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If it is compiled and run under the .NET Framework 2.0 or later versions, the method returns a three-element string array.</source>
          <target state="translated">S’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, la méthode retourne un tableau de chaînes de trois éléments.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si l’expression régulière peut correspondre à la chaîne vide, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> fractionne la chaîne dans un tableau de chaînes de caractères unique puisque le délimiteur de chaîne vide se retrouve à chaque emplacement.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The following example splits the string "characters" into as many elements as there are in the input string.</source>
          <target state="translated">L’exemple suivant fractionne la chaîne « caractères » en grand nombre d’éléments qu’il sont dans la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Because the null string matches the beginning of the input string, a null string is inserted at the beginning of the returned array.</source>
          <target state="translated">Étant donné que la chaîne null correspond au début de la chaîne d’entrée, une chaîne null est insérée au début du tableau retourné.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>This causes the tenth element to consist of the two characters at the end of the input string.</source>
          <target state="translated">Cela entraîne le dixième élément se compose de deux caractères à la fin de la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de fractionnement dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The string to split.</source>
          <target state="translated">Chaîne à fractionner.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression pattern.</source>
          <target state="translated">Fractionne une chaîne d’entrée en tableau de sous-chaînes aux positions définies par un modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>An array of strings.</source>
          <target state="translated">Tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> méthodes sont similaires à la <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> (méthode), à ceci près que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">`input`</ph> string is split as many times as possible.</source>
          <target state="translated">Le <ph id="ph1">`input`</ph> chaîne est fractionnée autant de fois que possible.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If <ph id="ph1">`pattern`</ph> is not found in the <ph id="ph2">`input`</ph> string, the return value contains one element whose value is the original <ph id="ph3">`input`</ph> string.</source>
          <target state="translated">Si <ph id="ph1">`pattern`</ph> est introuvable dans le <ph id="ph2">`input`</ph> chaîne, la valeur de retour contient un élément dont la valeur est la version d’origine <ph id="ph3">`input`</ph> chaîne.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">Les expressions régulières utilisées dans les appels statique compilées <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> méthodes sont mis en cache automatiquement.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">Pour gérer la durée de vie des expressions régulières compilées vous-même, utilisez l’instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Si plusieurs correspondances sont adjacentes, une chaîne vide est insérée dans le tableau.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</source>
          <target state="translated">Par exemple, le fractionnement d’une chaîne sur un trait d’union unique, le tableau retourné inclure une chaîne vide à la position où deux traits d’union sont trouvés, comme le montre le code suivant.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">Si une correspondance est trouvée au début ou à la fin de la chaîne d’entrée, une chaîne vide est incluse au début ou à la fin du tableau retourné.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`\d+`</ph> to split an input string on numeric characters.</source>
          <target state="translated">L’exemple suivant utilise le modèle d’expression régulière <ph id="ph1">`\d+`</ph> pour fractionner une chaîne d’entrée sur des caractères numériques.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Étant donné que la chaîne commence et se termine par la mise en correspondance des caractères numériques, la valeur du premier et le dernier élément du tableau retourné est <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Si des parenthèses de capture sont utilisées dans un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, tout texte capturée est inclus dans le tableau de chaînes résultant.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Par exemple, si vous fractionnez la chaîne « plum-poire » sur un trait d’union placé dans les parenthèses de capture, le tableau retourné inclut un élément de chaîne qui contient le trait d’union.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">Dans le .NET Framework 1.0 et 1.1, si une correspondance est introuvable dans le premier jeu de parenthèses, de texte capturé à partir des autres parenthèses de capture n’est pas inclus dans le tableau retourné.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">À compter de .NET Framework 2.0, tout le texte capturé est également ajouté au tableau retourné.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Par exemple, le code suivant utilise deux jeux de parenthèses de capture pour extraire les éléments d’une date, y compris les séparateurs de date, d’une chaîne de date.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">Le premier jeu de parenthèses de capture capture le trait d’union, et le deuxième capture la barre oblique.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Si l’exemple de code est compilé et exécuté sous .NET Framework 1.0 ou 1.1, il exclut les barres obliques ; s’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, il les inclut.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si l’expression régulière peut correspondre à la chaîne vide, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> fractionne la chaîne dans un tableau de chaînes de caractères unique puisque le délimiteur de chaîne vide se retrouve à chaque emplacement.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example:</source>
          <target state="translated">Exemple :</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Note that the returned array also includes an empty string at the beginning and end of the array.</source>
          <target state="translated">Notez que le tableau retourné inclut également une chaîne vide au début et à la fin du tableau.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de fractionnement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche la méthode d’arriver à expiration, est utilisé.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The recommended static method for splitting text on a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">La méthode statique recommandée pour fractionner le texte d’une correspondance de modèle est <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The string to be split.</source>
          <target state="translated">Chaîne à fractionner.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The maximum number of times the split can occur.</source>
          <target state="translated">Nombre maximal de fois où le fractionnement peut avoir lieu.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The character position in the input string where the search will begin.</source>
          <target state="translated">Position du caractère dans la chaîne d'entrée où la recherche commencera.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Fractionne une chaîne d'entrée spécifiée un nombre de fois maximal spécifié en un tableau de sous-chaînes, aux positions définies par une expression régulière spécifiée dans le constructeur <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The search for the regular expression pattern starts at a specified character position in the input string.</source>
          <target state="translated">La recherche du modèle d’expression régulière débute à une position de caractère spécifiée dans la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>An array of strings.</source>
          <target state="translated">Tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> méthodes sont similaires à la <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> (méthode), à ceci près que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter specifies the maximum number of substrings into which the <ph id="ph2">`input`</ph> string is split; the last string contains the unsplit remainder of the string.</source>
          <target state="translated">Le <ph id="ph1">`count`</ph> paramètre spécifie le nombre maximal de sous-chaînes dans lesquelles la <ph id="ph2">`input`</ph> chaîne est fractionnée ; la dernière chaîne contient la fractionnée de la chaîne.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>A <ph id="ph1">`count`</ph> value of zero provides the default behavior of splitting as many times as possible.</source>
          <target state="translated">A <ph id="ph1">`count`</ph> la valeur zéro fournit le comportement par défaut du fractionnement autant de fois que possible.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startat`</ph> parameter defines the point at which the search for the first delimiter begins (this can be used for skipping leading white space).</source>
          <target state="translated">Le <ph id="ph1">`startat`</ph> paramètre définit le point au niveau duquel commence la recherche pour le premier délimiteur (Cela peut être utilisé pour ignorer l’espace blanc de début).</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If no matches are found from the <ph id="ph1">`count`</ph>+1 position in the string, the method returns a one-element array that contains the <ph id="ph2">`input`</ph> string.</source>
          <target state="translated">Si aucune correspondance n’est trouvée à partir de la <ph id="ph1">`count`</ph>+ 1 position dans la chaîne, la méthode retourne un tableau d’un élément qui contient le <ph id="ph2">`input`</ph> chaîne.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If one or more matches are found, the first element of the returned array contains the first portion of the string from the first character up to one character before the match.</source>
          <target state="translated">Si une ou plusieurs correspondances sont trouvées, le premier élément du tableau retourné contient la première partie de la chaîne à partir du premier caractère jusqu’au caractère avant la correspondance.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If multiple matches are adjacent to one another and the number of matches found is at least two less than <ph id="ph1">`count`</ph>, an empty string is inserted into the array.</source>
          <target state="translated">Si plusieurs correspondances sont adjacentes et le nombre de correspondances trouvées est au moins deux inférieur à <ph id="ph1">`count`</ph>, une chaîne vide est insérée dans le tableau.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Similarly, if a match is found at <ph id="ph1">`startat`</ph>, which is the first character in the string, the first element of the returned array is an empty string.</source>
          <target state="translated">De même, si une correspondance est trouvée dans <ph id="ph1">`startat`</ph>, qui est le premier caractère dans la chaîne, le premier élément du tableau retourné est une chaîne vide.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>That is, empty strings that result from adjacent matches are counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Autrement dit, les chaînes vides qui résultent des correspondances adjacentes sont comptés pour déterminer si le nombre de mises en correspondance de sous-chaînes égal <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>In the following example, the regular expression <ph id="ph1">`\d+`</ph> is used to find the starting position of the first substring of numeric characters in a string, and then to split the string a maximum of three times starting at that position.</source>
          <target state="translated">Dans l’exemple suivant, l’expression régulière <ph id="ph1">`\d+`</ph> est utilisée pour rechercher la position de départ de la première chaîne de caractères numériques dans une chaîne, puis fractionne la chaîne pour un maximum de trois fois commençant à cette position.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Because the regular expression pattern matches the beginning of the input string, the returned string array consists of an empty string, a five-character alphabetic string, and the remainder of the string,</source>
          <target state="translated">Étant donné que le modèle d’expression régulière correspond au début de la chaîne d’entrée, le tableau de chaînes retourné se compose d’une chaîne vide, une chaîne de cinq caractères alphabétique et le reste de la chaîne,</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</source>
          <target state="translated">Si des parenthèses de capture sont utilisées dans une expression régulière, n’importe quel texte capturé est inclus dans le tableau de chaînes de fractionnement.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>However, any array elements that contain captured text are not counted in determining whether the number of matches has reached <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Toutefois, les éléments du tableau qui contiennent le texte capturé ne sont pas comptés pour déterminer si le nombre de correspondances a atteint <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For example, splitting the string '"apple-apricot-plum-pear-pomegranate-pineapple-peach" into a maximum of four substrings beginning at character 15 in the string results in a seven-element array, as the following code shows.</source>
          <target state="translated">Par exemple, si la chaîne « « apple-apricot-plum-pear-pomegranate-pineapple-peach » est fractionnée en un maximum de quatre sous-chaînes en commençant à caractère 15 dans les résultats de la chaîne dans un tableau de sept éléments, comme le montre le code suivant.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>In .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">Dans .NET Framework 1.0 et 1.1, si une correspondance est introuvable dans le premier jeu de parenthèses, le texte capturé à partir des autres parenthèses de capture n’est pas inclus dans le tableau retourné.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">À compter de .NET Framework 2.0, tout le texte capturé est également ajouté au tableau retourné.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the individual words in a string.</source>
          <target state="translated">Par exemple, le code suivant utilise deux jeux de parenthèses de capture pour extraire les mots individuels dans une chaîne.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the vertical bar.</source>
          <target state="translated">Le premier jeu de parenthèses de capture capture le trait d’union, et le deuxième capture la barre verticale.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the vertical bar characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Si l’exemple de code est compilé et exécuté sous .NET Framework 1.0 ou 1.1, il exclut la verticale de la barre des caractères ; s’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, il les inclut.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si l’expression régulière peut correspondre à la chaîne vide, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> fractionne la chaîne dans un tableau de chaînes de caractères unique puisque le délimiteur de chaîne vide se retrouve à chaque emplacement.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The following example splits the string "characters" into as many elements as the input string contains, starting with the character "a".</source>
          <target state="translated">L’exemple suivant fractionne les caractères « chaîne » en autant d’éléments que contient de la chaîne d’entrée, en commençant par le caractère « a ».</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Because the null string matches the end of the input string, a null string is inserted at the end of the returned array.</source>
          <target state="translated">Étant donné que la chaîne null correspond à la fin de la chaîne d’entrée, une chaîne null est insérée à la fin du tableau retourné.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de fractionnement dépasse l’intervalle de délai d’attente spécifié par le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objet est créé.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> est inférieur à zéro ou supérieur à la longueur de <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to split.</source>
          <target state="translated">Chaîne à fractionner.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</source>
          <target state="translated">Fractionne une chaîne d’entrée en tableau de sous-chaînes aux positions définies par un modèle d’expression régulière spécifié.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">Les options spécifiées modifient l'opération correspondante.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>An array of strings.</source>
          <target state="translated">Tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> méthodes sont similaires à la <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> (méthode), à ceci près que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">La chaîne est fractionnée autant de fois que possible.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no delimiter is found, the return value contains one element whose value is the original <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Si aucun délimiteur n’est trouvé, la valeur de retour contient un élément dont la valeur est la version d’origine <ph id="ph1">`input`</ph> chaîne.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">Les expressions régulières utilisées dans les appels statique compilées <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> méthodes sont mis en cache automatiquement.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">Pour gérer la durée de vie des expressions régulières compilées vous-même, utilisez l’instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Si plusieurs correspondances sont adjacentes, une chaîne vide est insérée dans le tableau.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</source>
          <target state="translated">Par exemple, le fractionnement d’une chaîne sur un trait d’union unique, le tableau retourné inclut une chaîne vide à la position où sont trouvent deux traits d’union.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">Si une correspondance est trouvée au début ou à la fin de la chaîne d’entrée, une chaîne vide est incluse au début ou à la fin du tableau retourné.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`[a-z]+`</ph> to split an input string on any uppercase or lowercase alphabetic character.</source>
          <target state="translated">L’exemple suivant utilise le modèle d’expression régulière <ph id="ph1">`[a-z]+`</ph> permettant de fractionner une chaîne d’entrée sur n’importe quel caractère alphabétique en majuscules ou minuscules.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Étant donné que la chaîne commence et se termine par la mise en correspondance des caractères alphabétiques, la valeur du premier et le dernier élément du tableau retourné est <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Si des parenthèses de capture sont utilisées dans un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, tout texte capturée est inclus dans le tableau de chaînes résultant.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Par exemple, si vous fractionnez la chaîne « plum-poire » sur un trait d’union placé dans les parenthèses de capture, le tableau retourné inclut un élément de chaîne qui contient le trait d’union.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">Dans le .NET Framework 1.0 et 1.1, si une correspondance est introuvable dans le premier jeu de parenthèses, de texte capturé à partir des autres parenthèses de capture n’est pas inclus dans le tableau retourné.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">À compter de .NET Framework 2.0, tout le texte capturé est également ajouté au tableau retourné.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Par exemple, le code suivant utilise deux jeux de parenthèses de capture pour extraire les éléments d’une date, y compris les séparateurs de date, d’une chaîne de date.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">Le premier jeu de parenthèses de capture capture le trait d’union, et le deuxième capture la barre oblique.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Si l’exemple de code est compilé et exécuté sous .NET Framework 1.0 ou 1.1, il exclut les barres obliques ; s’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, il les inclut.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si l’expression régulière peut correspondre à la chaîne vide, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> fractionne la chaîne dans un tableau de chaînes de caractères unique puisque le délimiteur de chaîne vide se retrouve à chaque emplacement.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception est levée si la durée d’exécution de l’opération de fractionnement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n'est pas une combinaison d'opérations de bits des valeurs <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, ce qui empêche la méthode d’arriver à expiration, est utilisé.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for splitting text on a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">La méthode statique recommandée pour fractionner le texte d’une correspondance de modèle est <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, qui vous permet de définir l’intervalle de délai d’attente.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to split.</source>
          <target state="translated">Chaîne à fractionner.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">Modèle d’expression régulière à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">Intervalle de délai d'attente, ou <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> pour indiquer que la méthode ne doit pas expirer.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</source>
          <target state="translated">Fractionne une chaîne d’entrée en tableau de sous-chaînes aux positions définies par un modèle d’expression régulière spécifié.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">Les paramètres supplémentaires spécifient les options qui modifient l'opération et l'intervalle de délai d'attente correspondants si aucune correspondance n'est trouvée.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A string array.</source>
          <target state="translated">Tableau de chaînes.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> méthodes sont similaires à la <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> (méthode), à ceci près que <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">La chaîne est fractionnée autant de fois que possible.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no delimiter is found, the return value contains one element whose value is the original <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">Si aucun délimiteur n’est trouvé, la valeur de retour contient un élément dont la valeur est la version d’origine <ph id="ph1">`input`</ph> chaîne.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">Les expressions régulières utilisées dans les appels statique compilées <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> méthodes sont mis en cache automatiquement.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">Pour gérer la durée de vie des expressions régulières compilées vous-même, utilisez l’instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">Si plusieurs correspondances sont adjacentes, une chaîne vide est insérée dans le tableau.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</source>
          <target state="translated">Par exemple, le fractionnement d’une chaîne sur un trait d’union unique, le tableau retourné inclut une chaîne vide à la position où sont trouvent deux traits d’union.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">Si une correspondance est trouvée au début ou à la fin de la chaîne d’entrée, une chaîne vide est incluse au début ou à la fin du tableau retourné.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`[a-z]+`</ph> to split an input string on any uppercase or lowercase alphabetic character.</source>
          <target state="translated">L’exemple suivant utilise le modèle d’expression régulière <ph id="ph1">`[a-z]+`</ph> permettant de fractionner une chaîne d’entrée sur n’importe quel caractère alphabétique en majuscules ou minuscules.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Étant donné que la chaîne commence et se termine par la mise en correspondance des caractères alphabétiques, la valeur du premier et le dernier élément du tableau retourné est <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">Si des parenthèses de capture sont utilisées dans un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, tout texte capturée est inclus dans le tableau de chaînes résultant.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">Par exemple, si vous fractionnez la chaîne « plum-poire » sur un trait d’union placé dans les parenthèses de capture, le tableau retourné inclut un élément de chaîne qui contient le trait d’union.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">Dans le .NET Framework 1.0 et 1.1, si une correspondance est introuvable dans le premier jeu de parenthèses, de texte capturé à partir des autres parenthèses de capture n’est pas inclus dans le tableau retourné.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">À compter de .NET Framework 2.0, tout le texte capturé est également ajouté au tableau retourné.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">Par exemple, le code suivant utilise deux jeux de parenthèses de capture pour extraire les éléments d’une date, y compris les séparateurs de date, d’une chaîne de date.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">Le premier jeu de parenthèses de capture capture le trait d’union, et le deuxième capture la barre oblique.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">Si l’exemple de code est compilé et exécuté sous .NET Framework 1.0 ou 1.1, il exclut les barres obliques ; s’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, il les inclut.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">Si l’expression régulière peut correspondre à la chaîne vide, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> fractionne la chaîne dans un tableau de chaînes de caractères unique puisque le délimiteur de chaîne vide se retrouve à chaque emplacement.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">Le <ph id="ph1">`matchTimeout`</ph> paramètre spécifie la manière dont la durée pendant laquelle une recherche de correspondance (méthode) doit effectuer pour trouver une correspondance avant d’expirer. Définition d’un intervalle de délai d’attente empêche les expressions régulières qui s’appuient sur une rétroaction excessive de semble cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>meilleures pratiques des Expressions régulières<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> et <bpt id="p2">[</bpt>rétroaction<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode lève un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> remplace toute valeur de délai d’attente par défaut défini pour le domaine d’application dans laquelle la méthode s’exécute.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">Une erreur d’analyse d’expression régulière s’est produite.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> n'est pas une combinaison d'opérations de bits des valeurs <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> est négatif, égal à zéro ou supérieur à environ 24 jours.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">Un dépassement du délai d’attente s’est produit.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">Nous vous recommandons de définir la <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> paramètre à une valeur appropriée, comme les deux secondes.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">Si vous désactivez des délais d’attente en spécifiant <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, le moteur des expressions régulières offre des performances sont légèrement meilleures.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">Toutefois, vous devez désactiver les délais d’expiration uniquement dans les conditions suivantes :</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">Cela exclut le texte qui a été dynamiquement par les utilisateurs.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">Lorsque le modèle d’expression régulière a été soigneusement testé pour s’assurer qu’elle gère efficacement correspond à, non-correspondances et proche correspond.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object to populate with serialization information.</source>
          <target state="translated">Objet à remplir avec des informations de sérialisation.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The place to store and retrieve serialized data.</source>
          <target state="translated">Emplacement de stockage et de récupération des données sérialisées.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This parameter is reserved for future use.</source>
          <target state="translated">Ce paramètre est réservé pour une future utilisation.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object with the data necessary to deserialize the current <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object.</source>
          <target state="translated">Remplit un objet <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> avec les données nécessaires pour désérialiser l'objet <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>Returns the regular expression pattern that was passed into the <ph id="ph1">&lt;see langword="Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Retourne le modèle d'expression régulière qui a été passé au constructeur <ph id="ph1">&lt;see langword="Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>The <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> parameter that was passed into the <ph id="ph2">&lt;see langword="Regex" /&gt;</ph> constructor.</source>
          <target state="translated">Paramètre <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> qui a été passé au constructeur <ph id="ph2">&lt;see langword="Regex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated">Le <ph id="ph1">`pattern`</ph> paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les expressions régulières, consultez <bpt id="p1">[</bpt>Expressions régulières .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> et <bpt id="p2">[</bpt>langage des expressions régulières - aide-mémoire<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> is the base class of regular expressions created by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> est la classe de base des expressions régulières créée par le <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>These compiled regular expressions use the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> implementation of the base class.</source>
          <target state="translated">Ces expressions régulières compilées utilisent le <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> implémentation de la classe de base.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>If called from a derived class, the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> method returns the string that was passed to the <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> parameter of the <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> class constructor that was used to define the regular expression.</source>
          <target state="translated">Si elle est appelée à partir d’une classe dérivée, la <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> méthode retourne la chaîne qui a été passée à la <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> paramètre de la <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> constructeur de classe qui a été utilisé pour définir l’expression régulière.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The input string containing the text to convert.</source>
          <target state="translated">Chaîne d'entrée qui contient le texte à convertir.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>Converts any escaped characters in the input string.</source>
          <target state="translated">Convertit les caractères d'échappement dans la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>A string of characters with any escaped characters converted to their unescaped form.</source>
          <target state="translated">Chaîne de caractères dont les caractères d'échappement remplacés sont remis dans leur forme initiale.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method performs one of the following two transformations:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> méthode effectue l’une des deux transformations suivantes :</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>It reverses the transformation performed by the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method by removing the escape character ("<ph id="ph2">\\</ph>") from each character escaped by the method.</source>
          <target state="translated">Il inverse la transformation exécutée par le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> méthode en supprimant le caractère d’échappement («<ph id="ph2">\\</ph>») à partir de chaque caractère d’échappement par la méthode.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>These include the <ph id="ph1">\\</ph>, *, +, ?, &amp;#124;, {, [, (,), ^, $,., #, and white space characters.</source>
          <target state="translated">Celles-ci incluent la <ph id="ph1">\\</ph>, *, +, ?, &amp;#124;, {, [, (,), ^, $,., # et les caractères d’espace blanc.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method unescapes the closing bracket (]) and closing brace (}) characters.</source>
          <target state="translated">En outre, le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> méthode annule le remplacement le crochet fermant (]) et la fermeture des accolades (}).</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> cannot reverse an escaped string perfectly because it cannot deduce precisely which characters were escaped,</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> ne peut pas inverser de chaîne avec séquence d’échappement parfaitement, car il ne peut pas déduire précisément quels caractères se sont échappés,</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>It replaces the representation of unprintable characters with the characters themselves.</source>
          <target state="translated">Il remplace la représentation sous forme de caractères non imprimables par les caractères eux-mêmes.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>For example, it replaces \a with \x07.</source>
          <target state="translated">Par exemple, il remplace \a par \x07.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The character representations it replaces are \a, \b, \e, \n, \r, \f, \t, and \v.</source>
          <target state="translated">Les représentations sous forme de caractères qu’il remplace sont \a, \b, \e, \n, \r, \f, \t et \v.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method encounters other escape sequences that it cannot convert, such as \w or \s, it throws an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> méthode rencontre d’autres séquences d’échappement qu’elle ne peut pas convertir, telles que \w ou \s, elle lève une <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> includes an unrecognized escape sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> inclut une séquence d'échappement non reconnue.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionC">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>Utilisé par un objet généré par la méthode <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionC">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property contains the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propriété <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> contient l'option <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionR">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>Utilisé par un objet généré par la méthode <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionR">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property contains the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /&gt;</ph> option; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propriété <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> contient l'option <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)">
          <source>The time-out interval to check.</source>
          <target state="translated">Délai d'attente à vérifier.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)">
          <source>Checks whether a time-out interval is within an acceptable range.</source>
          <target state="translated">Vérifie si un intervalle de délai d'attente est compris dans une plage acceptable.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>