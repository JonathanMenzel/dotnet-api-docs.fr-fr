<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MatchCollection.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5e87525df368996e12afb05786542f35ef70697a6.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e87525df368996e12afb05786542f35ef70697a6</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>Represents the set of successful matches found by iteratively applying a regular expression pattern to the input string.</source>
          <target state="translated">Représente l’ensemble des correspondances exactes trouvées en appliquant de manière itérative une expression régulière à la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>The collection is immutable (read-only) and has no public constructor.</source>
          <target state="translated">La collection est immuable (lecture seule) et n’a aucun constructeur public.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> retourne un objet <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>The collection contains zero or more <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match?displayProperty=nameWithType&gt;</ph> objects.</source>
          <target state="translated">La collection contient zéro ou plusieurs <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match?displayProperty=nameWithType&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>If the match is successful, the collection is populated with one <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match?displayProperty=nameWithType&gt;</ph> object for each match found in the input string.</source>
          <target state="translated">Si la correspondance est réussie, la collection est remplie avec un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match?displayProperty=nameWithType&gt;</ph> objet pour chaque correspondance trouvée dans la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>If the match is unsuccessful, the collection contains no <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match?displayProperty=nameWithType&gt;</ph> objects, and its <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> property equals zero.</source>
          <target state="translated">Si la correspondance est infructueuse, la collection ne contient pas <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match?displayProperty=nameWithType&gt;</ph> objets et son <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> propriété est égal à zéro.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>When applying a regular expression pattern to a particular input string, the regular expression engine uses either of two techniques to build the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object:</source>
          <target state="translated">Lorsque vous appliquez un modèle d’expression régulière à une chaîne d’entrée particulière, le moteur des expressions régulières utilise une des deux techniques pour générer le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet :</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>Direct evaluation.</source>
          <target state="translated">Évaluation directe.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object is populated all at once, with all matches resulting from a particular call to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet est rempli tous en même temps, avec toutes les correspondances qui résulte d’un appel particulier à la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>This technique is used when the collection's <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> property is accessed.</source>
          <target state="translated">Cette technique est utilisée lors de la collection <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> propriété est accessible.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>It typically is the more expensive method of populating the collection and entails a greater performance hit.</source>
          <target state="translated">En règle générale, il est la méthode la plus coûteuse du remplissage de la collection et entraîne une baisse des performances.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>Lazy evaluation.</source>
          <target state="translated">Évaluation différée.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object is populated as needed on a match-by-match basis.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet est rempli en fonction des besoins sur une base correspondance-par-correspondance.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>It is equivalent to the regular expression engine calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> method repeatedly and adding each match to the collection.</source>
          <target state="translated">Elle est équivalente à l’appel de moteur d’expression régulière la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> méthode à plusieurs reprises et l’ajout de chaque correspondance à la collection.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>This technique is used when the collection is accessed through its <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> method, or when it is accessed using the <ph id="ph2">`foreach`</ph> statement (in C#) or the <ph id="ph3">`For Each`</ph>...<ph id="ph4">`Next`</ph> statement (in Visual Basic).</source>
          <target state="translated">Cette technique est utilisée lorsque la collection est accessible via son <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> (méthode), ou lorsqu’il est accessible à l’aide de la <ph id="ph2">`foreach`</ph> instruction (c#) ou <ph id="ph3">`For Each`</ph>... <ph id="ph4">`Next`</ph> instruction (en Visual Basic).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>To iterate through the members of the collection, you should use the collection iteration construct provided by your language (such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">Pour parcourir les membres de la collection, vous devez utiliser la construction d’itération collection fournie par votre langage (tels que <ph id="ph1">`foreach`</ph> en c# et <ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>in Visual Basic) instead of retrieving the enumerator that is returned by the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> method.</source>
          <target state="translated">en Visual Basic) au lieu de récupérer l’énumérateur retourné par la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.MatchCollection">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> class to interrogate a set of <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> instances.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> classe pour interroger un ensemble de <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> instances.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source>The array the collection is to be copied into.</source>
          <target state="translated">Tableau dans lequel la collection doit être copiée.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source>The position in the array where copying is to begin.</source>
          <target state="translated">Position à laquelle la copie doit commencer dans le tableau.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source>Copies all the elements of the collection to the given array starting at the given index.</source>
          <target state="translated">Copie tous les éléments de la collection dans le tableau donné en commençant à l’index spécifié.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source>Because the collection is copied into the array starting at the given index, the destination array must be at least as large as the entire collection.</source>
          <target state="translated">Étant donné que la collection est copiée dans le tableau en commençant à l’index donné, le tableau de destination doit être au moins aussi grand que la collection entière.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source>This member is not present in the <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>.</source>
          <target state="translated">Ce membre n’est pas présent dans le <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source>If you are developing applications that target the <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>, use the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.CaptureCollection.System%23Collections%23ICollection%23CopyTo%2A?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Si vous développez des applications qui ciblent le <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>, utilisez la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.CaptureCollection.System%23Collections%23ICollection%23CopyTo%2A?displayProperty=nameWithType&gt;</ph> méthode à la place.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object is generally populated by using lazy evaluation, trying to copy the collection before it has been fully populated may throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet est généralement rempli à l’aide de l’évaluation différée, la tentative de copie de la collection avant qu’il a été entièrement rempli peut lever un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source>This exception can be thrown if a time-out value for matching operations is in effect, and the attempt to find a single match exceeds that time-out interval.</source>
          <target state="translated">Cette exception peut être levée si une valeur de délai d’attente pour les opérations de mise en correspondance est en vigueur, et la tentative de trouver une correspondance unique dépasse ce délai d’attente.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is a multi-dimensional array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est un tableau multidimensionnel.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is outside the bounds of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> est en dehors des limites de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> plus <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.MatchCollection.Count" /&gt;</ph> is outside the bounds of <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> plus <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.MatchCollection.Count" /&gt;</ph> sont en dehors des limites de <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>Gets the number of matches.</source>
          <target state="translated">Obtient le nombre de correspondances.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>The number of matches.</source>
          <target state="translated">Nombre de correspondances.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>Accessing individual members of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object by retrieving the value of the collection's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> property causes the regular expression engine to populate the collection using direct evaluation.</source>
          <target state="translated">Accéder aux membres individuels de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet en récupérant la valeur de la collection <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> propriété entraîne le moteur des expressions régulières remplir la collection à l’aide d’évaluation directe.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>ln contrast, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> method (or using the <ph id="ph2">`foreach`</ph> statement in C# and the <ph id="ph3">`For Each`</ph>...<ph id="ph4">`Next`</ph> statement in Visual Basic) causes the regular expression engine to populate the collection on an as needed basis using lazy evaluation.</source>
          <target state="translated">Inversement, en appelant le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> (méthode) (ou à l’aide de la <ph id="ph2">`foreach`</ph> instruction en c# et le <ph id="ph3">`For Each`</ph>... <ph id="ph4">`Next`</ph> instruction en Visual Basic) entraîne le moteur des expressions régulières remplir la collection selon nécessaire à l’aide de l’évaluation différée.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>Direct evaluation can be a much more expensive method of building the collection than lazy evaluation.</source>
          <target state="translated">Évaluation directe peut être une méthode beaucoup plus coûteuse de génération de la collection que l’évaluation différée.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object is generally populated by using lazy evaluation, trying to determine the number of elements in the collection before it has been fully populated may throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet est généralement rempli à l’aide de l’évaluation différée, essayez de déterminer le nombre d’éléments dans la collection avant qu’il a été entièrement rempli peut lever un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>This exception can be thrown if a time-out value for matching operations is in effect, and the attempt to find a single match exceeds that time-out interval.</source>
          <target state="translated">Cette exception peut être levée si une valeur de délai d’attente pour les opérations de mise en correspondance est en vigueur, et la tentative de trouver une correspondance unique dépasse ce délai d’attente.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> property to determine whether the call to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method found any matches.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> propriété pour déterminer si l’appel à la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> méthode trouvé aucune correspondance.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>If not, it indicates that no matches were found.</source>
          <target state="translated">Si ce n’est pas le cas, elle indique qu’aucune correspondance trouvée.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>Otherwise, it enumerates the matches and displays their value and the position in the input string at which they were found.</source>
          <target state="translated">Dans le cas contraire, il énumère les correspondances et affiche leur valeur et la position dans la chaîne d’entrée à laquelle ils ont été trouvés.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>The regular expression pattern <ph id="ph1">`\d+`</ph> matches one or more decimal characters in an input string.</source>
          <target state="translated">Le modèle d’expression régulière <ph id="ph1">`\d+`</ph> correspond à un ou plusieurs caractères décimaux dans une chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.MatchCollection.Count">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
          <source>Provides an enumerator that iterates through the collection.</source>
          <target state="translated">Fournit un énumérateur qui itère au sein de la collection.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
          <source>An object that contains all <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects within the <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph>.</source>
          <target state="translated">Objet qui contient tous les objets <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> au sein de la <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
          <source>Instead of  calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> method to retrieve an enumerator that lets you iterate through the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the collection, you should use the group iteration construct (such as <ph id="ph3">`foreach`</ph> in C# and <ph id="ph4">`For Each`</ph>…<ph id="ph5">`Next`</ph></source>
          <target state="translated">Au lieu d’appeler le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> méthode pour récupérer un énumérateur qui vous permet de parcourir le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> des objets dans la collection, vous devez utiliser la construction d’itération de groupe (tel que <ph id="ph3">`foreach`</ph> en c# et <ph id="ph4">`For Each`</ph>...<ph id="ph5">`Next`</ph></target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
          <source>in Visual Basic) provided by your programming language.</source>
          <target state="translated">en Visual Basic) fournie par votre langage de programmation.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
          <source>Iterating the members of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> method (or the <ph id="ph3">`foreach`</ph> statement in C# and the <ph id="ph4">`For Each`</ph>...<ph id="ph5">`Next`</ph> statement in Visual Basic) causes the regular expression engine to populate the collection on an as needed basis using lazy evaluation.</source>
          <target state="translated">Itérer les membres de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> à l’aide de l’objet le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> (méthode) (ou le <ph id="ph3">`foreach`</ph> instruction en c# et <ph id="ph4">`For Each`</ph>... <ph id="ph5">`Next`</ph> instruction en Visual Basic) entraîne le moteur des expressions régulières remplir la collection selon nécessaire à l’aide de l’évaluation différée.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
          <source>This is analogous to repeatedly calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> method, and then adding the resulting match to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">Cela est analogue à l’appel à plusieurs reprises la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> (méthode), puis en ajoutant la correspondance à la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
          <source>In contrast, the regular expression engine uses direct evaluation to populate the collection all at once when the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> property is accessed.</source>
          <target state="translated">En revanche, le moteur des expressions régulières utilise l’évaluation directe pour remplir la collection à la fois lorsque la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> propriété est accessible.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
          <source>This can be a much more expensive method of building the collection than lazy evaluation.</source>
          <target state="translated">Cela peut être une méthode beaucoup plus coûteuse de génération de la collection que l’évaluation différée.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object is generally populated by using lazy evaluation, trying to navigate to the next member of the collection may throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet est généralement rempli à l’aide de l’évaluation différée, la tentative de navigation vers le membre suivant de la collection peut lever un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
          <source>This exception can be thrown if a time-out value for matching operations is in effect, and the attempt to find the next match exceeds that time-out interval.</source>
          <target state="translated">Cette exception peut être levée si une valeur de délai d’attente pour les opérations de mise en correspondance est en vigueur, et la tentative de recherche de la correspondance suivante dépasse ce délai d’attente.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.MatchCollection.GetEnumerator">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.MatchCollection.IsReadOnly">
          <source>Gets a value that indicates whether the collection is read only.</source>
          <target state="translated">Obtient une valeur qui indique si la collection est en lecture seule.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> in all cases.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> dans tous les cas.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.MatchCollection.IsSynchronized">
          <source>Gets a value indicating whether access to the collection is synchronized (thread-safe).</source>
          <target state="translated">Obtient une valeur indiquant si l’accès à la collection est synchronisé (thread-safe).</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.IsSynchronized">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> in all cases.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> dans tous les cas.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.IsSynchronized">
          <source>This member is not present in the <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>.</source>
          <target state="translated">Ce membre n’est pas présent dans le <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.IsSynchronized">
          <source>If you are developing applications that target the <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>, use the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.System%23Collections%23ICollection%23IsSynchronized%2A?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">Si vous développez des applications qui ciblent le <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>, utilisez le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.System%23Collections%23ICollection%23IsSynchronized%2A?displayProperty=nameWithType&gt;</ph> propriété à la place.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>Index into the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> collection.</source>
          <target state="translated">Index dans la collection <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>Gets an individual member of the collection.</source>
          <target state="translated">Obtient un membre de la collection.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>The captured substring at position <ph id="ph1">&lt;paramref name="i" /&gt;</ph> in the collection.</source>
          <target state="translated">Sous-chaîne capturée à la position <ph id="ph1">&lt;paramref name="i" /&gt;</ph> dans la collection.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>In C#, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Item%2A&gt;</ph> property is an indexer; it is not explicitly referenced in code, but instead allows the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to be accessed as if it were an array.</source>
          <target state="translated">En c#, le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Item%2A&gt;</ph> propriété est un indexeur ; elle n’est pas explicitement référencée dans le code, mais elle autorise la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection accessibles comme s’il s’agissait d’un tableau.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>Typically, individual items in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object are accessed by their index only after the total number of items in the collection has been determined from the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> property.</source>
          <target state="translated">En règle générale, les éléments individuels dans le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet sont accessibles par leur index uniquement une fois que le nombre total d’éléments dans la collection a été déterminé à partir de la <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>However, accessing the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> property causes the regular expression engine to use direct evaluation to build the collection all at once.</source>
          <target state="translated">Toutefois, l’accès à la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A&gt;</ph> la propriété entraîne le moteur d’expression régulière à utiliser l’évaluation directe pour générer la collection à la fois.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>This is typically more expensive than iterating the collection using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> method, the C# <ph id="ph2">`foreach`</ph> statement, or the Visual Basic <ph id="ph3">`For Each`</ph>...<ph id="ph4">`Next`</ph> statement.</source>
          <target state="translated">Il s’agit en général plus coûteuse que l’itération de la collection à l’aide de la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.GetEnumerator%2A&gt;</ph> (méthode), C# <ph id="ph2">`foreach`</ph> instruction ou Visual Basic <ph id="ph3">`For Each`</ph>... <ph id="ph4">`Next`</ph> instruction.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object is generally populated by using lazy evaluation, trying to navigate to a specific match may throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet est généralement rempli à l’aide de l’évaluation différée, essayez d’accéder à une correspondance spécifique peut lever un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>This exception can be thrown if a time-out value for matching operations is in effect, and the attempt to find a specific match exceeds that time-out interval.</source>
          <target state="translated">Cette exception peut être levée si une valeur de délai d’attente pour les opérations de mise en correspondance est en vigueur, et la tentative de trouver une correspondance spécifique dépasse ce délai d’attente.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>The following example parses the first sentence of Nathaniel Hawthorne's <bpt id="p1">*</bpt>House of the Seven Gables<ept id="p1">*</ept> and returns a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object that contains all words that begin with either an uppercase or lowercase "h".</source>
          <target state="translated">L’exemple suivant analyse la première phrase de Nathaniel Hawthorne <bpt id="p1">*</bpt>House of les sept Gables<ept id="p1">*</ept> et retourne un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objet qui contient tous les mots qui commencent par ou un « h » majuscule ou minuscule.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Item%2A&gt;</ph> property is then used to retrieve each word and display it to the console.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Item%2A&gt;</ph> propriété est ensuite utilisée pour récupérer chaque mot et l’afficher dans la console.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>The example produces the following output:</source>
          <target state="translated">L'exemple produit la sortie suivante :</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="i" /&gt;</ph> is less than 0 or greater than or equal to <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.MatchCollection.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="i" /&gt;</ph> est inférieur à 0 ou supérieur ou égal à <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.MatchCollection.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.MatchCollection.Item(System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">Un délai d’attente a expiré.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.MatchCollection.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the collection.</source>
          <target state="translated">Obtient un objet qui peut être utilisé pour synchroniser l’accès à la collection.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.SyncRoot">
          <source>An object that can be used to synchronize access to the collection.</source>
          <target state="translated">Objet permettant de synchroniser l’accès à la collection.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.SyncRoot">
          <source>This property always returns the object itself.</source>
          <target state="translated">Cette propriété retourne toujours l'objet lui-même.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.SyncRoot">
          <source>This member is not present in the <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>.</source>
          <target state="translated">Ce membre n’est pas présent dans le <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.MatchCollection.SyncRoot">
          <source>If you are developing applications that target the <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>, use the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.System%23Collections%23ICollection%23SyncRoot%2A?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">Si vous développez des applications qui ciblent le <ph id="ph1">[!INCLUDE[net_portable](~/includes/net-portable-md.md)]</ph>, utilisez le <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.System%23Collections%23ICollection%23SyncRoot%2A?displayProperty=nameWithType&gt;</ph> propriété à la place.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>