<Type Name="MutexSecurity" FullName="System.Security.AccessControl.MutexSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="32296db222ea6141fe27393ef3e6f899d0231f0f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30490673" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MutexSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MutexSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.MutexSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MutexSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class MutexSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente la sécurité de contrôle d'accès Windows d'un mutex nommé. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Security.AccessControl.MutexSecurity> objet spécifie les droits d’accès d’un mutex système nommé et spécifie également la manière dont les tentatives d’accès sont auditées. Droits d’accès au mutex sont exprimés sous forme de règles, chaque règle d’accès représenté par un <xref:System.Security.AccessControl.MutexAccessRule> objet. Chaque règle d’audit est représentée par un <xref:System.Security.AccessControl.MutexAuditRule> objet.  
  
 Cela reflète le système de sécurité Windows sous-jacent, dans lequel chaque objet sécurisable a au plus une liste discretionary access control (DACL) qui contrôle l’accès à l’objet sécurisé et au plus un système liste contrôle d’accès (SACL) qui spécifie les accès les tentatives sont auditées. La liste DACL et SACL sont les listes ordonnées d’entrées de contrôle d’accès (ACE) qui spécifient les accès et audit pour les utilisateurs et groupes. A <xref:System.Security.AccessControl.MutexAccessRule> ou <xref:System.Security.AccessControl.MutexAuditRule> objet peut représenter plusieurs ACE.  
  
> [!NOTE]
>  A <xref:System.Threading.Mutex> objet peut représenter un mutex local ou un mutex système nommé. Sécurité de contrôle d’accès Windows est significative uniquement pour les mutex système nommé.  
  
 Le <xref:System.Security.AccessControl.MutexSecurity>, <xref:System.Security.AccessControl.MutexAccessRule>, et <xref:System.Security.AccessControl.MutexAuditRule> classes masquent les détails d’implémentation des ACL et des entrées. Ils permettent d’ignorer les différents types d’ACE dix-sept et la complexité de la maintenance d’héritage et la propagation de droits d’accès. Ces objets sont également conçues pour éviter les erreurs de contrôle d’accès courantes suivantes :  
  
-   Création d’un descripteur de sécurité avec une liste DACL null. Une référence null à une liste DACL permet à tout utilisateur d’ajouter des règles d’accès à un objet, qui crée une attaque par déni de service. Un nouveau <xref:System.Security.AccessControl.MutexSecurity> objet commence toujours par une liste DACL vide, ce qui refuse tout accès à tous les utilisateurs.  
  
-   Violation de l’ordre canonique d’ACE. Si la liste ACE dans la liste DACL n’est pas conservée dans l’ordre canonique, les utilisateurs peuvent par inadvertance données accès à l’objet sécurisé. Par exemple, des droits d’accès refusé doivent toujours apparaître avant droits d’accès autorisés. <xref:System.Security.AccessControl.MutexSecurity> objets conservent l’ordre correct en interne.  
  
-   Manipulation des indicateurs de descripteurs de sécurité, qui doivent se trouver sous le contrôle de gestionnaire de ressources uniquement.  
  
-   Création de combinaisons non valides d’indicateurs ACE.  
  
-   La manipulation de héritées. Héritage et propagation sont gérés par le Gestionnaire de ressources, en réponse aux modifications apportées aux règles d’accès et d’audit.  
  
-   L’insertion sans signification ACE dans l’ACL.  
  
 Les seules fonctionnalités non prises en charge par les objets de sécurité .NET sont des activités dangereuses qui doivent être évitées par la majorité des développeurs d’applications, telles que les éléments suivants :  
  
-   Tâches de bas niveau qui sont normalement effectuées par le Gestionnaire de ressources.  
  
-   Ajout ou suppression d’entrées de contrôle d’accès d’une manière qui ne conserve pas l’ordre canonique.  
  
 Pour modifier la sécurité de contrôle d’accès Windows d’un mutex nommé, utilisez la <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> méthode pour obtenir le <xref:System.Security.AccessControl.MutexSecurity> objet. Modifier l’objet de sécurité en ajoutant et supprimant des règles et ensuite utiliser le <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType> méthode pour le rattacher.  
  
> [!IMPORTANT]
>  Modifications apportées à un <xref:System.Security.AccessControl.MutexSecurity> objet n’affectent pas les niveaux d’accès du mutex nommé jusqu'à ce que vous appeliez la <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType> méthode pour attribuer l’objet de sécurité modifié pour le mutex nommé.  
  
 Pour copier la sécurité de contrôle d’accès d’un mutex à un autre, utilisez la <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> méthode pour obtenir un <xref:System.Security.AccessControl.MutexSecurity> de l’objet représentant les règles d’accès et d’audit pour le mutex en premier, puis utiliser le <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType> méthode ou un constructeur qui accepte un <xref:System.Security.AccessControl.MutexSecurity>objet, pour assigner ces règles au deuxième mutex.  
  
 Les utilisateurs avec un investissement dans le langage de définition de descripteur de sécurité (SDDL) peuvent utiliser le <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> pour définir des règles d’accès d’un mutex nommé et le <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> méthode pour obtenir une chaîne qui représente les règles d’accès au format SDDL. Cela n’est pas recommandé pour un nouveau développement.  
  
> [!NOTE]
>  La sécurité sur les objets de synchronisation n’est pas pris en charge par Windows 98 ou Windows Millennium Edition.  
  
   
  
## Examples  
 L’exemple de code suivant illustre la séparation entre <xref:System.Security.AccessControl.AccessControlType.Allow> règles et <xref:System.Security.AccessControl.AccessControlType.Deny> des règles et affiche la combinaison de droits des règles compatibles. L’exemple crée un <xref:System.Security.AccessControl.MutexSecurity> objet, ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel et affiche la paire de règles résultante. L’exemple permet de nouveaux droits de l’utilisateur actuel, puis affiche le résultat, en indiquant que les nouveaux droits sont fusionnés avec les <xref:System.Security.AccessControl.AccessControlType.Allow> règle.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:System.Threading.Mutex> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.MutexAccessRule" />
    <altmember cref="T:System.Security.AccessControl.MutexAuditRule" />
    <altmember cref="T:System.Security.AccessControl.MutexRights" />
    <altmember cref="M:System.Threading.Mutex.GetAccessControl" />
    <altmember cref="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.AccessControl.MutexSecurity" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MutexSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MutexSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.AccessControl.MutexSecurity" /> avec des valeurs par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nouveau <xref:System.Security.AccessControl.MutexSecurity> objet commence toujours par une liste vide accès discrétionnaire (DACL), ce qui refuse tout accès à tous les utilisateurs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette classe n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MutexSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, includeSections As AccessControlSections)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MutexSecurity(System::String ^ name, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="name">Nom du mutex système dont les règles de sécurité du contrôle d'accès doivent être récupérées.</param>
        <param name="includeSections">Combinaison d'indicateurs <see cref="T:System.Security.AccessControl.AccessControlSections" /> spécifiant les sections à récupérer.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.AccessControl.MutexSecurity" /> avec les sections spécifiées des règles de sécurité du contrôle d'accès du mutex système portant le nom spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur vous permet d’obtenir la sécurité de contrôle d’accès d’un mutex système nommé sans créer au préalable un <xref:System.Threading.Mutex> objet.  
  
 Attention Lorsque vous travaillez avec des objets système nommé qui doit être accordée. S’il est un objet système nommé `name` qui n’est pas un mutex, sa sécurité de contrôle d’accès peut être récupérée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Il n'existe aucun objet système portant le nom spécifié.</exception>
        <exception cref="T:System.NotSupportedException">Cette classe n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.MutexSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'énumération utilisée par la classe <see cref="T:System.Security.AccessControl.MutexSecurity" /> pour représenter des droits d'accès.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant l'énumération <see cref="T:System.Security.AccessControl.MutexRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes dérivées de la <xref:System.Security.AccessControl.ObjectSecurity> classe de remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> propriété et retourner le type qu’elles utilisent pour représenter des droits d’accès. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type d’énumération correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <see cref="T:System.Security.Principal.IdentityReference" /> qui identifie l'utilisateur ou le groupe auquel s'applique la règle.</param>
        <param name="accessMask">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.MutexRights" /> qui spécifient les droits d'accès à accorder ou refuser, castés en entier.</param>
        <param name="isInherited">Sans utilité pour les mutex nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="inheritanceFlags">Sans utilité pour les mutex nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="propagationFlags">Sans utilité pour les mutex nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="type">Une des valeurs <see cref="T:System.Security.AccessControl.AccessControlType" /> spécifiant si les droits sont accordés ou refusés.</param>
        <summary>Crée une règle de contrôle d'accès pour l'utilisateur spécifié, avec les droits d'accès, le contrôle d'accès et les indicateurs spécifiés.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.MutexAccessRule" /> représentant les droits spécifiés pour l'utilisateur spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode recommandée pour créer des règles de contrôle d’accès est d’utiliser les constructeurs de la <xref:System.Security.AccessControl.MutexAccessRule> classe.  
  
> [!NOTE]
>  Bien que les indicateurs d’héritage et de propagation sont sans effet pour les mutex nommés, il est toujours possible de les spécifier. Cela est déconseillé, car elle complique inutilement la maintenance des règles, par exemple par interférer avec la combinaison de règles qui serait normalement compatibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> ou <paramref name="type" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="accessMask" /> est égal à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> n'est ni du type <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni d'un type tel que <see cref="T:System.Security.Principal.NTAccount" /> qui peut être converti en type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.MutexSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type utilisé par la classe <see cref="T:System.Security.AccessControl.MutexSecurity" /> pour représenter des règles d'accès.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant la classe <see cref="T:System.Security.AccessControl.MutexAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes dérivées de la <xref:System.Security.AccessControl.ObjectSecurity> classe de remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> propriété et retourner le type qu’elles utilisent pour représenter des règles d’accès. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type de règle d’accès correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AddAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle de contrôle d'accès à ajouter.</param>
        <summary>Recherche une règle de contrôle d'accès correspondante avec laquelle la nouvelle règle peut être fusionnée. Ajoute la nouvelle règle en cas de recherche infructueuse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.AccessControl.MutexSecurity.AddAccessRule%2A> méthode recherche des règles ayant le même utilisateur ou groupe et le même <xref:System.Security.AccessControl.AccessControlType> comme `rule`. Si aucune n’est trouvée, `rule` est ajouté. Si une règle de correspondance est trouvée, les droits dans `rule` sont fusionnés avec la règle existante.  
  
   
  
## Examples  
 L’exemple de code suivant illustre la séparation entre <xref:System.Security.AccessControl.AccessControlType.Allow> règles et <xref:System.Security.AccessControl.AccessControlType.Deny> des règles et affiche la combinaison de droits des règles compatibles. L’exemple crée un <xref:System.Security.AccessControl.MutexSecurity> objet, ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel et affiche la paire de règles résultante. L’exemple permet de nouveaux droits de l’utilisateur actuel, puis affiche le résultat, en indiquant que les nouveaux droits sont fusionnés avec les <xref:System.Security.AccessControl.AccessControlType.Allow> règle.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:System.Threading.Mutex> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Security.Principal.IdentityNotMappedException">
          <paramref name="rule" /> ne peut pas être mappé à une identité connue.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AddAuditRule(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’audit à ajouter. L'utilisateur spécifié par cette règle détermine la recherche.</param>
        <summary>Recherche une règle d'audit avec laquelle la nouvelle règle peut être fusionnée. Ajoute la nouvelle règle en cas de recherche infructueuse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.AccessControl.MutexSecurity.AddAuditRule%2A> méthode recherche des règles ayant le même utilisateur ou groupe en tant que `rule`. Si aucune n’est trouvée, `rule` est ajouté. Si une règle de correspondance est trouvée, les indicateurs de `rule` sont fusionnées dans la règle existante.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <see cref="T:System.Security.Principal.IdentityReference" /> qui identifie l'utilisateur ou le groupe auquel s'applique la règle.</param>
        <param name="accessMask">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.MutexRights" /> spécifiant les droits d'accès à auditer, castés en entier.</param>
        <param name="isInherited">Sans utilité pour les handles d'attente nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="inheritanceFlags">Sans utilité pour les handles d'attente nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="propagationFlags">Sans utilité pour les handles d'attente nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="flags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.AuditFlags" /> qui spécifient s'il faut auditer les accès réussis, les échecs d'accès ou les deux.</param>
        <summary>Crée une règle d'audit, en spécifiant l'utilisateur auquel elle s'applique, les droits d'accès à auditer et le résultat qui déclenche la règle d'audit.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.MutexAuditRule" /> représentant la règle d'audit spécifiée pour l'utilisateur spécifié. Le type de retour de la méthode est la classe de base, <see cref="T:System.Security.AccessControl.AuditRule" />, mais la valeur de retour peut être castée sans risque en classe dérivée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode recommandée pour créer des règles d’audit consiste à utiliser les constructeurs de la <xref:System.Security.AccessControl.MutexAuditRule> classe.  
  
> [!NOTE]
>  Bien que les indicateurs d’héritage et de propagation sont sans effet pour les mutex nommés, il est toujours possible de les spécifier. Cela est déconseillé, car elle complique inutilement la maintenance des règles, par exemple par interférer avec la combinaison de règles qui serait normalement compatibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> ou <paramref name="flags" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="accessMask" /> est égal à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> n'est ni du type <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni d'un type tel que <see cref="T:System.Security.Principal.NTAccount" /> qui peut être converti en type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.MutexSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type utilisé par la classe <see cref="T:System.Security.AccessControl.MutexSecurity" /> pour représenter des règles d'audit.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant la classe <see cref="T:System.Security.AccessControl.MutexAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes dérivées de la <xref:System.Security.AccessControl.ObjectSecurity> classe de remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> propriété et retourner le type qu’elles utilisent pour représenter des droits d’audit. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type de règle d’audit correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As MutexAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> qui spécifie l'utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> à rechercher, ainsi qu'un jeu d'indicateurs d'héritage et de propagation avec lesquels une règle correspondante, si elle est trouvée, doit être compatible. Spécifie les droits à supprimer de la règle compatible, le cas échéant.</param>
        <summary>Recherche une règle de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle spécifiée et ayant des indicateurs d'héritage et de propagation compatibles ; si une telle règle est trouvée, les droits contenus dans la règle d'accès spécifiée en sont supprimés.</summary>
        <returns>
          <see langword="true" /> si une règle compatible est trouvée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En cours <xref:System.Security.AccessControl.MutexSecurity> est recherché dans une règle qui a le même utilisateur et le même <xref:System.Security.AccessControl.AccessControlType> valeur en tant que `rule`. Si aucune règle n’est trouvée, aucune action n’est effectuée et la méthode retourne `false`. Si des règles correspondantes sont trouvées, les indicateurs d’héritage et de compatibilité sont vérifiées pour la compatibilité avec les indicateurs spécifiés dans `rule`. Si aucune règle compatible n’est trouvée, aucune action n’est effectuée et la méthode retourne `false`. Si une règle avec des indicateurs compatibles est trouvée, les droits spécifiés dans `rule` sont supprimés de la règle compatible, et la méthode retourne `true`. Si `rule` spécifie des droits non contenus dans la règle compatible, aucune action n’est effectuée en ce qui concerne ces droits. Si tous les droits sont supprimés de la règle compatible, la règle entière est supprimée à partir du <xref:System.Security.AccessControl.MutexSecurity> objet.  
  
> [!IMPORTANT]
>  Bien que vous pouvez spécifier des indicateurs d’héritage et de propagation pour les règles d’accès de mutex, en les créant avec la <xref:System.Security.AccessControl.MutexSecurity.AccessRuleFactory%2A> méthode, cela n’est pas recommandée. L’héritage et la propagation n’ont aucune signification pour les mutex nommés et ils compliquent la maintenance des règles d’accès.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRule%2A> méthode pour supprimer des droits d’un <xref:System.Security.AccessControl.AccessControlType.Allow> de règles dans un <xref:System.Security.AccessControl.MutexSecurity> objet. Il montre également que les autres droits dans `rule` sont ignorés.  
  
 L’exemple crée un <xref:System.Security.AccessControl.MutexSecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel. Les droits accordés incluent <xref:System.Security.AccessControl.MutexRights.Modify>, <xref:System.Security.AccessControl.MutexRights.ReadPermissions>, et <xref:System.Security.AccessControl.MutexRights.Synchronize>. L’exemple crée ensuite une nouvelle règle pour l’utilisateur actuel, y compris <xref:System.Security.AccessControl.MutexRights.ReadPermissions> et <xref:System.Security.AccessControl.MutexRights.TakeOwnership> des droits, puis utilise cette règle avec la <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRule%2A> méthode pour supprimer <xref:System.Security.AccessControl.MutexRights.ReadPermissions> à partir de la <xref:System.Security.AccessControl.AccessControlType.Allow> de règle dans la <xref:System.Security.AccessControl.MutexSecurity> objet. Le texte superflu <xref:System.Security.AccessControl.MutexRights.TakeOwnership> avec le bouton droit dans `rule` est ignoré.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:System.Threading.Mutex> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> qui spécifie l'utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> à rechercher. Tous les droits spécifiés par cette règle sont ignorés.</param>
        <summary>Recherche toutes les règles de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle spécifiée et, s'il en existe, les supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En cours <xref:System.Security.AccessControl.MutexSecurity> règles qui ont le même utilisateur et le même objet est recherché <xref:System.Security.AccessControl.AccessControlType> valeur en tant que `rule`. Les droits spécifiés par `rule` sont ignorés lors de l’exécution de cette recherche. Si aucune règle correspondante n’est trouvée, aucune action n’est effectuée.  
  
   
  
## Examples  
 L’exemple de code suivant montre que le <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll%2A> méthode supprime toutes les règles qui correspondent à l’utilisateur et <xref:System.Security.AccessControl.AccessControlType>, en ignorant les droits.  
  
 L’exemple crée un <xref:System.Security.AccessControl.MutexSecurity> objet, ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel, puis fusionne les droits supplémentaires dans la <xref:System.Security.AccessControl.AccessControlType.Allow> règle. L’exemple crée ensuite une règle qui permet à l’utilisateur actuel s’approprier et utilise cette règle pour supprimer la <xref:System.Security.AccessControl.AccessControlType.Allow> de règles à partir de la <xref:System.Security.AccessControl.MutexSecurity> objet.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:System.Threading.Mutex> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> à supprimer.</param>
        <summary>Recherche une règle de contrôle d'accès qui correspond exactement à la règle spécifiée et, si une telle règle est trouvée, la supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La règle est supprimée uniquement si celle-ci correspond exactement à `rule` dans tous les détails, y compris les indicateurs. Autres règles ayant le même utilisateur et <xref:System.Security.AccessControl.AccessControlType> ne sont pas affectées.  
  
> [!IMPORTANT]
>  Une règle représente une ou plus sous-jacent entrées contrôle d’accès (ACE) et ces entrées sont combinées si nécessaire, lorsque vous modifiez les règles de sécurité d’accès pour un utilisateur. Par conséquent, une règle n’existe plus sous la forme qu’elle avait lorsqu’elle a été ajoutée et dans ce cas le <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> méthode ne peut pas le supprimer.  
  
   
  
## Examples  
 L’exemple de code suivant montre que le <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> méthode nécessite une correspondance exacte pour supprimer une règle, et que les règles pour autoriser et refuser des droits sont indépendantes les unes des autres.  
  
 L’exemple crée un <xref:System.Security.AccessControl.MutexSecurity> objet, ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel, puis fusionne les droits supplémentaires dans la <xref:System.Security.AccessControl.AccessControlType.Allow> règle d’accès. L’exemple passe ensuite l’original <xref:System.Security.AccessControl.AccessControlType.Allow> règle à la <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> (méthode) et affiche les résultats, qui montrent que rien n’est supprimé. L’exemple crée ensuite une règle qui correspond à la <xref:System.Security.AccessControl.AccessControlType.Allow> de règles dans le <xref:System.Security.AccessControl.MutexSecurity> objet, puis utilise la <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> méthode pour supprimer la règle.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:System.Threading.Mutex> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAuditRule(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As MutexAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> qui spécifie l'utilisateur à rechercher, ainsi qu'un jeu d'indicateurs d'héritage et de propagation avec lesquels une règle correspondante, si elle est trouvée, doit être compatible. Spécifie les droits à supprimer de la règle compatible, le cas échéant.</param>
        <summary>Recherche une règle de contrôle d'audit ayant le même utilisateur que la règle spécifiée et ayant des indicateurs d'héritage et de propagation compatibles ; si une règle compatible est trouvée, les droits contenus dans la règle spécifiée en sont supprimés.</summary>
        <returns>
          <see langword="true" /> si une règle compatible est trouvée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En cours <xref:System.Security.AccessControl.MutexSecurity> est recherché dans une règle d’audit ayant le même utilisateur que `rule`. Si aucune règle n’est trouvée, aucune action n’est effectuée et la méthode retourne `false`. Si des règles correspondantes sont trouvées, les indicateurs d’héritage et de compatibilité sont vérifiées pour la compatibilité avec les indicateurs spécifiés dans `rule`. Si aucune règle compatible n’est trouvée, aucune action n’est effectuée et la méthode retourne `false`. Si une règle avec des indicateurs compatibles est trouvée, les droits spécifiés dans `rule` sont supprimés de la règle compatible, et la méthode retourne `true`. Si `rule` spécifie des droits non contenus dans la règle compatible, aucune action n’est effectuée en ce qui concerne ces droits. Si tous les droits sont supprimés de la règle compatible, la règle entière est supprimée à partir du <xref:System.Security.AccessControl.MutexSecurity> objet.  
  
> [!IMPORTANT]
>  Bien que vous pouvez spécifier des indicateurs d’héritage et de propagation pour les règles d’audit de mutex, en les créant avec la <xref:System.Security.AccessControl.MutexSecurity.AccessRuleFactory%2A> méthode, cela n’est pas recommandée. L’héritage et la propagation n’ont aucune signification pour les mutex nommés et ils compliquent la maintenance des règles d’audit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAuditRuleAll(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> qui spécifie l'utilisateur à rechercher. Tous les droits spécifiés par cette règle sont ignorés.</param>
        <summary>Recherche toutes les règles d'audit ayant le même utilisateur que la règle spécifiée et, s'il en existe, les supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En cours <xref:System.Security.AccessControl.MutexSecurity> est recherchée dans les règles d’audit qui ont le même utilisateur que `rule`. Les droits spécifiés par `rule` sont ignorés lors de l’exécution de cette recherche. Toutes les règles correspondantes sont supprimées. Si aucune règle correspondante n’est trouvée, aucune action n’est effectuée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> à supprimer.</param>
        <summary>Recherche une règle d'audit qui correspond exactement à la règle spécifiée et, si une telle règle est trouvée, la supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La règle est supprimée uniquement si celle-ci correspond exactement à `rule` dans tous les détails, y compris les indicateurs. Autres règles d’audit pour le même utilisateur ne sont pas affectées.  
  
> [!IMPORTANT]
>  Une règle représente une ou plus sous-jacent entrées contrôle d’accès (ACE) et ces entrées sont combinées si nécessaire, lorsque vous modifiez les règles de sécurité d’audit pour un utilisateur. Par conséquent, une règle n’existe plus sous la forme qu’elle avait lorsqu’elle a été ajoutée et dans ce cas le <xref:System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific%2A> méthode ne peut pas le supprimer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.ResetAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> à ajouter. L'utilisateur spécifié par cette règle détermine les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles de contrôle d'accès ayant le même utilisateur que la règle spécifiée, indépendamment de <see cref="T:System.Security.AccessControl.AccessControlType" />, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucune règle d’accès dont l’utilisateur correspond à la règle spécifiée, `rule` est ajouté.  
  
   
  
## Examples  
 Le code suivant exemple montre comment la <xref:System.Security.AccessControl.MutexSecurity.ResetAccessRule%2A> méthode remplace toutes les règles de l’utilisateur correspondant à la règle de correspondance spécifiée.  
  
 L’exemple crée un <xref:System.Security.AccessControl.MutexSecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel. L’exemple crée ensuite une règle qui autorise l’utilisateur actuel un contrôle complet et utilise le <xref:System.Security.AccessControl.MutexSecurity.ResetAccessRule%2A> méthode pour remplacer les deux règles existantes avec la nouvelle règle.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:System.Threading.Mutex> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.SetAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> à ajouter. L'utilisateur et le <see cref="T:System.Security.AccessControl.AccessControlType" /> de cette règle déterminent les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle spécifiée, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la règle spécifiée a <xref:System.Security.AccessControl.AccessControlType.Allow>, l’effet de cette méthode consiste à supprimer tous les <xref:System.Security.AccessControl.AccessControlType.Allow> règles pour l’utilisateur spécifié, en les remplaçant par la règle spécifiée. Si la règle spécifiée a <xref:System.Security.AccessControl.AccessControlType.Deny>, tous les <xref:System.Security.AccessControl.AccessControlType.Deny> règles pour l’utilisateur spécifié sont remplacées par la règle spécifiée.  
  
 S’il en existe pas de règles dont l’utilisateur et <xref:System.Security.AccessControl.AccessControlType> correspond à la règle spécifiée, `rule` est ajouté.  
  
   
  
## Examples  
 Le code suivant montre d’exemple comment la <xref:System.Security.AccessControl.MutexSecurity.SetAccessRule%2A> méthode supprime toutes les règles qui correspondent à la fois à l’utilisateur et le <xref:System.Security.AccessControl.AccessControlType> de `rule`, en les remplaçant par `rule`.  
  
 L’exemple crée un <xref:System.Security.AccessControl.MutexSecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel. L’exemple crée ensuite une règle qui autorise l’utilisateur actuel un contrôle complet et utilise le <xref:System.Security.AccessControl.MutexSecurity.SetAccessRule%2A> règle avec la nouvelle règle d’autorisation pour remplacer la méthode. La règle qui refuse l’accès n’est pas affectée.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:System.Threading.Mutex> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.SetAuditRule(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> à ajouter. L'utilisateur spécifié par cette règle détermine les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles d'audit ayant le même utilisateur que la règle spécifiée, quelle que soit la valeur de <see cref="T:System.Security.AccessControl.AuditFlags" />, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucune règle d’audit dont l’utilisateur correspond à la règle spécifiée, `rule` est ajouté.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>