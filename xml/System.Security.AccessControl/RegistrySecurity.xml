<Type Name="RegistrySecurity" FullName="System.Security.AccessControl.RegistrySecurity">
  <Metadata><Meta Name="ms.openlocfilehash" Value="83a08bdb3dcd1015c17c86c1ba77c6ac1001351e" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52228091" /></Metadata><TypeSignature Language="C#" Value="public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistrySecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistrySecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistrySecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistrySecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type RegistrySecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente la sécurité du contrôle d'accès Windows d'une clé de Registre. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Security.AccessControl.RegistrySecurity> objet spécifie les droits d’accès pour une clé de Registre et spécifie également la façon dont les tentatives d’accès sont auditées. Droits d’accès à la clé de Registre sont exprimées sous forme de règles, chaque règle d’accès représenté par un <xref:System.Security.AccessControl.RegistryAccessRule> objet. Chaque règle d’audit est représenté par un <xref:System.Security.AccessControl.RegistryAuditRule> objet.  
  
 Cela reflète le système de sécurité Windows sous-jacent, dans lequel chaque objet sécurisable a au plus une liste discretionary access control (DACL) qui contrôle l’accès à l’objet sécurisé et au plus un accès contrôle liste système (SACL) qui spécifie les accès tentatives sont auditées. Le DACL et les SACL sont classés les listes d’entrées de contrôle d’accès (ACE) qui spécifient les accès et audit pour les utilisateurs et groupes. Un <xref:System.Security.AccessControl.RegistryAccessRule> ou <xref:System.Security.AccessControl.RegistryAuditRule> objet peut représenter plusieurs ACE.  
  
> [!NOTE]
>  Sécurité de contrôle d’accès Windows peut uniquement être appliquée aux clés de Registre. Il ne peut pas être appliqué aux paires clé/valeur individuelle stockées dans une clé.  
  
 Le <xref:System.Security.AccessControl.RegistrySecurity>, <xref:System.Security.AccessControl.RegistryAccessRule>, et <xref:System.Security.AccessControl.RegistryAuditRule> classes masquent les détails d’implémentation de l’ACL et les ACE. Ils permettent d’ignorer les différents types d’ACE dix-sept et la complexité du maintien correctement l’héritage et la propagation de droits d’accès. Ces objets sont également conçus pour empêcher les erreurs de contrôle d’accès courantes suivantes :  
  
-   Création d’un descripteur de sécurité avec une liste DACL null. Une référence null à une liste DACL permet à tout utilisateur à ajouter des règles d’accès à un objet, créant potentiellement une attaque par déni de service. Un nouveau <xref:System.Security.AccessControl.RegistrySecurity> objet commence toujours par une liste DACL vide, ce qui refuse tout accès à tous les utilisateurs.  
  
-   Violation de l’ordre canonique d’ACE. Si la liste ACE dans la liste DACL n’est pas conservée dans l’ordre canonique, les utilisateurs peuvent par inadvertance un accès à l’objet sécurisé. Par exemple, les droits d’accès refusé doivent toujours apparaître avant des droits d’accès autorisés. <xref:System.Security.AccessControl.RegistrySecurity> objets conservent l’ordre correct en interne.  
  
-   Manipulation des indicateurs de descripteurs de sécurité, qui doivent être sous le contrôle de gestionnaire de ressources uniquement.  
  
-   Création de combinaisons non valides d’indicateurs d’ACE.  
  
-   Manipulation des ACE héritées. Héritage et propagation sont gérés par le Gestionnaire de ressources, en réponse aux modifications apportées aux règles d’accès et d’audit.  
  
-   Insertion ACE dénuée de sens dans les ACL.  
  
 Les seules fonctionnalités non prises en charge par les objets de sécurité .NET sont des activités dangereuses doivent être évitées par la majorité des développeurs d’applications, telles que les éléments suivants :  
  
-   Tâches de bas niveau qui sont normalement effectuées par le Gestionnaire de ressources.  
  
-   Ajout ou suppression des entrées de contrôle d’accès de manière à ne conserve pas l’ordre canonique.  
  
 Pour modifier la sécurité de contrôle d’accès Windows pour une clé de Registre, utilisez la <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> méthode pour obtenir le <xref:System.Security.AccessControl.RegistrySecurity> objet. Modifier l’objet de sécurité en ajoutant et supprimant des règles et ensuite utiliser le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> méthode pour le rattacher.  
  
> [!IMPORTANT]
>  Modifications apportées à un <xref:System.Security.AccessControl.RegistrySecurity> objet n’affectent pas les niveaux d’accès de la clé de Registre jusqu'à ce que vous appeliez la <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> méthode pour attribuer l’objet de sécurité modifié à la clé de Registre.  
  
 Pour copier la sécurité de contrôle d’accès à partir d’une clé de Registre à un autre, utilisez la <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> méthode pour obtenir un <xref:System.Security.AccessControl.RegistrySecurity> représentant les règles d’accès et d’audit pour la première clé de Registre de l’objet et comment utiliser le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> méthode pour attribuer ces règles à la deuxième clé de Registre. Vous pouvez également affecter les règles à une deuxième clé de Registre avec une <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=nameWithType> ou <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=nameWithType> méthode qui prend un <xref:System.Security.AccessControl.RegistrySecurity> paramètre d’objet.  
  
 Les utilisateurs avec un investissement dans le langage de définition de descripteur de sécurité (SDDL) peuvent utiliser le <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> méthode pour définir des règles d’accès pour une clé de Registre et le <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> méthode pour obtenir une chaîne qui représente les règles d’accès au format SDDL. Cela n’est pas recommandé pour un nouveau développement.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre comment compatible de fusion de règles lorsque ajoutés et supprimés et le second illustre comment les indicateurs d’héritage et de propagation affectent l’ajout et la suppression de règles.  
  
 Exemple 1  
  
 Le code suivant montre l’exemple comment la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode supprime les droits à partir d’une règle compatible et comment la <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> méthode fusionne des droits avec les règles compatibles.  
  
 L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet et ajoute une règle qui autorise l’utilisateur actuel <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> droits. L’exemple crée ensuite une règle qui accorde à l’utilisateur <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, avec le même héritage et les droits de la propagation, ainsi que la première règle utilise le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode pour supprimer cette nouvelle règle à partir de la <xref:System.Security.AccessControl.RegistrySecurity> objet. <xref:System.Security.AccessControl.RegistryRights.SetValue> est un composant de <xref:System.Security.AccessControl.RegistryRights.ReadKey>, donc il est supprimé de la règle compatible. Les règles dans le <xref:System.Security.AccessControl.RegistrySecurity> objet s’affichent, présentent les composants restants du <xref:System.Security.AccessControl.RegistryRights.ReadKey>.  
  
 L’exemple de code appelle ensuite la <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> méthode pour fusionner le <xref:System.Security.AccessControl.RegistryRights.SetValue> avec le bouton droit dans la règle dans le <xref:System.Security.AccessControl.RegistrySecurity> objet.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Le deuxième exemple dans cette section attache un objet de sécurité, et comme les exemples de <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> et <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 Exemple 2  
  
 L’exemple de code suivant montre les règles d’accès avec héritage et de propagation. L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet, puis crée et ajoute deux règles qui ont le <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> indicateur. La première règle n’a aucun indicateur de propagation, tandis que la seconde a <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> et <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>.  
  
 Le programme affiche les règles dans le <xref:System.Security.AccessControl.RegistrySecurity> objet, puis utilise le <xref:System.Security.AccessControl.RegistrySecurity> objet à créer une sous-clé. Le programme crée un enfant de sous-clés et un petit-enfant, puis affiche la sécurité de chaque sous-clé. Enfin, le programme supprime les clés de test.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistrySecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistrySecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> avec des valeurs par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nouveau <xref:System.Security.AccessControl.RegistrySecurity> objet commence toujours par une liste vide accès discrétionnaire (DACL), qui refuse tout accès à tous les utilisateurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type d'énumération utilisé par la classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> pour représenter des droits d'accès.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant l'énumération <see cref="T:System.Security.AccessControl.RegistryRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de la <xref:System.Security.AccessControl.ObjectSecurity> classe remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> propriété et retournent le type qu’ils utilisent pour représenter des droits d’accès. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type d’énumération correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="registrySecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference"><see cref="T:System.Security.Principal.IdentityReference" /> qui identifie l'utilisateur ou le groupe auquel s'applique la règle.</param>
        <param name="accessMask">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.RegistryRights" /> qui spécifient les droits d'accès à accorder ou refuser, castés en entier.</param>
        <param name="isInherited">Valeur booléenne spécifiant si la règle est héritée.</param>
        <param name="inheritanceFlags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.InheritanceFlags" /> spécifiant la façon dont les sous-clés héritent de la règle.</param>
        <param name="propagationFlags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.PropagationFlags" /> qui modifient la façon dont les sous-clés héritent de la règle. Sans utilité si la valeur de <paramref name="inheritanceFlags" /> est <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="type">Une des valeurs <see cref="T:System.Security.AccessControl.AccessControlType" /> spécifiant si les droits sont accordés ou refusés.</param>
        <summary>Crée une règle de contrôle d'accès pour l'utilisateur spécifié, avec les droits d'accès, le contrôle d'accès et les indicateurs spécifiés.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> représentant les droits spécifiés pour l'utilisateur spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode recommandée pour créer des règles de contrôle d’accès consiste à utiliser les constructeurs de la <xref:System.Security.AccessControl.RegistryAccessRule> classe.  
  
> [!NOTE]
>  Bien que vous puissiez spécifier le <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> indicateur, il est inutile lors de cette opération. Dans le cadre du contrôle d’accès, les paires nom/valeur dans une sous-clé ne sont pas des objets distincts. Les droits d’accès pour les paires nom/valeur sont contrôlés par les droits de la sous-clé. En outre, étant donné que toutes les sous-clés sont des conteneurs (autrement dit, ils peuvent contenir d’autres sous-clés), elles ne sont pas affectées par la <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> indicateur. Enfin, en spécifiant le <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> indicateur complique inutilement la maintenance des règles, car il interfère avec la combinaison normale de règles compatibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> ou <paramref name="type" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identityReference" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="accessMask" /> est égal à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" /> n'est ni du type <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni d'un type tel que <see cref="T:System.Security.Principal.NTAccount" /> qui peut être converti en type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type utilisé par la classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> pour représenter des règles d'accès.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant la classe <see cref="T:System.Security.AccessControl.RegistryAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de la <xref:System.Security.AccessControl.ObjectSecurity> classe remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> propriété et retournent le type qu’ils utilisent pour représenter des règles d’accès. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type de règle d’accès correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle de contrôle d'accès à ajouter.</param>
        <summary>Recherche une règle de contrôle d'accès correspondante avec laquelle la nouvelle règle peut être fusionnée. Ajoute la nouvelle règle en cas de recherche infructueuse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> méthode recherche des règles avec le même utilisateur ou groupe et le même <xref:System.Security.AccessControl.AccessControlType> comme `rule`. Si aucune n’est trouvée, `rule` est ajouté. Si une règle de correspondance est trouvée, les droits dans `rule` sont fusionnés avec la règle existante.  
  
 Règles ne peut pas être fusionnées si elles ont des indicateurs d’héritage différents. Par exemple, si un utilisateur a un accès en lecture sans indicateurs d’héritage, et <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> est utilisé pour ajouter une règle donnant l’accès en écriture utilisateur avec héritage de sous-clés (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), les deux règles ne peuvent pas être fusionnées.  
  
 Règles avec différents <xref:System.Security.AccessControl.AccessControlType> valeurs ne sont jamais fusionnées.  
  
 Règles expriment les droits de la façon la plus économique. Par exemple, si un utilisateur a <xref:System.Security.AccessControl.RegistryRights.QueryValues>, <xref:System.Security.AccessControl.RegistryRights.Notify> et <xref:System.Security.AccessControl.RegistryRights.ReadPermissions> droits et que vous ajoutez une règle autorisant <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> droits, l’utilisateur a tous les éléments constitutifs de <xref:System.Security.AccessControl.RegistryRights.ReadKey> droits. Si vous interrogez les droits d’utilisateur, vous verrez une règle contenant <xref:System.Security.AccessControl.RegistryRights.ReadKey> droits. De même, si vous supprimez <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> des droits, les autres composants des <xref:System.Security.AccessControl.RegistryRights.ReadKey> droits réapparaît.  
  
   
  
## Examples  
 L’exemple de code suivant crée des règles d’accès de Registre et les ajoute à un <xref:System.Security.AccessControl.RegistrySecurity> objet, en montrant comment les règles qui autorisent et refusent des droits restent séparées, lors des règles compatibles du même type est fusionnée.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> et <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 Vous trouverez un exemple de code illustrant les indicateurs d’héritage et de propagation dans le <xref:System.Security.AccessControl.RegistryAccessRule> classe.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’audit à ajouter. L'utilisateur spécifié par cette règle détermine la recherche.</param>
        <summary>Recherche une règle d'audit avec laquelle la nouvelle règle peut être fusionnée. Ajoute la nouvelle règle en cas de recherche infructueuse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> recherches de méthode pour les règles avec le même utilisateur ou groupe en tant que `rule`. Si aucune n’est trouvée, `rule` est ajouté. Si une règle de correspondance est trouvée, les indicateurs dans `rule` sont fusionnées dans la règle existante.  
  
 Règles ne peut pas être fusionnées si elles ont des indicateurs d’héritage différents. Par exemple, en cas d’échec des tentatives d’écriture à une clé sont audités pour un utilisateur particulier, sans indicateurs d’héritage, et <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> est utilisée pour ajouter une règle qui spécifie que les tentatives ayant échoué pour modifier les autorisations sont vérifiés pour le même utilisateur, mais avec l’héritage pour sous-clés (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), les deux règles ne peuvent pas être fusionnées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="registrySecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference"><see cref="T:System.Security.Principal.IdentityReference" /> qui identifie l'utilisateur ou le groupe auquel s'applique la règle.</param>
        <param name="accessMask">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.RegistryRights" /> spécifiant les droits d'accès à auditer, castés en entier.</param>
        <param name="isInherited">Valeur booléenne spécifiant si la règle est héritée.</param>
        <param name="inheritanceFlags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.InheritanceFlags" /> spécifiant la façon dont les sous-clés héritent de la règle.</param>
        <param name="propagationFlags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.PropagationFlags" /> qui modifient la façon dont les sous-clés héritent de la règle. Sans utilité si la valeur de <paramref name="inheritanceFlags" /> est <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="flags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.AuditFlags" /> spécifiant s'il faut auditer les accès réussis, les échecs d'accès ou les deux.</param>
        <summary>Crée une règle d'audit, en spécifiant l'utilisateur auquel elle s'applique, les droits d'accès à auditer, l'héritage et la propagation de la règle, ainsi que le résultat qui déclenche la règle.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> représentant la règle d'audit spécifiée, pour l'utilisateur spécifié, avec les indicateurs spécifiés. Le type de retour de la méthode est la classe de base, <see cref="T:System.Security.AccessControl.AuditRule" />, mais la valeur de retour peut être castée sans risque en classe dérivée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode recommandée pour créer des règles d’audit consiste à utiliser les constructeurs de la <xref:System.Security.AccessControl.RegistryAuditRule> classe.  
  
> [!NOTE]
>  Bien que vous puissiez spécifier le <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> indicateur, il est inutile lors de cette opération. Dans le cadre du contrôle d’audit, les paires nom/valeur dans une sous-clé ne sont pas des objets distincts. Les droits d’audit pour les paires nom/valeur sont contrôlés par les droits de la sous-clé. En outre, étant donné que toutes les sous-clés sont des conteneurs (autrement dit, ils peuvent contenir d’autres sous-clés), elles ne sont pas affectées par la <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> indicateur. Enfin, en spécifiant le <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> indicateur complique inutilement la maintenance des règles, car il interfère avec la combinaison normale de règles compatibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> ou <paramref name="flags" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identityReference" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="accessMask" /> est égal à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" /> n'est ni du type <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni d'un type tel que <see cref="T:System.Security.Principal.NTAccount" /> qui peut être converti en type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type utilisé par la classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> pour représenter des règles d'audit.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant la classe <see cref="T:System.Security.AccessControl.RegistryAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de la <xref:System.Security.AccessControl.ObjectSecurity> classe remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> propriété et retournent le type qu’ils utilisent pour représenter des droits d’audit. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type de règle d’audit correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As RegistryAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; bool" Usage="registrySecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAccessRule" /> qui spécifie l'utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> à rechercher, ainsi qu'un jeu d'indicateurs d'héritage et de propagation avec lesquels une règle correspondante, si elle est trouvée, doit être compatible. Spécifie les droits à supprimer de la règle compatible, le cas échéant.</param>
        <summary>Recherche une règle de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle d'accès spécifiée et ayant des indicateurs d'héritage et de propagation compatibles ; si une telle règle est trouvée, les droits contenus dans la règle d'accès spécifiée en sont supprimés.</summary>
        <returns><see langword="true" /> si une règle compatible est trouvée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Security.AccessControl.RegistrySecurity> est recherché dans une règle qui a le même utilisateur et le même <xref:System.Security.AccessControl.AccessControlType> valeur sous la forme `rule`. Si aucune règle n’est trouvée, aucune action n’est effectuée, et la méthode retourne `false`. Si les règles de correspondance sont trouvées, les indicateurs d’héritage et de compatibilité sont activés pour la compatibilité avec les indicateurs spécifiés dans `rule`. Si aucune règle compatible n’est trouvée, aucune action n’est effectuée, et la méthode retourne `false`. Si une règle avec des indicateurs compatibles est trouvée, les droits spécifiés dans `rule` sont supprimés de la règle compatible, et la méthode retourne `true`. Si `rule` spécifie les droits non contenus dans la règle compatible, aucune action n’est effectuée en ce qui concerne ces droits. Si tous les droits sont supprimés de la règle compatible, la règle entière est supprimée à partir du <xref:System.Security.AccessControl.RegistrySecurity> objet.  
  
   
  
## Examples  
 Le code suivant montre l’exemple comment la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode supprime les droits à partir d’une règle compatible et comment la <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> méthode fusionne des droits avec les règles compatibles.  
  
 L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet et ajoute une règle qui autorise l’utilisateur actuel <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> droits. L’exemple crée ensuite une règle qui accorde à l’utilisateur <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, avec le même héritage et les droits de la propagation, ainsi que la première règle utilise le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode pour supprimer cette nouvelle règle à partir de la <xref:System.Security.AccessControl.RegistrySecurity> objet. <xref:System.Security.AccessControl.RegistryRights.SetValue> est un composant de <xref:System.Security.AccessControl.RegistryRights.ReadKey>, donc il est supprimé de la règle compatible. Les règles dans le <xref:System.Security.AccessControl.RegistrySecurity> objet s’affichent, présentent les composants restants du <xref:System.Security.AccessControl.RegistryRights.ReadKey>.  
  
 L’exemple de code appelle ensuite la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode pour fusionner le <xref:System.Security.AccessControl.RegistryRights.SetValue> avec le bouton droit dans la règle dans le <xref:System.Security.AccessControl.RegistrySecurity> objet.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Le deuxième exemple dans cette section attache un objet de sécurité, et comme les exemples de <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleAll : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAccessRule" /> qui spécifie l'utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> à rechercher. Les droits et les indicateurs d'héritage ou de propagation spécifiés par cette règle sont ignorés.</param>
        <summary>Recherche toutes les règles de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle spécifiée et, s'il en existe, les supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Security.AccessControl.RegistrySecurity> recherche est effectuée pour les règles qui ont le même utilisateur et la même <xref:System.Security.AccessControl.AccessControlType> valeur sous la forme `rule`. Des droits, les indicateurs d’héritage ou les indicateurs de propagation spécifiés par `rule` sont ignorés lors de l’exécution de cette recherche. Si aucune règle correspondante n’est trouvée, aucune action n’est effectuée.  
  
 Par exemple, si un utilisateur dispose de plusieurs règles qui permettent de divers droits avec différents indicateurs d’héritage et la propagation, vous pouvez supprimer toutes ces règles en créant un <xref:System.Security.AccessControl.RegistryAccessRule> objet qui spécifie l’utilisateur et <xref:System.Security.AccessControl.AccessControlType.Allow?displayProperty=nameWithType>, avec les droits arbitraires et les indicateurs, et en passant cette règle à la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre que le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> méthode supprime toutes les règles qui correspondent à l’utilisateur et <xref:System.Security.AccessControl.AccessControlType>, en ignorant les droits et les indicateurs.  
  
 L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel, avec différents indicateurs d’héritage et de propagation. L’exemple crée ensuite une nouvelle règle qui autorise l’utilisateur actuel s’approprier et passe cette règle à la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> méthode pour supprimer les deux règles qui autorisent l’accès.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Consultez le <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (méthode) et le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleSpecific : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAccessRule" /> à supprimer.</param>
        <summary>Recherche une règle de contrôle d'accès qui correspond exactement à la règle spécifiée et, si une telle règle est trouvée, la supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La règle est supprimée uniquement si celle-ci correspond exactement à `rule` dans tous les détails, y compris les indicateurs. Autres règles ayant les mêmes utilisateur et <xref:System.Security.AccessControl.AccessControlType> ne sont pas affectées.  
  
> [!IMPORTANT]
>  Une règle représente une ou plus sous-jacent entrées contrôle d’accès (ACE) et ces entrées sont combinées en fonction des besoins lorsque vous modifiez les règles de sécurité d’accès pour un utilisateur. Par conséquent, une règle n’existe plus dans le formulaire spécifique qu’elle avait lorsqu’il a été ajouté et dans ce cas le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> méthode ne peut pas le supprimer.  
  
   
  
## Examples  
 L’exemple de code suivant montre que le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> méthode supprime une règle uniquement si elle correspond à exactement.  
  
 L’exemple crée deux règles qui accordent des droits différents. Les règles ont des indicateurs d’héritage et de propagation compatibles, donc lors de l’ajout de la deuxième règle il fusionne avec la première. L’exemple appelle la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> méthode, en spécifiant la première règle, mais étant donné que les règles sont fusionnées il n’existe aucune règle correspondant. L’exemple appelle ensuite la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode pour supprimer la deuxième règle à partir de la règle fusionnée et enfin appelle le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> méthode pour supprimer la première règle.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Consultez le <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (méthode) et le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As RegistryAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; bool" Usage="registrySecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAuditRule" /> qui spécifie l'utilisateur à rechercher, ainsi qu'un jeu d'indicateurs d'héritage et de propagation avec lesquels une règle correspondante, si elle est trouvée, doit être compatible. Spécifie les droits à supprimer de la règle compatible, le cas échéant.</param>
        <summary>Recherche une règle de contrôle d'audit ayant le même utilisateur que la règle spécifiée et ayant des indicateurs d'héritage et de propagation compatibles ; si une règle compatible est trouvée, les droits contenus dans la règle spécifiée en sont supprimés.</summary>
        <returns><see langword="true" /> si une règle compatible est trouvée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Security.AccessControl.RegistrySecurity> est recherché dans une règle d’audit ayant le même utilisateur que `rule`. Si aucune règle n’est trouvée, aucune action n’est effectuée, et la méthode retourne `false`. Si les règles de correspondance sont trouvées, les indicateurs d’héritage et de compatibilité sont activés pour la compatibilité avec les indicateurs spécifiés dans `rule`. Si aucune règle compatible n’est trouvée, aucune action n’est effectuée, et la méthode retourne `false`. Si une règle avec des indicateurs compatibles est trouvée, les droits spécifiés dans `rule` sont supprimés de la règle compatible, et la méthode retourne `true`. Si `rule` spécifie les droits non contenus dans la règle compatible, aucune action n’est effectuée en ce qui concerne ces droits. Si tous les droits sont supprimés de la règle compatible, la règle entière est supprimée à partir du <xref:System.Security.AccessControl.RegistrySecurity> objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleAll : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAuditRule" /> qui spécifie l'utilisateur à rechercher. Les droits et les indicateurs d'héritage ou de propagation spécifiés par cette règle sont ignorés.</param>
        <summary>Recherche toutes les règles d'audit ayant le même utilisateur que la règle spécifiée et, s'il en existe, les supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Security.AccessControl.RegistrySecurity> est recherchée dans les règles d’audit ayant le même utilisateur que `rule`. Des droits, les indicateurs d’héritage ou les indicateurs de propagation spécifiés par `rule` sont ignorés lors de l’exécution de cette recherche. Si aucune règle correspondante n’est trouvée, aucune action n’est effectuée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleSpecific : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAuditRule" /> à supprimer.</param>
        <summary>Recherche une règle d'audit qui correspond exactement à la règle spécifiée et, si une telle règle est trouvée, la supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La règle est supprimée uniquement si celle-ci correspond exactement à `rule` dans tous les détails, y compris les indicateurs. Autres règles d’audit pour le même utilisateur ne sont pas affectés.  
  
> [!IMPORTANT]
>  Une règle représente une ou plus sous-jacent entrées contrôle d’accès (ACE) et ces entrées sont combinées en fonction des besoins lorsque vous modifiez les règles de sécurité d’audit pour un utilisateur. Par conséquent, une règle n’existe plus dans le formulaire spécifique qu’elle avait lorsqu’il a été ajouté et dans ce cas le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific%2A> méthode ne peut pas le supprimer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.ResetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAccessRule" /> à ajouter. L'utilisateur spécifié par cette règle détermine les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles de contrôle d'accès ayant le même utilisateur que la règle spécifiée, indépendamment de <see cref="T:System.Security.AccessControl.AccessControlType" />, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucune règle d’accès dont l’utilisateur correspond à la règle spécifiée, `rule` est ajouté.  
  
   
  
## Examples  
 Le code suivant montre l’exemple comment la <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> méthode remplace toutes les règles de l’utilisateur correspondant à la règle de correspondance spécifiée.  
  
 L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel, avec différents indicateurs d’héritage et de propagation. L’exemple crée ensuite une nouvelle règle qui autorise l’utilisateur actuel uniquement lire la clé et utilise le <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> méthode pour supprimer toutes les règles de l’utilisateur et les remplacer par la nouvelle règle.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Consultez le <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (méthode) et le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAccessRule" /> à ajouter. L'utilisateur et le <see cref="T:System.Security.AccessControl.AccessControlType" /> de cette règle déterminent les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle spécifiée, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la règle spécifiée a <xref:System.Security.AccessControl.AccessControlType.Allow>, l’effet de cette méthode consiste à supprimer tous les <xref:System.Security.AccessControl.AccessControlType.Allow> règles pour l’utilisateur spécifié, en les remplaçant par la règle spécifiée. Si la règle spécifiée a <xref:System.Security.AccessControl.AccessControlType.Deny>, tous les <xref:System.Security.AccessControl.AccessControlType.Deny> règles pour l’utilisateur spécifié sont remplacées par la règle spécifiée.  
  
 S’il n’existe aucune règle dont l’utilisateur et <xref:System.Security.AccessControl.AccessControlType> correspondent à la règle spécifiée, `rule` est ajouté.  
  
   
  
## Examples  
 L’exemple de code suivant montre que le <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> méthode supprime toutes les règles qui correspondent à la fois à l’utilisateur et le <xref:System.Security.AccessControl.AccessControlType> de `rule`, en ignorant les droits et les indicateurs et les remplace par `rule`.  
  
 L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel, avec différents indicateurs d’héritage et de propagation. L’exemple crée ensuite une nouvelle règle qui autorise l’utilisateur actuel uniquement lire la clé et utilise le <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> méthode pour supprimer les deux règles qui autorisent l’accès et les remplacer par la nouvelle règle. La règle qui refuse l’accès n’est pas affectée.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Consultez le <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (méthode) et le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAuditRule" /> à ajouter. L'utilisateur spécifié par cette règle détermine les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles d'audit ayant le même utilisateur que la règle spécifiée, quelle que soit la valeur de <see cref="T:System.Security.AccessControl.AuditFlags" />, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucune règle d’audit dont l’utilisateur correspond à la règle spécifiée, `rule` est ajouté.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>