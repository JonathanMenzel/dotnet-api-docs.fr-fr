<Type Name="RegistrySecurity" FullName="System.Security.AccessControl.RegistrySecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e52f3b248c05ba047d59c24d923733a12bfa7839" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30490733" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistrySecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistrySecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistrySecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistrySecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente la sécurité du contrôle d'accès Windows d'une clé de Registre. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Security.AccessControl.RegistrySecurity> objet spécifie les droits d’accès d’une clé de Registre et qu’il spécifie également la manière dont les tentatives d’accès sont auditées. Droits d’accès à la clé de Registre sont exprimées sous forme de règles, chaque règle d’accès représenté par un <xref:System.Security.AccessControl.RegistryAccessRule> objet. Chaque règle d’audit est représentée par un <xref:System.Security.AccessControl.RegistryAuditRule> objet.  
  
 Cela reflète le système de sécurité Windows sous-jacent, dans lequel chaque objet sécurisable a au plus une liste discretionary access control (DACL) qui contrôle l’accès à l’objet sécurisé et au plus un système liste contrôle d’accès (SACL) qui spécifie les accès les tentatives sont auditées. La liste DACL et SACL sont les listes ordonnées d’entrées de contrôle d’accès (ACE) qui spécifient les accès et audit pour les utilisateurs et groupes. A <xref:System.Security.AccessControl.RegistryAccessRule> ou <xref:System.Security.AccessControl.RegistryAuditRule> objet peut représenter plusieurs ACE.  
  
> [!NOTE]
>  Sécurité de contrôle d’accès Windows peut être appliquée uniquement aux clés de Registre. Il ne peut pas être appliqué aux paires clé/valeur stockées dans une clé.  
  
 Le <xref:System.Security.AccessControl.RegistrySecurity>, <xref:System.Security.AccessControl.RegistryAccessRule>, et <xref:System.Security.AccessControl.RegistryAuditRule> classes masquent les détails d’implémentation des ACL et des entrées. Ils permettent d’ignorer les différents types d’ACE dix-sept et la complexité de la maintenance d’héritage et la propagation de droits d’accès. Ces objets sont également conçues pour éviter les erreurs de contrôle d’accès courantes suivantes :  
  
-   Création d’un descripteur de sécurité avec une liste DACL null. Une référence null à une liste DACL permet à tout utilisateur d’ajouter des règles d’accès à un objet, qui crée une attaque par déni de service. Un nouveau <xref:System.Security.AccessControl.RegistrySecurity> objet commence toujours par une liste DACL vide, ce qui refuse tout accès à tous les utilisateurs.  
  
-   Violation de l’ordre canonique d’ACE. Si la liste ACE dans la liste DACL n’est pas conservée dans l’ordre canonique, les utilisateurs peuvent par inadvertance données accès à l’objet sécurisé. Par exemple, des droits d’accès refusé doivent toujours apparaître avant droits d’accès autorisés. <xref:System.Security.AccessControl.RegistrySecurity> objets conservent l’ordre correct en interne.  
  
-   Manipulation des indicateurs de descripteurs de sécurité, qui doivent se trouver sous le contrôle de gestionnaire de ressources uniquement.  
  
-   Création de combinaisons non valides d’indicateurs ACE.  
  
-   La manipulation de héritées. Héritage et propagation sont gérés par le Gestionnaire de ressources, en réponse aux modifications apportées aux règles d’accès et d’audit.  
  
-   L’insertion sans signification ACE dans l’ACL.  
  
 Les seules fonctionnalités non prises en charge par les objets de sécurité .NET sont des activités dangereuses qui doivent être évitées par la majorité des développeurs d’applications, telles que les éléments suivants :  
  
-   Tâches de bas niveau qui sont normalement effectuées par le Gestionnaire de ressources.  
  
-   Ajout ou suppression d’entrées de contrôle d’accès d’une manière qui ne conserve pas l’ordre canonique.  
  
 Pour modifier la sécurité de contrôle d’accès Windows pour une clé de Registre, utilisez la <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> méthode pour obtenir le <xref:System.Security.AccessControl.RegistrySecurity> objet. Modifier l’objet de sécurité en ajoutant et supprimant des règles et ensuite utiliser le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> méthode pour le rattacher.  
  
> [!IMPORTANT]
>  Modifications apportées à un <xref:System.Security.AccessControl.RegistrySecurity> objet n’affectent pas les niveaux d’accès de la clé de Registre jusqu'à ce que vous appeliez la <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> méthode pour attribuer l’objet de sécurité modifié à la clé de Registre.  
  
 Pour copier la sécurité de contrôle d’accès à partir d’une clé de Registre à l’autre, utilisez la <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> méthode pour obtenir un <xref:System.Security.AccessControl.RegistrySecurity> représentant les règles d’accès et d’audit pour la première clé de Registre de l’objet, puis utilisez le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> méthode pour attribuer ces règles à la deuxième clé de Registre. Vous pouvez également assigner les règles à une deuxième clé de Registre avec une <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=nameWithType> ou <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=nameWithType> méthode qui accepte un <xref:System.Security.AccessControl.RegistrySecurity> paramètre d’objet.  
  
 Les utilisateurs avec un investissement dans le langage de définition de descripteur de sécurité (SDDL) peuvent utiliser le <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> pour définir des règles d’accès pour une clé de Registre et les <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> méthode pour obtenir une chaîne qui représente les règles d’accès au format SDDL. Cela n’est pas recommandé pour un nouveau développement.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre comment compatible de fusion de règles lorsque ajoutés et supprimés et le second illustre comment les indicateurs d’héritage et de propagation affectent l’ajout et la suppression de règles.  
  
 Exemple 1  
  
 Le code suivant montre d’exemple comment la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode supprime les droits à partir d’une règle compatible et comment la <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> méthode fusionne des droits avec les règles compatibles.  
  
 L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet et ajoute une règle qui autorise l’utilisateur actuel <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> droits. L’exemple crée ensuite une règle qui accorde à l’utilisateur <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>avec le même héritage et les droits de propagation que la première règle et utilise le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode pour supprimer cette nouvelle règle de la <xref:System.Security.AccessControl.RegistrySecurity> objet. <xref:System.Security.AccessControl.RegistryRights.SetValue> est un composant de <xref:System.Security.AccessControl.RegistryRights.ReadKey>par conséquent, il est supprimé de la règle compatible. Les règles dans le <xref:System.Security.AccessControl.RegistrySecurity> objet s’affichent, présentent les composants restants du <xref:System.Security.AccessControl.RegistryRights.ReadKey>.  
  
 L’exemple de code appelle ensuite la <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> méthode pour fusionner le <xref:System.Security.AccessControl.RegistryRights.SetValue> avec le bouton droit dans la règle de la <xref:System.Security.AccessControl.RegistrySecurity> objet.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Le deuxième exemple de cette section attache un objet de sécurité, et comme les exemples de <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> et <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 Exemple 2  
  
 L’exemple de code suivant illustre les règles d’accès avec héritage et de propagation. L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet, puis crée et ajoute deux règles qui ont le <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> indicateur. La première règle ne comporte aucun indicateur de propagation, tandis que la seconde a <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> et <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>.  
  
 Le programme affiche les règles de la <xref:System.Security.AccessControl.RegistrySecurity> objet, puis utilise le <xref:System.Security.AccessControl.RegistrySecurity> objet pour créer une sous-clé. Le programme crée un enfant de sous-clés et un petit-enfant, puis affiche la sécurité de chaque sous-clé. Enfin, le programme supprime les clés de test.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistrySecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistrySecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> avec des valeurs par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nouveau <xref:System.Security.AccessControl.RegistrySecurity> objet commence toujours par une liste vide accès discrétionnaire (DACL), ce qui refuse tout accès à tous les utilisateurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type d'énumération utilisé par la classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> pour représenter des droits d'accès.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant l'énumération <see cref="T:System.Security.AccessControl.RegistryRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes dérivées de la <xref:System.Security.AccessControl.ObjectSecurity> classe de remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> propriété et retourner le type qu’elles utilisent pour représenter des droits d’accès. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type d’énumération correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <see cref="T:System.Security.Principal.IdentityReference" /> qui identifie l'utilisateur ou le groupe auquel s'applique la règle.</param>
        <param name="accessMask">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.RegistryRights" /> qui spécifient les droits d'accès à accorder ou refuser, castés en entier.</param>
        <param name="isInherited">Valeur booléenne spécifiant si la règle est héritée.</param>
        <param name="inheritanceFlags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.InheritanceFlags" /> spécifiant la façon dont les sous-clés héritent de la règle.</param>
        <param name="propagationFlags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.PropagationFlags" /> qui modifient la façon dont les sous-clés héritent de la règle. Sans utilité si la valeur de <c>inheritanceFlags</c> est <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="type">Une des valeurs <see cref="T:System.Security.AccessControl.AccessControlType" /> spécifiant si les droits sont accordés ou refusés.</param>
        <summary>Crée une règle de contrôle d'accès pour l'utilisateur spécifié, avec les droits d'accès, le contrôle d'accès et les indicateurs spécifiés.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> représentant les droits spécifiés pour l'utilisateur spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode recommandée pour créer des règles de contrôle d’accès est d’utiliser les constructeurs de la <xref:System.Security.AccessControl.RegistryAccessRule> classe.  
  
> [!NOTE]
>  Bien que vous puissiez spécifier le <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> indicateur, il est inutile de faire. Dans le cadre du contrôle d’accès, les paires nom/valeur d’une sous-clé ne sont pas des objets distincts. Les droits d’accès pour les paires nom/valeur sont contrôlés par les droits de la sous-clé. En outre, étant donné que toutes les sous-clés sont des conteneurs (autrement dit, ils peuvent contenir d’autres sous-clés), elles ne sont pas affectées par la <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> indicateur. Enfin, en spécifiant le <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> indicateur complique inutilement la maintenance des règles, parce qu’il interfère avec la combinaison normale de règles compatibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> ou <paramref name="type" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="accessMask" /> est égal à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> n'est ni du type <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni d'un type tel que <see cref="T:System.Security.Principal.NTAccount" /> qui peut être converti en type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type utilisé par la classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> pour représenter des règles d'accès.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant la classe <see cref="T:System.Security.AccessControl.RegistryAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes dérivées de la <xref:System.Security.AccessControl.ObjectSecurity> classe de remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> propriété et retourner le type qu’elles utilisent pour représenter des règles d’accès. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type de règle d’accès correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle de contrôle d'accès à ajouter.</param>
        <summary>Recherche une règle de contrôle d'accès correspondante avec laquelle la nouvelle règle peut être fusionnée. Ajoute la nouvelle règle en cas de recherche infructueuse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> méthode recherche des règles ayant le même utilisateur ou groupe et le même <xref:System.Security.AccessControl.AccessControlType> comme `rule`. Si aucune n’est trouvée, `rule` est ajouté. Si une règle de correspondance est trouvée, les droits dans `rule` sont fusionnés avec la règle existante.  
  
 Règles ne peuvent pas être fusionnées si elles ont des indicateurs d’héritage différent. Par exemple, si un utilisateur a un accès en lecture sans indicateurs d’héritage, et <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> est utilisé pour ajouter une règle donnant l’accès en écriture avec héritage de sous-clés utilisateur (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), les deux règles ne peuvent pas être fusionnées.  
  
 Règles avec différents <xref:System.Security.AccessControl.AccessControlType> valeurs ne sont jamais fusionnées.  
  
 Règles d’exprimer des droits de la façon la plus économique. Par exemple, si un utilisateur a <xref:System.Security.AccessControl.RegistryRights.QueryValues>, <xref:System.Security.AccessControl.RegistryRights.Notify> et <xref:System.Security.AccessControl.RegistryRights.ReadPermissions> droits et que vous ajoutez une règle autorisant <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> des droits, l’utilisateur dispose de tous les éléments constitutifs de <xref:System.Security.AccessControl.RegistryRights.ReadKey> droits. Si vous interrogez les droits d’utilisateur, vous verrez une règle contenant <xref:System.Security.AccessControl.RegistryRights.ReadKey> droits. De même, si vous supprimez <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> des droits, les autres composants des <xref:System.Security.AccessControl.RegistryRights.ReadKey> droits réapparaît.  
  
   
  
## Examples  
 L’exemple de code suivant crée des règles d’accès du Registre et les ajoute à une <xref:System.Security.AccessControl.RegistrySecurity> objet, en montrant comment les règles autorisent et refusent des droits restent distincts, tout en les règles compatibles du même type est fusionnée.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> et <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 Vous trouverez un exemple de code illustrant les indicateurs d’héritage et la propagation dans le <xref:System.Security.AccessControl.RegistryAccessRule> classe.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’audit à ajouter. L'utilisateur spécifié par cette règle détermine la recherche.</param>
        <summary>Recherche une règle d'audit avec laquelle la nouvelle règle peut être fusionnée. Ajoute la nouvelle règle en cas de recherche infructueuse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> méthode recherche des règles ayant le même utilisateur ou groupe en tant que `rule`. Si aucune n’est trouvée, `rule` est ajouté. Si une règle de correspondance est trouvée, les indicateurs de `rule` sont fusionnées dans la règle existante.  
  
 Règles ne peuvent pas être fusionnées si elles ont des indicateurs d’héritage différent. Par exemple, en cas d’échec des tentatives d’écriture à une clé sont auditées pour un utilisateur particulier, sans indicateurs d’héritage, et <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> est utilisée pour ajouter une règle en spécifiant que les tentatives ayant échoué pour changer les autorisations sont vérifiés pour le même utilisateur, mais avec l’héritage pour sous-clés (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), les deux règles ne peuvent pas être fusionnées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <see cref="T:System.Security.Principal.IdentityReference" /> qui identifie l'utilisateur ou le groupe auquel s'applique la règle.</param>
        <param name="accessMask">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.RegistryRights" /> spécifiant les droits d'accès à auditer, castés en entier.</param>
        <param name="isInherited">Valeur booléenne spécifiant si la règle est héritée.</param>
        <param name="inheritanceFlags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.InheritanceFlags" /> spécifiant la façon dont les sous-clés héritent de la règle.</param>
        <param name="propagationFlags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.PropagationFlags" /> qui modifient la façon dont les sous-clés héritent de la règle. Sans utilité si la valeur de <c>inheritanceFlags</c> est <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="flags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.AuditFlags" /> spécifiant s'il faut auditer les accès réussis, les échecs d'accès ou les deux.</param>
        <summary>Crée une règle d'audit, en spécifiant l'utilisateur auquel elle s'applique, les droits d'accès à auditer, l'héritage et la propagation de la règle, ainsi que le résultat qui déclenche la règle.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> représentant la règle d'audit spécifiée, pour l'utilisateur spécifié, avec les indicateurs spécifiés. Le type de retour de la méthode est la classe de base, <see cref="T:System.Security.AccessControl.AuditRule" />, mais la valeur de retour peut être castée sans risque en classe dérivée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode recommandée pour créer des règles d’audit consiste à utiliser les constructeurs de la <xref:System.Security.AccessControl.RegistryAuditRule> classe.  
  
> [!NOTE]
>  Bien que vous puissiez spécifier le <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> indicateur, il est inutile de faire. Dans le cadre du contrôle de l’audit, les paires nom/valeur d’une sous-clé ne sont pas des objets distincts. Les droits d’audit des paires nom/valeur sont contrôlés par les droits de la sous-clé. En outre, étant donné que toutes les sous-clés sont des conteneurs (autrement dit, ils peuvent contenir d’autres sous-clés), elles ne sont pas affectées par la <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> indicateur. Enfin, en spécifiant le <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> indicateur complique inutilement la maintenance des règles, parce qu’il interfère avec la combinaison normale de règles compatibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> ou <paramref name="flags" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> est <see langword="null" />.  
  
 - ou -  
  
 <paramref name="accessMask" /> est égal à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> n'est ni du type <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni d'un type tel que <see cref="T:System.Security.Principal.NTAccount" /> qui peut être converti en type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type utilisé par la classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> pour représenter des règles d'audit.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant la classe <see cref="T:System.Security.AccessControl.RegistryAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes dérivées de la <xref:System.Security.AccessControl.ObjectSecurity> classe de remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> propriété et retourner le type qu’elles utilisent pour représenter des droits d’audit. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type de règle d’audit correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As RegistryAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> qui spécifie l'utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> à rechercher, ainsi qu'un jeu d'indicateurs d'héritage et de propagation avec lesquels une règle correspondante, si elle est trouvée, doit être compatible. Spécifie les droits à supprimer de la règle compatible, le cas échéant.</param>
        <summary>Recherche une règle de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle d'accès spécifiée et ayant des indicateurs d'héritage et de propagation compatibles ; si une telle règle est trouvée, les droits contenus dans la règle d'accès spécifiée en sont supprimés.</summary>
        <returns>
          <see langword="true" /> si une règle compatible est trouvée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En cours <xref:System.Security.AccessControl.RegistrySecurity> est recherché dans une règle qui a le même utilisateur et le même <xref:System.Security.AccessControl.AccessControlType> valeur en tant que `rule`. Si aucune règle n’est trouvée, aucune action n’est effectuée et la méthode retourne `false`. Si des règles correspondantes sont trouvées, les indicateurs d’héritage et de compatibilité sont vérifiées pour la compatibilité avec les indicateurs spécifiés dans `rule`. Si aucune règle compatible n’est trouvée, aucune action n’est effectuée et la méthode retourne `false`. Si une règle avec des indicateurs compatibles est trouvée, les droits spécifiés dans `rule` sont supprimés de la règle compatible, et la méthode retourne `true`. Si `rule` spécifie des droits non contenus dans la règle compatible, aucune action n’est effectuée en ce qui concerne ces droits. Si tous les droits sont supprimés de la règle compatible, la règle entière est supprimée à partir du <xref:System.Security.AccessControl.RegistrySecurity> objet.  
  
   
  
## Examples  
 Le code suivant montre d’exemple comment la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode supprime les droits à partir d’une règle compatible et comment la <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> méthode fusionne des droits avec les règles compatibles.  
  
 L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet et ajoute une règle qui autorise l’utilisateur actuel <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> droits. L’exemple crée ensuite une règle qui accorde à l’utilisateur <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>avec le même héritage et les droits de propagation que la première règle et utilise le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode pour supprimer cette nouvelle règle de la <xref:System.Security.AccessControl.RegistrySecurity> objet. <xref:System.Security.AccessControl.RegistryRights.SetValue> est un composant de <xref:System.Security.AccessControl.RegistryRights.ReadKey>par conséquent, il est supprimé de la règle compatible. Les règles dans le <xref:System.Security.AccessControl.RegistrySecurity> objet s’affichent, présentent les composants restants du <xref:System.Security.AccessControl.RegistryRights.ReadKey>.  
  
 L’exemple de code appelle ensuite la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode pour fusionner le <xref:System.Security.AccessControl.RegistryRights.SetValue> avec le bouton droit dans la règle de la <xref:System.Security.AccessControl.RegistrySecurity> objet.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Le deuxième exemple de cette section attache un objet de sécurité, et comme les exemples de <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> qui spécifie l'utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> à rechercher. Les droits et les indicateurs d'héritage ou de propagation spécifiés par cette règle sont ignorés.</param>
        <summary>Recherche toutes les règles de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle spécifiée et, s'il en existe, les supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En cours <xref:System.Security.AccessControl.RegistrySecurity> recherche est effectuée pour les règles qui ont le même utilisateur et le même <xref:System.Security.AccessControl.AccessControlType> valeur en tant que `rule`. Des droits, les indicateurs d’héritage ou les indicateurs de propagation spécifiés par `rule` sont ignorés lors de l’exécution de cette recherche. Si aucune règle correspondante n’est trouvée, aucune action n’est effectuée.  
  
 Par exemple, si un utilisateur dispose de plusieurs règles qui autorisent divers droits avec héritage différent et indicateurs de propagation, vous pouvez supprimer toutes ces règles en créant un <xref:System.Security.AccessControl.RegistryAccessRule> objet qui spécifie l’utilisateur et <xref:System.Security.AccessControl.AccessControlType.Allow?displayProperty=nameWithType>, avec les droits arbitraires et les indicateurs, et en passant cette règle à la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre que le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> méthode supprime toutes les règles qui correspondent à l’utilisateur et <xref:System.Security.AccessControl.AccessControlType>, en ignorant les droits et les indicateurs.  
  
 L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel, avec différents indicateurs d’héritage et de propagation. L’exemple crée ensuite une règle qui permet à l’utilisateur actuel de prendre possession, puis passe cette règle à la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> méthode pour supprimer les deux règles qui autorisent l’accès.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Consultez le <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (méthode) et le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> à supprimer.</param>
        <summary>Recherche une règle de contrôle d'accès qui correspond exactement à la règle spécifiée et, si une telle règle est trouvée, la supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La règle est supprimée uniquement si celle-ci correspond exactement à `rule` dans tous les détails, y compris les indicateurs. Autres règles ayant le même utilisateur et <xref:System.Security.AccessControl.AccessControlType> ne sont pas affectées.  
  
> [!IMPORTANT]
>  Une règle représente une ou plus sous-jacent entrées contrôle d’accès (ACE) et ces entrées sont combinées si nécessaire, lorsque vous modifiez les règles de sécurité d’accès pour un utilisateur. Par conséquent, une règle n’existe plus sous la forme qu’elle avait lorsqu’elle a été ajoutée et dans ce cas le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> méthode ne peut pas le supprimer.  
  
   
  
## Examples  
 L’exemple de code suivant montre que le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> méthode supprime une règle uniquement si elle correspond à exactement.  
  
 L’exemple crée deux règles qui accordent des droits différents. Les règles ont des indicateurs d’héritage et de propagation compatibles, donc lorsque la deuxième règle est ajoutée, elle fusionne avec la première. L’exemple appelle la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> méthode, en spécifiant la première règle, mais étant donné que les règles sont fusionnées il n’existe aucune règle correspondant. L’exemple appelle ensuite la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> méthode pour supprimer la deuxième règle de la règle fusionnée et enfin appelle la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> méthode pour supprimer la première règle.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Consultez le <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (méthode) et le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As RegistryAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> qui spécifie l'utilisateur à rechercher, ainsi qu'un jeu d'indicateurs d'héritage et de propagation avec lesquels une règle correspondante, si elle est trouvée, doit être compatible. Spécifie les droits à supprimer de la règle compatible, le cas échéant.</param>
        <summary>Recherche une règle de contrôle d'audit ayant le même utilisateur que la règle spécifiée et ayant des indicateurs d'héritage et de propagation compatibles ; si une règle compatible est trouvée, les droits contenus dans la règle spécifiée en sont supprimés.</summary>
        <returns>
          <see langword="true" /> si une règle compatible est trouvée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En cours <xref:System.Security.AccessControl.RegistrySecurity> est recherché dans une règle d’audit ayant le même utilisateur que `rule`. Si aucune règle n’est trouvée, aucune action n’est effectuée et la méthode retourne `false`. Si des règles correspondantes sont trouvées, les indicateurs d’héritage et de compatibilité sont vérifiées pour la compatibilité avec les indicateurs spécifiés dans `rule`. Si aucune règle compatible n’est trouvée, aucune action n’est effectuée et la méthode retourne `false`. Si une règle avec des indicateurs compatibles est trouvée, les droits spécifiés dans `rule` sont supprimés de la règle compatible, et la méthode retourne `true`. Si `rule` spécifie des droits non contenus dans la règle compatible, aucune action n’est effectuée en ce qui concerne ces droits. Si tous les droits sont supprimés de la règle compatible, la règle entière est supprimée à partir du <xref:System.Security.AccessControl.RegistrySecurity> objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> qui spécifie l'utilisateur à rechercher. Les droits et les indicateurs d'héritage ou de propagation spécifiés par cette règle sont ignorés.</param>
        <summary>Recherche toutes les règles d'audit ayant le même utilisateur que la règle spécifiée et, s'il en existe, les supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En cours <xref:System.Security.AccessControl.RegistrySecurity> est recherchée dans les règles d’audit qui ont le même utilisateur que `rule`. Des droits, les indicateurs d’héritage ou les indicateurs de propagation spécifiés par `rule` sont ignorés lors de l’exécution de cette recherche. Si aucune règle correspondante n’est trouvée, aucune action n’est effectuée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> à supprimer.</param>
        <summary>Recherche une règle d'audit qui correspond exactement à la règle spécifiée et, si une telle règle est trouvée, la supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La règle est supprimée uniquement si celle-ci correspond exactement à `rule` dans tous les détails, y compris les indicateurs. Autres règles d’audit pour le même utilisateur ne sont pas affectées.  
  
> [!IMPORTANT]
>  Une règle représente une ou plus sous-jacent entrées contrôle d’accès (ACE) et ces entrées sont combinées si nécessaire, lorsque vous modifiez les règles de sécurité d’audit pour un utilisateur. Par conséquent, une règle n’existe plus sous la forme qu’elle avait lorsqu’elle a été ajoutée et dans ce cas le <xref:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific%2A> méthode ne peut pas le supprimer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> à ajouter. L'utilisateur spécifié par cette règle détermine les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles de contrôle d'accès ayant le même utilisateur que la règle spécifiée, indépendamment de <see cref="T:System.Security.AccessControl.AccessControlType" />, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucune règle d’accès dont l’utilisateur correspond à la règle spécifiée, `rule` est ajouté.  
  
   
  
## Examples  
 Le code suivant exemple montre comment la <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> méthode remplace toutes les règles de l’utilisateur correspondant à la règle de correspondance spécifiée.  
  
 L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel, avec différents indicateurs d’héritage et de propagation. L’exemple crée ensuite une règle qui permet à l’utilisateur actuel uniquement de lire la clé et utilise le <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> méthode pour supprimer toutes les règles de l’utilisateur et de les remplacer par la nouvelle règle.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Consultez le <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (méthode) et le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> à ajouter. L'utilisateur et le <see cref="T:System.Security.AccessControl.AccessControlType" /> de cette règle déterminent les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle spécifiée, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la règle spécifiée a <xref:System.Security.AccessControl.AccessControlType.Allow>, l’effet de cette méthode consiste à supprimer tous les <xref:System.Security.AccessControl.AccessControlType.Allow> règles pour l’utilisateur spécifié, en les remplaçant par la règle spécifiée. Si la règle spécifiée a <xref:System.Security.AccessControl.AccessControlType.Deny>, tous les <xref:System.Security.AccessControl.AccessControlType.Deny> règles pour l’utilisateur spécifié sont remplacées par la règle spécifiée.  
  
 S’il en existe pas de règles dont l’utilisateur et <xref:System.Security.AccessControl.AccessControlType> correspond à la règle spécifiée, `rule` est ajouté.  
  
   
  
## Examples  
 L’exemple de code suivant montre que le <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> méthode supprime toutes les règles qui correspondent à la fois à l’utilisateur et le <xref:System.Security.AccessControl.AccessControlType> de `rule`, en ignorant les droits et les indicateurs et les remplace par `rule`.  
  
 L’exemple crée un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel, avec différents indicateurs d’héritage et de propagation. L’exemple crée ensuite une règle qui permet à l’utilisateur actuel uniquement de lire la clé et utilise le <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> méthode pour supprimer les deux règles qui autorisent l’accès et les remplacer par la nouvelle règle. La règle qui refuse l’accès n’est pas affectée.  
  
> [!NOTE]
>  Cet exemple n’attache pas l’objet de sécurité à un <xref:Microsoft.Win32.RegistryKey> objet. Consultez le <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (méthode) et le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> à ajouter. L'utilisateur spécifié par cette règle détermine les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles d'audit ayant le même utilisateur que la règle spécifiée, quelle que soit la valeur de <see cref="T:System.Security.AccessControl.AuditFlags" />, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucune règle d’audit dont l’utilisateur correspond à la règle spécifiée, `rule` est ajouté.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>