<Type Name="SemaphoreSecurity" FullName="System.Security.AccessControl.SemaphoreSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="83fa29ebe41582803f0a783663ba024f0b1d03a6" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49140869" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SemaphoreSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SemaphoreSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.SemaphoreSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SemaphoreSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type SemaphoreSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente la sécurité de contrôle d'accès Windows d'un sémaphore nommé. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Security.AccessControl.SemaphoreSecurity> objet spécifie les droits d’accès pour un sémaphore système nommé et spécifie également la façon dont les tentatives d’accès sont auditées. Droits d’accès au sémaphore sont exprimées sous forme de règles, chaque règle d’accès représenté par un <xref:System.Security.AccessControl.SemaphoreAccessRule> objet. Chaque règle d’audit est représenté par un <xref:System.Security.AccessControl.SemaphoreAuditRule> objet.  
  
 Cela reflète le système de sécurité Windows sous-jacent, dans lequel chaque objet sécurisable a au plus une liste discretionary access control (DACL) qui contrôle l’accès à l’objet sécurisé et au plus un accès contrôle liste système (SACL) qui spécifie les accès tentatives sont auditées. Le DACL et les SACL sont classés les listes d’entrées de contrôle d’accès (ACE) qui spécifient les accès et audit pour les utilisateurs et groupes. Un <xref:System.Security.AccessControl.SemaphoreAccessRule> ou <xref:System.Security.AccessControl.SemaphoreAuditRule> objet peut représenter plusieurs ACE.  
  
> [!NOTE]
>  Un <xref:System.Threading.Semaphore> objet peut représenter un sémaphore local ou un sémaphore système nommé. Sécurité de contrôle d’accès Windows est significative uniquement pour les sémaphores de système nommé.  
  
 Le <xref:System.Security.AccessControl.SemaphoreSecurity>, <xref:System.Security.AccessControl.SemaphoreAccessRule>, et <xref:System.Security.AccessControl.SemaphoreAuditRule> classes masquent les détails d’implémentation de l’ACL et les ACE. Ils permettent d’ignorer les différents types d’ACE dix-sept et la complexité du maintien correctement l’héritage et la propagation de droits d’accès. Ces objets sont également conçus pour empêcher les erreurs de contrôle d’accès courantes suivantes :  
  
-   Création d’un descripteur de sécurité avec une liste DACL null. Une référence null à une liste DACL permet à tout utilisateur à ajouter des règles d’accès à un objet, créant potentiellement une attaque par déni de service. Un nouveau <xref:System.Security.AccessControl.SemaphoreSecurity> objet commence toujours par une liste DACL vide, ce qui refuse tout accès à tous les utilisateurs.  
  
-   Violation de l’ordre canonique d’ACE. Si la liste ACE dans la liste DACL n’est pas conservée dans l’ordre canonique, les utilisateurs peuvent par inadvertance un accès à l’objet sécurisé. Par exemple, les droits d’accès refusé doivent toujours apparaître avant des droits d’accès autorisés. <xref:System.Security.AccessControl.SemaphoreSecurity> objets conservent l’ordre correct en interne.  
  
-   Manipulation des indicateurs de descripteurs de sécurité, qui doivent être sous le contrôle de gestionnaire de ressources uniquement.  
  
-   Création de combinaisons non valides d’indicateurs d’ACE.  
  
-   Manipulation des ACE héritées. Héritage et propagation sont gérés par le Gestionnaire de ressources, en réponse aux modifications apportées aux règles d’accès et d’audit.  
  
-   Insertion ACE dénuée de sens dans les ACL.  
  
 Les seules fonctionnalités non prises en charge par les objets de sécurité .NET sont des activités dangereuses doivent être évitées par la majorité des développeurs d’applications, telles que les éléments suivants :  
  
-   Tâches de bas niveau qui sont normalement effectuées par le Gestionnaire de ressources.  
  
-   Ajout ou suppression des entrées de contrôle d’accès de manière à ne conserve pas l’ordre canonique.  
  
 Pour modifier la sécurité de contrôle d’accès Windows d’un sémaphore nommé, utilisez la <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> méthode pour obtenir le <xref:System.Security.AccessControl.SemaphoreSecurity> objet. Modifier l’objet de sécurité en ajoutant et supprimant des règles et ensuite utiliser le <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> méthode pour le rattacher.  
  
> [!IMPORTANT]
>  Modifications apportées à un <xref:System.Security.AccessControl.SemaphoreSecurity> objet n’affectent pas les niveaux d’accès du sémaphore nommé jusqu'à ce que vous appeliez la <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> méthode pour attribuer l’objet de sécurité modifié pour le sémaphore nommé.  
  
 Pour copier la sécurité de contrôle d’accès d’un sémaphore à un autre, utilisez la <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> méthode pour obtenir un <xref:System.Security.AccessControl.SemaphoreSecurity> de l’objet qui représente les règles d’accès et d’audit pour le sémaphore en premier, puis utiliser le <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> méthode ou un constructeur qui accepte un <xref:System.Security.AccessControl.SemaphoreSecurity> objet, pour assigner ces règles au deuxième sémaphore.  
  
 Les utilisateurs avec un investissement dans le langage de définition de descripteur de sécurité (SDDL) peuvent utiliser le <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> méthode pour définir des règles d’accès pour un sémaphore nommé et le <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> méthode pour obtenir une chaîne qui représente les règles d’accès au format SDDL. Cela n’est pas recommandé pour un nouveau développement.  
  
> [!NOTE]
>  Sécurité sur les objets de synchronisation n’est pas prise en charge pour Windows 98 ou Windows Millennium Edition.  
  
   
  
## Examples  
 L’exemple de code suivant illustre la séparation entre <xref:System.Security.AccessControl.AccessControlType.Allow> règles et <xref:System.Security.AccessControl.AccessControlType.Deny> règles et affiche la combinaison de droits des règles compatibles. L’exemple crée un <xref:System.Security.AccessControl.SemaphoreSecurity> objet, ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel et affiche la paire de règles résultante. L’exemple permet de nouveaux droits de l’utilisateur actuel, puis affiche le résultat, indiquant que les nouveaux droits sont fusionnés avec le <xref:System.Security.AccessControl.AccessControlType.Allow> règle.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:System.Threading.Semaphore> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.SemaphoreAccessRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreAuditRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreRights" />
    <altmember cref="M:System.Threading.Semaphore.GetAccessControl" />
    <altmember cref="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> avec des valeurs par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nouveau <xref:System.Security.AccessControl.SemaphoreSecurity> objet commence toujours par une liste vide accès discrétionnaire (DACL), qui refuse tout accès à tous les utilisateurs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette classe n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, includeSections As AccessControlSections)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity(System::String ^ name, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.SemaphoreSecurity : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="new System.Security.AccessControl.SemaphoreSecurity (name, includeSections)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="name">Nom du sémaphore système dont les règles de sécurité du contrôle d'accès doivent être récupérées.</param>
        <param name="includeSections">Combinaison d'indicateurs <see cref="T:System.Security.AccessControl.AccessControlSections" /> spécifiant les sections à récupérer.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> avec les sections spécifiées des règles de sécurité du contrôle d'accès du sémaphore système portant le nom spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur vous permet d’obtenir la sécurité de contrôle d’accès pour un sémaphore système nommé sans d’abord créer un <xref:System.Threading.Semaphore> objet.  
  
 Attention doit être prudent lors de l’utilisation des objets de système nommé. S’il est un objet système nommé `name` qui n’est pas un sémaphore, sa sécurité de contrôle d’accès risque d’être récupérée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette classe n'est pas prise en charge dans Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'énumération utilisée par la classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> pour représenter des droits d'accès.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant l'énumération <see cref="T:System.Security.AccessControl.SemaphoreRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de la <xref:System.Security.AccessControl.ObjectSecurity> classe remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> propriété et retournent le type qu’ils utilisent pour représenter des droits d’accès. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type d’énumération correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="abstract member AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule&#xA;override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="semaphoreSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <see cref="T:System.Security.Principal.IdentityReference" /> qui identifie l'utilisateur ou le groupe auquel s'applique la règle.</param>
        <param name="accessMask">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.SemaphoreRights" /> qui spécifient les droits d'accès à accorder ou refuser, castés en entier.</param>
        <param name="isInherited">Sans utilité pour les sémaphores nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="inheritanceFlags">Sans utilité pour les sémaphores nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="propagationFlags">Sans utilité pour les sémaphores nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="type">Une des valeurs <see cref="T:System.Security.AccessControl.AccessControlType" /> spécifiant si les droits sont accordés ou refusés.</param>
        <summary>Crée une règle de contrôle d'accès pour l'utilisateur spécifié, avec les droits d'accès, le contrôle d'accès et les indicateurs spécifiés.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> représentant les droits spécifiés pour l'utilisateur spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode recommandée pour créer des règles de contrôle d’accès consiste à utiliser les constructeurs de la <xref:System.Security.AccessControl.SemaphoreAccessRule> classe.  
  
> [!NOTE]
>  Bien que les indicateurs d’héritage et la propagation n’ont aucune signification pour les sémaphores nommés, il est toujours possible de les spécifier que ceci n’est pas recommandé, car ils compliquent inutilement la maintenance des règles, par exemple en raison d’interférences avec la combinaison de règles qui seraient compatibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> ou <paramref name="type" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="accessMask" /> est égal à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> n'est ni du type <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni d'un type tel que <see cref="T:System.Security.Principal.NTAccount" /> qui peut être converti en type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type utilisé par la classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> pour représenter des règles d'accès.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant la classe <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de la <xref:System.Security.AccessControl.ObjectSecurity> classe remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> propriété et retournent le type qu’ils utilisent pour représenter des règles d’accès. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type de règle d’accès correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle de contrôle d'accès à ajouter.</param>
        <summary>Recherche une règle correspondante avec laquelle la nouvelle règle peut être fusionnée. Ajoute la nouvelle règle en cas de recherche infructueuse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule%2A> méthode recherche des règles avec le même utilisateur ou groupe et le même <xref:System.Security.AccessControl.AccessControlType> comme `rule`. Si aucune n’est trouvée, `rule` est ajouté. Si une règle de correspondance est trouvée, les droits dans `rule` sont fusionnés avec la règle existante.  
  
   
  
## Examples  
 L’exemple de code suivant illustre la séparation entre <xref:System.Security.AccessControl.AccessControlType.Allow> règles et <xref:System.Security.AccessControl.AccessControlType.Deny> règles et affiche la combinaison de droits des règles compatibles. L’exemple crée un <xref:System.Security.AccessControl.SemaphoreSecurity> objet, ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel et affiche la paire de règles résultante. L’exemple permet de nouveaux droits de l’utilisateur actuel, puis affiche le résultat, indiquant que les nouveaux droits sont fusionnés avec le <xref:System.Security.AccessControl.AccessControlType.Allow> règle.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:System.Threading.Semaphore> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Règle d’audit à ajouter. L'utilisateur spécifié par cette règle détermine la recherche.</param>
        <summary>Recherche une règle d'audit avec laquelle la nouvelle règle peut être fusionnée. Ajoute la nouvelle règle en cas de recherche infructueuse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule%2A> recherches de méthode pour les règles avec le même utilisateur ou groupe en tant que `rule`. Si aucune n’est trouvée, `rule` est ajouté. Si une règle de correspondance est trouvée, les indicateurs dans `rule` sont fusionnées dans la règle existante.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="abstract member AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule&#xA;override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="semaphoreSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <see cref="T:System.Security.Principal.IdentityReference" /> qui identifie l'utilisateur ou le groupe auquel s'applique la règle.</param>
        <param name="accessMask">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.SemaphoreRights" /> spécifiant les droits d'accès à auditer, castés en entier.</param>
        <param name="isInherited">Sans utilité pour les handles d'attente nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="inheritanceFlags">Sans utilité pour les handles d'attente nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="propagationFlags">Sans utilité pour les handles d'attente nommés, car ils n'ont pas de hiérarchie.</param>
        <param name="flags">Combinaison d'opérations de bits de valeurs <see cref="T:System.Security.AccessControl.AuditFlags" /> qui spécifient s'il faut auditer les accès réussis, les échecs d'accès ou les deux.</param>
        <summary>Crée une règle d'audit, en spécifiant l'utilisateur auquel elle s'applique, les droits d'accès à auditer et le résultat qui déclenche la règle d'audit.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> représentant la règle d'audit spécifiée pour l'utilisateur spécifié. Le type de retour de la méthode est la classe de base, <see cref="T:System.Security.AccessControl.AuditRule" />, mais la valeur de retour peut être castée sans risque en classe dérivée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode recommandée pour créer des règles d’audit consiste à utiliser les constructeurs de la <xref:System.Security.AccessControl.SemaphoreAuditRule> classe.  
  
> [!NOTE]
>  Bien que les indicateurs d’héritage et la propagation n’ont aucune signification pour les sémaphores nommés, il est toujours possible de les spécifier. Cela n’est pas recommandée, car elle complique inutilement la maintenance des règles, par exemple en raison d’interférences avec la combinaison de règles qui seraient autrement compatible.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> ou <paramref name="flags" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="accessMask" /> est égal à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> n'est ni du type <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni d'un type tel que <see cref="T:System.Security.Principal.NTAccount" /> qui peut être converti en type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type utilisé par la classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> pour représenter des règles d'audit.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant la classe <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de la <xref:System.Security.AccessControl.ObjectSecurity> classe remplacement le <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> propriété et retournent le type qu’ils utilisent pour représenter des droits d’audit. Lorsque vous travaillez avec des tableaux ou collections contenant plusieurs types d’objets de sécurité, utilisez cette propriété pour déterminer le type de règle d’audit correct à utiliser avec chaque objet de sécurité.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As SemaphoreAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; bool" Usage="semaphoreSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> qui spécifie l'utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> à rechercher, ainsi qu'un jeu d'indicateurs d'héritage et de propagation avec lesquels une règle correspondante, si elle est trouvée, doit être compatible. Spécifie les droits à supprimer de la règle compatible, le cas échéant.</param>
        <summary>Recherche une règle de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle spécifiée et ayant des indicateurs d'héritage et de propagation compatibles ; si une telle règle est trouvée, les droits contenus dans la règle d'accès spécifiée en sont supprimés.</summary>
        <returns>
          <see langword="true" /> si une règle compatible est trouvée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Security.AccessControl.SemaphoreSecurity> est recherché dans une règle qui a le même utilisateur et le même <xref:System.Security.AccessControl.AccessControlType> valeur sous la forme `rule`. Si aucune règle n’est trouvée, aucune action n’est effectuée, et la méthode retourne `false`. Si les règles de correspondance sont trouvées, les indicateurs d’héritage et de compatibilité sont activés pour la compatibilité avec les indicateurs spécifiés dans `rule`. Si aucune règle compatible n’est trouvée, aucune action n’est effectuée, et la méthode retourne `false`. Si une règle avec des indicateurs compatibles est trouvée, les droits spécifiés dans `rule` sont supprimés de la règle compatible, et la méthode retourne `true`. Si `rule` spécifie les droits non contenus dans la règle compatible, aucune action n’est effectuée en ce qui concerne ces droits. Si tous les droits sont supprimés de la règle compatible, la règle entière est supprimée à partir du <xref:System.Security.AccessControl.SemaphoreSecurity> objet.  
  
> [!IMPORTANT]
>  Bien que vous pouvez spécifier des indicateurs d’héritage et de propagation pour les règles d’accès de sémaphore, en les créant avec la <xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A> (méthode), cela est déconseillé. L’héritage et la propagation n’ont aucune signification pour les sémaphores nommés et ils compliquent la maintenance des règles d’accès.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> méthode pour supprimer les droits à partir d’un <xref:System.Security.AccessControl.AccessControlType.Allow> règle dans un <xref:System.Security.AccessControl.SemaphoreSecurity> objet. Il montre également que les autres droits dans `rule` sont ignorés.  
  
 L’exemple crée un <xref:System.Security.AccessControl.SemaphoreSecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel. Les droits accordés incluent <xref:System.Security.AccessControl.SemaphoreRights.Modify>, <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>, et <xref:System.Security.AccessControl.SemaphoreRights.Synchronize>. L’exemple crée ensuite une nouvelle règle pour l’utilisateur actuel, y compris <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> et <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> des droits, puis utilise cette règle avec la <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> méthode pour supprimer <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> à partir de la <xref:System.Security.AccessControl.AccessControlType.Allow> règle dans le <xref:System.Security.AccessControl.SemaphoreSecurity> objet. Les informations superflues <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> avec le bouton droit dans `rule` est ignoré.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:System.Threading.Semaphore> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleAll : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> qui spécifie l'utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> à rechercher. Tous les droits spécifiés par cette règle sont ignorés.</param>
        <summary>Recherche toutes les règles de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle spécifiée et, s'il en existe, les supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Security.AccessControl.SemaphoreSecurity> recherche est effectuée pour les règles qui ont le même utilisateur et la même <xref:System.Security.AccessControl.AccessControlType> valeur sous la forme `rule`. Tous les droits spécifiés par `rule` sont ignorés lors de l’exécution de cette recherche. Si aucune règle correspondante n’est trouvée, aucune action n’est effectuée.  
  
   
  
## Examples  
 L’exemple de code suivant montre que le <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll%2A> méthode supprime toutes les règles qui correspondent à l’utilisateur et <xref:System.Security.AccessControl.AccessControlType>, en ignorant les droits.  
  
 L’exemple crée un <xref:System.Security.AccessControl.SemaphoreSecurity> objet, ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel, puis fusionne les droits supplémentaires dans le <xref:System.Security.AccessControl.AccessControlType.Allow> règle. L’exemple crée ensuite une nouvelle règle qui autorise l’utilisateur actuel s’approprier et utilise cette règle pour supprimer la <xref:System.Security.AccessControl.AccessControlType.Allow> de règles à partir de la <xref:System.Security.AccessControl.SemaphoreSecurity> objet.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:System.Threading.Semaphore> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleSpecific : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> à supprimer.</param>
        <summary>Recherche une règle de contrôle d'accès qui correspond exactement à la règle spécifiée et, si une telle règle est trouvée, la supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La règle est supprimée uniquement si celle-ci correspond exactement à `rule` dans tous les détails, y compris les indicateurs. Autres règles ayant les mêmes utilisateur et <xref:System.Security.AccessControl.AccessControlType> ne sont pas affectées.  
  
> [!IMPORTANT]
>  Une règle représente une ou plus sous-jacent entrées contrôle d’accès (ACE) et ces entrées sont combinées en fonction des besoins lorsque vous modifiez les règles de sécurité d’accès pour un utilisateur. Par conséquent, une règle n’existe plus dans le formulaire spécifique qu’elle avait lorsqu’il a été ajouté et dans ce cas le <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> méthode ne peut pas le supprimer.  
  
   
  
## Examples  
 L’exemple de code suivant montre que le <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> méthode nécessite une correspondance exacte pour supprimer une règle, et que les règles pour autoriser et refuser des droits sont indépendantes les unes des autres.  
  
 L’exemple crée un <xref:System.Security.AccessControl.SemaphoreSecurity> objet, ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel, puis fusionne les droits supplémentaires dans le <xref:System.Security.AccessControl.AccessControlType.Allow> règle d’accès. Cet exemple passe ensuite l’original <xref:System.Security.AccessControl.AccessControlType.Allow> règle pour le <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> (méthode) et affiche les résultats, qui montrent que rien n’est supprimé. L’exemple crée ensuite une règle qui correspond à la <xref:System.Security.AccessControl.AccessControlType.Allow> règle dans le <xref:System.Security.AccessControl.SemaphoreSecurity> objet et correctement utilise le <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> méthode pour supprimer la règle.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:System.Threading.Semaphore> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As SemaphoreAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; bool" Usage="semaphoreSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> qui spécifie l'utilisateur à rechercher, ainsi qu'un jeu d'indicateurs d'héritage et de propagation avec lesquels une règle correspondante, si elle est trouvée, doit être compatible. Spécifie les droits à supprimer de la règle compatible, le cas échéant.</param>
        <summary>Recherche une règle de contrôle d'audit ayant le même utilisateur que la règle spécifiée et ayant des indicateurs d'héritage et de propagation compatibles ; si une règle compatible est trouvée, les droits contenus dans la règle spécifiée en sont supprimés.</summary>
        <returns>
          <see langword="true" /> si une règle compatible est trouvée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Security.AccessControl.SemaphoreSecurity> est recherché dans une règle d’audit ayant le même utilisateur que `rule`. Si aucune règle n’est trouvée, aucune action n’est effectuée, et la méthode retourne `false`. Si les règles de correspondance sont trouvées, les indicateurs d’héritage et de compatibilité sont activés pour la compatibilité avec les indicateurs spécifiés dans `rule`. Si aucune règle compatible n’est trouvée, aucune action n’est effectuée, et la méthode retourne `false`. Si une règle avec des indicateurs compatibles est trouvée, les droits spécifiés dans `rule` sont supprimés de la règle compatible, et la méthode retourne `true`. Si `rule` spécifie les droits non contenus dans la règle compatible, aucune action n’est effectuée en ce qui concerne ces droits. Si tous les droits sont supprimés de la règle compatible, la règle entière est supprimée à partir du <xref:System.Security.AccessControl.SemaphoreSecurity> objet.  
  
> [!IMPORTANT]
>  Bien que vous pouvez spécifier des indicateurs d’héritage et de propagation pour les règles d’audit de sémaphore, en les créant avec la <xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A> (méthode), cela est déconseillé. L’héritage et la propagation n’ont aucune signification pour les sémaphores nommés et ils compliquent la maintenance des règles d’audit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleAll : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> qui spécifie l'utilisateur à rechercher. Tous les droits spécifiés par cette règle sont ignorés.</param>
        <summary>Recherche toutes les règles d'audit ayant le même utilisateur que la règle spécifiée et, s'il en existe, les supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Security.AccessControl.SemaphoreSecurity> est recherchée dans les règles d’audit ayant le même utilisateur que `rule`. Tous les droits spécifiés par `rule` sont ignorés lors de l’exécution de cette recherche. Toutes les règles correspondantes sont supprimées. Si aucune règle correspondante n’est trouvée, aucune action n’est effectuée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleSpecific : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> à supprimer.</param>
        <summary>Recherche une règle d'audit qui correspond exactement à la règle spécifiée et, si une telle règle est trouvée, la supprime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La règle est supprimée uniquement si celle-ci correspond exactement à `rule` dans tous les détails, y compris les indicateurs. Autres règles d’audit pour le même utilisateur ne sont pas affectés.  
  
> [!IMPORTANT]
>  Une règle représente une ou plus sous-jacent entrées contrôle d’accès (ACE) et ces entrées sont combinées en fonction des besoins lorsque vous modifiez les règles de sécurité d’audit pour un utilisateur. Par conséquent, une règle n’existe plus dans le formulaire spécifique qu’elle avait lorsqu’il a été ajouté et dans ce cas le <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific%2A> méthode ne peut pas le supprimer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.ResetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> à ajouter. L'utilisateur spécifié par cette règle détermine les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles de contrôle d'accès ayant le même utilisateur que la règle spécifiée, indépendamment de <see cref="T:System.Security.AccessControl.AccessControlType" />, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucune règle d’accès dont l’utilisateur correspond à la règle spécifiée, `rule` est ajouté.  
  
   
  
## Examples  
 Le code suivant montre l’exemple comment la <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> méthode remplace toutes les règles de l’utilisateur correspondant à la règle de correspondance spécifiée.  
  
 L’exemple crée un <xref:System.Security.AccessControl.SemaphoreSecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel. L’exemple crée ensuite une nouvelle règle qui autorise le contrôle total utilisateur actuel et qui utilise le <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> méthode pour remplacer les deux règles existantes avec la nouvelle règle.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:System.Threading.Semaphore> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> à ajouter. L'utilisateur et le <see cref="T:System.Security.AccessControl.AccessControlType" /> de cette règle déterminent les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles de contrôle d'accès ayant les mêmes utilisateur et <see cref="T:System.Security.AccessControl.AccessControlType" /> (autorisation ou refus) que la règle spécifiée, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la règle spécifiée a <xref:System.Security.AccessControl.AccessControlType.Allow>, l’effet de cette méthode consiste à supprimer tous les <xref:System.Security.AccessControl.AccessControlType.Allow> règles pour l’utilisateur spécifié, en les remplaçant par la règle spécifiée. Si la règle spécifiée a <xref:System.Security.AccessControl.AccessControlType.Deny>, tous les <xref:System.Security.AccessControl.AccessControlType.Deny> règles pour l’utilisateur spécifié sont remplacées par la règle spécifiée.  
  
 S’il n’existe aucune règle dont l’utilisateur et <xref:System.Security.AccessControl.AccessControlType> correspondent à la règle spécifiée, `rule` est ajouté.  
  
   
  
## Examples  
 Le code suivant montre l’exemple comment la <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> méthode supprime toutes les règles qui correspondent à la fois à l’utilisateur et le <xref:System.Security.AccessControl.AccessControlType> de `rule`, en les remplaçant par `rule`.  
  
 L’exemple crée un <xref:System.Security.AccessControl.SemaphoreSecurity> de l’objet et ajoute des règles qui accordent et refusent divers droits à l’utilisateur actuel. L’exemple crée ensuite une nouvelle règle qui autorise le contrôle total utilisateur actuel et qui utilise le <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> méthode pour remplacer la règle avec la nouvelle règle d’autorisation. La règle qui refuse l’accès n’est pas affectée.  
  
> [!NOTE]
>  Cet exemple ne s’attache pas l’objet de sécurité à un <xref:System.Threading.Semaphore> objet. Vous trouverez des exemples qui attachent des objets de sécurité dans <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> et <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> à ajouter. L'utilisateur spécifié par cette règle détermine les règles à supprimer avant l'ajout de celle-ci.</param>
        <summary>Supprime toutes les règles d'audit ayant le même utilisateur que la règle spécifiée, quelle que soit la valeur de <see cref="T:System.Security.AccessControl.AuditFlags" />, puis ajoute la règle spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucune règle d’audit dont l’utilisateur correspond à la règle spécifiée, `rule` est ajouté.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>