<Type Name="ParallelMergeOptions" FullName="System.Linq.ParallelMergeOptions">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="67c7b5aaf5171cfcb74824b3721aec2ea41e73f0" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51914569" />
  </Metadata>
  <TypeSignature Language="C#" Value="public enum ParallelMergeOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed ParallelMergeOptions extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Linq.ParallelMergeOptions" />
  <TypeSignature Language="VB.NET" Value="Public Enum ParallelMergeOptions" />
  <TypeSignature Language="C++ CLI" Value="public enum class ParallelMergeOptions" />
  <TypeSignature Language="F#" Value="type ParallelMergeOptions = " />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Spécifie le type préféré de *fusion de sortie* à utiliser dans une requête. En d’autres termes, il indique comment PLINQ doit fusionner les résultats des différentes partitions en une séquence de résultat unique. <span data-ttu-id="2bd2c-103">Cela n'est qu'une indication, que le système peut ne pas suivre pendant la parallélisation de toutes les requêtes.</span><span class="sxs-lookup"><span data-stu-id="2bd2c-103">This is a hint only, and may not be respected by the system when parallelizing all queries.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2bd2c-104">Utilisez `NotBuffered` pour les requêtes qui seront consommées et sous forme de flux de sortie, cela a la plus faible latence entre l’exécution de requête de début et de l’obtention des éléments.</span><span class="sxs-lookup"><span data-stu-id="2bd2c-104">Use `NotBuffered` for queries that will be consumed and output as streams, this has the lowest latency between beginning query execution and elements being yielded.</span></span> <span data-ttu-id="2bd2c-105">Pour certaines requêtes, telles que celles qui impliquent un tri (OrderBy, OrderByDescending), la mise en mémoire tampon est essentielle et une indication NotBuffered ou AutoBuffered sera ignorée.</span><span class="sxs-lookup"><span data-stu-id="2bd2c-105">For some queries, such as those involving a sort (OrderBy, OrderByDescending), buffering is essential and a hint of NotBuffered or AutoBuffered will be ignored.</span></span> <span data-ttu-id="2bd2c-106">Toutefois, les requêtes qui sont créés à l’aide de l’opérateur AsOrdered peuvent être diffusés tant qu’aucun tri n’est effectué au sein de la requête elle-même.</span><span class="sxs-lookup"><span data-stu-id="2bd2c-106">However, queries that are created by using the AsOrdered operator can be streamed as long as no further sorting is performed within the query itself.</span></span>  
  
 <span data-ttu-id="2bd2c-107">Utilisez `AutoBuffered` pour la plupart des cas ; il s’agit par défaut.</span><span class="sxs-lookup"><span data-stu-id="2bd2c-107">Use `AutoBuffered` for most cases; this is the default.</span></span> <span data-ttu-id="2bd2c-108">Il établit un équilibre entre la latence et les performances globales.</span><span class="sxs-lookup"><span data-stu-id="2bd2c-108">It strikes a balance between latency and overall performance.</span></span>  
  
 <span data-ttu-id="2bd2c-109">Utilisez `FullyBuffered` pour les requêtes lorsque l’intégralité du résultat peut être traité avant que les informations sont nécessaires.</span><span class="sxs-lookup"><span data-stu-id="2bd2c-109">Use `FullyBuffered` for queries when the entire output can be processed before the information is needed.</span></span> <span data-ttu-id="2bd2c-110">Cette option offre les meilleures performances lors de la totalité de la sortie pouvant être accumulée avant de produire des informations, même si elle ne convient pas pour le traitement de flux ou affichage partiel de résultats de requête intermédiaire.</span><span class="sxs-lookup"><span data-stu-id="2bd2c-110">This option offers the best performance when all of the output can be accumulated before yielding any information, though it is not suitable for stream processing or showing partial results mid-query.</span></span>  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">
      <span data-ttu-id="2bd2c-111">Parallel LINQ (PLINQ)</span>
      <span class="sxs-lookup">
        <span data-stu-id="2bd2c-111">Parallel LINQ (PLINQ)</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/e8f7be3b-88de-4f33-ab14-dc008e76c1ba">
      <span data-ttu-id="2bd2c-112">Options de fusion en PLINQ</span>
      <span class="sxs-lookup">
        <span data-stu-id="2bd2c-112">Merge Options in PLINQ</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/0f33b527-e91a-4550-a39a-e63e396fd831">
      <span data-ttu-id="2bd2c-113">Comment : spécifier des options de fusion en PLINQ</span>
      <span class="sxs-lookup">
        <span data-stu-id="2bd2c-113">How to: Specify Merge Options in PLINQ</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName="AutoBuffered">
      <MemberSignature Language="C#" Value="AutoBuffered" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions AutoBuffered = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.AutoBuffered" />
      <MemberSignature Language="VB.NET" Value="AutoBuffered" />
      <MemberSignature Language="C++ CLI" Value="AutoBuffered" />
      <MemberSignature Language="F#" Value="AutoBuffered = 2" Usage="System.Linq.ParallelMergeOptions.AutoBuffered" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="2bd2c-114">Utilisez une fusion avec mémoires tampons de sortie d'une taille choisie par le système.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2bd2c-114">Use a merge with output buffers of a size chosen by the system.</span>
          </span>
          <span data-ttu-id="2bd2c-115">Les résultats s'accumuleront dans une mémoire tampon de sortie avant de devenir accessibles par le consommateur de la requête.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2bd2c-115">Results will accumulate into an output buffer before they are available to the consumer of the query.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="Default" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions Default = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.Default" />
      <MemberSignature Language="VB.NET" Value="Default" />
      <MemberSignature Language="C++ CLI" Value="Default" />
      <MemberSignature Language="F#" Value="Default = 0" Usage="System.Linq.ParallelMergeOptions.Default" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="2bd2c-116">Utilisez AutoBuffered, le type de fusion par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2bd2c-116">Use the default merge type, which is AutoBuffered.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="FullyBuffered">
      <MemberSignature Language="C#" Value="FullyBuffered" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions FullyBuffered = int32(3)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.FullyBuffered" />
      <MemberSignature Language="VB.NET" Value="FullyBuffered" />
      <MemberSignature Language="C++ CLI" Value="FullyBuffered" />
      <MemberSignature Language="F#" Value="FullyBuffered = 3" Usage="System.Linq.ParallelMergeOptions.FullyBuffered" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>3</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="2bd2c-117">Utilisez une fusion avec les mémoires tampons de sortie à pleine charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2bd2c-117">Use a merge with full output buffers.</span>
          </span>
          <span data-ttu-id="2bd2c-118">Le système accumulera tous les résultats avant qu'ils ne deviennent accessibles par le consommateur de la requête.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2bd2c-118">The system will accumulate all of the results before making any of them available to the consumer of the query.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="NotBuffered">
      <MemberSignature Language="C#" Value="NotBuffered" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions NotBuffered = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.NotBuffered" />
      <MemberSignature Language="VB.NET" Value="NotBuffered" />
      <MemberSignature Language="C++ CLI" Value="NotBuffered" />
      <MemberSignature Language="F#" Value="NotBuffered = 1" Usage="System.Linq.ParallelMergeOptions.NotBuffered" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="2bd2c-119">Utilisez une fusion sans mémoire tampon de sortie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2bd2c-119">Use a merge without output buffers.</span>
          </span>
          <span data-ttu-id="2bd2c-120">Dès que les éléments de résultat ont été calculés, rendez cet élément accessible par le consommateur de la requête.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2bd2c-120">As soon as result elements have been computed, make that element available to the consumer of the query.</span>
          </span>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>