<Type Name="TempFileCollection" FullName="System.CodeDom.Compiler.TempFileCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3d5e612930becd3f073a77ce82eb5fc98a9a4aed" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58461928" /></Metadata><TypeSignature Language="C#" Value="public class TempFileCollection : IDisposable, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit TempFileCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.TempFileCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class TempFileCollection&#xA;Implements ICollection, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TempFileCollection : IDisposable, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type TempFileCollection = class&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une collection de fichiers temporaires.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.TempFileCollection> peut être utilisé pour générer des noms de fichier uniques et pour suivre une liste de fichiers. Cela peut être utile pour <xref:System.CodeDom.Compiler.ICodeCompiler> les implémenteurs lors de la gestion d’une liste de fichiers intermédiaires générés par le compilateur, parfois supprimés après utilisation.  
  
 Pour spécifier un répertoire pour générer des noms de fichier temporaire unique dans, utilisez le constructeur surchargé approprié. Vous pouvez également utiliser une surcharge de constructeur pour indiquer si les fichiers ajoutés à la collection doivent, si ce n’est ne pas indication contraire lors de l’utilisation du <xref:System.CodeDom.Compiler.TempFileCollection.AddFile%2A> ou <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> méthodes, être supprimée lorsque la collection est supprimée ou le <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> méthode est appelée.  
  
 Un fichier dans n’importe quel répertoire peut être ajouté à une instance de <xref:System.CodeDom.Compiler.TempFileCollection> à l’aide de la <xref:System.CodeDom.Compiler.TempFileCollection.AddFile%2A> (méthode).  
  
 Pour générer un nom unique pour un fichier temporaire d’une extension de fichier particulier, appelez <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> et spécifiez l’extension de nom de fichier à générer. Le <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> méthode retourne une chaîne composée d’un chemin d’accès complet à un nom de fichier de l’extension spécifiée dans le répertoire spécifié par le <xref:System.CodeDom.Compiler.TempFileCollection.TempDir%2A> propriété. Le <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> méthode retourne uniquement un nom de fichier unique par extension de nom de fichier.  
  
 À la fois le <xref:System.CodeDom.Compiler.TempFileCollection.AddFile%2A> et <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> méthodes ont des surcharges qui vous permettent de spécifier si les fichiers doivent être supprimés lors de la suppression de la collection ou le <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> méthode est appelée.  
  
 Le <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> méthode supprimera tous les fichiers dans la collection, à l’exception de ceux qui sont marqués pour être supprimés.  
  
 Le <xref:System.CodeDom.Compiler.TempFileCollection.BasePath%2A> propriété indique un chemin d’accès complet pour le nom de fichier de base, sans extension de nom de fichier, utilisé pour générer les noms de fichier retournés par le <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> (méthode).  
  
> [!NOTE]
>  Cette classe contient une demande de liaison et une demande d’héritage au niveau de la classe qui s’applique à tous les membres. Un <xref:System.Security.SecurityException> est levée lorsque l’appelant immédiat ou la classe dérivée n’a pas d’autorisations de confiance totale. Pour plus d’informations sur les demandes de sécurité, consultez [demandes de liaison](~/docs/framework/misc/link-demands.md) et [demandes d’héritage](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100)).  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.CodeDom.Compiler.TempFileCollection> classe et le <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> et <xref:System.CodeDom.Compiler.TempFileCollection.AddFile%2A> méthodes.  
  
 [!code-csharp[System.CodeDom.Compiler.TempFileCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CodeDom.Compiler.TempFileCollection/CS/program.cs#1)]
 [!code-vb[System.CodeDom.Compiler.TempFileCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CodeDom.Compiler.TempFileCollection/VB/program.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">pour dériver la <see cref="T:System.CodeDom.Compiler.TempFileCollection" /> classe. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; <see cref="T:System.Security.PermissionSet" />: <see langword="FullTrust" />.</permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par du code partiellement fiable.</permission>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.CodeDom.Compiler.TempFileCollection" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TempFileCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TempFileCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.CodeDom.Compiler.TempFileCollection" /> avec des valeurs par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un constructeur par défaut qui initialise la collection avec les paramètres par défaut. Par défaut, cette collection de fichiers temporaires stockera les fichiers dans un répertoire temporaire par défaut et supprimera les fichiers temporaires une fois qu’ils ont été générés et utilisés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TempFileCollection (string tempDir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tempDir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tempDir As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TempFileCollection(System::String ^ tempDir);" />
      <MemberSignature Language="F#" Value="new System.CodeDom.Compiler.TempFileCollection : string -&gt; System.CodeDom.Compiler.TempFileCollection" Usage="new System.CodeDom.Compiler.TempFileCollection tempDir" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="tempDir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tempDir">Chemin d'accès du répertoire temporaire destiné à recevoir les fichiers temporaires.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.CodeDom.Compiler.TempFileCollection" /> avec le répertoire temporaire spécifié, défini de façon à supprimer par défaut les fichiers temporaires après leur génération et leur utilisation.</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par du code partiellement fiable.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TempFileCollection (string tempDir, bool keepFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tempDir, bool keepFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tempDir As String, keepFiles As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TempFileCollection(System::String ^ tempDir, bool keepFiles);" />
      <MemberSignature Language="F#" Value="new System.CodeDom.Compiler.TempFileCollection : string * bool -&gt; System.CodeDom.Compiler.TempFileCollection" Usage="new System.CodeDom.Compiler.TempFileCollection (tempDir, keepFiles)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tempDir" Type="System.String" />
        <Parameter Name="keepFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="tempDir">Chemin d'accès du répertoire temporaire destiné à recevoir les fichiers temporaires.</param>
        <param name="keepFiles"><see langword="true" /> si les fichiers temporaires doivent être conservés après utilisation ; <see langword="false" /> s'ils doivent être supprimés.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.CodeDom.Compiler.TempFileCollection" /> avec le répertoire temporaire spécifié et la valeur spécifiée indiquant si les fichiers temporaires doivent être conservés ou supprimés par défaut après leur génération et leur utilisation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de `keepFiles` est utilisé pour définir le <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> paramètre. Les fichiers temporaires dans la collection sont conservés ou supprimés à la fin de l’activité du compilateur en fonction de la valeur de la <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> propriété dans la collection. Comme chaque fichier est ajouté à la collection, la valeur actuelle de <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> lui est associé, sauf si elle est ajoutée avec une méthode qui a un `keepFile` paramètre, auquel cas que la valeur est utilisée pour ce fichier spécifique. Lorsque le <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> méthode est appelée, si <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> est `true`, tous les fichiers sont supprimés, y compris ceux ajoutés avec un <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> valeur `true`. Ainsi, les fichiers spécifiques, ceux identifiés comme étant de conserver les fichiers, pour être temporairement après la compilation pour des opérations telles que le rapport d’erreurs, puis supprimé quand ils ne sont plus nécessaires.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par du code partiellement fiable.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddExtension">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute à la collection un nom de fichier doté de l'extension de nom de fichier spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddExtension">
      <MemberSignature Language="C#" Value="public string AddExtension (string fileExtension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string AddExtension(string fileExtension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.AddExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddExtension (fileExtension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ AddExtension(System::String ^ fileExtension);" />
      <MemberSignature Language="F#" Value="member this.AddExtension : string -&gt; string" Usage="tempFileCollection.AddExtension fileExtension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileExtension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileExtension">Extension assignée au nom de fichier temporaire généré automatiquement qui doit être ajouté à la collection.</param>
        <summary>Ajoute à la collection un nom de fichier doté de l'extension de nom de fichier spécifiée.</summary>
        <returns>Nom de fichier doté de l'extension spécifiée qui a été ajouté à la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne un nom de fichier avec l’extension spécifiée qui a été ajouté à la collection de fichiers temporaires. Tout autre code devez toujours créer le fichier avant de pouvoir être utilisé.  
  
 Cette méthode peut être appelée qu’une seule fois pour chaque extension de nom de fichier, car elle retourne le même nom si elle est appelée avec la même extension.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddExtension">
      <MemberSignature Language="C#" Value="public string AddExtension (string fileExtension, bool keepFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string AddExtension(string fileExtension, bool keepFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.AddExtension(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddExtension (fileExtension As String, keepFile As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ AddExtension(System::String ^ fileExtension, bool keepFile);" />
      <MemberSignature Language="F#" Value="member this.AddExtension : string * bool -&gt; string" Usage="tempFileCollection.AddExtension (fileExtension, keepFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileExtension" Type="System.String" />
        <Parameter Name="keepFile" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileExtension">Extension assignée au nom de fichier temporaire généré automatiquement qui doit être ajouté à la collection.</param>
        <param name="keepFile"><see langword="true" /> si le fichier doit être conservé après utilisation ; <see langword="false" /> s'il doit être supprimé.</param>
        <summary>Ajoute à la collection un nom de fichier doté de l'extension de nom de fichier spécifiée, en utilisant la valeur spécifiée qui indique si le fichier doit être supprimé ou conservé.</summary>
        <returns>Nom de fichier doté de l'extension spécifiée qui a été ajouté à la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne un nom de fichier avec l’extension spécifiée qui a été ajouté à la collection de fichiers temporaires. Tout autre code devez toujours créer le fichier avant de pouvoir être utilisé.  
  
 Cette méthode peut être appelée qu’une seule fois pour chaque extension de nom de fichier, car elle retourne le même nom si elle est appelée avec la même extension.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="fileExtension" /> est <see langword="null" /> ou est une chaîne vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddFile">
      <MemberSignature Language="C#" Value="public void AddFile (string fileName, bool keepFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFile(string fileName, bool keepFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.AddFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFile (fileName As String, keepFile As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFile(System::String ^ fileName, bool keepFile);" />
      <MemberSignature Language="F#" Value="member this.AddFile : string * bool -&gt; unit" Usage="tempFileCollection.AddFile (fileName, keepFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="keepFile" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier à ajouter à la collection.</param>
        <param name="keepFile"><see langword="true" /> si le fichier doit être conservé après utilisation ; <see langword="false" /> s'il doit être supprimé.</param>
        <summary>Ajoute le fichier spécifié à la collection, en utilisant la valeur spécifiée qui indique si le fichier doit être supprimé ou conservé lorsque la collection est supprimée ou que la méthode <see cref="M:System.CodeDom.Compiler.TempFileCollection.Delete" /> est appelée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.CodeDom.Compiler.TempFileCollection.AddFile%28System.String%2CSystem.Boolean%29> méthode pour ajouter un fichier qui doit être conservé à la collection. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.TempFileCollection> classe.  
  
 [!code-csharp[System.CodeDom.Compiler.TempFileCollection#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CodeDom.Compiler.TempFileCollection/CS/program.cs#2)]
 [!code-vb[System.CodeDom.Compiler.TempFileCollection#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CodeDom.Compiler.TempFileCollection/VB/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="fileName" /> est <see langword="null" /> ou est une chaîne vide.  
  
ou 
 <paramref name="fileName" /> est un doublon.</exception>
      </Docs>
    </Member>
    <Member MemberName="BasePath">
      <MemberSignature Language="C#" Value="public string BasePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BasePath" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.BasePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BasePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePath : string" Usage="System.CodeDom.Compiler.TempFileCollection.BasePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin d'accès complet du nom de fichier de base, sans extension de fichier, dans le chemin d'accès du répertoire temporaire, utilisé pour générer les noms de fichiers temporaires pour la collection.</summary>
        <value>Chemin d'accès complet du nom de fichier de base, sans extension de fichier, dans le chemin d'accès du répertoire temporaire, utilisé pour générer les noms de fichiers temporaires pour la collection.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Si la valeur de la propriété <see cref="P:System.CodeDom.Compiler.TempFileCollection.BasePath" /> est <see langword="null" /> ou si elle n'a pas été définie, et que <see cref="F:System.Security.Permissions.FileIOPermissionAccess.AllAccess" /> n'est pas accordé au répertoire temporaire spécifié par la propriété <see cref="P:System.CodeDom.Compiler.TempFileCollection.TempDir" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (string[] fileNames, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(string[] fileNames, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.CopyTo(System.String[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (fileNames As String(), start As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::String ^&gt; ^ fileNames, int start);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string[] * int -&gt; unit" Usage="tempFileCollection.CopyTo (fileNames, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileNames" Type="System.String[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="fileNames">Tableau de chaînes dans lequel la copie doit être effectuée.</param>
        <param name="start">Index du tableau auquel la copie commence.</param>
        <summary>Copie les membres de la collection dans la chaîne spécifiée, en commençant à l'index indiqué.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.CodeDom.Compiler.TempFileCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de fichiers contenus dans la collection.</summary>
        <value>Nombre de fichiers de la collection.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete();" />
      <MemberSignature Language="F#" Value="member this.Delete : unit -&gt; unit" Usage="tempFileCollection.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime de cette collection les fichiers temporaires qui ont été marqués pour être supprimés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> méthode examine chaque fichier dans la collection pour déterminer de manière individuelle, si le fichier doit être conservé ou supprimé. Fichiers peuvent être marqués explicitement pour être conservés lors de l’ajout à la collection à l’aide d’ajouter des méthodes qui prennent un `keepFile` paramètre. Lorsque vous ajoutez un fichier à la collection en utilisant la <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> surcharge qui n’a pas un `keepFile` paramètre la valeur de la <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> propriété est utilisée en tant que l’indicateur de fichier par défaut keep.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="tempFileCollection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.CodeDom.Compiler.TempFileCollection" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose()` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.CodeDom.Compiler.TempFileCollection>. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution de <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implémentation d’une méthode Dispose</related>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Nettoyage de ressources non managées</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TempFileCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TempFileCollection ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tempFileCollection.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tente de supprimer les fichiers temporaires avant que cet objet ne soit récupéré par un garbage collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode remplace <xref:System.Object.Finalize%2A?displayProperty=nameWithType> et nettoie les ressources en appelant `Dispose(false)`. Substitue `Dispose(Boolean)` pour personnaliser le nettoyage.  
  
 Code d’application ne doit pas appeler cette méthode ; d’un objet `Finalize` méthode est appelée automatiquement lors du garbage collection, à moins que la finalisation par le garbage collector a été désactivée par un appel à la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations, consultez [destructeurs et méthodes Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md), et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="tempFileCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un énumérateur pouvant énumérer les membres de la collection.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> qui contient les membres de la collection.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepFiles">
      <MemberSignature Language="C#" Value="public bool KeepFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepFiles" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.KeepFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepFiles { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepFiles : bool with get, set" Usage="System.CodeDom.Compiler.TempFileCollection.KeepFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les fichiers doivent être conservés, par défaut, lors de l'appel à la méthode <see cref="M:System.CodeDom.Compiler.TempFileCollection.Delete" /> ou de la suppression de la collection.</summary>
        <value><see langword="true" /> si les fichiers doivent être conservés ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> propriété est utilisée en tant que la valeur par défaut valeur lorsque le <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> surcharge qui n’a pas un `keepFile` paramètre est appelé pour ajouter un fichier temporaire à la collection. Chaque fichier temporaire dans la collection a un indicateur de fichier conserver associé qui détermine, sur une base par fichier, si ce fichier doit être conservé ou supprimé. Fichiers sont automatiquement conservés ou supprimés à la fin de la compilation en fonction de leur valeur de fichiers conserver associé. Toutefois, une fois la compilation terminée, les fichiers qui ont été conservés peuvent être libérés en définissant <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> false et continuent d’appeler le <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> (méthode).  Ainsi, tous les fichiers en cours de suppression.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int start);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int start) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="start">Index de base zéro dans un tableau au niveau duquel commencer la copie.</param>
        <summary>Copie les éléments de la collection dans un tableau, en commençant à l'index spécifié du tableau cible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.CodeDom.Compiler.TempFileCollection> est castée en interface <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d’éléments contenus dans la collection.</summary>
        <value>Nombre d'éléments contenus dans <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.CodeDom.Compiler.TempFileCollection> est castée en interface <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l’accès à la collection est synchronisé (thread-safe).</summary>
        <value><see langword="true" /> si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe) ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.CodeDom.Compiler.TempFileCollection> est castée en interface <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui peut être utilisé pour synchroniser l’accès à la collection.</summary>
        <value>Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.CodeDom.Compiler.TempFileCollection> est castée en interface <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.CodeDom.Compiler.TempFileCollection> est castée en interface <xref:System.Collections.IEnumerable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exécute les tâches définies par l'application associées à la libération ou à la redéfinition des ressources non managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.CodeDom.Compiler.TempFileCollection> est castée en interface <xref:System.IDisposable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IDisposable.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="TempDir">
      <MemberSignature Language="C#" Value="public string TempDir { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TempDir" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.TempDir" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TempDir As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TempDir { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TempDir : string" Usage="System.CodeDom.Compiler.TempFileCollection.TempDir" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le répertoire temporaire dans lequel les fichiers temporaires doivent être stockés.</summary>
        <value>Répertoire temporaire dans lequel les fichiers doivent être stockés.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>