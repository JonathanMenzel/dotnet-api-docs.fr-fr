<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c00ef54e956a8f875ecf66668178f9222eacafe4" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36647504" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type CodeDomProvider = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une classe de base pour les implémentations de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />. Cette classe est abstraite.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.CodeDom.Compiler.CodeDomProvider> peut être utilisé pour créer et récupérer des instances de générateurs de code et des compilateurs de code. Les générateurs de code permettent de générer du code dans un langage donné, tandis que les compilateurs de code permettent de compiler du code dans des assemblys.  
  
> [!NOTE]
>  Dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], les méthodes disponibles dans le Générateur de code et du compilateur de code sont directement disponibles dans le fournisseur de code. Vous n’avez pas besoin d’appeler <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> ou <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> pour accéder aux méthodes et ces méthodes sont marquées comme obsolètes. Cela s’applique aux préexistant, ainsi que de nouvelles implémentations de fournisseur de code.  
  
 A <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation fournit généralement code code et/ou de la génération des interfaces de compilation pour la génération de code et de gestion de la compilation pour un seul langage de programmation. Plusieurs langues sont prises en charge par <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations fournies avec le [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]. Ces langages incluent c#, Visual Basic, C++ et JScript. Les développeurs ou les éditeurs de compilateurs peuvent implémenter la <xref:System.CodeDom.Compiler.ICodeGenerator> et <xref:System.CodeDom.Compiler.ICodeCompiler> interfaces et fournir un <xref:System.CodeDom.Compiler.CodeDomProvider> qui étend la prise en charge de CodeDOM à d’autres langages de programmation.  
  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration de l’ordinateur (Machine.config) de fichiers fournit un mécanisme pour les développeurs et aux fournisseurs de compilateur d’ajouter des paramètres de configuration pour supplémentaires<xref:System.CodeDom.Compiler.CodeDomProvider>implémentations.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider> classe fournit des méthodes statiques pour découvrir et énumérer les <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations sur un ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> méthode retourne les paramètres pour tous les <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations sur un ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> méthode retourne les paramètres pour un spécifique <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation, en fonction du nom de langage de programmation. Le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode retourne une instance d’un <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue spécifique.  
  
 Pour plus d’informations sur les paramètres du fournisseur de langage dans le fichier de configuration, consultez [compilateur et langage de schéma des paramètres fournisseur](http://msdn.microsoft.com/library/c020b139-8699-4f0d-9ac9-70d0c5b2a8c8).  
  
> [!NOTE]
>  Cette classe effectue une demande de liaison et une demande d’héritage au niveau de la classe. A <xref:System.Security.SecurityException> est levée si l’appelant immédiat ou la classe dérivée ne dispose pas d’autorisation de confiance totale. Pour plus d’informations sur les demandes de sécurité, consultez [les demandes de liaison](~/docs/framework/misc/link-demands.md) et [des demandes d’héritage](http://msdn.microsoft.com/library/28b9adbb-8f08-4f10-b856-dbf59eb932d9).  
  
   
  
## Examples  
 L’exemple de programme suivant peut générer et compiler le code source basé sur un modèle CodeDOM d’un programme qui imprime « Hello World » à l’aide de la <xref:System.Console> classe. Une interface utilisateur Windows Forms est fournie. L’utilisateur peut sélectionner la cible de langage à partir de plusieurs sélections de programmation : c#, Visual Basic et JScript.  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par du code partiellement fiable.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers de. Cette classe ne peut pas être héritée par du code partiellement fiable.</permission>
    <block subset="none" type="overrides">
      <para>Dans les versions 1.0 et 1.1 du .NET Framework, les fournisseurs de code se composent d’implémentations de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, <see cref="T:System.CodeDom.Compiler.ICodeParser" />, et <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />. Dans la [ ! Include[dnprdnlong](~/Includes/dnprdnlong-MD.MD)], le <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />, <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />, et <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> sont obsolètes et les méthodes de <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> et <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> sont directement disponibles dans la <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe. Vous devez substituer ces méthodes dans votre implémentation de fournisseur de code et n’appelez pas les méthodes de base.</para>
    </block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par du code partiellement fiable.</permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromDom (options, compilationUnits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Objet <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> indiquant les paramètres de la compilation.</param>
        <param name="compilationUnits">Tableau de type <see cref="T:System.CodeDom.CodeCompileUnit" /> indiquant le code à compiler.</param>
        <summary>Compile un assembly basé sur les arborescences <see cref="N:System.CodeDom" /> contenues dans le tableau d'objets <see cref="T:System.CodeDom.CodeCompileUnit" /> spécifié, à l'aide des paramètres du compilateur spécifiés.</summary>
        <returns>Objet <see cref="T:System.CodeDom.Compiler.CompilerResults" /> indiquant les résultats de la compilation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des compilateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’un compilateur de code.</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromFile (options, fileNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="fileNames" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Objet <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> indiquant les paramètres de la compilation.</param>
        <param name="fileNames">Tableau des noms des fichiers à compiler.</param>
        <summary>Compile un assembly à partir du code source contenu dans les fichiers spécifiés, à l'aide des paramètres du compilateur spécifiés.</summary>
        <returns>Objet <see cref="T:System.CodeDom.Compiler.CompilerResults" /> indiquant les résultats de la compilation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des compilateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’un compilateur de code.</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromSource (options, sources)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="sources" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Objet <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> indiquant les paramètres du compilateur pour cette compilation.</param>
        <param name="sources">Tableau de chaînes de code source à compiler.</param>
        <summary>Compile un assembly à partir du tableau de chaînes spécifié contenant le code source, à l'aide des paramètres du compilateur spécifiés.</summary>
        <returns>Objet <see cref="T:System.CodeDom.Compiler.CompilerResults" /> indiquant les résultats de la compilation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des compilateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’un compilateur de code.</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberSignature Language="F#" Value="abstract member CreateCompiler : unit -&gt; System.CodeDom.Compiler.ICodeCompiler" Usage="codeDomProvider.CreateCompiler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau compilateur de code.</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> pouvant être utilisé pour la compilation de représentations du code source basées sur <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. L’alternative recommandée consiste à appeler le <xref:System.CodeDom.Compiler.ICodeCompiler> les méthodes qui sont directement disponibles dans le fournisseur de code.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Dans la [ ! Include[dnprdnlong](~/Includes/dnprdnlong-MD.MD)], vous devez implémenter la <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> membres dans le <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe et lève un <see cref="T:System.NotSupportedException" /> lorsque cette méthode est appelée.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateEscapedIdentifier : string -&gt; string&#xA;override this.CreateEscapedIdentifier : string -&gt; string" Usage="codeDomProvider.CreateEscapedIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne pour laquelle un identificateur avec séquence d'échappement doit être créé.</param>
        <summary>Crée un identificateur avec séquence d'échappement pour la valeur spécifiée.</summary>
        <returns>Identificateur avec séquence d'échappement pour la valeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> tests si l’identificateur est en conflit avec les réservés ou des mots clés du langage et si tel est le cas, retourne un nom équivalent avec la mise en forme du code d’échappement spécifique au langage. Cela s’appelle un identificateur de séquence d’échappement. L’identificateur de séquence d’échappement contient la même `value` mais est mise en forme du code d’échappement ajoutée afin de différencier l’identificateur du mot clé. Deux exemples d’implémentation précèdent la `value` avec « @ » ou mettent entre crochets le `value` avec » [ » et «] ».  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : unit -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code.</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> pouvant être utilisé pour générer des représentations du code source basées sur <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. L’alternative recommandée consiste à appeler la <xref:System.CodeDom.Compiler.ICodeGenerator> les méthodes qui sont directement disponibles dans la <xref:System.CodeDom.Compiler.CodeDomProvider> classe.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Dans la [ ! Include[dnprdnlong](~/Includes/dnprdnlong-MD.MD)], vous devez implémenter la <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> membres dans le <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe et lève un <see cref="T:System.NotSupportedException" /> lorsque cette méthode est appelée.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> à utiliser pour effectuer la sortie.</param>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code à l'aide du <see cref="T:System.IO.TextWriter" /> spécifié pour la sortie.</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> pouvant être utilisé pour générer des représentations du code source basées sur <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise le <xref:System.IO.TextWriter> pour la sortie. Cette méthode prend en charge la génération de code optimisé plus que de façon incrémentielle met à jour le code source.  
  
> [!NOTE]
>  L’implémentation de classe de base appelle la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> (méthode), qui est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] et entraîne une <xref:System.NotSupportedException> si un <xref:System.CodeDom.Compiler.ICodeGenerator> objet n’est retourné.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier vers lequel effectuer la sortie.</param>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code à l'aide du nom de fichier spécifié pour la sortie.</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> pouvant être utilisé pour générer des représentations du code source basées sur <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise le nom de fichier spécifié pour la sortie.  
  
> [!NOTE]
>  L’implémentation de classe de base appelle la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> (méthode), qui est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] et entraîne une <xref:System.NotSupportedException> si un <xref:System.CodeDom.Compiler.ICodeGenerator> objet n’est retourné.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberSignature Language="F#" Value="abstract member CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser&#xA;override this.CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser" Usage="codeDomProvider.CreateParser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouvel analyseur de code.</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeParser" /> pouvant être utilisé pour analyser le code source. L'implémentation de base retourne toujours <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> pour le langage spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">Nom du langage.</param>
        <summary>Crée une instance de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> pour le langage spécifié.</summary>
        <returns>Fournisseur CodeDOM  qui est implémentée pour le nom du langage spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode est généralement utilisée pour créer une instance d’un fournisseur de code dans une application qui peut utiliser un des fournisseurs. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> vous permet de spécifier au moment de l’exécution, le fournisseur de code que vous souhaitez instancier. Si vous connaissez au moment du design quel code fournisseur doit être utilisé, vous devez créer une instance de ce fournisseur de code plutôt que d’utiliser le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> (méthode).  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode retourne un <xref:System.CodeDom.Compiler.CodeDomProvider> de l’instance pour un nom de langage spécifique ; elle est similaire à l’appel du <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> méthode avec le type de fournisseur de langage. Utilisez <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> lorsque vous souhaitez rechercher dynamiquement une implémentation de fournisseur configurée pour un nom de langue.  
  
 Si plusieurs implémentations de fournisseur sont configurée pour le nom de la langue, <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> retourne une instance de fournisseur pour le dernier élément de configuration correspondant.  
  
 Utilisez le <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> surcharge de méthode lorsque vous souhaitez une implémentation de fournisseur de langage spécifique. Par exemple, utiliser le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode pour obtenir une instance de fournisseur qui prend en charge le nom du langage `"CSharp"`; utiliser le <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> surcharge de méthode pour obtenir une instance de fournisseur spécifiquement pour le <xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType> implémentation. Vous devez utiliser le [\], CultureInfo, objet\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D% 2CSystem.Globalization.CultureInfo%2CSystem.Object%5B%5D%29?displayProperty=nameWithType > méthode si vous disposez de plusieurs fournisseurs de code pour un langage et que vous souhaitez instancier un fournisseur de code spécifique.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> méthode vérifie si au moins une implémentation de fournisseur prend en charge une langue spécifique. Vous pouvez valider un nom de langue à l’aide de <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> avant leur transmission à <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>. Si vous passez un nom de langage non pris en charge pour <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> un <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> est levée.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> méthode peut être utilisée pour déterminer toutes les <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations sur un ordinateur, y compris les implémentations supplémentaires fournies par les développeurs et les fournisseurs de compilateur qui sont identifiées dans le [ &lt;system.codedom &gt; Élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans le fichier de configuration de l’ordinateur (Machine.config).  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode retourne une instance d’un <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue spécifique.  
  
 Noms de langue respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue d’entrée et affiche les paramètres configurés pour le fournisseur de langage. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Le <paramref name="language" /> n'a pas de fournisseur configuré sur cet ordinateur.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="language" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider (language, providerOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="language">Nom du langage.</param>
        <param name="providerOptions">Collection d'options de fournisseur issue du fichier de configuration.</param>
        <summary>Obtient une instance <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> pour le langage et les options de fournisseur spécifiés.</summary>
        <returns>Fournisseur CodeDOM implémenté pour le nom de langage et les options spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode est généralement utilisée pour créer une instance d’un fournisseur de code dans une application qui peut utiliser un des fournisseurs. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> permet de spécifier au moment de l’exécution de la version du fournisseur de code que vous souhaitez instancier. Si vous connaissez au moment du design quel code fournisseur doit être utilisé, vous devez créer une instance de ce fournisseur de code au lieu d’utiliser le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> (méthode).  
  
 Utilisez <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> lorsque vous souhaitez rechercher dynamiquement une implémentation de fournisseur configurée pour une langue spécifique et les options. Noms de langue respectent la casse. Pour plus d’informations sur les options de fournisseur prises en charge, consultez la documentation du fournisseur CodeDOM spécifique.  
  
 Pour plus d’informations sur la validation d’un fournisseur et l’appel d’un fournisseur si plusieurs implémentations de fournisseur sont configurée pour le nom du langage, consultez la section Notes de la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une instance d’un fournisseur à l’aide de le `providerOptions` paramètre.  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateValidIdentifier : string -&gt; string&#xA;override this.CreateValidIdentifier : string -&gt; string" Usage="codeDomProvider.CreateValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne pour laquelle un identificateur valide doit être généré.</param>
        <summary>Crée un identificateur valide pour la valeur spécifiée.</summary>
        <returns>Identificateur valide pour la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> Teste si l’identificateur est en conflit avec réservés ou des mots clés du langage, et le cas échéant, tente de retourner un identificateur valide nom qui n’est pas en conflit. Généralement l’identificateur retourné est légèrement modifié pour différencier l’identificateur du mot clé ; par exemple, le nom peut être précédé par le caractère de soulignement (« _ »).  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FileExtension : string" Usage="System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit l'extension du nom de fichier par défaut à utiliser pour les fichiers de code source dans le langage actuel.</summary>
        <value>Extension du nom de fichier correspondant à l'extension des fichiers sources du langage actuel. L'implémentation de base retourne toujours <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est utilisée par les générateurs de code et des compilateurs de code pour indiquer les extensions de fichier doivent être générées ou a utilisée.  
  
   
  
## Examples  
 L’exemple de code suivant crée une instance de <xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>. L’exemple affiche le nom du fournisseur, le hachage par défaut et le code d’extension de fichier pour la nouvelle instance de fournisseur.  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromCompileUnit (compileUnit, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="compileUnit">
          <see cref="T:System.CodeDom.CodeCompileUnit" /> pour lequel du code doit être généré.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour l'unité de compilation CodeDOM (Code Document Object Model) spécifiée et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A> méthode pour générer du code pour une application « Hello World » à partir d’un <xref:System.CodeDom.CodeCompileUnit>. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CodeDomProvider> classe.  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromExpression (expression, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="expression">Objet <see cref="T:System.CodeDom.CodeExpression" /> indiquant l'expression pour laquelle du code doit être généré.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour l'expression CodeDOM (Code Document Object Model) spécifiée et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromMember (member, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="member">Objet <see cref="T:System.CodeDom.CodeTypeMember" /> indiquant le membre pour lequel du code doit être généré.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour la déclaration de membre CodeDOM (Code Document Object Model) spécifiée et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de classe de base lève une <xref:System.NotImplementedException>. Consultez <xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType> pour obtenir la documentation décrivant une implémentation de cette méthode.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> la méthode implémentée par le <xref:Microsoft.CSharp.CSharpCodeProvider> et <xref:Microsoft.VisualBasic.VBCodeProvider> classes.  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Cette méthode n'est pas substituée dans une classe dérivée.</exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromNamespace (codeNamespace, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">Objet <see cref="T:System.CodeDom.CodeNamespace" /> indiquant l'espace de noms pour lequel du code doit être généré.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour l'espace de noms CodeDOM (Code Document Object Model) spécifié et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromStatement (statement, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="statement">
          <see cref="T:System.CodeDom.CodeStatement" /> qui contient les éléments CodeDOM pour lesquels du code doit être généré.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour l'instruction CodeDOM (Code Document Object Model) spécifiée et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromType (codeType, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeType">Objet <see cref="T:System.CodeDom.CodeTypeDeclaration" /> indiquant le type pour lequel du code doit être généré.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour la déclaration de type CodeDOM (Code Document Object Model) spécifiée et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberSignature Language="F#" Value="static member GetAllCompilerInfo : unit -&gt; System.CodeDom.Compiler.CompilerInfo[]" Usage="System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le fournisseur de langages et les paramètres de configuration de compilateur pour cet ordinateur.</summary>
        <returns>Tableau de type <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> qui représente les paramètres de toutes les implémentations de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> configurées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> méthode pour énumérer les paramètres du fournisseur de langue sur un ordinateur.  
  
> [!NOTE]
>  Dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], les fournisseurs de langages par défaut fournis par le .NET Framework ne sont pas spécifiés dans le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) configuration de compilateur section et ne peut pas être supprimé, par conséquent cette méthode retourne des informations sur les fournisseurs par défaut et tout spécifié dans le fichier de configuration.  
  
   
  
## Examples  
 L’exemple de code suivant énumère les fournisseurs de langages sur l’ordinateur et affiche les paramètres de configuration et de compilateur pour chaque fournisseur de langage. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member GetCompilerInfo : string -&gt; System.CodeDom.Compiler.CompilerInfo" Usage="System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">Nom de langage.</param>
        <summary>Retourne le fournisseur de langages et les paramètres de configuration de compilateur pour le langage spécifié.</summary>
        <returns>Objet <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> rempli avec les paramètres de l'implémentation de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> configurée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration de l’ordinateur le fichier contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur l’ordinateur. Pour plus d’informations sur les fichiers de configuration machine, consultez la section des fichiers de Configuration Machine dans [configuration des applications](http://msdn.microsoft.com/library/86bd26d3-737e-4484-9782-19b17f34cd1f). Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> méthode recherche chaque élément de configuration de fournisseur pour le nom de la langue spécifiée. Retourné <xref:System.CodeDom.Compiler.CompilerInfo> instance contient les paramètres de langue configuré pour le compilateur et du fournisseur.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> méthode vérifie si au moins une implémentation de fournisseur prend en charge une langue spécifique. Vous pouvez valider un nom de langue à l’aide de <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> avant leur transmission à <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>. Cela empêche la levée d’une <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> quand vous accédez à la <xref:System.CodeDom.Compiler.CompilerInfo> instance pour un nom de langage non pris en charge.  
  
 Si plusieurs implémentations de fournisseur sont configurée pour le nom de la langue d’entrée, <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> renvoie les paramètres du fournisseur correspondant dernier élément de configuration.  
  
 Noms de langue respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue d’entrée et affiche les paramètres configurés pour le fournisseur de langage. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">Le <paramref name="language" /> n'a pas de fournisseur configuré sur cet ordinateur.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="language" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetConverter : Type -&gt; System.ComponentModel.TypeConverter&#xA;override this.GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="codeDomProvider.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Type d'objet pour lequel un convertisseur de type doit être récupéré.</param>
        <summary>Obtient <see cref="T:System.ComponentModel.TypeConverter" /> pour le type de données spécifié.</summary>
        <returns>
          <see cref="T:System.ComponentModel.TypeConverter" /> pour le type spécifié, ou <see langword="null" /> si aucun <see cref="T:System.ComponentModel.TypeConverter" /> n'est trouvé pour le type spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une classe dérivée peut substituer cette méthode pour fournir des types spécifiques de convertisseurs de type pour les types de données spécifiques.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member GetLanguageFromExtension : string -&gt; string" Usage="System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">Extension de nom de fichier.</param>
        <summary>Retourne un nom de langage associé à l'extension de nom de fichier spécifiée, comme configuré dans la section de configuration de compilateur <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <returns>Nom de langage associé à l'extension de nom de fichier, comme configuré dans les paramètres de configuration de compilateur <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur fichier (Machine.config) contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur le ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> méthode recherche chaque élément de configuration de fournisseur pour l’extension de nom de fichier spécifié.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> méthode vérifie si au moins une implémentation de fournisseur prend en charge une extension de nom de fichier spécifique. Vous pouvez valider une extension de nom de fichier à l’aide <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> avant leur transmission à <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>. Cela empêche <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> de lever une <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> pour une extension de nom de fichier non pris en charge.  
  
 Si une implémentation de fournisseur prend en charge l’extension de nom de fichier d’entrée et il existe plusieurs langues prises en charge configurés pour ce fournisseur, puis <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> retourne le premier nom de langage pour ce fournisseur. Si plusieurs implémentations de fournisseur sont configurée pour l’extension de nom de fichier d’entrée, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> renvoie le nom de la langue du fournisseur correspondant dernier élément de configuration.  
  
 Noms de langue et les extensions de nom de fichier respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une extension de nom de fichier d’entrée et affiche les paramètres configurés pour le fournisseur de langage. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">Le <paramref name="extension" /> n'a pas de fournisseur de langages configuré sur cet ordinateur.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="extension" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string&#xA;override this.GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string" Usage="codeDomProvider.GetTypeOutput type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.CodeDom.CodeTypeReference" /> qui indique le type à retourner.</param>
        <summary>Obtient le type indiqué par le <see cref="T:System.CodeDom.CodeTypeReference" /> spécifié.</summary>
        <returns>Représentation textuelle du type spécifié, mise en forme pour le langage dans lequel du code est généré par ce générateur de code. En Visual Basic, par exemple, passer <see cref="T:System.CodeDom.CodeTypeReference" /> pour le type <see cref="T:System.Int32" /> retourne "Integer".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member IsDefinedExtension : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">Extension de nom de fichier.</param>
        <summary>Vérifie si une implémentation de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> configurée sur l'ordinateur est associée à une extension de nom de fichier.</summary>
        <returns>
          <see langword="true" /> si une implémentation de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> est configurée pour l'extension de nom de fichier spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur fichier (Machine.config) contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur le ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> méthode recherche les éléments de configuration de fournisseur pour l’extension de nom de fichier spécifié.  
  
 Extensions de nom de fichier respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une extension de nom de fichier d’entrée et affiche les paramètres configurés pour le fournisseur de langage. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="extension" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member IsDefinedLanguage : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">Nom du langage.</param>
        <summary>Vérifie si un langage dispose d'une implémentation de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> configurée sur l'ordinateur.</summary>
        <returns>
          <see langword="true" /> si une implémentation de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> est configurée pour le langage spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur fichier (Machine.config) contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur le ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> méthode recherche les éléments de configuration de fournisseur pour le nom de la langue spécifiée.  
  
 Noms de langue respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue d’entrée et affiche les paramètres configurés pour le fournisseur de langage. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="language" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValidIdentifier : string -&gt; bool&#xA;override this.IsValidIdentifier : string -&gt; bool" Usage="codeDomProvider.IsValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à vérifier comme identificateur valide.</param>
        <summary>Retourne une valeur indiquant si la valeur spécifiée est un identificateur valide pour le langage actuel.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> est un identificateur valide ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode vérifie si un identificateur est valide. Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A> méthode est spécifique au fournisseur. Les identificateurs qui sont valides pour un fournisseur n’est peut-être pas valides pour les autres fournisseurs. Si `value` contient des caractères en dehors de la plage de caractères ASCII, vérifiez l’identificateur pour toutes les langues qui pourraient être utilisées pour compiler le code.  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" /> dans une classe dérivée, concevez le retour de la méthode <see langword="true" /> uniquement si la valeur respecte les règles du langage et n’est pas en conflit avec un mot clé.  Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOptions : System.CodeDom.Compiler.LanguageOptions" Usage="System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un identificateur de fonctionnalités de langage.</summary>
        <value>
          <see cref="T:System.CodeDom.Compiler.LanguageOptions" /> qui indique les fonctionnalités spéciales du langage.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberSignature Language="F#" Value="abstract member Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit&#xA;override this.Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomProvider.Parse codeStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="codeStream">Objet <see cref="T:System.IO.TextReader" /> utilisé pour lire le code à analyser.</param>
        <summary>Compile le code lu à partir du flux de texte spécifié dans <see cref="T:System.CodeDom.CodeCompileUnit" />.</summary>
        <returns>
          <see cref="T:System.CodeDom.CodeCompileUnit" /> contenant une représentation du code analysé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeParser> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeParser> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un analyseur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des analyseurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeParser" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’analyseur de code.</para>
        </block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports supports" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">To be added.</param>
        <param name="supports">To be added.</param>
        <summary>Retourne une valeur indiquant si la prise en charge de la génération de code spécifiée est fournie.</summary>
        <returns>
          <see langword="true" /> si la prise en charge de la génération de code spécifiée est fournie ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée avec un nombre de <xref:System.CodeDom.Compiler.GeneratorSupport> indicateurs en une seule fois à un ensemble de fonctionnalités de test en joignant un ensemble d’indicateurs appropriés ainsi que d’un fichier binaire `OR` (opérateur) (&#124;).  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même s’il n’est pas remplacé par le fournisseur de code. Si le fournisseur de code ne substitue pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides">
          <para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtenez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>