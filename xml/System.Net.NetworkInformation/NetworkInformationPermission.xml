<Type Name="NetworkInformationPermission" FullName="System.Net.NetworkInformation.NetworkInformationPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f7e49c104db0648ce7487440f3dd8fc8c06d8693" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39987930" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NetworkInformationPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit NetworkInformationPermission extends System.Security.CodeAccessPermission implements class System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="DocId" Value="T:System.Net.NetworkInformation.NetworkInformationPermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NetworkInformationPermission&#xA;Inherits CodeAccessPermission&#xA;Implements IUnrestrictedPermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetworkInformationPermission sealed : System::Security::CodeAccessPermission, System::Security::Permissions::IUnrestrictedPermission" />
  <TypeSignature Language="F#" Value="type NetworkInformationPermission = class&#xA;    inherit CodeAccessPermission&#xA;    interface IUnrestrictedPermission" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.CodeAccessPermission</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.Permissions.IUnrestrictedPermission</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Contrôle l'accès aux informations réseau et aux statistiques de trafic pour l'ordinateur local. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette autorisation est utilisée pour sécuriser les données retournées par les classes dans le <xref:System.Net.NetworkInformation> espace de noms.  
  
 Pour la sécurité déclarative, utilisez la <xref:System.Net.NetworkInformation.NetworkInformationPermissionAttribute> classe.  
  
   
  
## Examples  
 L’exemple suivant crée un objet d’autorisation illimitée.  
  
 [!code-cpp[NclNetworkInfoPerms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNetworkInfoPerms/CPP/NclNetworkInfoPerms.cpp#1)]
 [!code-csharp[NclNetworkInfoPerms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNetworkInfoPerms/CS/permissionexample.cs#1)]
 [!code-vb[NclNetworkInfoPerms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNetworkInfoPerms/VB/permissionexample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.NetworkInformation.NetworkInformationPermission" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkInformationPermission (System.Net.NetworkInformation.NetworkInformationAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.NetworkInformation.NetworkInformationAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.NetworkInformation.NetworkInformationPermission.#ctor(System.Net.NetworkInformation.NetworkInformationAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (access As NetworkInformationAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkInformationPermission(System::Net::NetworkInformation::NetworkInformationAccess access);" />
      <MemberSignature Language="F#" Value="new System.Net.NetworkInformation.NetworkInformationPermission : System.Net.NetworkInformation.NetworkInformationAccess -&gt; System.Net.NetworkInformation.NetworkInformationPermission" Usage="new System.Net.NetworkInformation.NetworkInformationPermission access" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="access" Type="System.Net.NetworkInformation.NetworkInformationAccess" />
      </Parameters>
      <Docs>
        <param name="access">Une des valeurs de <see cref="T:System.Net.NetworkInformation.NetworkInformationAccess" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.NetworkInformation.NetworkInformationPermission" /> avec la valeur <see cref="T:System.Net.NetworkInformation.NetworkInformationAccess" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’autorisation créée par ce constructeur peut être utilisée pour sécuriser l’accès aux informations réseau.  
  
   
  
## Examples  
 L’exemple suivant crée un objet d’autorisation qui contrôle l’accès aux informations réseau.  
  
 [!code-cpp[NclNetworkInfoPerms#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNetworkInfoPerms/CPP/NclNetworkInfoPerms.cpp#3)]
 [!code-csharp[NclNetworkInfoPerms#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNetworkInfoPerms/CS/permissionexample.cs#3)]
 [!code-vb[NclNetworkInfoPerms#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNetworkInfoPerms/VB/permissionexample.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkInformationPermission (System.Security.Permissions.PermissionState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Permissions.PermissionState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.NetworkInformation.NetworkInformationPermission.#ctor(System.Security.Permissions.PermissionState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As PermissionState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetworkInformationPermission(System::Security::Permissions::PermissionState state);" />
      <MemberSignature Language="F#" Value="new System.Net.NetworkInformation.NetworkInformationPermission : System.Security.Permissions.PermissionState -&gt; System.Net.NetworkInformation.NetworkInformationPermission" Usage="new System.Net.NetworkInformation.NetworkInformationPermission state" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Security.Permissions.PermissionState" />
      </Parameters>
      <Docs>
        <param name="state">Une des valeurs de <see cref="T:System.Security.Permissions.PermissionState" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.NetworkInformation.NetworkInformationPermission" /> avec le <see cref="T:System.Security.Permissions.PermissionState" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’autorisation créée par ce constructeur peut être utilisée pour sécuriser l’accès aux informations réseau.  
  
   
  
## Examples  
 L’exemple suivant crée un objet d’autorisation illimitée.  
  
 [!code-cpp[NclNetworkInfoPerms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNetworkInfoPerms/CPP/NclNetworkInfoPerms.cpp#1)]
 [!code-csharp[NclNetworkInfoPerms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNetworkInfoPerms/CS/permissionexample.cs#1)]
 [!code-vb[NclNetworkInfoPerms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNetworkInfoPerms/VB/permissionexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Access">
      <MemberSignature Language="C#" Value="public System.Net.NetworkInformation.NetworkInformationAccess Access { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.NetworkInformation.NetworkInformationAccess Access" />
      <MemberSignature Language="DocId" Value="P:System.Net.NetworkInformation.NetworkInformationPermission.Access" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Access As NetworkInformationAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::NetworkInformation::NetworkInformationAccess Access { System::Net::NetworkInformation::NetworkInformationAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.Access : System.Net.NetworkInformation.NetworkInformationAccess" Usage="System.Net.NetworkInformation.NetworkInformationPermission.Access" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.NetworkInformation.NetworkInformationAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le niveau d'accès aux informations réseau contrôlé par cette autorisation.</summary>
        <value>Une des valeurs de <see cref="T:System.Net.NetworkInformation.NetworkInformationAccess" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Net.NetworkInformation.NetworkInformationPermission> créé avec <xref:System.Security.Permissions.PermissionState.Unrestricted?displayProperty=nameWithType> porte <xref:System.Net.NetworkInformation.NetworkInformationAccess.Ping> &#124; <xref:System.Net.NetworkInformation.NetworkInformationAccess.Read> accès. Un <xref:System.Net.NetworkInformation.NetworkInformationPermission> créé avec <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType> porte <xref:System.Net.NetworkInformation.NetworkInformationAccess.None> accès.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.NetworkInformation.NetworkInformationPermission>, ajoute un <xref:System.Net.NetworkInformation.NetworkInformationAccess> valeur et affiche la valeur de cette propriété.  
  
 [!code-cpp[NclNetworkInfoPerms#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNetworkInfoPerms/CPP/NclNetworkInfoPerms.cpp#7)]
 [!code-csharp[NclNetworkInfoPerms#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNetworkInfoPerms/CS/permissionexample.cs#7)]
 [!code-vb[NclNetworkInfoPerms#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNetworkInfoPerms/VB/permissionexample.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPermission">
      <MemberSignature Language="C#" Value="public void AddPermission (System.Net.NetworkInformation.NetworkInformationAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPermission(valuetype System.Net.NetworkInformation.NetworkInformationAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.NetworkInformation.NetworkInformationPermission.AddPermission(System.Net.NetworkInformation.NetworkInformationAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPermission (access As NetworkInformationAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPermission(System::Net::NetworkInformation::NetworkInformationAccess access);" />
      <MemberSignature Language="F#" Value="member this.AddPermission : System.Net.NetworkInformation.NetworkInformationAccess -&gt; unit" Usage="networkInformationPermission.AddPermission access" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="access" Type="System.Net.NetworkInformation.NetworkInformationAccess" />
      </Parameters>
      <Docs>
        <param name="access">Une des valeurs de <see cref="T:System.Net.NetworkInformation.NetworkInformationAccess" />.</param>
        <summary>Ajoute la valeur spécifiée à cette autorisation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour modifier l’accès aux informations réseau en ajoutant à l’état de l’autorisation actuelle.  
  
   
  
## Examples  
 L’exemple suivant crée un objet d’autorisation vide et comment ajoute à celle-ci.  
  
 [!code-cpp[NclNetworkInfoPerms#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNetworkInfoPerms/CPP/NclNetworkInfoPerms.cpp#7)]
 [!code-csharp[NclNetworkInfoPerms#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNetworkInfoPerms/CS/permissionexample.cs#7)]
 [!code-vb[NclNetworkInfoPerms#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNetworkInfoPerms/VB/permissionexample.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.NetworkInformation.NetworkInformationPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission&#xA;override this.Copy : unit -&gt; System.Security.IPermission" Usage="networkInformationPermission.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée et retourne une copie identique de cette autorisation.</summary>
        <returns>
          <see cref="T:System.Net.NetworkInformation.NetworkInformationPermission" /> qui est identique à l'autorisation en cours.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une copie d’une autorisation représente le même accès aux ressources que l’autorisation d’origine.  
  
   
  
## Examples  
 L’exemple suivant crée la copie d’un objet d’autorisation.  
  
 [!code-cpp[NclNetworkInfoPerms#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNetworkInfoPerms/CPP/NclNetworkInfoPerms.cpp#4)]
 [!code-csharp[NclNetworkInfoPerms#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNetworkInfoPerms/CS/permissionexample.cs#4)]
 [!code-vb[NclNetworkInfoPerms#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNetworkInfoPerms/VB/permissionexample.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public override void FromXml (System.Security.SecurityElement securityElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXml(class System.Security.SecurityElement securityElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.NetworkInformation.NetworkInformationPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXml(System::Security::SecurityElement ^ securityElement);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit&#xA;override this.FromXml : System.Security.SecurityElement -&gt; unit" Usage="networkInformationPermission.FromXml securityElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityElement" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="securityElement">
          <see cref="T:System.Security.SecurityElement" /> qui contient l'encodage XML à utiliser pour définir l'état de l'autorisation actuelle.</param>
        <summary>Définit l'état de cette autorisation à l'aide de l'encodage XML spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée par le système de sécurité et n’est normalement pas appelée par le code d’application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityElement" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="securityElement" /> n'est pas un encodage d'autorisation.  
  
- ou - 
 <paramref name="securityElement" /> n'est pas un encodage d'un <see cref="T:System.Net.NetworkInformation.NetworkInformationPermission" />.  
  
- ou - 
 <paramref name="securityElement" /> a des valeurs <see cref="T:System.Net.NetworkInformation.NetworkInformationAccess" /> non valides.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.NetworkInformation.NetworkInformationPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="networkInformationPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Security.IPermission" /> à intersecter avec l'autorisation en cours. Elle doit être du même type que l’autorisation actuelle.</param>
        <summary>Crée et retourne une autorisation qui constitue l’intersection entre l’autorisation actuelle et l’autorisation spécifiée.</summary>
        <returns>
          <see cref="T:System.Net.NetworkInformation.NetworkInformationPermission" /> qui représente l'intersection entre l'autorisation en cours et l'autorisation spécifiée. Cette nouvelle autorisation est <see langword="null" /> si l'intersection est vide ou si <paramref name="target" /> est <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’intersection de deux autorisations est une autorisation qui décrit l’état qu’elles décrivent en commun. Seule une demande qui passe les deux autorisations d’origine transmettra l’intersection.  
  
   
  
## Examples  
 L’exemple suivant crée un objet d’autorisation qui est l’intersection des objets d’autorisation existants.  
  
 [!code-cpp[NclNetworkInfoPerms#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNetworkInfoPerms/CPP/NclNetworkInfoPerms.cpp#6)]
 [!code-csharp[NclNetworkInfoPerms#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNetworkInfoPerms/CS/permissionexample.cs#6)]
 [!code-vb[NclNetworkInfoPerms#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNetworkInfoPerms/VB/permissionexample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> n'est pas un <see cref="T:System.Net.NetworkInformation.NetworkInformationPermission" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public override bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.NetworkInformation.NetworkInformationPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool&#xA;override this.IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="networkInformationPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Security.IPermission" /> qui doit être testé pour la relation de sous-ensemble. Cette autorisation doit être du même type que l'autorisation en cours.</param>
        <summary>Détermine si l’autorisation actuelle est un sous-ensemble de l’autorisation spécifiée.</summary>
        <returns>
          <see langword="true" /> si l'autorisation en cours est un sous-ensemble de l'autorisation spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’autorisation actuelle est un sous-ensemble de l’autorisation spécifiée si l’autorisation en cours spécifie un état qui est entièrement contenu par l’autorisation spécifiée. Si cette méthode retourne la valeur true, l’autorisation en cours ne représente aucun plus d’accès à la ressource protégée que l’autorisation spécifiée.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la relation de sous-ensemble entre deux autorisations.  
  
 [!code-cpp[NclNetworkInfoPerms#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNetworkInfoPerms/CPP/NclNetworkInfoPerms.cpp#5)]
 [!code-csharp[NclNetworkInfoPerms#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNetworkInfoPerms/CS/permissionexample.cs#5)]
 [!code-vb[NclNetworkInfoPerms#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNetworkInfoPerms/VB/permissionexample.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnrestricted">
      <MemberSignature Language="C#" Value="public bool IsUnrestricted ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsUnrestricted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.NetworkInformation.NetworkInformationPermission.IsUnrestricted" />
      <MemberSignature Language="VB.NET" Value="Public Function IsUnrestricted () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsUnrestricted();" />
      <MemberSignature Language="F#" Value="abstract member IsUnrestricted : unit -&gt; bool&#xA;override this.IsUnrestricted : unit -&gt; bool" Usage="networkInformationPermission.IsUnrestricted " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si l’autorisation actuelle est illimitée.</summary>
        <returns>
          <see langword="true" /> si l'autorisation en cours est illimitée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une autorisation illimitée est créée à l’aide de la <xref:System.Net.NetworkInformation.NetworkInformationPermission.%23ctor%2A> constructeur.  
  
   
  
## Examples  
 L’exemple suivant crée un objet d’autorisation et affiche son état.  
  
 [!code-cpp[NclNetworkInfoPerms#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNetworkInfoPerms/CPP/NclNetworkInfoPerms.cpp#2)]
 [!code-csharp[NclNetworkInfoPerms#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNetworkInfoPerms/CS/permissionexample.cs#2)]
 [!code-vb[NclNetworkInfoPerms#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNetworkInfoPerms/VB/permissionexample.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public override System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.NetworkInformation.NetworkInformationPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement&#xA;override this.ToXml : unit -&gt; System.Security.SecurityElement" Usage="networkInformationPermission.ToXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un encodage XML de l'état de cette autorisation.</summary>
        <returns>
          <see cref="T:System.Security.SecurityElement" /> qui contient l'encodage XML de l'autorisation en cours.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée par le système de sécurité et n’est normalement pas appelée par le code d’application.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.NetworkInformation.NetworkInformationPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="networkInformationPermission.Union target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorisation <see cref="T:System.Net.NetworkInformation.NetworkInformationPermission" /> à combiner avec l'autorisation en cours.</param>
        <summary>Crée une autorisation qui est l'union entre cette autorisation et l'autorisation spécifiée.</summary>
        <returns>Nouvelle autorisation qui représente l’union de l’autorisation actuelle et de l’autorisation spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.NetworkInformation.NetworkInformationPermission.Union%2A> méthode retourne une autorisation qui représente tous les États représentés par l’autorisation actuelle et l’autorisation spécifiée. Toutes les demandes qui transmet une autorisation passent leur union.  
  
   
  
## Examples  
 L’exemple suivant crée un objet d’autorisation qui est l’union des objets d’autorisation existants.  
  
 [!code-cpp[NclNetworkInfoPerms#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNetworkInfoPerms/CPP/NclNetworkInfoPerms.cpp#5)]
 [!code-csharp[NclNetworkInfoPerms#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNetworkInfoPerms/CS/permissionexample.cs#5)]
 [!code-vb[NclNetworkInfoPerms#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNetworkInfoPerms/VB/permissionexample.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>