<Type Name="SpeechEventInfo" FullName="System.Speech.Synthesis.TtsEngine.SpeechEventInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3b02f757d0ac69721fd31393c982cf1de0a57791" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37755318" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct SpeechEventInfo : IEquatable&lt;System.Speech.Synthesis.TtsEngine.SpeechEventInfo&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit SpeechEventInfo extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Speech.Synthesis.TtsEngine.SpeechEventInfo&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" />
  <TypeSignature Language="VB.NET" Value="Public Structure SpeechEventInfo&#xA;Implements IEquatable(Of SpeechEventInfo)" />
  <TypeSignature Language="C++ CLI" Value="public value class SpeechEventInfo : IEquatable&lt;System::Speech::Synthesis::TtsEngine::SpeechEventInfo&gt;" />
  <TypeSignature Language="F#" Value="type SpeechEventInfo = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Speech.Synthesis.TtsEngine.SpeechEventInfo&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ImmutableObject(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Utilisé pour spécifier le type d’événement et ses arguments (le cas échéant) à générer dans le cadre de la restitution de la conversion de texte par synthèse vocale par un moteur de synthèse vocal personnalisé.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un moteur de synthèse vocale personnalisée demande la génération d’événements sous la plateforme de reconnaissance vocale en fournissant un approprié <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> l’instance à <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite.AddEvents%2A> membre de la <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite> objet de site du moteur passé aux implémentations de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak%2A>, <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.AddLexicon%2A>, et <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.RemoveLexicon%2A>.  
  
   
  
## Examples  
 L’exemple ci-dessous fait partie d’une implémentation de synthèse vocale personnalisée héritant de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml>et à l’aide de l’utilisation de <xref:System.Speech.Synthesis.TtsEngine.TextFragment>, <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo>, <xref:System.Speech.Synthesis.TtsEngine.FragmentState>, et <xref:System.Speech.Synthesis.TtsEngine.TtsEventId>  
  
 L’implémentation de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak%2A>  
  
1.  Reçoit un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances et crée un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances à passer à la `Speak` méthode sur un moteur de synthèse sous-jacents.  
  
2.  Si le <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction> valeur d’énumération par trouvé à partir de la <xref:System.Speech.Synthesis.TtsEngine.FragmentState.Action%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.FragmentState> retourné par la <xref:System.Speech.Synthesis.TtsEngine.TextFragment.State%2A> propriété de chaque <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instance est <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction.Speak>, l’implémentation  
  
    -   Traduit Americanism à Britishisms dans le texte à énoncer.  
  
    -   Si le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite.EventInterest%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite> fournis à la prise en charge de l’implémentation des interfaces le <xref:System.Speech.Synthesis.TtsEngine.TtsEventId.WordBoundary> type d’événement, un <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> instance est utilisée pour créer un événement au lecteur une jauge de progression du synthétiseur est créée.  
  
3.  Un moteur de rendu de reconnaissance vocale est ensuite appelé avec le texte modifié <xref:System.Speech.Synthesis.TtsEngine.TextFragment> tableau.  
  
```  
private const int WordBoundaryFlag = 1 << (int)TtsEventId.WordBoundary;  
private readonly char[] spaces = new char[] { ' ', '\t', '\r', '\n' };  
internal struct UsVsUk  
{  
  internal string UK;  
  internal string US;  
}  
  
override public void Speak (TextFragment [] frags, IntPtr wfx, ITtsEngineSite site)  
{  
  TextFragment [] newFrags=new TextFragment[frags.Length];  
  
  for (int i=0;i<frags.Length;i++){  
    newFrags[i].State=frags[i].State;  
    //truncate  
    newFrags[i].TextToSpeak = frags[i].TextToSpeak.Substring(frags[i].TextOffset,  
                               frags[i].TextLength);  
    newFrags[i].TextLength = newFrags[i].TextToSpeak.Length;  
    newFrags[i].TextOffset = 0;  
    if (newFrags[i].State.Action == TtsEngineAction.Speak) {  
      //Us to UK conversion  
      foreach (UsVsUk term in TransList) {  
      newFrags[i].TextToSpeak.Replace(term.US, term.UK);  
      }  
      //Generate progress meter events if supported  
      if ((site.EventInterest & WordBoundaryFlag) != 0) {  
      string[] subs = newFrags[i].TextToSpeak.Split(spaces);  
  
      foreach (string s in subs) {  
        int offset = newFrags[i].TextOffset;  
        SpeechEventInfo spEvent = new SpeechEventInfo((Int16)TtsEventId.WordBoundary,   
                (Int16)EventParameterType.Undefined,   
                 s.Length, new IntPtr(offset));  
        offset += s.Length;  
        if (s.Trim().Length > 0) {  
          SpeechEventInfo[] events = new SpeechEventInfo[1];  
          events[0] = spEvent;  
          site.AddEvents(events, 1);  
        }  
      }  
      }  
    }  
  }  
  
  _baseSynthesize.Speak(newFrags, wfx, site);  
  
}  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SpeechEventInfo (short eventId, short parameterType, int param1, IntPtr param2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int16 eventId, int16 parameterType, int32 param1, native int param2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.#ctor(System.Int16,System.Int16,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (eventId As Short, parameterType As Short, param1 As Integer, param2 As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SpeechEventInfo(short eventId, short parameterType, int param1, IntPtr param2);" />
      <MemberSignature Language="F#" Value="new System.Speech.Synthesis.TtsEngine.SpeechEventInfo : int16 * int16 * int * nativeint -&gt; System.Speech.Synthesis.TtsEngine.SpeechEventInfo" Usage="new System.Speech.Synthesis.TtsEngine.SpeechEventInfo (eventId, parameterType, param1, param2)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int16" />
        <Parameter Name="parameterType" Type="System.Int16" />
        <Parameter Name="param1" Type="System.Int32" />
        <Parameter Name="param2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventId">Instance de <see cref="T:System.Speech.Synthesis.TtsEngine.TtsEventId" /> indiquant le tri de l'événement de plateforme de reconnaissance vocale que l'objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> doit gérer.</param>
        <param name="parameterType">Instance d’<see cref="T:System.Speech.Synthesis.TtsEngine.EventParameterType" /> indiquant comment la référence <see langword="System.IntPtr" /> de <c>param2</c> doit être interprétée, et, implicitement, l’utilisation de <c>param1</c>.</param>
        <param name="param1">Valeur entière à passer à la plateforme de reconnaissance vocale lorsque l'événement demandé par l'instance <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> à construire est généré.  La signification exacte de cet entier est implicitement déterminée par la valeur <c>parameterType</c>.</param>
        <param name="param2">Instance <see langword="System.IntPtr" /> référençant un objet. à passer à la plateforme de reconnaissance vocale lorsque l'événement demandé par l'instance <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> à construire est généré.  Le type qui doit être référencé est défini explicitement par la valeur <c>parameterType</c>. Valeur <see langword="System.IntPtr.Zero" />.</param>
        <summary>Construit une <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" />appropriée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisé pour des valeurs autorisées `parameterType`, `param1`, et `param2` et leur signification est déterminée par le type d’événement demandé, tel que spécifié par le membre de <xref:System.Speech.Synthesis.TtsEngine.TtsEventId> utilisé pour `eventId`.  
  
 Pour plus d’informations sur les valeurs appropriées pour `parameterType`, `param1`, et `param2`, consultez la documentation pour <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.EventId%2A>  
  
 Le type des événements qui peuvent être gérées par l’infrastructure de plateforme de reconnaissance vocale peut être obtenu via la <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite.EventInterest%2A> propriété sur l’implémentation de site du moteur synthétiseur de <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite>.  
  
   
  
## Examples  
 L’exemple ci-dessous fait partie d’une implémentation de synthèse vocale personnalisée héritant de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml>et à l’aide de l’utilisation de <xref:System.Speech.Synthesis.TtsEngine.TextFragment>, <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo>, <xref:System.Speech.Synthesis.TtsEngine.FragmentState>, et <xref:System.Speech.Synthesis.TtsEngine.TtsEventId>  
  
 L’implémentation de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak%2A>  
  
1.  Reçoit un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances et crée un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances à passer à la `Speak` méthode sur un moteur de synthèse sous-jacents.  
  
2.  Si le <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction> valeur d’énumération par trouvé à partir de la <xref:System.Speech.Synthesis.TtsEngine.FragmentState.Action%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.FragmentState> retourné par la <xref:System.Speech.Synthesis.TtsEngine.TextFragment.State%2A> propriété de chaque <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instance est <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction.Speak>, l’implémentation  
  
    -   Traduit Americanism à Britishisms dans le texte à énoncer.  
  
    -   Si le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite.EventInterest%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite> fournis à la prise en charge de l’implémentation des interfaces le <xref:System.Speech.Synthesis.TtsEngine.TtsEventId.WordBoundary> type d’événement, un <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> instance est utilisée pour créer un événement au lecteur une jauge de progression du synthétiseur est créée.  
  
3.  Un moteur de rendu de reconnaissance vocale est ensuite appelé avec le texte modifié <xref:System.Speech.Synthesis.TtsEngine.TextFragment> tableau.  
  
```  
private const int WordBoundaryFlag = 1 << (int)TtsEventId.WordBoundary;  
private readonly char[] spaces = new char[] { ' ', '\t', '\r', '\n' };  
internal struct UsVsUk  
{  
  internal string UK;  
  internal string US;  
}  
  
override public void Speak (TextFragment [] frags, IntPtr wfx, ITtsEngineSite site)  
{  
  TextFragment [] newFrags=new TextFragment[frags.Length];  
  
  for (int i=0;i<frags.Length;i++){  
    newFrags[i].State=frags[i].State;  
    //truncate  
    newFrags[i].TextToSpeak = frags[i].TextToSpeak.Substring(frags[i].TextOffset,  
                               frags[i].TextLength);  
    newFrags[i].TextLength = newFrags[i].TextToSpeak.Length;  
    newFrags[i].TextOffset = 0;  
    if (newFrags[i].State.Action == TtsEngineAction.Speak) {  
      //Us to UK conversion  
      foreach (UsVsUk term in TransList) {  
      newFrags[i].TextToSpeak.Replace(term.US, term.UK);  
      }  
      //Generate progress meter events if supported  
      if ((site.EventInterest & WordBoundaryFlag) != 0) {  
      string[] subs = newFrags[i].TextToSpeak.Split(spaces);  
  
      foreach (string s in subs) {  
        int offset = newFrags[i].TextOffset;  
        SpeechEventInfo spEvent = new SpeechEventInfo((Int16)TtsEventId.WordBoundary,   
                (Int16)EventParameterType.Undefined,   
                 s.Length, new IntPtr(offset));  
        offset += s.Length;  
        if (s.Trim().Length > 0) {  
          SpeechEventInfo[] events = new SpeechEventInfo[1];  
          events[0] = spEvent;  
          site.AddEvents(events, 1);  
        }  
      }  
      }  
    }  
  }  
  
  _baseSynthesize.Speak(newFrags, wfx, site);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si une instance de <c>SpeechEventInfo</c> est égale à un autre objet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="speechEventInfo.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à évaluer.</param>
        <summary>Détermine si un objet spécifié est une instance de <c>SpeechEventInfo</c> et est égal à l’instance actuelle de <c>SpeechEventInfo</c>.</summary>
        <returns>
          <see langword="true" /> si <paramref name="obj" /> est égal à l’objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> actuel ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Speech.Synthesis.TtsEngine.SpeechEventInfo other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Speech.Synthesis.TtsEngine.SpeechEventInfo other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Equals(System.Speech.Synthesis.TtsEngine.SpeechEventInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As SpeechEventInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Speech::Synthesis::TtsEngine::SpeechEventInfo other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Speech.Synthesis.TtsEngine.SpeechEventInfo -&gt; bool" Usage="speechEventInfo.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Speech.Synthesis.TtsEngine.SpeechEventInfo" />
      </Parameters>
      <Docs>
        <param name="other">Objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> à évaluer.</param>
        <summary>Détermine si un objet <c>SpeechEventInfo</c> spécifié est égal à l’instance actuelle de <c>SpeechEventInfo</c>.</summary>
        <returns>
          <see langword="true" /> si <paramref name="other" /> est égal à l’objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> actuel ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EventId">
      <MemberSignature Language="C#" Value="public short EventId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 EventId" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.EventId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EventId As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short EventId { short get(); };" />
      <MemberSignature Language="F#" Value="member this.EventId : int16" Usage="System.Speech.Synthesis.TtsEngine.SpeechEventInfo.EventId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient et définit l'événement de plateforme de reconnaissance vocale demandé en utilisant une instance de <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" />.</summary>
        <value>Retourne un membre <see cref="T:System.Speech.Synthesis.TtsEngine.TtsEventId" /> en tant que <see langword="short" />, indiquant le type d'événement que l'objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> doit générer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple ci-dessous fait partie d’une implémentation de synthèse vocale personnalisée héritant de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml>et à l’aide de l’utilisation de <xref:System.Speech.Synthesis.TtsEngine.TextFragment>, <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo>, <xref:System.Speech.Synthesis.TtsEngine.FragmentState>, et <xref:System.Speech.Synthesis.TtsEngine.TtsEventId>  
  
 L’implémentation de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak%2A>  
  
1.  Reçoit un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances et crée un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances à passer à la `Speak` méthode sur un moteur de synthèse sous-jacents.  
  
2.  Si le <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction> valeur d’énumération par trouvé à partir de la <xref:System.Speech.Synthesis.TtsEngine.FragmentState.Action%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.FragmentState> retourné par la <xref:System.Speech.Synthesis.TtsEngine.TextFragment.State%2A> propriété de chaque <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instance est <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction.Speak>, l’implémentation  
  
    -   Traduit Americanism à Britishisms dans le texte à énoncer.  
  
    -   Si le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite.EventInterest%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite> fournis à la prise en charge de l’implémentation des interfaces le <xref:System.Speech.Synthesis.TtsEngine.TtsEventId.WordBoundary> type d’événement, un <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> instance est utilisée pour créer un événement au lecteur une jauge de progression du synthétiseur est créée.  
  
         Les paramètres sur <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo>, y compris <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.EventId%2A> sont utilisées pour enregistrer l’événement généré par le biais du `LogSpeechEvent` (méthode).  
  
3.  Un moteur de rendu de reconnaissance vocale est ensuite appelé avec le texte modifié <xref:System.Speech.Synthesis.TtsEngine.TextFragment> tableau.  
  
```  
private const int WordBoundaryFlag = 1 << (int)TtsEventId.WordBoundary;  
private readonly char[] spaces = new char[] { ' ', '\t', '\r', '\n' };  
internal struct UsVsUk  
{  
  internal string UK;  
  internal string US;  
}  
  
override public void Speak (TextFragment [] frags, IntPtr wfx, ITtsEngineSite site)  
{  
  TextFragment [] newFrags=new TextFragment[frags.Length];  
  
  for (int i=0;i<frags.Length;i++){  
    newFrags[i].State=frags[i].State;  
    //truncate  
    newFrags[i].TextToSpeak = frags[i].TextToSpeak.Substring(frags[i].TextOffset,  
                               frags[i].TextLength);  
    newFrags[i].TextLength = newFrags[i].TextToSpeak.Length;  
    newFrags[i].TextOffset = 0;  
    if (newFrags[i].State.Action == TtsEngineAction.Speak) {  
      //Us to UK conversion  
      foreach (UsVsUk term in TransList) {  
      newFrags[i].TextToSpeak.Replace(term.US, term.UK);  
      }  
      //Generate progress meter events if supported  
      if ((site.EventInterest & WordBoundaryFlag) != 0) {  
      string[] subs = newFrags[i].TextToSpeak.Split(spaces);  
  
      foreach (string s in subs) {  
        int offset = newFrags[i].TextOffset;  
        SpeechEventInfo spEvent = new SpeechEventInfo((Int16)TtsEventId.WordBoundary,   
                (Int16)EventParameterType.Undefined,   
                 s.Length, new IntPtr(offset));  
         LogSpeechEvent(spEvent.EventId,   
                        spEvent.ParameterType,   
                        spEvent.Param1,  
                        spEvent.Param2);  
        offset += s.Length;  
        if (s.Trim().Length > 0) {  
          SpeechEventInfo[] events = new SpeechEventInfo[1];  
          events[0] = spEvent;  
          site.AddEvents(events, 1);  
        }  
      }  
      }  
    }  
  }  
  
  _baseSynthesize.Speak(newFrags, wfx, site);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="speechEventInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit un code de hachage pour un objet <c>SpeechEventInfo</c>.</summary>
        <returns>Code de hachage d'un objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Speech.Synthesis.TtsEngine.SpeechEventInfo event1, System.Speech.Synthesis.TtsEngine.SpeechEventInfo event2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Speech.Synthesis.TtsEngine.SpeechEventInfo event1, valuetype System.Speech.Synthesis.TtsEngine.SpeechEventInfo event2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.op_Equality(System.Speech.Synthesis.TtsEngine.SpeechEventInfo,System.Speech.Synthesis.TtsEngine.SpeechEventInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (event1 As SpeechEventInfo, event2 As SpeechEventInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Speech::Synthesis::TtsEngine::SpeechEventInfo event1, System::Speech::Synthesis::TtsEngine::SpeechEventInfo event2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Speech.Synthesis.TtsEngine.SpeechEventInfo * System.Speech.Synthesis.TtsEngine.SpeechEventInfo -&gt; bool" Usage="event1 = event2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="event1" Type="System.Speech.Synthesis.TtsEngine.SpeechEventInfo" />
        <Parameter Name="event2" Type="System.Speech.Synthesis.TtsEngine.SpeechEventInfo" />
      </Parameters>
      <Docs>
        <param name="event1">Objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> à comparer à <c>event2</c>.</param>
        <param name="event2">Objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> à comparer à <c>event1</c>.</param>
        <summary>Détermine si deux instances de <c>SpeechEventInfo</c> sont égales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="event1" /> est identique à <paramref name="event2" />, sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[La méthode équivalente pour cet opérateur est <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Equals%28System.Speech.Synthesis.TtsEngine.SpeechEventInfo%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Speech.Synthesis.TtsEngine.SpeechEventInfo event1, System.Speech.Synthesis.TtsEngine.SpeechEventInfo event2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Speech.Synthesis.TtsEngine.SpeechEventInfo event1, valuetype System.Speech.Synthesis.TtsEngine.SpeechEventInfo event2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.op_Inequality(System.Speech.Synthesis.TtsEngine.SpeechEventInfo,System.Speech.Synthesis.TtsEngine.SpeechEventInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (event1 As SpeechEventInfo, event2 As SpeechEventInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Speech::Synthesis::TtsEngine::SpeechEventInfo event1, System::Speech::Synthesis::TtsEngine::SpeechEventInfo event2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Speech.Synthesis.TtsEngine.SpeechEventInfo * System.Speech.Synthesis.TtsEngine.SpeechEventInfo -&gt; bool" Usage="System.Speech.Synthesis.TtsEngine.SpeechEventInfo.op_Inequality (event1, event2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="event1" Type="System.Speech.Synthesis.TtsEngine.SpeechEventInfo" />
        <Parameter Name="event2" Type="System.Speech.Synthesis.TtsEngine.SpeechEventInfo" />
      </Parameters>
      <Docs>
        <param name="event1">Objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> à comparer à <c>event2</c>.</param>
        <param name="event2">Objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> à comparer à <c>event1</c>.</param>
        <summary>Détermine si deux instances de <c>SpeechEventInfo</c> ne sont pas égales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="event1" /> est différent de <paramref name="event2" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[La méthode équivalente pour cet opérateur est <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Equals%28System.Speech.Synthesis.TtsEngine.SpeechEventInfo%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Param1">
      <MemberSignature Language="C#" Value="public int Param1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Param1" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Param1 As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Param1 { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Param1 : int" Usage="System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient et définit la valeur de <see langword="integer" /> (<paramref name="param1" /> dans le constructeur) à passer à la plateforme de reconnaissance vocale pour générer un événement demandé en utilisant l'instance actuelle de <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" />.</summary>
        <value>Retourne l'<see langword="integer" /> à passer à la plateforme de reconnaissance vocale lorsque l'événement spécifié par l'instance actuelle de <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> est généré.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La configuration requise et la signification de <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param1%2A> propriété du <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> déterminée de manière unique par les valeurs de la <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.EventId%2A> et <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.ParameterType%2A> propriétés la <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> instance.  
  
 Pour plus d’informations sur la façon de les utiliser <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param1%2A>, consultez la documentation pour <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.EventId%2A>.  
  
   
  
## Examples  
 L’exemple ci-dessous fait partie d’une implémentation de synthèse vocale personnalisée héritant de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml>et à l’aide de l’utilisation de <xref:System.Speech.Synthesis.TtsEngine.TextFragment>, <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo>, <xref:System.Speech.Synthesis.TtsEngine.FragmentState>, et <xref:System.Speech.Synthesis.TtsEngine.TtsEventId>  
  
 L’implémentation de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak%2A>  
  
1.  Reçoit un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances et crée un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances à passer à la `Speak` méthode sur un moteur de synthèse sous-jacents.  
  
2.  Si le <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction> valeur d’énumération par trouvé à partir de la <xref:System.Speech.Synthesis.TtsEngine.FragmentState.Action%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.FragmentState> retourné par la <xref:System.Speech.Synthesis.TtsEngine.TextFragment.State%2A> propriété de chaque <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instance est <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction.Speak>, l’implémentation  
  
    -   Traduit Americanism à Britishisms dans le texte à énoncer.  
  
    -   Si le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite.EventInterest%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite> fournis à la prise en charge de l’implémentation des interfaces le <xref:System.Speech.Synthesis.TtsEngine.TtsEventId.WordBoundary> type d’événement, un <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> instance est utilisée pour créer un événement au lecteur une jauge de progression du synthétiseur est créée.  
  
         Les paramètres sur <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo>, y compris <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param1%2A> sont utilisées pour enregistrer l’événement généré par le biais du `LogSpeechEvent` (méthode).  
  
3.  Un moteur de rendu de reconnaissance vocale est ensuite appelé avec le texte modifié <xref:System.Speech.Synthesis.TtsEngine.TextFragment> tableau.  
  
```  
private const int WordBoundaryFlag = 1 << (int)TtsEventId.WordBoundary;  
private readonly char[] spaces = new char[] { ' ', '\t', '\r', '\n' };  
internal struct UsVsUk  
{  
  internal string UK;  
  internal string US;  
}  
  
override public void Speak (TextFragment [] frags, IntPtr wfx, ITtsEngineSite site)  
{  
  TextFragment [] newFrags=new TextFragment[frags.Length];  
  
  for (int i=0;i<frags.Length;i++){  
    newFrags[i].State=frags[i].State;  
    //truncate  
    newFrags[i].TextToSpeak = frags[i].TextToSpeak.Substring(frags[i].TextOffset,  
                               frags[i].TextLength);  
    newFrags[i].TextLength = newFrags[i].TextToSpeak.Length;  
    newFrags[i].TextOffset = 0;  
    if (newFrags[i].State.Action == TtsEngineAction.Speak) {  
      //Us to UK conversion  
      foreach (UsVsUk term in TransList) {  
      newFrags[i].TextToSpeak.Replace(term.US, term.UK);  
      }  
      //Generate progress meter events if supported  
      if ((site.EventInterest & WordBoundaryFlag) != 0) {  
      string[] subs = newFrags[i].TextToSpeak.Split(spaces);  
  
      foreach (string s in subs) {  
        int offset = newFrags[i].TextOffset;  
        SpeechEventInfo spEvent = new SpeechEventInfo((Int16)TtsEventId.WordBoundary,   
                (Int16)EventParameterType.Undefined,   
                 s.Length, new IntPtr(offset));  
         LogSpeechEvent(spEvent.EventId,   
                        spEvent.ParameterType,   
                        spEvent.Param1,  
                        spEvent.Param2);  
        offset += s.Length;  
        if (s.Trim().Length > 0) {  
          SpeechEventInfo[] events = new SpeechEventInfo[1];  
          events[0] = spEvent;  
          site.AddEvents(events, 1);  
        }  
      }  
      }  
    }  
  }  
  
  _baseSynthesize.Speak(newFrags, wfx, site);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Param2">
      <MemberSignature Language="C#" Value="public IntPtr Param2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Param2" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Param2 As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Param2 { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Param2 : nativeint" Usage="System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient et définit l'instance de <see langword="System.IntPtr" /> (<paramref name="param2" /> dans le constructeur) qui référence l'objet à passer à la plateforme de reconnaissance vocale pour générer un événement demandé en utilisant l'instance actuelle de <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" />.</summary>
        <value>Retourne le <see langword="System.IntPtr" /> qui référence l'objet à passer à la plateforme vocale lorsque l'événement spécifié par l'instance actuelle de <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> est généré.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La configuration requise sur le `System.IntPtr` de référence de la <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param2%2A> propriété de <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> déterminée de manière unique par les valeurs de la <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.EventId%2A> et <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.ParameterType%2A> propriétés la <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> instance.  
  
 Pour plus d’informations sur la façon de les utiliser <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param2%2A>, consultez la documentation pour <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.EventId%2A>.  
  
   
  
## Examples  
 L’exemple ci-dessous fait partie d’une implémentation de synthèse vocale personnalisée héritant de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml>et à l’aide de l’utilisation de <xref:System.Speech.Synthesis.TtsEngine.TextFragment>, <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo>, <xref:System.Speech.Synthesis.TtsEngine.FragmentState>, et <xref:System.Speech.Synthesis.TtsEngine.TtsEventId>  
  
 L’implémentation de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak%2A>  
  
1.  Reçoit un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances et crée un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances à passer à la `Speak` méthode sur un moteur de synthèse sous-jacents.  
  
2.  Si le <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction> valeur d’énumération par trouvé à partir de la <xref:System.Speech.Synthesis.TtsEngine.FragmentState.Action%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.FragmentState> retourné par la <xref:System.Speech.Synthesis.TtsEngine.TextFragment.State%2A> propriété de chaque <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instance est <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction.Speak>, l’implémentation  
  
    -   Traduit Americanism à Britishisms dans le texte à énoncer.  
  
    -   Si le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite.EventInterest%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite> fournis à la prise en charge de l’implémentation des interfaces le <xref:System.Speech.Synthesis.TtsEngine.TtsEventId.WordBoundary> type d’événement, un <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> instance est utilisée pour créer un événement au lecteur une jauge de progression du synthétiseur est créée.  
  
         Les paramètres sur <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo>, y compris <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param2%2A> sont utilisées pour enregistrer l’événement généré par le biais du `LogSpeechEvent` (méthode).  
  
3.  Un moteur de rendu de reconnaissance vocale est ensuite appelé avec le texte modifié <xref:System.Speech.Synthesis.TtsEngine.TextFragment> tableau.  
  
```  
private const int WordBoundaryFlag = 1 << (int)TtsEventId.WordBoundary;  
private readonly char[] spaces = new char[] { ' ', '\t', '\r', '\n' };  
internal struct UsVsUk  
{  
  internal string UK;  
  internal string US;  
}  
  
override public void Speak (TextFragment [] frags, IntPtr wfx, ITtsEngineSite site)  
{  
  TextFragment [] newFrags=new TextFragment[frags.Length];  
  
  for (int i=0;i<frags.Length;i++){  
    newFrags[i].State=frags[i].State;  
    //truncate  
    newFrags[i].TextToSpeak = frags[i].TextToSpeak.Substring(frags[i].TextOffset,  
                               frags[i].TextLength);  
    newFrags[i].TextLength = newFrags[i].TextToSpeak.Length;  
    newFrags[i].TextOffset = 0;  
    if (newFrags[i].State.Action == TtsEngineAction.Speak) {  
      //Us to UK conversion  
      foreach (UsVsUk term in TransList) {  
      newFrags[i].TextToSpeak.Replace(term.US, term.UK);  
      }  
      //Generate progress meter events if supported  
      if ((site.EventInterest & WordBoundaryFlag) != 0) {  
      string[] subs = newFrags[i].TextToSpeak.Split(spaces);  
  
      foreach (string s in subs) {  
        int offset = newFrags[i].TextOffset;  
        SpeechEventInfo spEvent = new SpeechEventInfo((Int16)TtsEventId.WordBoundary,   
                (Int16)EventParameterType.Undefined,   
                 s.Length, new IntPtr(offset));  
         LogSpeechEvent(spEvent.EventId,   
                        spEvent.ParameterType,   
                        spEvent.Param1,  
                        spEvent.Param2);  
        offset += s.Length;  
        if (s.Trim().Length > 0) {  
          SpeechEventInfo[] events = new SpeechEventInfo[1];  
          events[0] = spEvent;  
          site.AddEvents(events, 1);  
        }  
      }  
      }  
    }  
  }  
  
  _baseSynthesize.Speak(newFrags, wfx, site);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParameterType">
      <MemberSignature Language="C#" Value="public short ParameterType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 ParameterType" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.ParameterType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParameterType As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short ParameterType { short get(); };" />
      <MemberSignature Language="F#" Value="member this.ParameterType : int16" Usage="System.Speech.Synthesis.TtsEngine.SpeechEventInfo.ParameterType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne le type de données de l'objet pointé vers <see langword="IntPtr" /> retourné par le paramètre <see cref="P:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param2" /> sur l'objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> actuel.</summary>
        <value>Valeur <see langword="short" /> correspondant à un membre de l'énumération <see cref="T:System.Speech.Synthesis.TtsEngine.EventParameterType" /> et indiquant le type de données de l'objet vers lequel pointe <see langword="IntPtr" /> retourné par le paramètre <see cref="P:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param2" /> et utilisé comme deuxième argument du constructeur de l'objet <see cref="T:System.Speech.Synthesis.TtsEngine.SpeechEventInfo" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La configuration requise sur le `System.IntPtr` de référence de la <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param2%2A> propriété de <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> déterminée de manière unique par les valeurs de la <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.EventId%2A> et <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.ParameterType%2A> propriétés la <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> instance.  
  
 Pour plus d’informations sur la façon de les utiliser <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.Param2%2A>, consultez la documentation pour <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.EventId%2A>.  
  
   
  
## Examples  
 L’exemple ci-dessous fait partie d’une implémentation de synthèse vocale personnalisée héritant de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml>et à l’aide de l’utilisation de <xref:System.Speech.Synthesis.TtsEngine.TextFragment>, <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo>, <xref:System.Speech.Synthesis.TtsEngine.FragmentState>, et <xref:System.Speech.Synthesis.TtsEngine.TtsEventId>  
  
 L’implémentation de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak%2A>  
  
1.  Reçoit un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances et crée un tableau de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instances à passer à la `Speak` méthode sur un moteur de synthèse sous-jacents.  
  
2.  Si le <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction> valeur d’énumération par trouvé à partir de la <xref:System.Speech.Synthesis.TtsEngine.FragmentState.Action%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.FragmentState> retourné par la <xref:System.Speech.Synthesis.TtsEngine.TextFragment.State%2A> propriété de chaque <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instance est <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction.Speak>, l’implémentation  
  
    -   Traduit Americanism à Britishisms dans le texte à énoncer.  
  
    -   Si le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite.EventInterest%2A> propriété sur le <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite> fournis à la prise en charge de l’implémentation des interfaces le <xref:System.Speech.Synthesis.TtsEngine.TtsEventId.WordBoundary> type d’événement, un <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> instance est utilisée pour créer un événement au lecteur une jauge de progression du synthétiseur est créée.  
  
         Les paramètres sur <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo>, y compris <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo.ParameterType%2A> sont utilisées pour enregistrer l’événement généré par le biais du `LogSpeechEvent` (méthode).  
  
3.  Un moteur de rendu de reconnaissance vocale est ensuite appelé avec le texte modifié <xref:System.Speech.Synthesis.TtsEngine.TextFragment> tableau.  
  
```  
private const int WordBoundaryFlag = 1 << (int)TtsEventId.WordBoundary;  
private readonly char[] spaces = new char[] { ' ', '\t', '\r', '\n' };  
internal struct UsVsUk  
{  
  internal string UK;  
  internal string US;  
}  
  
override public void Speak (TextFragment [] frags, IntPtr wfx, ITtsEngineSite site)  
{  
  TextFragment [] newFrags=new TextFragment[frags.Length];  
  
  for (int i=0;i<frags.Length;i++){  
    newFrags[i].State=frags[i].State;  
    //truncate  
    newFrags[i].TextToSpeak = frags[i].TextToSpeak.Substring(frags[i].TextOffset,  
                               frags[i].TextLength);  
    newFrags[i].TextLength = newFrags[i].TextToSpeak.Length;  
    newFrags[i].TextOffset = 0;  
    if (newFrags[i].State.Action == TtsEngineAction.Speak) {  
      //Us to UK conversion  
      foreach (UsVsUk term in TransList) {  
      newFrags[i].TextToSpeak.Replace(term.US, term.UK);  
      }  
      //Generate progress meter events if supported  
      if ((site.EventInterest & WordBoundaryFlag) != 0) {  
      string[] subs = newFrags[i].TextToSpeak.Split(spaces);  
  
      foreach (string s in subs) {  
        int offset = newFrags[i].TextOffset;  
        SpeechEventInfo spEvent = new SpeechEventInfo((Int16)TtsEventId.WordBoundary,   
                (Int16)EventParameterType.Undefined,   
                 s.Length, new IntPtr(offset));  
         LogSpeechEvent(spEvent.EventId,   
                        spEvent.ParameterType,   
                        spEvent.Param1,  
                        spEvent.Param2);  
        offset += s.Length;  
        if (s.Trim().Length > 0) {  
          SpeechEventInfo[] events = new SpeechEventInfo[1];  
          events[0] = spEvent;  
          site.AddEvents(events, 1);  
        }  
      }  
      }  
    }  
  }  
  
  _baseSynthesize.Speak(newFrags, wfx, site);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>