<Type Name="ScrollBar" FullName="System.Windows.Controls.Primitives.ScrollBar">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5cef7d1b9f6caf5fdd091ceedd31775f7332d88e" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39882935" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ScrollBar : System.Windows.Controls.Primitives.RangeBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScrollBar extends System.Windows.Controls.Primitives.RangeBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.ScrollBar" />
  <TypeSignature Language="VB.NET" Value="Public Class ScrollBar&#xA;Inherits RangeBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScrollBar : System::Windows::Controls::Primitives::RangeBase" />
  <TypeSignature Language="F#" Value="type ScrollBar = class&#xA;    inherit RangeBase" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.RangeBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.TemplatePart(Name="PART_Track", Type=typeof(System.Windows.Controls.Primitives.Track))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un contrôle qui fournit une barre de défilement ayant un <see cref="T:System.Windows.Controls.Primitives.Thumb" /> glissant dont la position correspond à une valeur.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’illustration suivante montre un <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle.  
  
 ![Illustration de la barre de défilement](~/add/media/scrollbar-illustration.JPG "illustration de la barre de défilement")  
  
 Le <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle contient un <xref:System.Windows.Controls.Primitives.Track> contrôle. Le <xref:System.Windows.Controls.Primitives.Track> contrôle se compose d’un <xref:System.Windows.Controls.Primitives.Thumb> contrôle et deux <xref:System.Windows.Controls.Primitives.RepeatButton> contrôles. Vous pouvez augmenter et diminuer la <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> propriété de la <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle en appuyant sur la <xref:System.Windows.Controls.Primitives.RepeatButton> contrôle ou en déplaçant le <xref:System.Windows.Controls.Primitives.Thumb>. La plage par défaut des valeurs pour le <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> propriété est comprise entre 0 à 1. Le <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> représente la distance linéaire de la <xref:System.Windows.Controls.Primitives.Thumb> entre les points de terminaison de la <xref:System.Windows.Controls.Primitives.ScrollBar>. Vous pouvez modifier la plage de valeurs par défaut en définissant le <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> et <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> propriétés. Le <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A> propriété détermine si le <xref:System.Windows.Controls.Primitives.ScrollBar> est affiché horizontalement ou verticalement, et vous devez définir cette propriété pour le <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle s’affiche.  
  
 Le <xref:System.Windows.Controls.Primitives.Track> dans un <xref:System.Windows.Controls.Primitives.ScrollBar> est orienté afin que les valeurs augmentent de haut en bas pour un vertical <xref:System.Windows.Controls.Primitives.ScrollBar> ou de gauche à droite pour un horizontal <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Le <xref:System.Windows.Controls.Primitives.Track> propriétés dans le tableau suivant sont des cibles de liaison pour le correspondantes <xref:System.Windows.Controls.Primitives.ScrollBar> propriétés lorsque le <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> propriété n’est pas définie explicitement. Si vous définissez explicitement la <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> propriété, la liaison ne se produit pas.  
  
|Propriété <xref:System.Windows.Controls.Primitives.Track>|Propriété <xref:System.Windows.Controls.Primitives.ScrollBar>|  
|----------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Windows.Controls.Primitives.Track.Maximum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Minimum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Value%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Value%2A?displayProperty=nameWithType>|  
  
 Vous pouvez accéder à la <xref:System.Windows.Controls.Primitives.Track> contrôle d’un <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle à l’aide de la <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> propriété.  
  
 Pour afficher <xref:System.Windows.UIElement> contenu dans une zone avec des barres de défilement, utilisez le <xref:System.Windows.Controls.ScrollViewer> contrôle.  
  
## <a name="customizing-the-scrollbar-control"></a>Personnalisation du contrôle de barre de défilement  
 Pour appliquer les mêmes paramètres de propriété à plusieurs <xref:System.Windows.Controls.Primitives.ScrollBar> contrôles, utiliser le <xref:System.Windows.FrameworkElement.Style%2A> propriété. Vous pouvez modifier la valeur par défaut <xref:System.Windows.Controls.ControlTemplate> pour donner le contrôle une apparence unique. Pour plus d’informations sur la création d’un <xref:System.Windows.Controls.ControlTemplate>, consultez [personnalisation de l’apparence d’un contrôle existant en créant un ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Pour afficher les parties et les États qui sont spécifiques à la <xref:System.Windows.Controls.Primitives.ScrollBar>, consultez [modèles et Styles de barre de défilement](~/docs/framework/wpf/controls/scrollbar-styles-and-templates.md).  
  
 Les propriétés de dépendance pour ce contrôle peuvent être définies par le style par défaut.  Si une propriété est définie par un style par défaut, la propriété peut changer à partir de sa valeur par défaut lorsque le contrôle s’affiche dans l’application. Le style par défaut est déterminé par le thème de bureau est utilisé lors de l’exécution de l’application.  Pour plus d’informations, consultez [thèmes WPF par défaut](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  Définition d’une propriété visual uniquement aura un effet si cette propriété est à la fois présents dans <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle du modèle par défaut et est définie à l’aide d’un. Vous trouverez une liste de propriétés visuelles dans la section « Modification de la Visual Structure d’un contrôle » dans [personnalisation de l’apparence d’un contrôle existant en créant un ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un horizontal <xref:System.Windows.Controls.Primitives.ScrollBar> qui a une plage de valeurs comprise entre 0 et 100.  
  
 [!code-xaml[ScrollBarSnips#ScrollBar](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scrollbar)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Primitives.RangeBase" />
    <altmember cref="T:System.Windows.Controls.Primitives.Track" />
    <altmember cref="T:System.Windows.Controls.Primitives.Thumb" />
    <altmember cref="T:System.Windows.Controls.ScrollViewer" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScrollBar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScrollBar();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable DeferScrollToHorizontalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui notifie <see cref="T:System.Windows.Controls.ScrollViewer" /> que l'utilisateur fait glisser <see cref="T:System.Windows.Controls.Primitives.Thumb" /> du <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontal à la valeur fournie dans <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’utilisateur fait glisser le curseur d’un <xref:System.Windows.Controls.Primitives.ScrollBar>, le <xref:System.Windows.Controls.Primitives.ScrollBar> appels <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> pour le <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand>. Si <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> retourne `true`, le <xref:System.Windows.Controls.Primitives.ScrollBar> exécute cette commande.  Si <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> retourne `false`, le <xref:System.Windows.Controls.Primitives.ScrollBar> exécute le <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand>.  
  
 Le <xref:System.Windows.Controls.ScrollViewer> utilise cette commande pour activer le défilement différé. Lorsque <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> est `true` et un utilisateur fait glisser le <xref:System.Windows.Controls.Primitives.Thumb> de la <xref:System.Windows.Controls.Primitives.ScrollBar>, le contenu de la <xref:System.Windows.Controls.ScrollViewer> ne change pas jusqu'à ce que l’utilisateur relâche le <xref:System.Windows.Controls.Primitives.Thumb>. Si le défilement différé est activé, le <xref:System.Windows.Controls.Primitives.ScrollBar> exécute le <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand> pour un horizontal <xref:System.Windows.Controls.Primitives.ScrollBar> lorsque l’utilisateur fait glisser le <xref:System.Windows.Controls.Primitives.Thumb>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable DeferScrollToVerticalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui notifie <see cref="T:System.Windows.Controls.ScrollViewer" /> que l'utilisateur fait glisser <see cref="T:System.Windows.Controls.Primitives.Thumb" /> du <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> vertical à la valeur fournie dans <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’utilisateur fait glisser le curseur d’un <xref:System.Windows.Controls.Primitives.ScrollBar>, le <xref:System.Windows.Controls.Primitives.ScrollBar> appels <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> pour le <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand>. Si <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> retourne `true`, le <xref:System.Windows.Controls.Primitives.ScrollBar> exécute cette commande.  Si <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> retourne `false`, le <xref:System.Windows.Controls.Primitives.ScrollBar> exécute le <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand>.  
  
 Le <xref:System.Windows.Controls.ScrollViewer> utilise cette commande pour activer le défilement différé. Lorsque <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> est `true` et un utilisateur fait glisser le <xref:System.Windows.Controls.Primitives.Thumb> de la <xref:System.Windows.Controls.Primitives.ScrollBar>, le contenu de la <xref:System.Windows.Controls.ScrollViewer> ne change pas jusqu'à ce que l’utilisateur relâche le <xref:System.Windows.Controls.Primitives.Thumb>. Si le défilement différé est activé, le <xref:System.Windows.Controls.Primitives.ScrollBar> exécute le <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand> un vertical <xref:System.Windows.Controls.Primitives.ScrollBar> lorsque l’utilisateur fait glisser le <xref:System.Windows.Controls.Primitives.Thumb>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> est activée.</summary>
        <value>
          <see langword="true" /> si la <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> est activée dans un <see cref="T:System.Windows.Controls.ScrollViewer" /> et si la taille du contenu est plus grande que la zone d'affichage ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation définit <xref:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore%2A> à `true` uniquement si le <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> valeur de la <xref:System.Windows.Controls.Primitives.ScrollBar> est supérieure à la <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> valeur et le <xref:System.Windows.Controls.Primitives.ScrollBar> est activé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineDownCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineDownCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait légèrement défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> dans la direction verticale des valeurs croissantes de son <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande augmente la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> dans le <xref:System.Windows.Controls.Primitives.ScrollBar> par la valeur de la <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> propriété.  
  
 Cette commande se produit lorsque l’utilisateur appuie sur la touche de direction bas.  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_LineDownCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.LineDownCommand**`"/>`  
  
   
  
## Examples  
 L’exemple suivant montre comment spécifier le <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand> personnalisé <xref:System.Windows.Controls.Primitives.ScrollBar> modèle de style.  
  
 [!code-xaml[ScrollBarTemplateExample#LineDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineLeftCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineLeftCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait légèrement défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> dans la direction horizontale des valeurs décroissantes de son <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande diminue la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> dans le <xref:System.Windows.Controls.Primitives.ScrollBar> par la valeur de la <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> propriété.  
  
 Cette commande se produit lorsque l’utilisateur appuie sur la gauche <xref:System.Windows.Controls.Primitives.RepeatButton>.  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_LineLeftCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.LineLeftCommand**`"/>`  
  
   
  
## Examples  
 L’exemple suivant montre comment spécifier le <xref:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand> personnalisé <xref:System.Windows.Controls.Primitives.ScrollBar> modèle de style.  
  
 [!code-xaml[ScrollBarTemplateExample#LineLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineRightCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineRightCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait légèrement défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> dans la direction horizontale des valeurs croissantes de son <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande augmente la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> dans le <xref:System.Windows.Controls.Primitives.ScrollBar> par la valeur de la <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> propriété.  
  
 Cette commande se produit lorsque l’utilisateur appuie sur la droite <xref:System.Windows.Controls.Primitives.RepeatButton>.  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_LineRightCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.LineRightCommand**`"/>`  
  
   
  
## Examples  
 L’exemple suivant montre comment spécifier le <xref:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand> personnalisé <xref:System.Windows.Controls.Primitives.ScrollBar> modèle de style.  
  
 [!code-xaml[ScrollBarTemplateExample#LineRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineUpCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineUpCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait légèrement défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> dans la direction verticale des valeurs décroissantes de son <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande permet de réduire le <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> dans le <xref:System.Windows.Controls.Primitives.ScrollBar> par la valeur de la <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> propriété.  
  
 Cette commande se produit lorsque l’utilisateur appuie sur la touche haut.  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_LineUpCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.LineUpCommand**`"/>`  
  
   
  
## Examples  
 L’exemple suivant montre comment spécifier le <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand> personnalisé <xref:System.Windows.Controls.Primitives.ScrollBar> modèle de style.  
  
 [!code-xaml[ScrollBarTemplateExample#LineUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="override this.OnApplyTemplate : unit -&gt; unit" Usage="scrollBar.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée l’arborescence d’éléments visuels pour le <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation définit également la <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> propriété le <xref:System.Windows.Controls.Primitives.Track> qui est définie dans le <xref:System.Windows.Controls.Primitives.ScrollBar> modèle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="scrollBar.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Fournit la gestion de classe pour l'événement <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> qui se produit lorsque le <see cref="T:System.Windows.Controls.ContextMenu" /> d'une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> se ferme.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.ContextMenu> d’un <xref:System.Windows.Controls.Primitives.ScrollBar> fournit des options pour modifier le <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> de la <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="scrollBar.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Fournit la gestion de classe pour l'événement <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> qui se produit lorsque le <see cref="T:System.Windows.Controls.ContextMenu" /> d'une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> s'ouvre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.ContextMenu> d’un <xref:System.Windows.Controls.Primitives.ScrollBar> fournit des options pour modifier le <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> de la <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="scrollBar.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> pour ce contrôle <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <returns>
          <see cref="T:System.Windows.Automation.Peers.ScrollBarAutomationPeer" /> du contrôle <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="scrollBar.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Fournit la gestion de classe pour l’événement <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation modifie le <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> de la <xref:System.Windows.Controls.Primitives.ScrollBar> à l’emplacement de la <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> événement qui se produit lorsque l’utilisateur appuie sur la touche MAJ ENFONCÉE. L’événement est géré en définissant <xref:System.Windows.RoutedEventArgs.Handled%2A> dans les données d’événement `e` à `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="scrollBar.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Fournit la gestion de classe pour l’événement <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation enregistre la position de la souris afin que le <xref:System.Windows.Controls.Primitives.ScrollBar> peut défiler à sa position en réponse à un <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand>.  
  
   
  
## Examples  
 Un <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand> se produit lorsque l’utilisateur sélectionne **défilement ici** dans le menu qui apparaît lorsque l’utilisateur appuie sur le bouton droit de la souris sur le <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Orientation">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Orientation Orientation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.Orientation Orientation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />
      <MemberSignature Language="VB.NET" Value="Public Property Orientation As Orientation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Orientation Orientation { System::Windows::Controls::Orientation get(); void set(System::Windows::Controls::Orientation value); };" />
      <MemberSignature Language="F#" Value="member this.Orientation : System.Windows.Controls.Orientation with get, set" Usage="System.Windows.Controls.Primitives.ScrollBar.Orientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Orientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit si la <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> s'affiche horizontalement ou verticalement.</summary>
        <value>Valeur d'énumération <see cref="T:System.Windows.Controls.Orientation" /> qui définit si la <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> est affichée horizontalement ou verticalement. La valeur par défaut est <see cref="F:System.Windows.Controls.Orientation.Vertical" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Orientation"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A> propriété pour un <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle.  
  
 [!code-csharp[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#orientation)]
 [!code-vb[ScrollBarSnips#Orientation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#orientation)]
 [!code-xaml[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#orientation)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Orientation" />
      </Docs>
    </Member>
    <Member MemberName="OrientationProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OrientationProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OrientationProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OrientationProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OrientationProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OrientationProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ScrollBar.OrientationProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageDownCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageDownCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait largement défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> dans la direction verticale des valeurs croissantes de son <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande augmente la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> dans le <xref:System.Windows.Controls.Primitives.ScrollBar> par la valeur de la <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> propriété.  
  
 Cette commande se produit lorsque l’utilisateur appuie sur la touche PAGE suivante.  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_PageDownCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.PageDownCommand**`"/>`  
  
   
  
## Examples  
 L’exemple suivant montre comment spécifier le <xref:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand> personnalisé <xref:System.Windows.Controls.Primitives.ScrollBar> modèle de style.  
  
 [!code-xaml[ScrollBarTemplateExample#PageDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageLeftCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageLeftCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait largement défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> dans la direction horizontale des valeurs décroissantes de son <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande diminue la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> dans le <xref:System.Windows.Controls.Primitives.ScrollBar> par la valeur de la <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> propriété.  
  
 Cette commande se produit lorsque l’utilisateur appuie sur le bouton de page qui est à gauche de la <xref:System.Windows.Controls.Primitives.Thumb>. L’illustration suivante montre les boutons de page dans un <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ![Les différentes parties d’une barre de défilement](~/add/media/scrollbarpagebutton.png "les différentes parties d’une barre de défilement")  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_PageLeftCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.PageLeftCommand**`"/>`  
  
   
  
## Examples  
 L’exemple suivant montre comment spécifier le <xref:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand> personnalisé <xref:System.Windows.Controls.Primitives.ScrollBar> modèle de style.  
  
 [!code-xaml[ScrollBarTemplateExample#PageLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageRightCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageRightCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait largement défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> dans la direction horizontale des valeurs croissantes de son <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande augmente la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> dans le <xref:System.Windows.Controls.Primitives.ScrollBar> par la valeur de la <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> propriété.  
  
 Cette commande se produit lorsque l’utilisateur appuie sur le bouton de page qui apparaît à droite de la <xref:System.Windows.Controls.Primitives.Thumb>. L’illustration suivante montre les boutons de page dans un <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ![Les différentes parties d’une barre de défilement](~/add/media/scrollbarpagebutton.png "les différentes parties d’une barre de défilement")  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_PageRightCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.PageRightCommand**`"/>`  
  
   
  
## Examples  
 L’exemple suivant montre comment spécifier le <xref:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand> personnalisé <xref:System.Windows.Controls.Primitives.ScrollBar> modèle de style.  
  
 [!code-xaml[ScrollBarTemplateExample#PageRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageUpCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageUpCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait largement défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> dans la direction verticale des valeurs décroissantes de son <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande permet de réduire le <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> dans le <xref:System.Windows.Controls.Primitives.ScrollBar> par la valeur de la <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> propriété.  
  
 Cette commande se produit lorsque l’utilisateur appuie sur la touche PAGE précédente.  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_PageUpCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.PageUpCommand**`"/>`  
  
   
  
## Examples  
 L’exemple suivant montre comment spécifier le <xref:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand> personnalisé <xref:System.Windows.Controls.Primitives.ScrollBar> modèle de style.  
  
 [!code-xaml[ScrollBarTemplateExample#PageUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="Scroll">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.Primitives.ScrollEventHandler Scroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.Primitives.ScrollEventHandler Scroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Scroll As ScrollEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::Primitives::ScrollEventHandler ^ Scroll;" />
      <MemberSignature Language="F#" Value="member this.Scroll : System.Windows.Controls.Primitives.ScrollEventHandler " Usage="member this.Scroll : System.Windows.Controls.Primitives.ScrollEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.ScrollEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit une ou plusieurs fois lors du défilement du contenu dans une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> lorsque l'utilisateur déplace le <see cref="P:System.Windows.Controls.Primitives.Track.Thumb" /> en utilisant la souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement produit généralement plusieurs fois lorsque l’utilisateur modifie le <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> de la <xref:System.Windows.Controls.Primitives.ScrollBar> en faisant glisser le <xref:System.Windows.Controls.Primitives.Track.Thumb%2A>. Il n’existe aucune limite au nombre de fois où cet événement est déclenché comme le <xref:System.Windows.Controls.Primitives.Track.Thumb%2A> position est déplacée.  
  
 Cet événement n’est pas déclenché lorsque le <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> de la <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle est modifié dans le code.  
  
<a name="routedEventInfo_Scroll"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Controls.Primitives.ScrollEventHandler>|  
  
   
  
## Examples  
 L’exemple suivant montre comment assigner un gestionnaire d’événements pour le <xref:System.Windows.Controls.Primitives.ScrollBar.Scroll> événement à un <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle et comment définir le Gestionnaire d’événements dans le code.  
  
 [!code-xaml[ScrollBarSnips#Scroll](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scroll)]  
  
 [!code-csharp[ScrollBarSnips#ScrollHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#scrollhandler)]
 [!code-vb[ScrollBarSnips#ScrollHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#scrollhandler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ScrollEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ScrollEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ScrollEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ScrollEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ScrollEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollHereCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollHereCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollHereCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollHereCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollHereCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollHereCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> jusqu'à l'emplacement du clic de souris qui a ouvert le <see cref="T:System.Windows.Controls.ContextMenu" /> dans la <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande se produit lorsque l’utilisateur sélectionne **défilement ici** à partir de la <xref:System.Windows.Controls.ContextMenu> options. Le <xref:System.Windows.Controls.ContextMenu> de la <xref:System.Windows.Controls.Primitives.ScrollBar> s’affiche lorsque l’utilisateur place le pointeur de la souris sur le <xref:System.Windows.Controls.Primitives.ScrollBar> et appuie sur le bouton droit de la souris. Ce menu fournit des options pour faire défiler le <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Cette commande s’applique à un <xref:System.Windows.Controls.Primitives.ScrollBar> qui fait partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôler et est exécutée par le <xref:System.Windows.Controls.ScrollViewer>.  
  
<a name="xamlTextUsage_ScrollHereCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété* `="` **ScrollBar.ScrollHereCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToBottomCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToBottomCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToBottomCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToBottomCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToBottomCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToBottomCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToBottomCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToBottomCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> à la valeur <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour un vertical <xref:System.Windows.Controls.Primitives.ScrollBar>, ce déplacement se produit lorsque l’utilisateur appuie sur les touches CTRL + fin.  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_ScrollToBottomCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.ScrollToBottomCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait défiler le contenu vers le coin inférieur droit d'un contrôle <see cref="T:System.Windows.Controls.ScrollViewer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande est utilisée uniquement avec un <xref:System.Windows.Controls.ScrollViewer> contrôle.  
  
<a name="xamlTextUsage_ScrollToEndCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.ScrollToEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHomeCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHomeCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHomeCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHomeCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHomeCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHomeCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToHomeCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToHomeCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait défiler le contenu vers le coin supérieur gauche d'un contrôle <see cref="T:System.Windows.Controls.ScrollViewer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande est utilisée uniquement avec un <xref:System.Windows.Controls.ScrollViewer> contrôle.  
  
<a name="xamlTextUsage_ScrollToHomeCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.ScrollToHomeCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToHorizontalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontale dans un <see cref="T:System.Windows.Controls.ScrollViewer" /> à la valeur fournie dans <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande est utilisée uniquement avec un <xref:System.Windows.Controls.ScrollViewer> contrôle.  
  
<a name="xamlTextUsage_ScrollToHorizontalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *object* *property*`="`**ScrollBar.ScrollToHorizontalOffsetCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToLeftEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToLeftEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToLeftEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToLeftEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToLeftEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToLeftEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToLeftEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToLeftEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> à la valeur <see cref="P:System.Windows.Controls.Primitives.RangeBase.Minimum" /> pour une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande se produit lorsque l’utilisateur appuie sur les touches CTRL + origine pour un horizontal <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_ScrollToLeftEndCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété* `="` **ScrollBar.ScrollToLeftEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToRightEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToRightEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToRightEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToRightEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToRightEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToRightEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToRightEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToRightEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> à la valeur <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" /> pour une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande se produit lorsque l’utilisateur appuie sur les touches CTRL + fin pour un horizontal <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_ScrollToRightEndCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété* `="` **ScrollBar.ScrollToRightEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToTopCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToTopCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToTopCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToTopCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToTopCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToTopCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToTopCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToTopCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> à la valeur <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" /> pour une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verticale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour un vertical <xref:System.Windows.Controls.Primitives.ScrollBar>, ce déplacement se produit lorsque l’utilisateur appuie sur les touches CTRL + origine.  
  
 Lorsque vous implémentez un <xref:System.Windows.Controls.Primitives.ScrollBar> en tant que partie d’un <xref:System.Windows.Controls.ScrollViewer> contrôle, le <xref:System.Windows.Controls.ScrollViewer> exécute cette commande.  
  
<a name="xamlTextUsage_ScrollToTopCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *objet* *propriété*`="`**ScrollBar.ScrollToTopCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToVerticalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Commande qui fait défiler une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verticale dans un <see cref="T:System.Windows.Controls.ScrollViewer" /> à la valeur fournie dans <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette commande est utilisée uniquement avec un <xref:System.Windows.Controls.ScrollViewer> contrôle.  
  
<a name="xamlTextUsage_ScrollToVerticalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 `<` *object* *property*`="`**ScrollBar.ScrollToVerticalOffsetCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Track">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Primitives.Track Track { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.Primitives.Track Track" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Track" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Track As Track" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Primitives::Track ^ Track { System::Windows::Controls::Primitives::Track ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Track : System.Windows.Controls.Primitives.Track" Usage="System.Windows.Controls.Primitives.ScrollBar.Track" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.Track</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Windows.Controls.Primitives.Track" /> pour un contrôle <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <value>
          <see cref="T:System.Windows.Controls.Primitives.Track" /> utilisé avec un contrôle <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un modèle de style type pour un <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle inclut un <xref:System.Windows.Controls.Primitives.Track> contrôle est entouré des deux côtés par deux <xref:System.Windows.Controls.Button> contrôles.  
  
   
  
## Examples  
 L’exemple suivant montre comment accéder à la <xref:System.Windows.Controls.Primitives.Track> contrôle qui est utilisé avec un <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle.  
  
 [!code-csharp[ScrollBarSnips#Track](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#track)]
 [!code-vb[ScrollBarSnips#Track](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#track)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSize">
      <MemberSignature Language="C#" Value="public double ViewportSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewportSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.ViewportSize : double with get, set" Usage="System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la quantité de contenu de défilement actuellement visible.</summary>
        <value>Quantité de contenu déroulant qui est actuellement visible. La valeur par défaut est 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les unités qui sont utilisées pour <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> sont les mêmes unités qui sont utilisées pour décrire la longueur du contenu. Certains exemples incluent des lignes de texte ou des pages de texte.  
  
 La valeur de la <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> propriété est utilisée pour calculer la taille de la <xref:System.Windows.Controls.Primitives.Thumb> contrôle qui s’affiche en tant qu’indicateur de valeur décalée dans un <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle. Le <xref:System.Windows.Controls.Primitives.Thumb> taille du contrôle représente la quantité d’un <xref:System.Windows.Controls.ScrollViewer> contenu du contrôle qui est visible.  Si 25 pour cent d’un <xref:System.Windows.Controls.ScrollViewer> contenu du contrôle est visible, le <xref:System.Windows.Controls.Primitives.Thumb> occupe 25 pour cent de la piste dans le <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Vous pouvez décider quelles unités <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> utilise.  Lorsque vous définissez cette propriété, assurez-vous que le <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A>, <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A>, <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A>, et <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> propriétés utilisent les mêmes unités.  
  
 L’illustration suivante montre comment la <xref:System.Windows.Controls.Primitives.Thumb> taille reflète la quantité de contenu qui est visible.  
  
 ![La longueur de piste et d’une barre de défilement](~/add/media/scrollbarthumbsize.png "la longueur de piste et d’une barre de défilement")  
  
<a name="dependencyPropertyInfo_ViewportSize"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> sur un <xref:System.Windows.Controls.Primitives.ScrollBar> contrôle.  
  
 [!code-csharp[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#viewport)]
 [!code-vb[ScrollBarSnips#Viewport](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#viewport)]
 [!code-xaml[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#viewport)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ViewportSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ViewportSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ViewportSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ViewportSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ViewportSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>