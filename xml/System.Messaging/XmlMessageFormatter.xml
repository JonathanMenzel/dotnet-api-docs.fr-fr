<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a9a1931c75db76f56c20e9b7b0a8567e6d17609" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48590750" /></Metadata><TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Sérialise et désérialise des objets de/vers le corps d'un message à l'aide du format XML, en se basant sur la définition de schéma XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.XmlMessageFormatter> est le formateur par défaut qui une instance de <xref:System.Messaging.MessageQueue> utilise pour sérialiser les messages écrits dans la file d’attente. Lorsque vous créez une instance de <xref:System.Messaging.MessageQueue>, une instance de <xref:System.Messaging.XmlMessageFormatter> est créé pour vous et associé le <xref:System.Messaging.MessageQueue>. Vous pouvez spécifier un autre formateur en le créant dans votre code et l’assigner à la <xref:System.Messaging.MessageQueue.Formatter%2A> propriété de votre <xref:System.Messaging.MessageQueue>.  
  
 Par défaut d’une file d’attente <xref:System.Messaging.XmlMessageFormatter> instance peut être utilisée pour écrire dans la file d’attente, mais il ne peut pas être utilisé pour lire à partir de la file d’attente jusqu'à ce que vous définissez le <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propriété sur le formateur. Vous pouvez définir une ou ces deux valeurs sur l’instance de formateur par défaut, ou vous pouvez créer une nouvelle instance du formateur et définir les valeurs automatiquement en les passant en tant qu’arguments dans approprié <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructeur.  
  
 Lorsque vous spécifiez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> plutôt que <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, existence du type est vérifiée au moment de la compilation plutôt que des temps de lecture, ce qui réduit le risque d’erreur. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> nécessite que chaque entrée soit qualifiée complète, en spécifiant son nom d’assembly. En outre, lorsque vous travaillez avec plusieurs versions simultanément, le numéro de version doit également être ajouté au nom du type cible.  
  
 Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message. Cela permet au formateur d’interpréter le corps du message.  
  
 L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux. L’ensemble de types est l’ensemble combiné à partir des deux propriétés. La décision de la propriété à utiliser est spécifique à votre application. Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée lorsque le message est lu.  
  
 Le <xref:System.Messaging.XmlMessageFormatter> est un élément essentiel de la messagerie XML faiblement couplée. Les utilisations d’utilitaire XSD.exe que le format XML est utilisé pour générer le schéma XML, comme lorsque vous utilisez l’utilitaire pour sérialiser une classe utilisée par votre application. La classe doit avoir un constructeur par défaut.  
  
 Le format est utilisé à nouveau dans le processus inverse lorsque l’utilitaire génère une classe basée sur le schéma vous distribuez pour décrire votre classe de données. L’utilisation de l’utilitaire et le schéma XML qu’il génère vous permet d’éviter la redistribution des fichiers chaque recompilation d’une classe après que l’implémentation de votre classe a changé. Tant que le schéma ne change pas sur le client ou le serveur, autres modifications des deux côtés n’affectent pas l’autre.  
  
   
  
## Examples  
 L’exemple de code suivant comprend trois extraits de code : un composant serveur, une classe order et le code client. La classe order peut être utilisée par l’utilitaire XSD.exe pour générer le schéma que le serveur reconnaît dans les messages entrants. Le schéma est un fichier au format XML qui décrit la « forme » de la classe. Ce schéma peut ensuite être utilisé sur le côté client pour générer une classe de commandes propre au client qui partage le même schéma que la classe du serveur.  
  
 L’exemple de code suivant représente un composant de serveur qui reçoit des commandes via une file d’attente. Le corps du message doit être un objet de commande dont le schéma correspond à la classe Order.cs ci-dessous. Le processus de serveur ou l’application désérialise l’ordre.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 L’exemple de code suivant représente la classe de commande qui fournit un schéma pour les objets de commande que l’application sur le serveur reçoit et désérialise.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Toute application cliente qui interagit avec l’application sur le serveur doit envoyer des messages au serveur en sérialisant les informations dans une classe de commandes définie localement dans le corps du message. La classe de commandes définie localement doit avoir le même schéma que la classe de commande définie par le serveur dans lequel l’application sur le serveur tente de désérialiser le corps du message. L’utilitaire XSD.exe permet au Gestionnaire de l’application sur le serveur de créer et distribuer le schéma que le client doit utiliser pour sérialiser les messages envoyés au serveur.  
  
 Lorsque le Gestionnaire de l’application cliente reçoit le schéma pour la classe order, l’utilitaire XSD.exe est réutilisé pour générer une classe de commandes propre au client à partir du schéma. C’est cette classe est utilisée dans l’exemple de code client ci-dessous, pas la classe de serveur ordre (l’utilitaire XSD.exe génère la classe de schéma généré avoir le même nom que la classe d’origine). Cette nouvelle classe de commande est utilisée pour sérialiser la commande dans le corps du message.  
  
 L’exemple de code suivant est la côté client de traitement, utilisé pour sérialiser une commande et envoyer les informations associées à l’ordre à une file d’attente. Le code associe des informations d’élément, la quantité et adresse avec des éléments du schéma qui ont été générés pour la classe Order.cs par l’utilitaire XSD.exe. Une commande est envoyée à la file d’attente de commandes sur l’ordinateur local.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Une fois que le schéma est généré à partir de la classe order sur le serveur, vous pouvez modifier la classe. À moins que les modifications de schéma, vous n’avez pas besoin de redistribuer le schéma. Après avoir distribué le schéma et généré une classe de commande du côté client, cette classe de client également sont modifiables indépendamment de la classe de serveur ordre, tant que le schéma lui-même n’est pas modifié. Les deux classes sont devenues faiblement couplées.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.XmlMessageFormatter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.XmlMessageFormatter" />, sans que des types cibles soient définis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge du constructeur est utilisée plus fréquemment lors de l’écriture à la file d’attente, comme types de cibles ne sont pas requis lors de l’écriture.  
  
 Pour lire un message à partir d’une file d’attente à l’aide d’une instance de <xref:System.Messaging.XmlMessageFormatter> créé à l’aide de ce constructeur, vous devez définir le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés afin que le formateur sache quels types de tentative de désérialisation.  
  
 Lorsque vous créez un nouveau <xref:System.Messaging.MessageQueue>, une valeur par défaut <xref:System.Messaging.XmlMessageFormatter> instance est créée, sans le jeu de types cibles. Comme avec un formateur créé à l’aide de ce constructeur, vous devez définir les types de cibles pour cette instance de formateur si vous souhaitez lire à partir de la file d’attente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Tableau de type <see cref="T:System.String" /> qui spécifie le jeu de types possibles qui seront désérialisés par le formateur à partir du message fourni. Ces valeurs doivent être qualifiées complètes (par exemple, "MyNamespace.MyOrders, MyOrdersAssemblyName").</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.XmlMessageFormatter" /> en définissant des types cibles passés sous la forme d'un tableau de valeurs de chaîne (qualifiées complètes).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les constructeurs avec des paramètres de type de cible sont fréquemment utilisés lors de la lecture à partir de la file d’attente. Lors de l’écriture, il n’est pas nécessaire de spécifier les types de cibles.  
  
 Cette surcharge de la <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructeur affecte la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propriété pour les valeurs du tableau passé dans le `targetTypeNames` paramètre. Définition de cette propriété permet un <xref:System.Messaging.MessageQueue> à l’aide de ce <xref:System.Messaging.XmlMessageFormatter> instance pour lire les messages contenant des objets de types donnés.  
  
 À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message. Cela permet au formateur d’interpréter le corps du message.  
  
 L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux. L’ensemble de types est l’ensemble combiné à partir des deux propriétés. La décision dont l’application à utiliser est spécifique à votre application. Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée au moment de la lecture.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="targetTypeNames" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Tableau de type <see cref="T:System.Type" /> qui spécifie le jeu de types possibles qui seront désérialisés par le formateur à partir du message fourni.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.XmlMessageFormatter" /> en définissant des types cibles passés sous la forme d'un tableau de types d'objets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les constructeurs avec des paramètres de type de cible sont fréquemment utilisés lors de la lecture à partir de la file d’attente. Lors de l’écriture, il n’est pas nécessaire de spécifier les types de cibles.  
  
 Cette surcharge de la <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructeur affecte la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriété pour les valeurs du tableau passé dans le `targetTypes` paramètre. Définition de cette propriété permet un <xref:System.Messaging.MessageQueue> à l’aide de ce <xref:System.Messaging.XmlMessageFormatter> instance pour lire les messages contenant des objets de types donnés.  
  
 À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message. Cela permet au formateur d’interpréter le corps du message.  
  
 L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux. L’ensemble de types est l’ensemble combiné à partir des deux propriétés. La décision dont l’application à utiliser est spécifique à votre application. Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée au moment de la lecture.  
  
 Lorsque vous spécifiez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> plutôt que <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, existence du type est vérifiée au moment de la compilation plutôt que des temps de lecture, ce qui réduit le risque d’erreur. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> nécessite que chaque entrée soit qualifiée complète, en spécifiant son nom d’assembly. En outre, lorsque vous travaillez avec plusieurs versions simultanément, le numéro de version doit également être ajouté au nom du type cible.  
  
 Lorsque vous utilisez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, vous pouvez ajouter chaque objet (par exemple, `MyClass`) à la liste dans la manière illustrée par le code c# suivant.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="targetTypes" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.Messaging.Message" /> à examiner.</param>
        <summary>Détermine si le formateur peut désérialiser le message.</summary>
        <returns><see langword="true" /> si le formateur XML peut désérialiser le message ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> est appelée, le formateur tente de déterminer si le contenu du message est quelque chose qu’il peut désérialiser. Le formateur peut désérialiser uniquement le message si le type dans le corps du message a le même schéma qu’un des types dans le tableau représenté par la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Retourne `false` dans les deux circonstances suivantes :  
  
-   Le message a été pas mise en forme à l’aide de la <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Le schéma du corps du message n’est pas parmi ceux répertoriés dans le le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriété.  
  
 Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent au formateur les types d’objets qu’il doit être en mesure de désérialiser. Si n’importe quel type est manquant dans la liste, mais est détecté dans le message, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> retourne `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ni la propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />, ni la propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> n'ont été définies.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="message" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une instance de la classe <see cref="T:System.Messaging.XmlMessageFormatter" /> dont les propriétés de lecture/écriture (les jeux de types cibles) sont identiques à celles de l'instance de <see cref="T:System.Messaging.XmlMessageFormatter" /> en cours.</summary>
        <returns>Objet dont les propriétés sont identiques à celles de cette instance de <see cref="T:System.Messaging.XmlMessageFormatter" />, mais dont les métadonnées ne spécifient pas qu'il s'agit d'une instance de la classe du formateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée une copie du formateur et initialise toutes ses propriétés pour les valeurs de cette <xref:System.Messaging.XmlMessageFormatter> objet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.Messaging.Message" />, au format XML, à désérialiser.</param>
        <summary>Lit le contenu du message donné et crée un objet qui contient le message désérialisé.</summary>
        <returns>Message désérialisé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message. Une de ces propriétés doit être définie avant que le message peut être désérialisé.  
  
 L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Les types de cibles n’ont pas à être spécifiée afin d’écrire dans la file d’attente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ni la propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />, ni la propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> n'ont été définies.  
  
- ou - 
L'instance sérialisée dans le corps du message ne correspond à aucun des schémas représentés par les types dans les propriétés <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> et <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="message" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie le jeu de types éventuels qui sont désérialisés par le formateur à partir du message fourni.</summary>
        <value>Tableau de type <see cref="T:System.String" /> qui spécifie les types d'objets à désérialiser à partir du corps du message lors de sa lecture.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message. Cela permet au formateur d’interpréter le corps du message.  
  
 L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux. L’ensemble de types est l’ensemble combiné à partir des deux propriétés. La décision de la propriété à utiliser est spécifique à votre application. Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée lorsque le message est lu.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> nécessite que chaque entrée soit qualifiée complète, en spécifiant son nom d’assembly. En outre, lorsque vous travaillez avec plusieurs versions simultanément, le numéro de version doit également être ajouté au nom du type cible.  
  
 Les types de cibles sont uniquement requis lors de la lecture à partir de la file d’attente. Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés n’êtes pas obligé d’être définies pour écrire dans la file d’attente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie le jeu de types éventuels qui sont désérialisés par le formateur à partir du message fourni.</summary>
        <value>Tableau de type <see cref="T:System.Type" /> qui spécifie les types d'objets à désérialiser à partir du corps du message lors de sa lecture.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message. Cela permet au formateur d’interpréter le corps du message.  
  
 L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux. L’ensemble de types est l’ensemble combiné à partir des deux propriétés. La décision de la propriété à utiliser est spécifique à votre application. Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée lorsque le message est lu.  
  
 Les types de cibles sont uniquement requis lors de la lecture à partir de la file d’attente. Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés n’êtes pas obligé d’être définies pour écrire dans la file d’attente.  
  
 Lorsque vous spécifiez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> plutôt que <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, existence du type est vérifiée au moment de la compilation plutôt que des temps de lecture, ce qui réduit le risque d’erreur.  
  
 Lorsque vous utilisez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, vous pouvez ajouter chaque objet (par exemple, `MyClass`) à la liste de la manière illustrée par le code c# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 L’exemple de code suivant envoie et reçoit un message qui contient une commande vers et depuis une file d’attente.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.Body" /> contiendra l’objet sérialisé.</param>
        <param name="obj"><see cref="T:System.Object" /> à sérialiser dans le corps du message.</param>
        <summary>Sérialise un objet dans le corps du message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types de cibles ne doivent pas être spécifiés pour écrire dans la file d’attente, car ils doivent être lors de la lecture. Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriété est utilisée par le formateur uniquement lors de la désérialisation d’un message.  
  
 Le <xref:System.Messaging.XmlMessageFormatter> utilise le <xref:System.Xml.Serialization.XmlSerializer> (classe), qui définit ce qui peut être sérialisé. Seuls les champs publics et les propriétés publiques peuvent être sérialisées. Structures, les structures avec des tableaux et des tableaux de structures sont tous sérialisables, tant qu’ils n’utilisent pas le style encodé avec le protocole SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="message" /> a la valeur <see langword="null" />.  
  
- ou - 
Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>