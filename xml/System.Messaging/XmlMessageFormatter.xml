<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e9b5b367df928ff6d7a99dc28208e2d881b64249" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37478893" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="e503f-101">Serializes and deserializes objects to or from the body of a message, using the XML format based on the XSD schema definition.</span>
      <span class="sxs-lookup">
        <span data-stu-id="e503f-101">Serializes and deserializes objects to or from the body of a message, using the XML format based on the XSD schema definition.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e503f-102">Le <xref:System.Messaging.XmlMessageFormatter> est le formateur par défaut qui une instance de <xref:System.Messaging.MessageQueue> utilise pour sérialiser les messages écrits dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-102">The <xref:System.Messaging.XmlMessageFormatter> is the default formatter that an instance of <xref:System.Messaging.MessageQueue> uses to serialize messages written to the queue.</span></span> <span data-ttu-id="e503f-103">Lorsque vous créez une instance de <xref:System.Messaging.MessageQueue>, une instance de <xref:System.Messaging.XmlMessageFormatter> est créé pour vous et associé le <xref:System.Messaging.MessageQueue>.</span><span class="sxs-lookup"><span data-stu-id="e503f-103">When you create an instance of <xref:System.Messaging.MessageQueue>, an instance of <xref:System.Messaging.XmlMessageFormatter> is created for you and associated with the <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="e503f-104">Vous pouvez spécifier un autre formateur en le créant dans votre code et l’assigner à la <xref:System.Messaging.MessageQueue.Formatter%2A> propriété de votre <xref:System.Messaging.MessageQueue>.</span><span class="sxs-lookup"><span data-stu-id="e503f-104">You can specify a different formatter by creating it in your code and assigning it to the <xref:System.Messaging.MessageQueue.Formatter%2A> property of your <xref:System.Messaging.MessageQueue>.</span></span>  
  
 <span data-ttu-id="e503f-105">Par défaut d’une file d’attente <xref:System.Messaging.XmlMessageFormatter> instance peut être utilisée pour écrire dans la file d’attente, mais il ne peut pas être utilisé pour lire à partir de la file d’attente jusqu'à ce que vous définissez le <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propriété sur le formateur.</span><span class="sxs-lookup"><span data-stu-id="e503f-105">A queue's default <xref:System.Messaging.XmlMessageFormatter> instance can be used to write to the queue, but it cannot be used to read from the queue until you set either the <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> property on the formatter.</span></span> <span data-ttu-id="e503f-106">Vous pouvez définir une ou ces deux valeurs sur l’instance de formateur par défaut, ou vous pouvez créer une nouvelle instance du formateur et définir les valeurs automatiquement en les passant en tant qu’arguments dans approprié <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructeur.</span><span class="sxs-lookup"><span data-stu-id="e503f-106">You can either set one or both of these values on the default formatter instance, or you can create a new instance of the formatter and set the values automatically by passing them as arguments into the appropriate <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="e503f-107">Lorsque vous spécifiez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> plutôt que <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, existence du type est vérifiée au moment de la compilation plutôt que des temps de lecture, ce qui réduit le risque d’erreur.</span><span class="sxs-lookup"><span data-stu-id="e503f-107">When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error.</span></span> <span data-ttu-id="e503f-108"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> nécessite que chaque entrée soit qualifiée complète, en spécifiant son nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="e503f-108"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name.</span></span> <span data-ttu-id="e503f-109">En outre, lorsque vous travaillez avec plusieurs versions simultanément, le numéro de version doit également être ajouté au nom du type cible.</span><span class="sxs-lookup"><span data-stu-id="e503f-109">Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</span></span>  
  
 <span data-ttu-id="e503f-110">Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message.</span><span class="sxs-lookup"><span data-stu-id="e503f-110">The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="e503f-111">Cela permet au formateur d’interpréter le corps du message.</span><span class="sxs-lookup"><span data-stu-id="e503f-111">This allows the formatter to interpret the message body.</span></span>  
  
 <span data-ttu-id="e503f-112">L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types.</span><span class="sxs-lookup"><span data-stu-id="e503f-112">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="e503f-113">Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.</span><span class="sxs-lookup"><span data-stu-id="e503f-113">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="e503f-114">Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux.</span><span class="sxs-lookup"><span data-stu-id="e503f-114">Only one of the two properties needs to be set when reading from the queue, but you can set both.</span></span> <span data-ttu-id="e503f-115">L’ensemble de types est l’ensemble combiné à partir des deux propriétés.</span><span class="sxs-lookup"><span data-stu-id="e503f-115">The set of types is the combined set from the two properties.</span></span> <span data-ttu-id="e503f-116">La décision de la propriété à utiliser est spécifique à votre application.</span><span class="sxs-lookup"><span data-stu-id="e503f-116">The decision of which property to use is specific to your application.</span></span> <span data-ttu-id="e503f-117">Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée lorsque le message est lu.</span><span class="sxs-lookup"><span data-stu-id="e503f-117">If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</span></span>  
  
 <span data-ttu-id="e503f-118">Le <xref:System.Messaging.XmlMessageFormatter> est un élément essentiel de la messagerie XML faiblement couplée.</span><span class="sxs-lookup"><span data-stu-id="e503f-118">The <xref:System.Messaging.XmlMessageFormatter> is a crucial component of loosely coupled XML-based messaging.</span></span> <span data-ttu-id="e503f-119">Les utilisations d’utilitaire XSD.exe que le format XML est utilisé pour générer le schéma XML, comme lorsque vous utilisez l’utilitaire pour sérialiser une classe utilisée par votre application.</span><span class="sxs-lookup"><span data-stu-id="e503f-119">The XSD.exe utility uses the XML format is used to generate XML schema, such as when you use the utility to serialize a class used by your application.</span></span> <span data-ttu-id="e503f-120">La classe doit avoir un constructeur par défaut.</span><span class="sxs-lookup"><span data-stu-id="e503f-120">The class must have a default constructor.</span></span>  
  
 <span data-ttu-id="e503f-121">Le format est utilisé à nouveau dans le processus inverse lorsque l’utilitaire génère une classe basée sur le schéma vous distribuez pour décrire votre classe de données.</span><span class="sxs-lookup"><span data-stu-id="e503f-121">The format is used again in the reverse process when the utility generates a class based on the schema you distribute to describe your class data.</span></span> <span data-ttu-id="e503f-122">L’utilisation de l’utilitaire et le schéma XML qu’il génère vous permet d’éviter la redistribution des fichiers chaque recompilation d’une classe après que l’implémentation de votre classe a changé.</span><span class="sxs-lookup"><span data-stu-id="e503f-122">The use of the utility and the XML schema it generates enables you to avoid redistributing.dll files every time you recompile a class after the implementation of your class has changed.</span></span> <span data-ttu-id="e503f-123">Tant que le schéma ne change pas sur le client ou le serveur, autres modifications des deux côtés n’affectent pas l’autre.</span><span class="sxs-lookup"><span data-stu-id="e503f-123">As long as the schema does not change on the client or the server, other changes on either side do not affect the other.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e503f-124">L’exemple de code suivant comprend trois extraits de code : un composant serveur, une classe order et le code client.</span><span class="sxs-lookup"><span data-stu-id="e503f-124">The following code example includes three pieces of code: a server component, an order class, and client code.</span></span> <span data-ttu-id="e503f-125">La classe order peut être utilisée par l’utilitaire XSD.exe pour générer le schéma que le serveur reconnaît dans les messages entrants.</span><span class="sxs-lookup"><span data-stu-id="e503f-125">The order class can be used by the XSD.exe utility to generate schema that the server recognizes within incoming messages.</span></span> <span data-ttu-id="e503f-126">Le schéma est un fichier au format XML qui décrit la « forme » de la classe.</span><span class="sxs-lookup"><span data-stu-id="e503f-126">The schema is an XML formatted file that describes the "shape" of the class.</span></span> <span data-ttu-id="e503f-127">Ce schéma peut ensuite être utilisé sur le côté client pour générer une classe de commandes propre au client qui partage le même schéma que la classe du serveur.</span><span class="sxs-lookup"><span data-stu-id="e503f-127">This schema can then be used on the client side to generate a client-specific order class that shares the same schema as the server class.</span></span>  
  
 <span data-ttu-id="e503f-128">L’exemple de code suivant représente un composant de serveur qui reçoit des commandes via une file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-128">The following code example represents a server component that receives orders through a message queue.</span></span> <span data-ttu-id="e503f-129">Le corps du message doit être un objet de commande dont le schéma correspond à la classe Order.cs ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="e503f-129">The body of the message should be an order object whose schema matches the Order.cs class below.</span></span> <span data-ttu-id="e503f-130">Le processus de serveur ou l’application désérialise l’ordre.</span><span class="sxs-lookup"><span data-stu-id="e503f-130">The server process or application deserializes the order.</span></span>  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 <span data-ttu-id="e503f-131">L’exemple de code suivant représente la classe de commande qui fournit un schéma pour les objets de commande que l’application sur le serveur reçoit et désérialise.</span><span class="sxs-lookup"><span data-stu-id="e503f-131">The following code example represents the order class that provides a schema for the order objects that the application on the server receives and deserializes.</span></span>  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="e503f-132">Toute application cliente qui interagit avec l’application sur le serveur doit envoyer des messages au serveur en sérialisant les informations dans une classe de commandes définie localement dans le corps du message.</span><span class="sxs-lookup"><span data-stu-id="e503f-132">Any client application that interacts with the application on the server must send messages to the server by serializing information in a locally defined order class into the message body.</span></span> <span data-ttu-id="e503f-133">La classe de commandes définie localement doit avoir le même schéma que la classe de commande définie par le serveur dans lequel l’application sur le serveur tente de désérialiser le corps du message.</span><span class="sxs-lookup"><span data-stu-id="e503f-133">The locally defined order class must have the same schema as the server-defined order class into which the application on the server will attempt to deserialize the message body.</span></span> <span data-ttu-id="e503f-134">L’utilitaire XSD.exe permet au Gestionnaire de l’application sur le serveur de créer et distribuer le schéma que le client doit utiliser pour sérialiser les messages envoyés au serveur.</span><span class="sxs-lookup"><span data-stu-id="e503f-134">The XSD.exe utility lets the manager of the application on the server create and distribute the schema the client must use to serialize messages going to the server.</span></span>  
  
 <span data-ttu-id="e503f-135">Lorsque le Gestionnaire de l’application cliente reçoit le schéma pour la classe order, l’utilitaire XSD.exe est réutilisé pour générer une classe de commandes propre au client à partir du schéma.</span><span class="sxs-lookup"><span data-stu-id="e503f-135">When the manager of the client application receives the schema for the order class, the XSD.exe utility is used again to generate a client-specific order class from the schema.</span></span> <span data-ttu-id="e503f-136">C’est cette classe est utilisée dans l’exemple de code client ci-dessous, pas la classe de serveur ordre (l’utilitaire XSD.exe génère la classe de schéma généré avoir le même nom que la classe d’origine).</span><span class="sxs-lookup"><span data-stu-id="e503f-136">It is this class that is used in the client code example below, not the server's order class (the XSD.exe utility causes the schema-generated class to have the same name as the original class).</span></span> <span data-ttu-id="e503f-137">Cette nouvelle classe de commande est utilisée pour sérialiser la commande dans le corps du message.</span><span class="sxs-lookup"><span data-stu-id="e503f-137">This new order class is used to serialize the order into the message body.</span></span>  
  
 <span data-ttu-id="e503f-138">L’exemple de code suivant est la côté client de traitement, utilisé pour sérialiser une commande et envoyer les informations associées à l’ordre à une file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-138">The following code example is the client-side processing, used to serialize an order and send the information associated with the order to a queue.</span></span> <span data-ttu-id="e503f-139">Le code associe des informations d’élément, la quantité et adresse avec des éléments du schéma qui ont été générés pour la classe Order.cs par l’utilitaire XSD.exe.</span><span class="sxs-lookup"><span data-stu-id="e503f-139">The code associates Item, Quantity, and Address information with elements of the schema that were generated for the Order.cs class by the XSD.exe utility.</span></span> <span data-ttu-id="e503f-140">Une commande est envoyée à la file d’attente de commandes sur l’ordinateur local.</span><span class="sxs-lookup"><span data-stu-id="e503f-140">An order is sent to the Orders queue on the local computer.</span></span>  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 <span data-ttu-id="e503f-141">Une fois que le schéma est généré à partir de la classe order sur le serveur, vous pouvez modifier la classe.</span><span class="sxs-lookup"><span data-stu-id="e503f-141">After the schema is generated from the order class on the server, you can modify the class.</span></span> <span data-ttu-id="e503f-142">À moins que les modifications de schéma, vous n’avez pas besoin de redistribuer le schéma.</span><span class="sxs-lookup"><span data-stu-id="e503f-142">Unless the schema changes, you do not need to redistribute the schema.</span></span> <span data-ttu-id="e503f-143">Après avoir distribué le schéma et généré une classe de commande du côté client, cette classe de client également sont modifiables indépendamment de la classe de serveur ordre, tant que le schéma lui-même n’est pas modifié.</span><span class="sxs-lookup"><span data-stu-id="e503f-143">After you have distributed the schema and generated a client-side order class, that client class can also be modified independently of the server's order class, as long as the schema itself is not modified.</span></span> <span data-ttu-id="e503f-144">Les deux classes sont devenues faiblement couplées.</span><span class="sxs-lookup"><span data-stu-id="e503f-144">The two classes have become loosely coupled.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e503f-145">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-145">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e503f-146">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, without target types set.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-146">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, without target types set.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e503f-147">Cette surcharge du constructeur est utilisée plus fréquemment lors de l’écriture à la file d’attente, comme types de cibles ne sont pas requis lors de l’écriture.</span><span class="sxs-lookup"><span data-stu-id="e503f-147">This overload of the constructor is used most frequently when writing to the queue, as target types are not required when writing.</span></span>  
  
 <span data-ttu-id="e503f-148">Pour lire un message à partir d’une file d’attente à l’aide d’une instance de <xref:System.Messaging.XmlMessageFormatter> créé à l’aide de ce constructeur, vous devez définir le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés afin que le formateur sache quels types de tentative de désérialisation.</span><span class="sxs-lookup"><span data-stu-id="e503f-148">To read a message from a queue using an instance of <xref:System.Messaging.XmlMessageFormatter> created using this constructor, you must set the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties so the formatter knows what types to attempt to deserialize.</span></span>  
  
 <span data-ttu-id="e503f-149">Lorsque vous créez un nouveau <xref:System.Messaging.MessageQueue>, une valeur par défaut <xref:System.Messaging.XmlMessageFormatter> instance est créée, sans le jeu de types cibles.</span><span class="sxs-lookup"><span data-stu-id="e503f-149">When you create a new <xref:System.Messaging.MessageQueue>, a default <xref:System.Messaging.XmlMessageFormatter> instance is created, without the target types set.</span></span> <span data-ttu-id="e503f-150">Comme avec un formateur créé à l’aide de ce constructeur, vous devez définir les types de cibles pour cette instance de formateur si vous souhaitez lire à partir de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-150">As with a formatter created using this constructor, you must set target types for that formatter instance if you want to read from the queue.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">
          <span data-ttu-id="e503f-151">An array of type <see cref="T:System.String" /> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-151">An array of type <see cref="T:System.String" /> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</span>
          </span>
          <span data-ttu-id="e503f-152">These values must be fully qualified, for example, "MyNamespace.MyOrders, MyOrdersAssemblyName".</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-152">These values must be fully qualified, for example, "MyNamespace.MyOrders, MyOrdersAssemblyName".</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e503f-153">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, setting target types passed in as an array of (fully qualified) string values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-153">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, setting target types passed in as an array of (fully qualified) string values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e503f-154">Les constructeurs avec des paramètres de type de cible sont fréquemment utilisés lors de la lecture à partir de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-154">The constructors with target type parameters are most frequently used when reading from the queue.</span></span> <span data-ttu-id="e503f-155">Lors de l’écriture, il n’est pas nécessaire de spécifier les types de cibles.</span><span class="sxs-lookup"><span data-stu-id="e503f-155">When writing, it is not necessary to specify target types.</span></span>  
  
 <span data-ttu-id="e503f-156">Cette surcharge de la <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructeur affecte la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propriété pour les valeurs du tableau passé dans le `targetTypeNames` paramètre.</span><span class="sxs-lookup"><span data-stu-id="e503f-156">This overload of the <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor sets the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> property to the array values passed in through the `targetTypeNames` parameter.</span></span> <span data-ttu-id="e503f-157">Définition de cette propriété permet un <xref:System.Messaging.MessageQueue> à l’aide de ce <xref:System.Messaging.XmlMessageFormatter> instance pour lire les messages contenant des objets de types donnés.</span><span class="sxs-lookup"><span data-stu-id="e503f-157">Setting this property enables a <xref:System.Messaging.MessageQueue> using this <xref:System.Messaging.XmlMessageFormatter> instance to read messages containing objects of given types.</span></span>  
  
 <span data-ttu-id="e503f-158">À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message.</span><span class="sxs-lookup"><span data-stu-id="e503f-158">Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="e503f-159">Cela permet au formateur d’interpréter le corps du message.</span><span class="sxs-lookup"><span data-stu-id="e503f-159">This allows the formatter to interpret the message body.</span></span>  
  
 <span data-ttu-id="e503f-160">L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types.</span><span class="sxs-lookup"><span data-stu-id="e503f-160">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="e503f-161">Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.</span><span class="sxs-lookup"><span data-stu-id="e503f-161">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="e503f-162">Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux.</span><span class="sxs-lookup"><span data-stu-id="e503f-162">Only one of the two properties needs to be set when reading from the queue, but you can set both.</span></span> <span data-ttu-id="e503f-163">L’ensemble de types est l’ensemble combiné à partir des deux propriétés.</span><span class="sxs-lookup"><span data-stu-id="e503f-163">The set of types is the combined set from the two properties.</span></span> <span data-ttu-id="e503f-164">La décision dont l’application à utiliser est spécifique à votre application.</span><span class="sxs-lookup"><span data-stu-id="e503f-164">The decision of which one to use is specific to your application.</span></span> <span data-ttu-id="e503f-165">Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée au moment de la lecture.</span><span class="sxs-lookup"><span data-stu-id="e503f-165">If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.</span></span>  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e503f-166">The <paramref name="targetTypeNames" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-166">The <paramref name="targetTypeNames" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">
          <span data-ttu-id="e503f-167">An array of type <see cref="T:System.Type" /> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-167">An array of type <see cref="T:System.Type" /> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e503f-168">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, setting target types passed in as an array of object types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-168">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, setting target types passed in as an array of object types.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e503f-169">Les constructeurs avec des paramètres de type de cible sont fréquemment utilisés lors de la lecture à partir de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-169">The constructors with target type parameters are most frequently used when reading from the queue.</span></span> <span data-ttu-id="e503f-170">Lors de l’écriture, il n’est pas nécessaire de spécifier les types de cibles.</span><span class="sxs-lookup"><span data-stu-id="e503f-170">When writing, it is not necessary to specify target types.</span></span>  
  
 <span data-ttu-id="e503f-171">Cette surcharge de la <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructeur affecte la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriété pour les valeurs du tableau passé dans le `targetTypes` paramètre.</span><span class="sxs-lookup"><span data-stu-id="e503f-171">This overload of the <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor sets the <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property to the array values passed in through the `targetTypes` parameter.</span></span> <span data-ttu-id="e503f-172">Définition de cette propriété permet un <xref:System.Messaging.MessageQueue> à l’aide de ce <xref:System.Messaging.XmlMessageFormatter> instance pour lire les messages contenant des objets de types donnés.</span><span class="sxs-lookup"><span data-stu-id="e503f-172">Setting this property enables a <xref:System.Messaging.MessageQueue> using this <xref:System.Messaging.XmlMessageFormatter> instance to read messages containing objects of the given types.</span></span>  
  
 <span data-ttu-id="e503f-173">À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message.</span><span class="sxs-lookup"><span data-stu-id="e503f-173">Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="e503f-174">Cela permet au formateur d’interpréter le corps du message.</span><span class="sxs-lookup"><span data-stu-id="e503f-174">This allows the formatter to interpret the message body.</span></span>  
  
 <span data-ttu-id="e503f-175">L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types.</span><span class="sxs-lookup"><span data-stu-id="e503f-175">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="e503f-176">Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.</span><span class="sxs-lookup"><span data-stu-id="e503f-176">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="e503f-177">Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux.</span><span class="sxs-lookup"><span data-stu-id="e503f-177">Only one of the two properties needs to be set when reading from the queue, but you can set both.</span></span> <span data-ttu-id="e503f-178">L’ensemble de types est l’ensemble combiné à partir des deux propriétés.</span><span class="sxs-lookup"><span data-stu-id="e503f-178">The set of types is the combined set from the two properties.</span></span> <span data-ttu-id="e503f-179">La décision dont l’application à utiliser est spécifique à votre application.</span><span class="sxs-lookup"><span data-stu-id="e503f-179">The decision of which one to use is specific to your application.</span></span> <span data-ttu-id="e503f-180">Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée au moment de la lecture.</span><span class="sxs-lookup"><span data-stu-id="e503f-180">If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.</span></span>  
  
 <span data-ttu-id="e503f-181">Lorsque vous spécifiez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> plutôt que <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, existence du type est vérifiée au moment de la compilation plutôt que des temps de lecture, ce qui réduit le risque d’erreur.</span><span class="sxs-lookup"><span data-stu-id="e503f-181">When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error.</span></span> <span data-ttu-id="e503f-182"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> nécessite que chaque entrée soit qualifiée complète, en spécifiant son nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="e503f-182"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name.</span></span> <span data-ttu-id="e503f-183">En outre, lorsque vous travaillez avec plusieurs versions simultanément, le numéro de version doit également être ajouté au nom du type cible.</span><span class="sxs-lookup"><span data-stu-id="e503f-183">Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</span></span>  
  
 <span data-ttu-id="e503f-184">Lorsque vous utilisez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, vous pouvez ajouter chaque objet (par exemple, `MyClass`) à la liste dans la manière illustrée par le code c# suivant.</span><span class="sxs-lookup"><span data-stu-id="e503f-184">When using <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, you can add each object (for example, `MyClass`) to the list in a way demonstrated by the following C# code.</span></span>  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e503f-185">The <paramref name="targetTypes" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-185">The <paramref name="targetTypes" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">
          <span data-ttu-id="e503f-186">The <see cref="T:System.Messaging.Message" /> to inspect.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-186">The <see cref="T:System.Messaging.Message" /> to inspect.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e503f-187">Determines whether the formatter can deserialize the message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-187">Determines whether the formatter can deserialize the message.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e503f-188">
            <see langword="true" /> if the XML formatter can deserialize the message; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-188">
              <see langword="true" /> if the XML formatter can deserialize the message; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e503f-189">Lorsque <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> est appelée, le formateur tente de déterminer si le contenu du message est quelque chose qu’il peut désérialiser.</span><span class="sxs-lookup"><span data-stu-id="e503f-189">When <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> is called, the formatter attempts to determine if the contents of the message are something it can deserialize.</span></span> <span data-ttu-id="e503f-190">Le formateur peut désérialiser uniquement le message si le type dans le corps du message a le même schéma qu’un des types dans le tableau représenté par la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="e503f-190">The formatter can only deserialize the message if the type in the message body has the same schema as one of the types in the array represented by the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties.</span></span> <span data-ttu-id="e503f-191"><xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Retourne `false` dans les deux circonstances suivantes :</span><span class="sxs-lookup"><span data-stu-id="e503f-191"><xref:System.Messaging.XmlMessageFormatter.CanRead%2A> returns `false` under the following two circumstances:</span></span>  
  
-   <span data-ttu-id="e503f-192">Le message a été pas mise en forme à l’aide de la <xref:System.Messaging.XmlMessageFormatter>.</span><span class="sxs-lookup"><span data-stu-id="e503f-192">The message was not formatted using the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
-   <span data-ttu-id="e503f-193">Le schéma du corps du message n’est pas parmi ceux répertoriés dans le le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="e503f-193">The schema of the message body is not among those listed in either the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property.</span></span>  
  
 <span data-ttu-id="e503f-194">Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent au formateur les types d’objets qu’il doit être en mesure de désérialiser.</span><span class="sxs-lookup"><span data-stu-id="e503f-194">The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what types of objects it must be able to deserialize.</span></span> <span data-ttu-id="e503f-195">Si n’importe quel type est manquant dans la liste, mais est détecté dans le message, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="e503f-195">If any type is missing from the list, yet is found within the message, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="e503f-196">Neither the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nor <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property has been set.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-196">Neither the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nor <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property has been set.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e503f-197">The <paramref name="message" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-197">The <paramref name="message" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e503f-198">Creates an instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class whose read/write properties (the sets of target types) are the same as the current <see cref="T:System.Messaging.XmlMessageFormatter" /> instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-198">Creates an instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class whose read/write properties (the sets of target types) are the same as the current <see cref="T:System.Messaging.XmlMessageFormatter" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e503f-199">An object whose properties are identical to those of this <see cref="T:System.Messaging.XmlMessageFormatter" /> instance, but whose metadata does not specify it to be a formatter class instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-199">An object whose properties are identical to those of this <see cref="T:System.Messaging.XmlMessageFormatter" /> instance, but whose metadata does not specify it to be a formatter class instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e503f-200">Cette méthode crée une copie du formateur et initialise toutes ses propriétés pour les valeurs de cette <xref:System.Messaging.XmlMessageFormatter> objet.</span><span class="sxs-lookup"><span data-stu-id="e503f-200">This method creates a copy of the formatter and initializes all its properties to the values of this <xref:System.Messaging.XmlMessageFormatter> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">
          <span data-ttu-id="e503f-201">The <see cref="T:System.Messaging.Message" />, in XML format, to deserialize.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-201">The <see cref="T:System.Messaging.Message" />, in XML format, to deserialize.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e503f-202">Reads the contents from the given message and creates an object that contains the deserialized message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-202">Reads the contents from the given message and creates an object that contains the deserialized message.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e503f-203">The deserialized message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-203">The deserialized message.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e503f-204">À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message.</span><span class="sxs-lookup"><span data-stu-id="e503f-204">Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="e503f-205">Une de ces propriétés doit être définie avant que le message peut être désérialisé.</span><span class="sxs-lookup"><span data-stu-id="e503f-205">One of these properties must be set before the message can be deserialized.</span></span>  
  
 <span data-ttu-id="e503f-206">L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types.</span><span class="sxs-lookup"><span data-stu-id="e503f-206">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="e503f-207">Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.</span><span class="sxs-lookup"><span data-stu-id="e503f-207">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="e503f-208">Les types de cibles n’ont pas à être spécifiée afin d’écrire dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-208">The target types do not have to be specified in order to write to the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="e503f-209">Neither the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nor <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property has been set.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-209">Neither the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nor <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property has been set.</span>
          </span>
          <span data-ttu-id="e503f-210">-or-  The instance serialized in the message body does not comply with any of the schemas represented by the types in the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> and <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> properties.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-210">-or-  The instance serialized in the message body does not comply with any of the schemas represented by the types in the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> and <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> properties.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e503f-211">The <paramref name="message" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-211">The <paramref name="message" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e503f-212">Specifies the set of possible types that will be deserialized by the formatter from the message provided.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-212">Specifies the set of possible types that will be deserialized by the formatter from the message provided.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e503f-213">Tableau de type <see cref="T:System.String" /> qui spécifie les types d’objets à désérialiser à partir du corps de message lors de la lecture du message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-213">An array of type <see cref="T:System.String" /> that specifies the types of objects to deserialize from the message body when reading the message.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e503f-214">À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message.</span><span class="sxs-lookup"><span data-stu-id="e503f-214">Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="e503f-215">Cela permet au formateur d’interpréter le corps du message.</span><span class="sxs-lookup"><span data-stu-id="e503f-215">This allows the formatter to interpret the message body.</span></span>  
  
 <span data-ttu-id="e503f-216">L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types.</span><span class="sxs-lookup"><span data-stu-id="e503f-216">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="e503f-217">Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.</span><span class="sxs-lookup"><span data-stu-id="e503f-217">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="e503f-218">Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux.</span><span class="sxs-lookup"><span data-stu-id="e503f-218">Only one of the two properties needs to be set when reading from the queue, but you can set both.</span></span> <span data-ttu-id="e503f-219">L’ensemble de types est l’ensemble combiné à partir des deux propriétés.</span><span class="sxs-lookup"><span data-stu-id="e503f-219">The set of types is the combined set from the two properties.</span></span> <span data-ttu-id="e503f-220">La décision de la propriété à utiliser est spécifique à votre application.</span><span class="sxs-lookup"><span data-stu-id="e503f-220">The decision of which property to use is specific to your application.</span></span> <span data-ttu-id="e503f-221">Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée lorsque le message est lu.</span><span class="sxs-lookup"><span data-stu-id="e503f-221">If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</span></span>  
  
 <span data-ttu-id="e503f-222"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> nécessite que chaque entrée soit qualifiée complète, en spécifiant son nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="e503f-222"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name.</span></span> <span data-ttu-id="e503f-223">En outre, lorsque vous travaillez avec plusieurs versions simultanément, le numéro de version doit également être ajouté au nom du type cible.</span><span class="sxs-lookup"><span data-stu-id="e503f-223">Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</span></span>  
  
 <span data-ttu-id="e503f-224">Les types de cibles sont uniquement requis lors de la lecture à partir de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-224">The target types are only required when reading from the queue.</span></span> <span data-ttu-id="e503f-225">Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés n’êtes pas obligé d’être définies pour écrire dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-225">The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties do not need to be set to write to the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e503f-226">The <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> property is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-226">The <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> property is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e503f-227">Specifies the set of possible types that will be deserialized by the formatter from the message provided.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-227">Specifies the set of possible types that will be deserialized by the formatter from the message provided.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e503f-228">Tableau de type <see cref="T:System.Type" /> qui spécifie les types d’objets à désérialiser à partir du corps de message lors de la lecture du message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-228">An array of type <see cref="T:System.Type" /> that specifies the types of objects to deserialize from the message body when reading the message.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e503f-229">À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent le formateur les schémas en correspondance lors de la désérialisation d’un message.</span><span class="sxs-lookup"><span data-stu-id="e503f-229">Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="e503f-230">Cela permet au formateur d’interpréter le corps du message.</span><span class="sxs-lookup"><span data-stu-id="e503f-230">This allows the formatter to interpret the message body.</span></span>  
  
 <span data-ttu-id="e503f-231">L’instance sérialisée dans le corps du message doit être conforme avec l’un des schémas représentés dans le tableau de types.</span><span class="sxs-lookup"><span data-stu-id="e503f-231">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="e503f-232">Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.</span><span class="sxs-lookup"><span data-stu-id="e503f-232">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="e503f-233">Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux.</span><span class="sxs-lookup"><span data-stu-id="e503f-233">Only one of the two properties needs to be set when reading from the queue, but you can set both.</span></span> <span data-ttu-id="e503f-234">L’ensemble de types est l’ensemble combiné à partir des deux propriétés.</span><span class="sxs-lookup"><span data-stu-id="e503f-234">The set of types is the combined set from the two properties.</span></span> <span data-ttu-id="e503f-235">La décision de la propriété à utiliser est spécifique à votre application.</span><span class="sxs-lookup"><span data-stu-id="e503f-235">The decision of which property to use is specific to your application.</span></span> <span data-ttu-id="e503f-236">Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée lorsque le message est lu.</span><span class="sxs-lookup"><span data-stu-id="e503f-236">If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</span></span>  
  
 <span data-ttu-id="e503f-237">Les types de cibles sont uniquement requis lors de la lecture à partir de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-237">The target types are only required when reading from the queue.</span></span> <span data-ttu-id="e503f-238">Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés n’êtes pas obligé d’être définies pour écrire dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-238">The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties do not need to be set to write to the queue.</span></span>  
  
 <span data-ttu-id="e503f-239">Lorsque vous spécifiez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> plutôt que <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, existence du type est vérifiée au moment de la compilation plutôt que des temps de lecture, ce qui réduit le risque d’erreur.</span><span class="sxs-lookup"><span data-stu-id="e503f-239">When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error.</span></span>  
  
 <span data-ttu-id="e503f-240">Lorsque vous utilisez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, vous pouvez ajouter chaque objet (par exemple, `MyClass`) à la liste de la manière illustrée par le code c# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.</span><span class="sxs-lookup"><span data-stu-id="e503f-240">When using <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, you can add each object (for example, `MyClass`) to the list in a way demonstrated by the C# code `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e503f-241">L’exemple de code suivant envoie et reçoit un message qui contient une commande vers et depuis une file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e503f-241">The following code example sends and receives a message that contains an order to and from a queue.</span></span>  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e503f-242">The <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-242">The <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">
          <span data-ttu-id="e503f-243">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Body" /> property will contain the serialized object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-243">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Body" /> property will contain the serialized object.</span>
          </span>
        </param>
        <param name="obj">
          <span data-ttu-id="e503f-244">The <see cref="T:System.Object" /> to be serialized into the message body.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-244">The <see cref="T:System.Object" /> to be serialized into the message body.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e503f-245">Serializes an object into the body of the message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-245">Serializes an object into the body of the message.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e503f-246">Les types de cibles ne doivent pas être spécifiés pour écrire dans la file d’attente, car ils doivent être lors de la lecture.</span><span class="sxs-lookup"><span data-stu-id="e503f-246">The target types need not be specified to write to the queue as they must be when reading.</span></span> <span data-ttu-id="e503f-247">Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriété est utilisée par le formateur uniquement lors de la désérialisation d’un message.</span><span class="sxs-lookup"><span data-stu-id="e503f-247">The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property is used by the formatter only when deserializing a message.</span></span>  
  
 <span data-ttu-id="e503f-248">Le <xref:System.Messaging.XmlMessageFormatter> utilise le <xref:System.Xml.Serialization.XmlSerializer> (classe), qui définit ce qui peut être sérialisé.</span><span class="sxs-lookup"><span data-stu-id="e503f-248">The <xref:System.Messaging.XmlMessageFormatter> makes use of the <xref:System.Xml.Serialization.XmlSerializer> class, which defines what can be serialized.</span></span> <span data-ttu-id="e503f-249">Seuls les champs publics et les propriétés publiques peuvent être sérialisées.</span><span class="sxs-lookup"><span data-stu-id="e503f-249">Only public fields and public properties can be serialized.</span></span> <span data-ttu-id="e503f-250">Structures, les structures avec des tableaux et des tableaux de structures sont tous sérialisables, tant qu’ils n’utilisent pas le style encodé avec le protocole SOAP.</span><span class="sxs-lookup"><span data-stu-id="e503f-250">Structures, structures with arrays, and arrays of structures are all serializable, as long as they do not use the encoded style with the SOAP protocol.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e503f-251">The <paramref name="message" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-251">The <paramref name="message" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="e503f-252">-or-  The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e503f-252">-or-  The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>