<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="563e678b40760a20036da2630095cb8b05f461de" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460733" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Sérialise et désérialise des objets de/vers le corps d'un message à l'aide du format XML, en se basant sur la définition de schéma XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.XmlMessageFormatter> est le formateur par défaut qui une instance de <xref:System.Messaging.MessageQueue> pour sérialiser les messages écrits dans la file d’attente. Lorsque vous créez une instance de <xref:System.Messaging.MessageQueue>, une instance de <xref:System.Messaging.XmlMessageFormatter> est créé et associé à la <xref:System.Messaging.MessageQueue>. Vous pouvez spécifier un autre formateur en créant dans votre code et en l’affectant à la <xref:System.Messaging.MessageQueue.Formatter%2A> propriété de votre <xref:System.Messaging.MessageQueue>.  
  
 Par défaut de la file d’attente <xref:System.Messaging.XmlMessageFormatter> instance peut être utilisée pour écrire dans la file d’attente, mais il ne peut pas être utilisé pour lire à partir de la file d’attente jusqu'à ce que vous définissez la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propriété sur le module de formatage. Vous pouvez définir une ou deux de ces valeurs sur l’instance de formateur par défaut, ou vous pouvez créer une nouvelle instance du formateur et définir les valeurs automatiquement en les passant en tant qu’arguments dans les <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructeur.  
  
 Lors de la spécification <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> plutôt que <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, existence du type est vérifiée au moment de la compilation plutôt que des temps de lecture, ce qui réduit le risque d’erreur. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> nécessite que chaque entrée soit qualifiée complète, en spécifiant son nom d’assembly. En outre, lorsque vous travaillez avec plusieurs versions simultanées, le numéro de version doit également être ajouté pour le nom du type cible.  
  
 Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent au formateur les schémas auxquels correspondre lors de la désérialisation d’un message. Cela permet au formateur d’interpréter le corps du message.  
  
 L’instance sérialisée dans le corps du message doit être conforme à un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux. L’ensemble de types est l’ensemble combiné à partir des deux propriétés. Le choix de la propriété à utiliser est spécifique à votre application. Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception est levée lorsque le message est lu.  
  
 Le <xref:System.Messaging.XmlMessageFormatter> est un composant essentiel de la messagerie XML faiblement couplée. Les utilisations d’utilitaire XSD.exe qu'au format XML est utilisé pour générer le schéma XML, comme lorsque vous utilisez l’utilitaire pour sérialiser une classe utilisée par votre application. La classe doit avoir un constructeur par défaut.  
  
 Le format est utilisé à nouveau dans le processus inverse lorsque l’utilitaire génère une classe basée sur le schéma que vous distribuez pour décrire votre classe de données. L’utilisation de l’utilitaire et le schéma XML vous permet de vous permet d’éviter la redistribution des fichiers chaque recompilation d’une classe après que l’implémentation de votre classe a changé. Tant que le schéma ne change pas sur le client ou le serveur, les modifications apportées sur un côté n’affectent pas l’autre.  
  
   
  
## Examples  
 L’exemple de code suivant comprend trois extraits de code : un composant serveur, une classe de commande et le code client. La classe de commande peut être utilisée par l’utilitaire XSD.exe pour générer le schéma reconnu par le serveur dans les messages entrants. Le schéma est un fichier au format XML qui décrit la « forme » de la classe. Ce schéma peut ensuite être utilisé côté client pour générer une classe de commandes propre au client qui partage le même schéma que la classe du serveur.  
  
 L’exemple de code suivant représente un composant de serveur qui reçoit des commandes via une file d’attente. Le corps du message doit être un objet de commande dont le schéma correspond à la classe Order.cs ci-dessous. Le processus de serveur ou l’application désérialise la commande.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 L’exemple de code suivant représente la classe de commande qui fournit un schéma pour les objets de commande que l’application sur le serveur reçoit et désérialise.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Toute application cliente qui interagit avec l’application sur le serveur doit envoyer des messages au serveur en sérialisant les informations dans une classe de commandes définie localement dans le corps du message. La classe de commandes définie localement doit avoir le même schéma que la classe définie par le serveur l’ordre dans lequel l’application sur le serveur tente de désérialiser le corps du message. L’utilitaire XSD.exe permet au Gestionnaire de l’application sur le serveur de créer et distribuer le schéma que le client doit utiliser pour sérialiser les messages envoyés au serveur.  
  
 Lorsque le Gestionnaire de l’application cliente reçoit le schéma de la classe order, l’utilitaire XSD.exe est réutilisé pour générer une classe de commandes propre au client à partir du schéma. Cette classe est utilisée dans l’exemple de code client ci-dessous, pas la classe de serveur ordre (l’utilitaire XSD.exe implique que la classe générée par le schéma d’avoir le même nom que la classe d’origine). Cette nouvelle classe de commande est utilisée pour sérialiser la commande dans le corps du message.  
  
 L’exemple de code suivant est la côté client du traitement, utilisé pour sérialiser une commande et les informations associées à l’ordre à une file d’attente d’envoi. Le code associe l’article, quantité, et l’adresse comportant des éléments du schéma qui ont été générés pour la classe Order.cs par l’utilitaire XSD.exe. Une commande est envoyée à la file d’attente de commandes sur l’ordinateur local.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Une fois que le schéma est généré à partir de la classe de commande sur le serveur, vous pouvez modifier la classe. À moins que les modifications de schéma, vous n’avez pas besoin de redistribuer le schéma. Après avoir distribué le schéma et généré une classe de commandes côté client, cette classe de client peut également être modifiée indépendamment de la classe de serveur ordre, tant que le schéma lui-même n’est pas modifié. Les deux classes sont devenues faiblement couplées.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.XmlMessageFormatter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.XmlMessageFormatter" />, sans que des types cibles soient définis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge du constructeur est plus fréquemment utilisée lors de l’écriture dans la file d’attente, comme les types de cibles ne sont pas requis lors de l’écriture.  
  
 Pour lire un message à partir d’une file d’attente à l’aide d’une instance de <xref:System.Messaging.XmlMessageFormatter> créé à l’aide de ce constructeur, vous devez définir le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés afin du formateur les types qu’il doit pour tenter de désérialiser.  
  
 Lorsque vous créez un nouveau <xref:System.Messaging.MessageQueue>, une valeur par défaut <xref:System.Messaging.XmlMessageFormatter> instance est créée, sans le jeu de types de cibles. Comme avec un formateur créé à l’aide de ce constructeur, vous devez définir les types de cibles pour cette instance de formateur si vous souhaitez lire à partir de la file d’attente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Tableau de type <see cref="T:System.String" /> qui spécifie le jeu de types possibles qui seront désérialisés par le formateur à partir du message fourni. Ces valeurs doivent être qualifiées complètes (par exemple, "MyNamespace.MyOrders, MyOrdersAssemblyName").</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.XmlMessageFormatter" /> en définissant des types cibles passés sous la forme d'un tableau de valeurs de chaîne (qualifiées complètes).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les constructeurs avec des paramètres de type de cible sont fréquemment utilisés lors de la lecture à partir de la file d’attente. Lors de l’écriture, il n’est pas nécessaire de spécifier les types de cibles.  
  
 Cette surcharge de la <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructeur définit la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propriété les valeurs du tableau passé dans le `targetTypeNames` paramètre. Définition de cette propriété permet un <xref:System.Messaging.MessageQueue> à l’aide de ce <xref:System.Messaging.XmlMessageFormatter> instance pour lire les messages contenant des objets de types donnés.  
  
 À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent au formateur les schémas auxquels correspondre lors de la désérialisation d’un message. Cela permet au formateur d’interpréter le corps du message.  
  
 L’instance sérialisée dans le corps du message doit être conforme à un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux. L’ensemble de types est l’ensemble combiné à partir des deux propriétés. Le choix de l’application à utiliser est spécifique à votre application. Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée au moment de la lecture.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="targetTypeNames" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Tableau de type <see cref="T:System.Type" /> qui spécifie le jeu de types possibles qui seront désérialisés par le formateur à partir du message fourni.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.XmlMessageFormatter" /> en définissant des types cibles passés sous la forme d'un tableau de types d'objets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les constructeurs avec des paramètres de type de cible sont fréquemment utilisés lors de la lecture à partir de la file d’attente. Lors de l’écriture, il n’est pas nécessaire de spécifier les types de cibles.  
  
 Cette surcharge de la <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructeur définit la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriété les valeurs du tableau passé dans le `targetTypes` paramètre. Définition de cette propriété permet un <xref:System.Messaging.MessageQueue> à l’aide de ce <xref:System.Messaging.XmlMessageFormatter> instance pour lire les messages contenant des objets de types donnés.  
  
 À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent au formateur les schémas auxquels correspondre lors de la désérialisation d’un message. Cela permet au formateur d’interpréter le corps du message.  
  
 L’instance sérialisée dans le corps du message doit être conforme à un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux. L’ensemble de types est l’ensemble combiné à partir des deux propriétés. Le choix de l’application à utiliser est spécifique à votre application. Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception sera levée au moment de la lecture.  
  
 Lors de la spécification <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> plutôt que <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, existence du type est vérifiée au moment de la compilation plutôt que des temps de lecture, ce qui réduit le risque d’erreur. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> nécessite que chaque entrée soit qualifiée complète, en spécifiant son nom d’assembly. En outre, lorsque vous travaillez avec plusieurs versions simultanées, le numéro de version doit également être ajouté pour le nom du type cible.  
  
 Lorsque vous utilisez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, vous pouvez ajouter chaque objet (par exemple, `MyClass`) à la liste de la manière illustrée par le code c# suivant.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="targetTypes" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" /> à examiner.</param>
        <summary>Détermine si le formateur peut désérialiser le message.</summary>
        <returns>
          <see langword="true" /> si le formateur XML peut désérialiser le message ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> est appelé, le formateur tente de déterminer si le contenu du message est un élément pouvant être désérialisé. Le formateur ne peut désérialiser le message si le type dans le corps du message a le même schéma qu’un des types du tableau représenté par la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Retourne `false` dans les deux circonstances suivantes :  
  
-   Le message n’a pas a été formaté à l’aide de la <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Le schéma du corps du message n’est pas parmi ceux répertoriés, que ce soit le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriété.  
  
 Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent au formateur les types d’objets doit être capable de désérialiser. Si n’importe quel type est manquant dans la liste, mais est détecté dans le message, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> retourne `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ni la propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />, ni la propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> n'ont été définies.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="message" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une instance de la classe <see cref="T:System.Messaging.XmlMessageFormatter" /> dont les propriétés de lecture/écriture (les jeux de types cibles) sont identiques à celles de l'instance de <see cref="T:System.Messaging.XmlMessageFormatter" /> en cours.</summary>
        <returns>Objet dont les propriétés sont identiques à celles de cette instance de <see cref="T:System.Messaging.XmlMessageFormatter" />, mais dont les métadonnées ne spécifient pas qu'il s'agit d'une instance de la classe du formateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée une copie du formateur et initialise toutes ses propriétés pour les valeurs de cette <xref:System.Messaging.XmlMessageFormatter> objet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" />, au format XML, à désérialiser.</param>
        <summary>Lit le contenu du message donné et crée un objet qui contient le message désérialisé.</summary>
        <returns>Message désérialisé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent au formateur les schémas auxquels correspondre lors de la désérialisation d’un message. Une de ces propriétés doit être définie avant que le message peut être désérialisé.  
  
 L’instance sérialisée dans le corps du message doit être conforme à un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Les types de cibles n’ont pas à être spécifiée afin d’écrire dans la file d’attente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ni la propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />, ni la propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> n'ont été définies.  
  
 - ou -  
  
 L'instance sérialisée dans le corps du message ne correspond à aucun des schémas représentés par les types dans les propriétés <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> et <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="message" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie le jeu de types éventuels qui sont désérialisés par le formateur à partir du message fourni.</summary>
        <value>Tableau de type <see cref="T:System.String" /> qui spécifie les types d'objets à désérialiser à partir du corps du message lors de sa lecture.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent au formateur les schémas auxquels correspondre lors de la désérialisation d’un message. Cela permet au formateur d’interpréter le corps du message.  
  
 L’instance sérialisée dans le corps du message doit être conforme à un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux. L’ensemble de types est l’ensemble combiné à partir des deux propriétés. Le choix de la propriété à utiliser est spécifique à votre application. Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception est levée lorsque le message est lu.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> nécessite que chaque entrée soit qualifiée complète, en spécifiant son nom d’assembly. En outre, lorsque vous travaillez avec plusieurs versions simultanées, le numéro de version doit également être ajouté pour le nom du type cible.  
  
 Les types de cibles sont uniquement requises lors de la lecture à partir de la file d’attente. Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés n’avez pas besoin d’être définie à écrire dans la file d’attente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie le jeu de types éventuels qui sont désérialisés par le formateur à partir du message fourni.</summary>
        <value>Tableau de type <see cref="T:System.Type" /> qui spécifie les types d'objets à désérialiser à partir du corps du message lors de sa lecture.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À la fois le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés indiquent au formateur les schémas auxquels correspondre lors de la désérialisation d’un message. Cela permet au formateur d’interpréter le corps du message.  
  
 L’instance sérialisée dans le corps du message doit être conforme à un des schémas représentés dans le tableau de types. Lorsque vous lisez le message à l’aide de la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), la méthode crée un objet du type qui correspond au schéma identifié et lit le corps du message dans celui-ci.  
  
 Seul l’un des deux propriétés doit être définie lors de la lecture à partir de la file d’attente, mais vous pouvez définir les deux. L’ensemble de types est l’ensemble combiné à partir des deux propriétés. Le choix de la propriété à utiliser est spécifique à votre application. Si le corps du message contient un type dont le schéma ne correspond pas à un des types dans le tableau pour des propriétés, une exception est levée lorsque le message est lu.  
  
 Les types de cibles sont uniquement requises lors de la lecture à partir de la file d’attente. Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> et <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriétés n’avez pas besoin d’être définie à écrire dans la file d’attente.  
  
 Lors de la spécification <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> plutôt que <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, existence du type est vérifiée au moment de la compilation plutôt que des temps de lecture, ce qui réduit le risque d’erreur.  
  
 Lorsque vous utilisez <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, vous pouvez ajouter chaque objet (par exemple, `MyClass`) à la liste de la manière illustrée par le code c# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 L’exemple de code suivant envoie et reçoit un message qui contient un ordre vers et depuis une file d’attente.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propriété <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.Body" /> contiendra l’objet sérialisé.</param>
        <param name="obj">
          <see cref="T:System.Object" /> à sérialiser dans le corps du message.</param>
        <summary>Sérialise un objet dans le corps du message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types de cibles pas nécessaire de spécifier à écrire dans la file d’attente, comme c’est lors de la lecture. Le <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriété est utilisée par le formateur uniquement lors de la désérialisation d’un message.  
  
 Le <xref:System.Messaging.XmlMessageFormatter> utilise le <xref:System.Xml.Serialization.XmlSerializer> (classe), qui définit ce qui peut être sérialisé. Uniquement les champs publics et les propriétés publics peuvent être sérialisées. Les structures, les structures avec des tableaux et les tableaux de structures sont tous sérialisables, tant qu’ils n’utilisent pas le style encodé avec le protocole SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="message" /> a la valeur <see langword="null" />.  
  
 - ou -  
  
 Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>