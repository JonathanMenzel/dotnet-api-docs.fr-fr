<Type Name="MessageQueueEnumerator" FullName="System.Messaging.MessageQueueEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2dd645dcfd97fa2036ad0395acbbbf3e86c2865e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30459943" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueueEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueueEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueueEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueueEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueueEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit un curseur avant uniquement pour énumérer les messages dans une file d’attente de messages.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Messaging.MessageQueueEnumerator> pour l’interaction dynamique avec les files d’attente sur le réseau. Les méthodes disponibles via le <xref:System.Messaging.MessageQueue> classe peut retourner un <xref:System.Messaging.MessageQueueEnumerator> contenant une liste dynamique de files d’attente ou un tableau qui contient un instantané de la collection de file d’attente au moment où la méthode spécifiée a été appelée.  
  
 Il n’existe pas de classement défini des files d’attente dans un réseau. Ils ne sont pas ordonnés, par exemple, par ordinateur, étiquette, état public ou privé, ou d’autres critères accessibles par l’utilisateur. A <xref:System.Messaging.MessageQueueEnumerator> est un curseur, initialisé en tête d’une liste dynamique. Vous pouvez déplacer le curseur vers la première file d’attente de l’énumération en appelant <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A>. Une fois que l’énumérateur a été initialisé, vous pouvez utiliser <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> pour parcourir les files d’attente restantes.  
  
 Il n’est pas possible de revenir en arrière avec un <xref:System.Messaging.MessageQueueEnumerator>. Un curseur autorise uniquement les déplacements vers l’avant dans l’énumération de la file d’attente. Toutefois, vous pouvez appeler <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> pour réinitialiser l’énumération et placez le curseur au début de la liste. Étant donné que l’énumérateur est dynamique, une file d’attente qui est ajoutée après la position du curseur actuel est accessible par l’énumérateur. Une file d’attente qui est inséré avant la position du curseur en cours ne sont pas accessibles sans d’abord appeler Reset.  
  
   
  
## Examples  
 L’exemple de code suivant effectue une itération dans toutes les files d’attente de message dans le réseau et examine le chemin d’accès pour chaque file d’attente. Enfin, il affiche le nombre de files d’attente publiques sur le réseau.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources associées à l'énumérateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le système d’exploitation retient un handle ouvert, <xref:System.Messaging.MessageQueueEnumerator.LocatorHandle%2A>, vers l’énumérateur de la file d’attente pendant la durée de vie du curseur. Lorsque vous avez terminé de travailler avec l’énumérateur, appelez <xref:System.Messaging.MessageQueueEnumerator.Close%2A> pour libérer les ressources associées au handle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueueEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ Current { System::Messaging::MessageQueue ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Messaging.MessageQueue" /> en cours de l'énumération.</summary>
        <value>La file d'attente où le curseur se trouve.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’énumérateur est créé, il ne pointe pas vers quoi que ce soit, par conséquent, <xref:System.Messaging.MessageQueueEnumerator.Current%2A> n’est pas valide et lèvera une exception si elle est accessible. Vous devez appeler <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> pour positionner le curseur à la première file d’attente de l’énumération.  
  
 Appels multiples à <xref:System.Messaging.MessageQueueEnumerator.Current%2A> sans appels intermédiaires à <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> retournera le même <xref:System.Messaging.MessageQueue> objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Vous avez appelé <see cref="P:System.Messaging.MessageQueueEnumerator.Current" /> avant le premier appel à <see cref="M:System.Messaging.MessageQueueEnumerator.MoveNext" />. Le curseur est placé avant la première file d'attente de l'énumération.  
  
 - ou -  
  
 Vous avez appelé <see cref="P:System.Messaging.MessageQueueEnumerator.Current" /> après qu'un appel à <see cref="M:System.Messaging.MessageQueueEnumerator.MoveNext" /> a retourné False (indiquant que le curseur se trouve après la dernière file d'attente de l'énumération).</exception>
        <altmember cref="M:System.Messaging.MessageQueueEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageQueueEnumerator.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère les ressources utilisées par le <see cref="T:System.Messaging.MessageQueueEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.Messaging.MessageQueueEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Messaging.MessageQueueEnumerator.Dispose%2A> autorise les ressources utilisées par le <xref:System.Messaging.MessageQueueEnumerator> à être réaffectés à d’autres fins. Pour plus d’informations sur <xref:System.Messaging.MessageQueueEnumerator.Dispose%2A>, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Messaging.MessageQueueEnumerator" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public <xref:System.Messaging.MessageQueueEnumerator.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose` appelle la méthode protégée `Dispose(Boolean)` méthode avec la `disposing` paramètre la valeur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` la valeur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Messaging.MessageQueueEnumerator>. Cette méthode appelle la méthode `Dispose` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution de <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose" />, consultez [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Pour plus d’informations sur <see langword="Dispose" /> et <see langword="Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageQueueEnumerator ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocatorHandle">
      <MemberSignature Language="C#" Value="public IntPtr LocatorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int LocatorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueEnumerator.LocatorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocatorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr LocatorHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle Message Queuing natif utilisé pour rechercher les files d'attente dans un réseau.</summary>
        <value>Le handle natif de la file d'attente en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous n’avez plus besoin cela <xref:System.Messaging.MessageQueueEnumerator> de l’instance, appelez <xref:System.Messaging.MessageQueueEnumerator.Close%2A> pour rendre ce handle à la ressource.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Le handle n'existe pas.</exception>
        <exception cref="T:System.Security.SecurityException">Le code appelant n'a pas l'autorisation de navigation requise.</exception>
        <altmember cref="P:System.Messaging.MessageQueueEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avance l'énumérateur jusqu'à la file d'attente suivante de l'énumération, s'il y en a une de disponible.</summary>
        <returns>
          <see langword="true" /> si l'énumérateur a réussi à avancer jusqu'à la file d'attente suivante ; <see langword="false" />, si l'énumérateur a atteint la fin de l'énumération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> Retourne `false` immédiatement s’il n’y aucune file d’attente associée à l’énumération.  
  
 <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> retournera `true` jusqu'à ce qu’il a atteint la fin de la collection. Elle retournera ensuite `false` pour chaque appel. Cependant, après que <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> a retourné `false`, l’accès à la <xref:System.Messaging.MessageQueueEnumerator.Current%2A> propriété lève une exception.  
  
 Lors de la création, conceptuel un énumérateur est placé avant le premier <xref:System.Messaging.MessageQueue> de l’énumération et le premier appel à <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> affiche la première file d’attente de l’énumération dans la vue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Le code appelant n'a pas l'autorisation de navigation requise.</exception>
        <altmember cref="P:System.Messaging.MessageQueueEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageQueueEnumerator.Reset" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rétablit le curseur, de manière qu'il pointe vers le début de l'énumération.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un énumérateur se déplace dans une direction avant uniquement. Utilisez cette méthode pour retourner au début de l’énumération des files d’attente.  
  
 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> Positionne le curseur sur la première file d’attente dans la liste. Vous n’avez pas besoin d’appeler <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> après l’appel <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> pour avancer le curseur vers la première file d’attente de l’énumération.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueueEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageQueueEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Messaging.MessageQueue" /> en cours de l'énumération.</summary>
        <value>La file d'attente où le curseur se trouve.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>