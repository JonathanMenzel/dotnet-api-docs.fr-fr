<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dfbd83b435486357a91721f19b050fdc1e7aa258" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52611159" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="89550-101">Fournit un curseur avant uniquement pour énumérer les messages dans une file d’attente de messages.</span>
      <span class="sxs-lookup">
        <span data-stu-id="89550-101">Provides a forward-only cursor to enumerate through messages in a message queue.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-102">Utilisez <xref:System.Messaging.MessageEnumerator> pour l’interaction dynamique avec des messages dans une file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-102">Use <xref:System.Messaging.MessageEnumerator> for dynamic interaction with messages in a queue.</span></span> <span data-ttu-id="89550-103">Méthodes disponibles via le <xref:System.Messaging.MessageQueue> classe peut retourner un <xref:System.Messaging.MessageEnumerator> qui pointe vers une liste dynamique de messages dans la file d’attente ou un tableau qui contient une copie à un instant donné - un instantané, de la file d’attente au moment de la méthode spécifiée a été appelée.</span><span class="sxs-lookup"><span data-stu-id="89550-103">Methods available through the <xref:System.Messaging.MessageQueue> class can return either a <xref:System.Messaging.MessageEnumerator> pointing to a dynamic list of messages in the queue, or an array that contains a copy at a given instant - a snapshot - of the queue at the time the specified method was called.</span></span>  
  
 <span data-ttu-id="89550-104">Contrairement à un instantané statique, un énumérateur vous permet de modifier la collection.</span><span class="sxs-lookup"><span data-stu-id="89550-104">Unlike a static snapshot, an enumerator allows you to modify the collection.</span></span> <span data-ttu-id="89550-105">À l’aide un <xref:System.Messaging.MessageEnumerator>, vous pouvez supprimer les messages de la file d’attente et la modification est immédiatement répercutée dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-105">Using a <xref:System.Messaging.MessageEnumerator>, you can remove messages from the queue, and the change is immediately reflected in the queue.</span></span>  
  
 <span data-ttu-id="89550-106">Un énumérateur ne supprime pas les messages à partir de la file d’attente lors de l’interrogation de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-106">An enumerator does not remove the messages from the queue when it queries the queue.</span></span> <span data-ttu-id="89550-107">Il retourne des informations sur le message à la position actuelle du curseur, mais laisse le message dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-107">It returns information about the message at the current cursor position, but it leaves the message in the queue.</span></span>  
  
 <span data-ttu-id="89550-108">Un <xref:System.Messaging.MessageEnumerator> est un curseur, initialisé en tête d’une liste dynamique.</span><span class="sxs-lookup"><span data-stu-id="89550-108">A <xref:System.Messaging.MessageEnumerator> is a cursor, initialized to the head of a dynamic list.</span></span> <span data-ttu-id="89550-109">L’ordre de la liste est identique à l’ordre des messages dans la file d’attente, en fonction de la priorité du message.</span><span class="sxs-lookup"><span data-stu-id="89550-109">The list order is the same as the order of the messages in the queue, according to message priority.</span></span> <span data-ttu-id="89550-110">Vous pouvez déplacer le curseur vers le premier message dans la file d’attente en appelant <xref:System.Messaging.MessageEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="89550-110">You can move the cursor to the first message in the queue by calling <xref:System.Messaging.MessageEnumerator.MoveNext%2A>.</span></span> <span data-ttu-id="89550-111">Après que l’énumérateur a été initialisé, vous pouvez utiliser <xref:System.Messaging.MessageEnumerator.MoveNext%2A> pour parcourir les messages restants.</span><span class="sxs-lookup"><span data-stu-id="89550-111">After the enumerator has been initialized, you can use <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to step forward through the remaining messages.</span></span> <span data-ttu-id="89550-112">Vous pouvez spécifier s’il faut attendre un message soit disponible en passant un délai d’expiration dans le <xref:System.Messaging.MessageEnumerator.MoveNext%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="89550-112">You can specify whether to wait for a message to become available by passing a timeout into the <xref:System.Messaging.MessageEnumerator.MoveNext%2A> method.</span></span>  
  
 <span data-ttu-id="89550-113">Étant donné que l’énumérateur est dynamique, un message est ajouté au-delà de la position du curseur actuel (par exemple, en raison d’un niveau de priorité faible) est accessible par l’énumérateur.</span><span class="sxs-lookup"><span data-stu-id="89550-113">Because the enumerator is dynamic, a message that is appended beyond the cursor's current position (for example, due to low priority), can be accessed by the enumerator.</span></span> <span data-ttu-id="89550-114">Un message qui est inséré avant la position actuelle du curseur n’est pas accessible.</span><span class="sxs-lookup"><span data-stu-id="89550-114">A message that is inserted before the cursor's current position cannot be accessed.</span></span> <span data-ttu-id="89550-115">Il n’est pas possible de revenir en arrière avec un <xref:System.Messaging.MessageEnumerator>.</span><span class="sxs-lookup"><span data-stu-id="89550-115">It is not possible to step backward with a <xref:System.Messaging.MessageEnumerator>.</span></span> <span data-ttu-id="89550-116">Un curseur permet le déplacement avant uniquement.</span><span class="sxs-lookup"><span data-stu-id="89550-116">A cursor allows forward-only movement.</span></span> <span data-ttu-id="89550-117">Le <xref:System.Messaging.MessageEnumerator.Reset%2A> méthode vous permet de placer le curseur au début de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-117">The <xref:System.Messaging.MessageEnumerator.Reset%2A> method enables you to place the cursor back at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="89550-118">Instances de <xref:System.Messaging.MessageEnumerator> pour une file d’attente donnée fonctionnent indépendamment.</span><span class="sxs-lookup"><span data-stu-id="89550-118">Instances of <xref:System.Messaging.MessageEnumerator> for a given queue work independently.</span></span> <span data-ttu-id="89550-119">Vous pouvez créer deux <xref:System.Messaging.MessageEnumerator> instances qui s’appliquent à la même file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-119">You can create two <xref:System.Messaging.MessageEnumerator> instances that apply to the same queue.</span></span> <span data-ttu-id="89550-120">Les modifications qu’un <xref:System.Messaging.MessageEnumerator> facilite pour les messages dans la file d’attente est répercutées immédiatement dans un second énumérateur si ce dernier est positionné avant le premier.</span><span class="sxs-lookup"><span data-stu-id="89550-120">The changes that one <xref:System.Messaging.MessageEnumerator> makes to the messages in the queue will be reflected immediately in a second enumerator if the second enumerator is positioned before the first.</span></span> <span data-ttu-id="89550-121">Toutefois, si deux énumérateurs ont la même position et un d’eux supprime le message à cette position, une exception est levée si l’autre énumérateur tente d’obtenir la valeur de la <xref:System.Messaging.MessageEnumerator.Current%2A> propriété sur le message supprimé maintenant.</span><span class="sxs-lookup"><span data-stu-id="89550-121">However, if two enumerators have the same position and one of them removes the message at that position, an exception is thrown if the other enumerator attempts to get the value of the <xref:System.Messaging.MessageEnumerator.Current%2A> property on the now-deleted message.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="89550-122">Si vous créez une instance de <xref:System.Messaging.MessageQueue> avec <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> défini sur `true`, aucune autre application ne peut modifier les messages dans votre énumérateur pendant que la connexion à la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-122">If you create an instance of <xref:System.Messaging.MessageQueue> with <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> set to `true`, no other application can modify the messages in your enumerator while you have the connection to the queue.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89550-123">L’exemple suivant obtient une liste dynamique de messages dans une file d’attente et compte tous les messages avec la <xref:System.Messaging.Message.Priority%2A> propriété définie sur <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="89550-123">The following example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="89550-124">Libère les ressources associées à l'énumérateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-124">Frees the resources associated with the enumerator.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-125">Le système d’exploitation conserve un handle ouvert vers la file d’attente pendant la durée de vie du curseur.</span><span class="sxs-lookup"><span data-stu-id="89550-125">The operating system retains an open handle to the queue during the lifetime of the cursor.</span></span> <span data-ttu-id="89550-126">Lorsque vous avez fini de travailler avec l’énumérateur, appelez <xref:System.Messaging.MessageEnumerator.Close%2A> pour libérer les ressources associées au handle.</span><span class="sxs-lookup"><span data-stu-id="89550-126">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release the resources associated with the handle.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="89550-127">Obtient le <see cref="T:System.Messaging.Message" /> actuel vers lequel cet énumérateur pointe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-127">Gets the current <see cref="T:System.Messaging.Message" /> that this enumerator points to.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="89550-128">Le message en cours.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-128">The current message.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-129">Lorsque l’énumérateur est créé, il pointe vers le début de la file d’attente, à un emplacement avant le premier message.</span><span class="sxs-lookup"><span data-stu-id="89550-129">When the enumerator is created, it points to the head of the queue, at a location before the first message.</span></span> <span data-ttu-id="89550-130">Dans ce cas, <xref:System.Messaging.MessageEnumerator.Current%2A> n’est pas valide et lève une exception si elle est accessible.</span><span class="sxs-lookup"><span data-stu-id="89550-130">In this case, <xref:System.Messaging.MessageEnumerator.Current%2A> is not valid and will throw an exception if it is accessed.</span></span> <span data-ttu-id="89550-131">Vous devez appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> pour positionner le curseur sur le premier message dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-131">You must call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to position the cursor at the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="89550-132">Vous avez appelé <see cref="P:System.Messaging.MessageEnumerator.Current" /> avant le premier appel à <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-132">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> before the first call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />.</span>
          </span>
          <span data-ttu-id="89550-133">Le curseur se trouve avant le premier élément de l'énumération de messages.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-133">The cursor is located before the first element of the message enumeration.</span>
          </span>
          <span data-ttu-id="89550-134">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-134">-or-</span>
          </span>
          <span data-ttu-id="89550-135">Vous avez appelé <see cref="P:System.Messaging.MessageEnumerator.Current" /> après qu'un appel à <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> a retourné <see langword="false" /> (indiquant que le curseur se trouve après le dernier élément de l'énumération de messages).</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-135">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> after a call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> had returned <see langword="false" /> (indicating the cursor is located after the last element of the message enumeration.)</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="89550-136">Le message vers lequel l'énumérateur pointe actuellement n'existe plus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-136">The message the enumerator is currently pointing to no longer exists.</span>
          </span>
          <span data-ttu-id="89550-137">Il a peut-être été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-137">It might have been deleted.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="89550-138">Obtient le handle de curseur Message Queuing natif utilisé pour parcourir les messages dans la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-138">Gets the native Message Queuing cursor handle used to browse messages in the queue.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="89550-139">Le handle de curseur natif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-139">The native cursor handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-140">Cette propriété contient le handle natif de l’énumération.</span><span class="sxs-lookup"><span data-stu-id="89550-140">This property contains the native handle to the enumeration.</span></span> <span data-ttu-id="89550-141">Lorsque vous avez fini de travailler avec l’énumérateur, appelez <xref:System.Messaging.MessageEnumerator.Close%2A> pour libérer cette ressource.</span><span class="sxs-lookup"><span data-stu-id="89550-141">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release this resource.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="89550-142">Le handle n'existe pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-142">The handle does not exist.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="89550-143">Libère les ressources utilisées par le <see cref="T:System.Messaging.MessageEnumerator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-143">Releases the resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="89550-144">Libère toutes les ressources utilisées par <see cref="T:System.Messaging.MessageEnumerator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-144">Releases all resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-145">Appel <xref:System.Messaging.MessageEnumerator.Dispose%2A> autorise les ressources utilisées par le <xref:System.Messaging.MessageEnumerator> d’être réaffectées à d’autres fins.</span><span class="sxs-lookup"><span data-stu-id="89550-145">Calling <xref:System.Messaging.MessageEnumerator.Dispose%2A> allows the resources used by the <xref:System.Messaging.MessageEnumerator> to be reallocated for other purposes.</span></span> <span data-ttu-id="89550-146">Pour plus d’informations sur <xref:System.Messaging.MessageEnumerator.Dispose%2A>, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="89550-146">For more information about <xref:System.Messaging.MessageEnumerator.Dispose%2A>, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">
          <span data-ttu-id="89550-147">Nettoyage de ressources non managées</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-147">Cleaning Up Unmanaged Resources</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="89550-148">
            <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-148">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89550-149">Libère les ressources non managées utilisées par <see cref="T:System.Messaging.MessageEnumerator" /> et libère éventuellement les ressources managées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-149">Releases the unmanaged resources used by the <see cref="T:System.Messaging.MessageEnumerator" /> and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-150">Cette méthode est appelée par le public <xref:System.Messaging.MessageEnumerator.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="89550-150">This method is called by the public <xref:System.Messaging.MessageEnumerator.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="89550-151">`Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`.</span><span class="sxs-lookup"><span data-stu-id="89550-151">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="89550-152"><xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.</span><span class="sxs-lookup"><span data-stu-id="89550-152"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="89550-153">Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Messaging.MessageEnumerator>.</span><span class="sxs-lookup"><span data-stu-id="89550-153">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Messaging.MessageEnumerator> references.</span></span> <span data-ttu-id="89550-154">Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.</span><span class="sxs-lookup"><span data-stu-id="89550-154">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="89550-155">
              <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets.</span>
            <span class="sxs-lookup">
              <span data-stu-id="89550-155">
                <see langword="Dispose" /> can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="89550-156">Lors de la substitution de <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="89550-156">When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span>
            </span>
            <span data-ttu-id="89550-157">Pour plus d’informations sur l’implémentation <see langword="Dispose" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            <span class="sxs-lookup">
              <span data-stu-id="89550-157">For more information about how to implement <see langword="Dispose" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            </span>
            <span data-ttu-id="89550-158">Pour plus d’informations sur <see langword="Dispose" /> et <see langword="Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span>
            <span class="sxs-lookup">
              <span data-stu-id="89550-158">For more information about <see langword="Dispose" /> and <see langword="Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">
          <span data-ttu-id="89550-159">Implémentation d’une méthode Dispose</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-159">Implementing a Dispose method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">
          <span data-ttu-id="89550-160">Nettoyage de ressources non managées</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-160">Cleaning Up Unmanaged Resources</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="89550-161">Libère les ressources détenues par l'énumérateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-161">Releases the resources held by the enumerator.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="89550-162">Cette méthode se substitue à <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="89550-162">This method overrides <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="89550-163">Code d’application ne doit pas appeler cette méthode ; la méthode Finalize d’un objet est automatiquement appelée lors du garbage collection, sauf si la finalisation par le garbage collector a été désactivée par un appel à la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="89550-163">Application code should not call this method; an object's Finalize method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="89550-164">Pour plus d’informations, consultez [destructeurs et méthodes Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md), et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="89550-164">For more information, see [Finalize Methods and Destructors](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md), and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="89550-165">Avance l'énumérateur jusqu'au message suivant de la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-165">Advances the enumerator to the next message in the queue.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="89550-166">Avance l'énumérateur jusqu'au message suivant dans la file d'attente, s'il y en a un de disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-166">Advances the enumerator to the next message in the queue, if one is currently available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89550-167">
            <see langword="true" /> si l'énumérateur a réussi à avancer jusqu'au message suivant ; <see langword="false" /> si l'énumérateur a atteint la fin de la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-167">
              <see langword="true" /> if the enumerator was succesfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-168">Cette surcharge retourne immédiatement si aucun message n’est dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-168">This overload returns immediately if there is no message in the queue.</span></span> <span data-ttu-id="89550-169">Il existe une autre surcharge qui attend une certaine <xref:System.TimeSpan> pour un message arrive.</span><span class="sxs-lookup"><span data-stu-id="89550-169">There is another overload that waits a specified <xref:System.TimeSpan> for a message to arrive.</span></span>  
  
 <span data-ttu-id="89550-170">Si un message n’est pas disponible actuellement, car la file d’attente est vide ou parce que vous avez déplacé au-delà du dernier élément dans la collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> retourne `false` à la méthode appelante.</span><span class="sxs-lookup"><span data-stu-id="89550-170">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> returns `false` to the calling method.</span></span>  
  
 <span data-ttu-id="89550-171">Lors de la création, conceptuel un énumérateur est placé avant le premier message de la file d’attente et le premier appel à <xref:System.Messaging.MessageEnumerator.MoveNext%2A> affiche le premier message de la file d’attente dans la vue.</span><span class="sxs-lookup"><span data-stu-id="89550-171">Upon creation, an enumerator is conceptually positioned before the first message of the queue, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the queue into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="89550-172">Une exception spécifique à Message Queuing a été levée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-172">An exception specific to Message Queuing was thrown.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="89550-173">Le <see cref="T:System.TimeSpan" /> d'attente pour qu'un message soit disponible si l'énumérateur est placé à la fin de la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-173">The <see cref="T:System.TimeSpan" /> to wait for a message to be available if the enumerator is positioned at the end of the queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89550-174">Avance l'énumérateur jusqu'au message suivant de la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-174">Advances the enumerator to the next message in the queue.</span>
          </span>
          <span data-ttu-id="89550-175">Si l'énumérateur est placé à la fin de la file d'attente, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> attend qu'un message soit disponible ou que le délai spécifié expire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-175">If the enumerator is positioned at the end of the queue, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> waits until a message is available or the given timeout expires.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89550-176">
            <see langword="true" /> si l'énumérateur a réussi à avancer jusqu'au message suivant ; <see langword="false" /> si l'énumérateur a atteint la fin de la file d'attente et si aucun message n'est disponible dans le délai spécifié par le paramètre <paramref name="timeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-176">
              <see langword="true" /> if the enumerator successfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue and a message does not become available within the time specified by the <paramref name="timeout" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-177">Cette surcharge attend que s’il n’existe aucun message dans la file d’attente ou si le curseur a atteint la fin de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-177">This overload waits if there is no message in the queue or if the cursor has reached the end of the queue.</span></span> <span data-ttu-id="89550-178">Si un message n’est pas disponible actuellement, car la file d’attente est vide ou parce que vous avez déplacé au-delà du dernier élément dans la collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> attend le délai spécifié.</span><span class="sxs-lookup"><span data-stu-id="89550-178">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> waits the specified timeout.</span></span>  
  
 <span data-ttu-id="89550-179">Si le curseur se trouve déjà à la fin de la file d’attente, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> retourne uniquement `true` si le nouveau message arrive dans l’intervalle de temps spécifié, a une priorité plus faible que tous les messages actuellement dans la file d’attente et est placé à la fin de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-179">If the cursor is already at the end of the queue, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> only returns `true` if the new message arrives within the specified time interval, has lower priority than all messages currently in the queue and is placed at the end of the queue.</span></span> <span data-ttu-id="89550-180">Une surcharge sans paramètre retourne immédiatement si aucun autre message n’est dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-180">An overload with no parameter returns immediately if no further messages are in the queue.</span></span>  
  
 <span data-ttu-id="89550-181">Lors de la création, conceptuel un énumérateur est placé avant le premier message de l’énumération et le premier appel à <xref:System.Messaging.MessageEnumerator.MoveNext%2A> affiche le premier message de l’énumération dans la vue.</span><span class="sxs-lookup"><span data-stu-id="89550-181">Upon creation, an enumerator is conceptually positioned before the first message of the enumeration, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the enumeration into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="89550-182">La valeur spécifiée pour le paramètre de délai d'attente n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-182">The value specified for the timeout parameter is invalid.</span>
          </span>
          <span data-ttu-id="89550-183">Il peut s'agir d'un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-183">It might represent a negative number.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="89550-184">Une exception spécifique à Message Queuing a été levée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-184">An exception specific to Message Queuing was thrown.</span>
          </span>
          <span data-ttu-id="89550-185">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-185">-or-</span>
          </span>
          <span data-ttu-id="89550-186">Le délai a expiré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-186">The timeout has expired.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="89550-187">Supprime le message en cours de la file d'attente et retourne le message à l'application appelante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-187">Removes the current message from the queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="89550-188">La suppression du message l'efface de la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-188">Removing the message deletes it from the queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-189">Le comportement décrit pour ces surcharges est applicable uniquement si le <xref:System.Messaging.MessageEnumerator> instance est récupérée à l’aide de la <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>.</span><span class="sxs-lookup"><span data-stu-id="89550-189">The behavior described for these overloads is applicable only if the <xref:System.Messaging.MessageEnumerator> instance is retrieved by using the <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>.</span></span> <span data-ttu-id="89550-190">N’utilisez pas <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> pour récupérer une instance de <xref:System.Messaging.MessageEnumerator> que cette méthode a été déconseillée.</span><span class="sxs-lookup"><span data-stu-id="89550-190">Do not use <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> to retrieve an instance of <xref:System.Messaging.MessageEnumerator> as this method has been deprecated.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="89550-191">Supprime le message en cours d'une file d'attente transactionnelle ou non et retourne le message à l'application appelante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-191">Removes the current message from a transactional or non-transactional queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="89550-192">Il n'y a pas de délai d'attente spécifié pour l'arrivée d'un message dans la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-192">There is no timeout specified for a message to arrive in the queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89550-193">
            <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-193">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-194"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur.</span><span class="sxs-lookup"><span data-stu-id="89550-194"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span>  
  
 <span data-ttu-id="89550-195">Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.</span><span class="sxs-lookup"><span data-stu-id="89550-195">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="89550-196">Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant.</span><span class="sxs-lookup"><span data-stu-id="89550-196">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="89550-197">Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="89550-197">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="89550-198">Si vous appelez cette surcharge sur une file d’attente transactionnelle, Message Queuing crée une transaction interne unique.</span><span class="sxs-lookup"><span data-stu-id="89550-198">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <span data-ttu-id="89550-199">L'objet <see cref="T:System.Messaging.MessageQueueTransaction" /> qui spécifie la transaction dans laquelle le message sera supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-199">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction in which the message will be removed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89550-200">Supprime le message en cours d'une file d'attente transactionnelle et retourne le message à l'application appelante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-200">Removes the current message from a transactional queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="89550-201">Il n'y a pas de délai d'attente spécifié pour l'arrivée d'un message dans la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-201">There is no timeout specified for a message to arrive in the queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89550-202">
            <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-202">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-203"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur, en utilisant le contexte de transaction interne défini par le `transaction` paramètre.</span><span class="sxs-lookup"><span data-stu-id="89550-203"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using the internal transaction context defined by the `transaction` parameter.</span></span>  
  
 <span data-ttu-id="89550-204">Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.</span><span class="sxs-lookup"><span data-stu-id="89550-204">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="89550-205">Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-205">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="89550-206">La suppression est irréversible pas jusqu'à ce que la transaction est validée.</span><span class="sxs-lookup"><span data-stu-id="89550-206">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="89550-207">Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant.</span><span class="sxs-lookup"><span data-stu-id="89550-207">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="89550-208">Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="89550-208">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89550-209">Le paramètre <paramref name="transaction" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-209">The <paramref name="transaction" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">
          <span data-ttu-id="89550-210">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-210">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89550-211">Supprime le message en cours d'une file d'attente et retourne le message à l'application appelante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-211">Removes the current message from a queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="89550-212">Il n'y a pas de délai d'attente spécifié pour l'arrivée d'un message dans la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-212">There is no timeout specified for a message to arrive in the queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89550-213">
            <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-213">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-214"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur, à l’aide d’un contexte de transaction défini par le `transactionType` paramètre.</span><span class="sxs-lookup"><span data-stu-id="89550-214"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span>  
  
 <span data-ttu-id="89550-215">Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message.</span><span class="sxs-lookup"><span data-stu-id="89550-215">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="89550-216">Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne.</span><span class="sxs-lookup"><span data-stu-id="89550-216">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="89550-217">Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.</span><span class="sxs-lookup"><span data-stu-id="89550-217">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="89550-218">Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.</span><span class="sxs-lookup"><span data-stu-id="89550-218">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="89550-219">Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-219">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="89550-220">La suppression est irréversible pas jusqu'à ce que la transaction est validée.</span><span class="sxs-lookup"><span data-stu-id="89550-220">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="89550-221">Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant.</span><span class="sxs-lookup"><span data-stu-id="89550-221">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="89550-222">Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="89550-222">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="89550-223">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-223">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="89550-224"> La durée d'attente pour l'arrivée d'un message dans la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-224">The interval of time to wait for a message to arrive in the queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89550-225">Supprime le message en cours de la file d'attente et retourne le message à l'application appelante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-225">Removes the current message from the queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="89550-226">S'il y a un message à supprimer, le retour de la méthode est immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-226">If there is a message to remove, the method returns it immediately.</span>
          </span>
          <span data-ttu-id="89550-227">Sinon, la méthode attend le délai spécifié pour l'arrivée d'un message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-227">Otherwise, the method waits the specified timeout for a new message to arrive.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89550-228">
            <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-228">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-229"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur.</span><span class="sxs-lookup"><span data-stu-id="89550-229"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="89550-230">Si le curseur se trouve à la fin de la file d’attente, cette surcharge de la méthode attend qu’un message soit disponible ou que l’intervalle spécifié par le `timeout` paramètre a expiré.</span><span class="sxs-lookup"><span data-stu-id="89550-230">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="89550-231">Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.</span><span class="sxs-lookup"><span data-stu-id="89550-231">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="89550-232">Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant.</span><span class="sxs-lookup"><span data-stu-id="89550-232">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="89550-233">Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="89550-233">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="89550-234">Si vous appelez cette surcharge sur une file d’attente transactionnelle, Message Queuing crée une transaction interne unique.</span><span class="sxs-lookup"><span data-stu-id="89550-234">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="89550-235">La valeur spécifiée pour le paramètre <paramref name="timeout" /> est non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-235">The value specified for the <paramref name="timeout" /> parameter is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="89550-236">Le délai a expiré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-236">The timeout has expired.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="89550-237">Durée d'attente pour la suppression d'un message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-237">The interval of time to wait for the message to be removed.</span>
          </span>
        </param>
        <param name="transaction">
          <span data-ttu-id="89550-238">L'objet <see cref="T:System.Messaging.MessageQueueTransaction" /> qui spécifie le contexte de la transaction pour le message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-238">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction context for the message.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89550-239">Supprime le message en cours d'une file d'attente transactionnelle et retourne le message à l'application appelante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-239">Removes the current message from a transactional queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="89550-240">S'il y a un message à supprimer, le retour de la méthode est immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-240">If there is a message to remove, the method returns it immediately.</span>
          </span>
          <span data-ttu-id="89550-241">Sinon, la méthode attend le délai spécifié pour l'arrivée d'un message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-241">Otherwise, the method waits the specified timeout for a new message to arrive.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89550-242">
            <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-242">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-243"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur.</span><span class="sxs-lookup"><span data-stu-id="89550-243"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="89550-244">Si le curseur se trouve à la fin de la file d’attente, cette surcharge de la méthode attend qu’un message soit disponible ou que l’intervalle spécifié par le `timeout` paramètre a expiré.</span><span class="sxs-lookup"><span data-stu-id="89550-244">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="89550-245">Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-245">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="89550-246">La suppression est irréversible pas jusqu'à ce que la transaction est validée.</span><span class="sxs-lookup"><span data-stu-id="89550-246">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="89550-247">Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.</span><span class="sxs-lookup"><span data-stu-id="89550-247">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="89550-248">Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant.</span><span class="sxs-lookup"><span data-stu-id="89550-248">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="89550-249">Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="89550-249">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="89550-250">La valeur spécifiée pour le paramètre <paramref name="timeout" /> est non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-250">The value specified for the <paramref name="timeout" /> parameter is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89550-251">Le paramètre <paramref name="transaction" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-251">The <paramref name="transaction" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="89550-252">Le délai a expiré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-252">The timeout has expired.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="89550-253">Durée d'attente pour la suppression d'un message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-253">The interval of time to wait for the message to be removed.</span>
          </span>
        </param>
        <param name="transactionType">
          <span data-ttu-id="89550-254">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-254">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89550-255">Supprime le message en cours d'une file d'attente et retourne le message à l'application appelante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-255">Removes the current message from a queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="89550-256">S'il y a un message à supprimer, le retour de la méthode est immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-256">If there is a message to remove, the method returns it immediately.</span>
          </span>
          <span data-ttu-id="89550-257">Sinon, la méthode attend le délai spécifié pour l'arrivée d'un message.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-257">Otherwise, the method waits the specified timeout for a new message to arrive.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89550-258">
            <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-258">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-259"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur, à l’aide d’un contexte de transaction défini par le `transactionType` paramètre.</span><span class="sxs-lookup"><span data-stu-id="89550-259"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="89550-260">Si le curseur se trouve à la fin de la file d’attente, cette surcharge de la méthode attend qu’un message soit disponible ou que l’intervalle spécifié par le `timeout` paramètre a expiré.</span><span class="sxs-lookup"><span data-stu-id="89550-260">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="89550-261">Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message.</span><span class="sxs-lookup"><span data-stu-id="89550-261">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="89550-262">Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne.</span><span class="sxs-lookup"><span data-stu-id="89550-262">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="89550-263">Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.</span><span class="sxs-lookup"><span data-stu-id="89550-263">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="89550-264">Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.</span><span class="sxs-lookup"><span data-stu-id="89550-264">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="89550-265">Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-265">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="89550-266">La suppression est irréversible pas jusqu'à ce que la transaction est validée.</span><span class="sxs-lookup"><span data-stu-id="89550-266">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="89550-267">Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant.</span><span class="sxs-lookup"><span data-stu-id="89550-267">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="89550-268">Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="89550-268">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="89550-269">La valeur spécifiée pour le paramètre <paramref name="timeout" /> est non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-269">The value specified for the <paramref name="timeout" /> parameter is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="89550-270">Le délai a expiré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-270">The timeout has expired.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="89550-271">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-271">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="89550-272">Réinitialise l'énumérateur en cours, de manière à ce qu'il pointe vers le début de la file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-272">Resets the current enumerator so it points to the head of the queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89550-273">Un énumérateur peut uniquement se déplacer vers l’avant.</span><span class="sxs-lookup"><span data-stu-id="89550-273">An enumerator can only move in a forward direction.</span></span> <span data-ttu-id="89550-274">Utilisez cette méthode pour recommencer au début de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-274">Use this method to start over at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="89550-275">Après avoir appelé <xref:System.Messaging.MessageEnumerator.Reset%2A>, le curseur pointe vers le premier message.</span><span class="sxs-lookup"><span data-stu-id="89550-275">After calling <xref:System.Messaging.MessageEnumerator.Reset%2A>, the cursor points to the first message.</span></span> <span data-ttu-id="89550-276">Vous n’avez pas besoin d’appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.Reset%2A> pour avancer le curseur vers le premier message dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="89550-276">You do not need to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.Reset%2A> to move the cursor forward to the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="89550-277">Retourne <see cref="T:System.Messaging.Message" /> qui référence le message à la position actuelle du curseur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-277">Returns a <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="89550-278">
            <see cref="T:System.Messaging.Message" /> qui référence le message à la position actuelle du curseur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89550-278">A <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>