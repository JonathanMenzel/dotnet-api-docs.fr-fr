<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4096f6ae9125cd6cd98cc1be09adad375d1ea992" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37647571" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides a forward-only cursor to enumerate through messages in a message queue.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Messaging.MessageEnumerator> pour l’interaction dynamique avec des messages dans une file d’attente. Méthodes disponibles via le <xref:System.Messaging.MessageQueue> classe peut retourner un <xref:System.Messaging.MessageEnumerator> qui pointe vers une liste dynamique de messages dans la file d’attente ou un tableau qui contient une copie à un instant donné - un instantané, de la file d’attente au moment de la méthode spécifiée a été appelée.  
  
 Contrairement à un instantané statique, un énumérateur vous permet de modifier la collection. À l’aide un <xref:System.Messaging.MessageEnumerator>, vous pouvez supprimer les messages de la file d’attente et la modification est immédiatement répercutée dans la file d’attente.  
  
 Un énumérateur ne supprime pas les messages à partir de la file d’attente lors de l’interrogation de la file d’attente. Il retourne des informations sur le message à la position actuelle du curseur, mais laisse le message dans la file d’attente.  
  
 Un <xref:System.Messaging.MessageEnumerator> est un curseur, initialisé en tête d’une liste dynamique. L’ordre de la liste est identique à l’ordre des messages dans la file d’attente, en fonction de la priorité du message. Vous pouvez déplacer le curseur vers le premier message dans la file d’attente en appelant <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Après que l’énumérateur a été initialisé, vous pouvez utiliser <xref:System.Messaging.MessageEnumerator.MoveNext%2A> pour parcourir les messages restants. Vous pouvez spécifier s’il faut attendre un message soit disponible en passant un délai d’expiration dans le <xref:System.Messaging.MessageEnumerator.MoveNext%2A> (méthode).  
  
 Étant donné que l’énumérateur est dynamique, un message est ajouté au-delà de la position du curseur actuel (par exemple, en raison d’un niveau de priorité faible) est accessible par l’énumérateur. Un message qui est inséré avant la position actuelle du curseur n’est pas accessible. Il n’est pas possible de revenir en arrière avec un <xref:System.Messaging.MessageEnumerator>. Un curseur permet le déplacement avant uniquement. Le <xref:System.Messaging.MessageEnumerator.Reset%2A> méthode vous permet de placer le curseur au début de la file d’attente.  
  
 Instances de <xref:System.Messaging.MessageEnumerator> pour une file d’attente donnée fonctionnent indépendamment. Vous pouvez créer deux <xref:System.Messaging.MessageEnumerator> instances qui s’appliquent à la même file d’attente. Les modifications qu’un <xref:System.Messaging.MessageEnumerator> facilite pour les messages dans la file d’attente est répercutées immédiatement dans un second énumérateur si ce dernier est positionné avant le premier. Toutefois, si deux énumérateurs ont la même position et un d’eux supprime le message à cette position, une exception est levée si l’autre énumérateur tente d’obtenir la valeur de la <xref:System.Messaging.MessageEnumerator.Current%2A> propriété sur le message supprimé maintenant.  
  
> [!NOTE]
>  Si vous créez une instance de <xref:System.Messaging.MessageQueue> avec <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> défini sur `true`, aucune autre application ne peut modifier les messages dans votre énumérateur pendant que la connexion à la file d’attente.  
  
   
  
## Examples  
 L’exemple suivant obtient une liste dynamique de messages dans une file d’attente et compte tous les messages avec la <xref:System.Messaging.Message.Priority%2A> propriété définie sur <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees the resources associated with the enumerator.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le système d’exploitation conserve un handle ouvert vers la file d’attente pendant la durée de vie du curseur. Lorsque vous avez fini de travailler avec l’énumérateur, appelez <xref:System.Messaging.MessageEnumerator.Close%2A> pour libérer les ressources associées au handle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current <see cref="T:System.Messaging.Message" /> that this enumerator points to.</summary>
        <value>Le message en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’énumérateur est créé, il pointe vers le début de la file d’attente, à un emplacement avant le premier message. Dans ce cas, <xref:System.Messaging.MessageEnumerator.Current%2A> n’est pas valide et lève une exception si elle est accessible. Vous devez appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> pour positionner le curseur sur le premier message dans la file d’attente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> before the first call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. The cursor is located before the first element of the message enumeration.  -or-  You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> after a call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> had returned <see langword="false" /> (indicating the cursor is located after the last element of the message enumeration.)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The message the enumerator is currently pointing to no longer exists. It might have been deleted.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native Message Queuing cursor handle used to browse messages in the queue.</summary>
        <value>Le handle de curseur natif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété contient le handle natif de l’énumération. Lorsque vous avez fini de travailler avec l’énumérateur, appelez <xref:System.Messaging.MessageEnumerator.Close%2A> pour libérer cette ressource.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">The handle does not exist.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Releases the resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Messaging.MessageEnumerator.Dispose%2A> autorise les ressources utilisées par le <xref:System.Messaging.MessageEnumerator> d’être réaffectées à d’autres fins. Pour plus d’informations sur <xref:System.Messaging.MessageEnumerator.Dispose%2A>, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.Messaging.MessageEnumerator" /> and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public <xref:System.Messaging.MessageEnumerator.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Messaging.MessageEnumerator>. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d’autres objets. Lors de la substitution de <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose" />, consultez [implémentation d’un Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Pour plus d’informations sur <see langword="Dispose" /> et <see langword="Finalize" />, consultez [nettoyage des Resources](~/docs/standard/garbage-collection/unmanaged.md) non managé et [substitution de la méthode Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Advances the enumerator to the next message in the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Advances the enumerator to the next message in the queue, if one is currently available.</summary>
        <returns>
          <see langword="true" /> if the enumerator was succesfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge retourne immédiatement si aucun message n’est dans la file d’attente. Il existe une autre surcharge qui attend une certaine <xref:System.TimeSpan> pour un message arrive.  
  
 Si un message n’est pas disponible actuellement, car la file d’attente est vide ou parce que vous avez déplacé au-delà du dernier élément dans la collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> retourne `false` à la méthode appelante.  
  
 Lors de la création, conceptuel un énumérateur est placé avant le premier message de la file d’attente et le premier appel à <xref:System.Messaging.MessageEnumerator.MoveNext%2A> affiche le premier message de la file d’attente dans la vue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An exception specific to Message Queuing was thrown.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">The <see cref="T:System.TimeSpan" /> to wait for a message to be available if the enumerator is positioned at the end of the queue.</param>
        <summary>Advances the enumerator to the next message in the queue. If the enumerator is positioned at the end of the queue, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> waits until a message is available or the given timeout expires.</summary>
        <returns>
          <see langword="true" /> if the enumerator successfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue and a message does not become available within the time specified by the <paramref name="timeout" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge attend que s’il n’existe aucun message dans la file d’attente ou si le curseur a atteint la fin de la file d’attente. Si un message n’est pas disponible actuellement, car la file d’attente est vide ou parce que vous avez déplacé au-delà du dernier élément dans la collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> attend le délai spécifié.  
  
 Si le curseur se trouve déjà à la fin de la file d’attente, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> retourne uniquement `true` si le nouveau message arrive dans l’intervalle de temps spécifié, a une priorité plus faible que tous les messages actuellement dans la file d’attente et est placé à la fin de la file d’attente. Une surcharge sans paramètre retourne immédiatement si aucun autre message n’est dans la file d’attente.  
  
 Lors de la création, conceptuel un énumérateur est placé avant le premier message de l’énumération et le premier appel à <xref:System.Messaging.MessageEnumerator.MoveNext%2A> affiche le premier message de l’énumération dans la vue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the timeout parameter is invalid. It might represent a negative number.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An exception specific to Message Queuing was thrown.  -or-  The timeout has expired.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Removes the current message from the queue and returns the message to the calling application. Removing the message deletes it from the queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement décrit pour ces surcharges est applicable uniquement si le <xref:System.Messaging.MessageEnumerator> instance est récupérée à l’aide de la <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. N’utilisez pas <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> pour récupérer une instance de <xref:System.Messaging.MessageEnumerator> que cette méthode a été déconseillée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes the current message from a transactional or non-transactional queue and returns the message to the calling application. There is no timeout specified for a message to arrive in the queue.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Si vous appelez cette surcharge sur une file d’attente transactionnelle, Message Queuing crée une transaction interne unique.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction in which the message will be removed.</param>
        <summary>Removes the current message from a transactional queue and returns the message to the calling application. There is no timeout specified for a message to arrive in the queue.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur, en utilisant le contexte de transaction interne défini par le `transaction` paramètre.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente. La suppression est irréversible pas jusqu'à ce que la transaction est validée.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Removes the current message from a queue and returns the message to the calling application. There is no timeout specified for a message to arrive in the queue.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur, à l’aide d’un contexte de transaction défini par le `transactionType` paramètre.  
  
 Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente. La suppression est irréversible pas jusqu'à ce que la transaction est validée.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">The interval of time to wait for a message to arrive in the queue.</param>
        <summary>Removes the current message from the queue and returns the message to the calling application. If there is a message to remove, the method returns it immediately. Otherwise, the method waits the specified timeout for a new message to arrive.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur. Si le curseur se trouve à la fin de la file d’attente, cette surcharge de la méthode attend qu’un message soit disponible ou que l’intervalle spécifié par le `timeout` paramètre a expiré.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Si vous appelez cette surcharge sur une file d’attente transactionnelle, Message Queuing crée une transaction interne unique.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is invalid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The timeout has expired.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">The interval of time to wait for the message to be removed.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction context for the message.</param>
        <summary>Removes the current message from a transactional queue and returns the message to the calling application. If there is a message to remove, the method returns it immediately. Otherwise, the method waits the specified timeout for a new message to arrive.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur. Si le curseur se trouve à la fin de la file d’attente, cette surcharge de la méthode attend qu’un message soit disponible ou que l’intervalle spécifié par le `timeout` paramètre a expiré.  
  
 Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente. La suppression est irréversible pas jusqu'à ce que la transaction est validée.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is invalid.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The timeout has expired.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">The interval of time to wait for the message to be removed.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Removes the current message from a queue and returns the message to the calling application. If there is a message to remove, the method returns it immediately. Otherwise, the method waits the specified timeout for a new message to arrive.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur, à l’aide d’un contexte de transaction défini par le `transactionType` paramètre. Si le curseur se trouve à la fin de la file d’attente, cette surcharge de la méthode attend qu’un message soit disponible ou que l’intervalle spécifié par le `timeout` paramètre a expiré.  
  
 Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente. La suppression est irréversible pas jusqu'à ce que la transaction est validée.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is invalid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The timeout has expired.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the current enumerator so it points to the head of the queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un énumérateur peut uniquement se déplacer vers l’avant. Utilisez cette méthode pour recommencer au début de la file d’attente.  
  
 Après avoir appelé <xref:System.Messaging.MessageEnumerator.Reset%2A>, le curseur pointe vers le premier message. Vous n’avez pas besoin d’appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.Reset%2A> pour avancer le curseur vers le premier message dans la file d’attente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Messaging.MessageEnumerator.System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</summary>
        <value>Un <see cref="T:System.Messaging.Message" /> qui référence le message à la position actuelle du curseur.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>