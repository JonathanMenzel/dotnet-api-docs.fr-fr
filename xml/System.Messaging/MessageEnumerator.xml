<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="23b91a2631794fe77c1398283e744a03f64ef34f" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46645623" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit un curseur avant uniquement pour énumérer les messages dans une file d’attente de messages.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Messaging.MessageEnumerator> pour l’interaction dynamique avec des messages dans une file d’attente. Méthodes disponibles via le <xref:System.Messaging.MessageQueue> classe peut retourner un <xref:System.Messaging.MessageEnumerator> qui pointe vers une liste dynamique de messages dans la file d’attente ou un tableau qui contient une copie à un instant donné - un instantané, de la file d’attente au moment de la méthode spécifiée a été appelée.  
  
 Contrairement à un instantané statique, un énumérateur vous permet de modifier la collection. À l’aide un <xref:System.Messaging.MessageEnumerator>, vous pouvez supprimer les messages de la file d’attente et la modification est immédiatement répercutée dans la file d’attente.  
  
 Un énumérateur ne supprime pas les messages à partir de la file d’attente lors de l’interrogation de la file d’attente. Il retourne des informations sur le message à la position actuelle du curseur, mais laisse le message dans la file d’attente.  
  
 Un <xref:System.Messaging.MessageEnumerator> est un curseur, initialisé en tête d’une liste dynamique. L’ordre de la liste est identique à l’ordre des messages dans la file d’attente, en fonction de la priorité du message. Vous pouvez déplacer le curseur vers le premier message dans la file d’attente en appelant <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Après que l’énumérateur a été initialisé, vous pouvez utiliser <xref:System.Messaging.MessageEnumerator.MoveNext%2A> pour parcourir les messages restants. Vous pouvez spécifier s’il faut attendre un message soit disponible en passant un délai d’expiration dans le <xref:System.Messaging.MessageEnumerator.MoveNext%2A> (méthode).  
  
 Étant donné que l’énumérateur est dynamique, un message est ajouté au-delà de la position du curseur actuel (par exemple, en raison d’un niveau de priorité faible) est accessible par l’énumérateur. Un message qui est inséré avant la position actuelle du curseur n’est pas accessible. Il n’est pas possible de revenir en arrière avec un <xref:System.Messaging.MessageEnumerator>. Un curseur permet le déplacement avant uniquement. Le <xref:System.Messaging.MessageEnumerator.Reset%2A> méthode vous permet de placer le curseur au début de la file d’attente.  
  
 Instances de <xref:System.Messaging.MessageEnumerator> pour une file d’attente donnée fonctionnent indépendamment. Vous pouvez créer deux <xref:System.Messaging.MessageEnumerator> instances qui s’appliquent à la même file d’attente. Les modifications qu’un <xref:System.Messaging.MessageEnumerator> facilite pour les messages dans la file d’attente est répercutées immédiatement dans un second énumérateur si ce dernier est positionné avant le premier. Toutefois, si deux énumérateurs ont la même position et un d’eux supprime le message à cette position, une exception est levée si l’autre énumérateur tente d’obtenir la valeur de la <xref:System.Messaging.MessageEnumerator.Current%2A> propriété sur le message supprimé maintenant.  
  
> [!NOTE]
>  Si vous créez une instance de <xref:System.Messaging.MessageQueue> avec <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> défini sur `true`, aucune autre application ne peut modifier les messages dans votre énumérateur pendant que la connexion à la file d’attente.  
  
   
  
## Examples  
 L’exemple suivant obtient une liste dynamique de messages dans une file d’attente et compte tous les messages avec la <xref:System.Messaging.Message.Priority%2A> propriété définie sur <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources associées à l'énumérateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le système d’exploitation conserve un handle ouvert vers la file d’attente pendant la durée de vie du curseur. Lorsque vous avez fini de travailler avec l’énumérateur, appelez <xref:System.Messaging.MessageEnumerator.Close%2A> pour libérer les ressources associées au handle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Messaging.Message" /> actuel vers lequel cet énumérateur pointe.</summary>
        <value>Le message en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’énumérateur est créé, il pointe vers le début de la file d’attente, à un emplacement avant le premier message. Dans ce cas, <xref:System.Messaging.MessageEnumerator.Current%2A> n’est pas valide et lève une exception si elle est accessible. Vous devez appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> pour positionner le curseur sur le premier message dans la file d’attente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Vous avez appelé <see cref="P:System.Messaging.MessageEnumerator.Current" /> avant le premier appel à <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. Le curseur se trouve avant le premier élément de l'énumération de messages.  
  
- ou - 
Vous avez appelé <see cref="P:System.Messaging.MessageEnumerator.Current" /> après qu'un appel à <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> a retourné <see langword="false" /> (indiquant que le curseur se trouve après le dernier élément de l'énumération de messages).</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Le message vers lequel l'énumérateur pointe actuellement n'existe plus. Il a peut-être été supprimé.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle de curseur Message Queuing natif utilisé pour parcourir les messages dans la file d'attente.</summary>
        <value>Le handle de curseur natif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété contient le handle natif de l’énumération. Lorsque vous avez fini de travailler avec l’énumérateur, appelez <xref:System.Messaging.MessageEnumerator.Close%2A> pour libérer cette ressource.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Le handle n'existe pas.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère les ressources utilisées par le <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Messaging.MessageEnumerator.Dispose%2A> autorise les ressources utilisées par le <xref:System.Messaging.MessageEnumerator> d’être réaffectées à d’autres fins. Pour plus d’informations sur <xref:System.Messaging.MessageEnumerator.Dispose%2A>, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Nettoyage de ressources non managées</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Messaging.MessageEnumerator" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public <xref:System.Messaging.MessageEnumerator.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Messaging.MessageEnumerator>. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution de <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see langword="Dispose" /> et <see langword="Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implémentation d’une méthode Dispose</related>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Nettoyage de ressources non managées</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avance l'énumérateur jusqu'au message suivant de la file d'attente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avance l'énumérateur jusqu'au message suivant dans la file d'attente, s'il y en a un de disponible.</summary>
        <returns>
          <see langword="true" /> si l'énumérateur a réussi à avancer jusqu'au message suivant ; <see langword="false" /> si l'énumérateur a atteint la fin de la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge retourne immédiatement si aucun message n’est dans la file d’attente. Il existe une autre surcharge qui attend une certaine <xref:System.TimeSpan> pour un message arrive.  
  
 Si un message n’est pas disponible actuellement, car la file d’attente est vide ou parce que vous avez déplacé au-delà du dernier élément dans la collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> retourne `false` à la méthode appelante.  
  
 Lors de la création, conceptuel un énumérateur est placé avant le premier message de la file d’attente et le premier appel à <xref:System.Messaging.MessageEnumerator.MoveNext%2A> affiche le premier message de la file d’attente dans la vue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une exception spécifique à Message Queuing a été levée.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Le <see cref="T:System.TimeSpan" /> d'attente pour qu'un message soit disponible si l'énumérateur est placé à la fin de la file d'attente.</param>
        <summary>Avance l'énumérateur jusqu'au message suivant de la file d'attente. Si l'énumérateur est placé à la fin de la file d'attente, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> attend qu'un message soit disponible ou que le délai spécifié expire.</summary>
        <returns>
          <see langword="true" /> si l'énumérateur a réussi à avancer jusqu'au message suivant ; <see langword="false" /> si l'énumérateur a atteint la fin de la file d'attente et si aucun message n'est disponible dans le délai spécifié par le paramètre <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge attend que s’il n’existe aucun message dans la file d’attente ou si le curseur a atteint la fin de la file d’attente. Si un message n’est pas disponible actuellement, car la file d’attente est vide ou parce que vous avez déplacé au-delà du dernier élément dans la collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> attend le délai spécifié.  
  
 Si le curseur se trouve déjà à la fin de la file d’attente, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> retourne uniquement `true` si le nouveau message arrive dans l’intervalle de temps spécifié, a une priorité plus faible que tous les messages actuellement dans la file d’attente et est placé à la fin de la file d’attente. Une surcharge sans paramètre retourne immédiatement si aucun autre message n’est dans la file d’attente.  
  
 Lors de la création, conceptuel un énumérateur est placé avant le premier message de l’énumération et le premier appel à <xref:System.Messaging.MessageEnumerator.MoveNext%2A> affiche le premier message de l’énumération dans la vue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre de délai d'attente n'est pas valide. Il peut s'agir d'un nombre négatif.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une exception spécifique à Message Queuing a été levée.  
  
- ou - 
Le délai a expiré.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime le message en cours de la file d'attente et retourne le message à l'application appelante. La suppression du message l'efface de la file d'attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement décrit pour ces surcharges est applicable uniquement si le <xref:System.Messaging.MessageEnumerator> instance est récupérée à l’aide de la <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. N’utilisez pas <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> pour récupérer une instance de <xref:System.Messaging.MessageEnumerator> que cette méthode a été déconseillée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime le message en cours d'une file d'attente transactionnelle ou non et retourne le message à l'application appelante. Il n'y a pas de délai d'attente spécifié pour l'arrivée d'un message dans la file d'attente.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Si vous appelez cette surcharge sur une file d’attente transactionnelle, Message Queuing crée une transaction interne unique.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">L'objet <see cref="T:System.Messaging.MessageQueueTransaction" /> qui spécifie la transaction dans laquelle le message sera supprimé.</param>
        <summary>Supprime le message en cours d'une file d'attente transactionnelle et retourne le message à l'application appelante. Il n'y a pas de délai d'attente spécifié pour l'arrivée d'un message dans la file d'attente.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur, en utilisant le contexte de transaction interne défini par le `transaction` paramètre.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente. La suppression est irréversible pas jusqu'à ce que la transaction est validée.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="transaction" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</param>
        <summary>Supprime le message en cours d'une file d'attente et retourne le message à l'application appelante. Il n'y a pas de délai d'attente spécifié pour l'arrivée d'un message dans la file d'attente.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur, à l’aide d’un contexte de transaction défini par le `transactionType` paramètre.  
  
 Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente. La suppression est irréversible pas jusqu'à ce que la transaction est validée.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">La durée d'attente pour l'arrivée d'un message dans la file d'attente.</param>
        <summary>Supprime le message en cours de la file d'attente et retourne le message à l'application appelante. S'il y a un message à supprimer, le retour de la méthode est immédiat. Sinon, la méthode attend le délai spécifié pour l'arrivée d'un message.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur. Si le curseur se trouve à la fin de la file d’attente, cette surcharge de la méthode attend qu’un message soit disponible ou que l’intervalle spécifié par le `timeout` paramètre a expiré.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Si vous appelez cette surcharge sur une file d’attente transactionnelle, Message Queuing crée une transaction interne unique.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> est non valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Le délai a expiré.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Durée d'attente pour la suppression d'un message.</param>
        <param name="transaction">L'objet <see cref="T:System.Messaging.MessageQueueTransaction" /> qui spécifie le contexte de la transaction pour le message.</param>
        <summary>Supprime le message en cours d'une file d'attente transactionnelle et retourne le message à l'application appelante. S'il y a un message à supprimer, le retour de la méthode est immédiat. Sinon, la méthode attend le délai spécifié pour l'arrivée d'un message.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur. Si le curseur se trouve à la fin de la file d’attente, cette surcharge de la méthode attend qu’un message soit disponible ou que l’intervalle spécifié par le `timeout` paramètre a expiré.  
  
 Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente. La suppression est irréversible pas jusqu'à ce que la transaction est validée.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> est non valide.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="transaction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Le délai a expiré.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Durée d'attente pour la suppression d'un message.</param>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</param>
        <summary>Supprime le message en cours d'une file d'attente et retourne le message à l'application appelante. S'il y a un message à supprimer, le retour de la méthode est immédiat. Sinon, la méthode attend le délai spécifié pour l'arrivée d'un message.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Supprime et retourne le message à l’emplacement actuel du curseur, à l’aide d’un contexte de transaction défini par le `transactionType` paramètre. Si le curseur se trouve à la fin de la file d’attente, cette surcharge de la méthode attend qu’un message soit disponible ou que l’intervalle spécifié par le `timeout` paramètre a expiré.  
  
 Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Si vous utilisez la journalisation de file d’attente, la suppression du message entraîne une copie à conserver dans la file d’attente du journal, tout comme le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Receive%2A> méthode effectue.  
  
 Lorsque vous travaillez avec des files d’attente transactionnelles, la restauration d’une transaction provoque des messages supprimés par un appel à <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> à retourner à la file d’attente. La suppression est irréversible pas jusqu'à ce que la transaction est validée.  
  
 Lorsque vous supprimez le message en cours, le curseur est déplacé vers le message suivant. Vous n’avez pas à appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> est non valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Le délai a expiré.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réinitialise l'énumérateur en cours, de manière à ce qu'il pointe vers le début de la file d'attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un énumérateur peut uniquement se déplacer vers l’avant. Utilisez cette méthode pour recommencer au début de la file d’attente.  
  
 Après avoir appelé <xref:System.Messaging.MessageEnumerator.Reset%2A>, le curseur pointe vers le premier message. Vous n’avez pas besoin d’appeler <xref:System.Messaging.MessageEnumerator.MoveNext%2A> après avoir appelé <xref:System.Messaging.MessageEnumerator.Reset%2A> pour avancer le curseur vers le premier message dans la file d’attente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne <see cref="T:System.Messaging.Message" /> qui référence le message à la position actuelle du curseur.</summary>
        <value>
          <see cref="T:System.Messaging.Message" /> qui référence le message à la position actuelle du curseur.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>