<Type Name="TextFieldParser" FullName="Microsoft.VisualBasic.FileIO.TextFieldParser">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="013d626bb8bc81d9eb4e03b891788c9c26fbc2a6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36659061" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextFieldParser : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi TextFieldParser extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
  <TypeSignature Language="VB.NET" Value="Public Class TextFieldParser&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextFieldParser : IDisposable" />
  <TypeSignature Language="F#" Value="type TextFieldParser = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit des méthodes et des propriétés pour analyser des fichiers texte structurés.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `TextFieldParser` objet fournit des méthodes et propriétés pour analyser les fichiers texte structurés. Analyser un fichier texte avec le `TextFieldParser` est similaire à un fichier texte, une itération pendant la `ReadFields` méthode pour extraire des champs de texte correspond à fractionner les chaînes.  
  
 Le `TextFieldParser` peut analyser deux types de fichiers : délimité ou à largeur fixe. Certaines propriétés, telles que `Delimiters` et `HasFieldsEnclosedInQuotes` sont significatives uniquement lorsque vous travaillez avec des fichiers délimités, alors que le `FieldWidths` propriété n’est significative uniquement lorsque vous travaillez avec les fichiers de longueur fixe.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `Microsoft.VisualBasic.FileIO.TextFieldParser` objet.  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d’un fichier texte délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire à partir d’un fichier texte avec plusieurs formats|[Guide pratique : lire des fichiers texte avec plusieurs formats](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple analyse un fichier texte délimité, `Bigfile`.  
  
 [!code-vb[VbVbalrTextFieldParser#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#17)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see langword="TextFieldParser" />.</summary>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Flux à analyser.</param>
        <summary>Initialise une nouvelle instance de la classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un nouveau `TextFieldParser` objet pour analyser le fichier ou un flux qui est représenté par la `stream` paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">Il n'est pas possible de lire depuis <paramref name="stream" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.TextReader -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser reader" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" />. Flux <see cref="T:System.IO.TextReader" /> à analyser.</param>
        <summary>Initialise une nouvelle instance de la classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un nouveau `TextFieldParser` objet pour analyser le fichier ou un flux qui est représenté par la `reader` paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> est <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. Chemin d'accès complet au fichier à analyser.</param>
        <summary>Initialise une nouvelle instance de la classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un nouveau `TextFieldParser` objet à analyser le fichier spécifié par le `path` paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est une chaîne vide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Flux à analyser.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Encodage de caractères à utiliser si l'encodage n'est pas déterminé à partir du fichier. La valeur par défaut est <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un nouveau `TextFieldParser` objet pour analyser le fichier ou un flux qui est représenté par la `stream` paramètre.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="defaultEncoding" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">Il n'est pas possible de lire depuis <paramref name="stream" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, defaultEncoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path, System::Text::Encoding ^ defaultEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string * System.Text.Encoding -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (path, defaultEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. Chemin d'accès complet au fichier à analyser.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Encodage de caractères à utiliser si l'encodage n'est pas déterminé à partir du fichier. La valeur par défaut est <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un nouveau `TextFieldParser` objet à analyser le fichier spécifié par le `path` paramètre.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est une chaîne vide ou <paramref name="defaultEncoding" /> est <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding, detectEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Flux à analyser.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Encodage de caractères à utiliser si l'encodage n'est pas déterminé à partir du fichier. La valeur par défaut est <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Indique s'il faut rechercher les marques d'ordre des octets au début du fichier. La valeur par défaut est <see langword="True" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un nouveau `TextFieldParser` objet pour analyser le fichier ou un flux qui est représenté par la `stream` paramètre.  
  
 Si le `detectEncoding` paramètre est `True`, ce constructeur essaie de détecter l’encodage en examinant les trois premiers octets du fichier ou du flux de données. Il reconnaît automatiquement Unicode UTF-8, little-endian et big-endian Unicode texte si le fichier démarre avec les marques d’ordre d’octet appropriées. Dans le cas contraire, l’encodage spécifié par `defaultEncoding` est utilisée.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="defaultEncoding" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">Il n'est pas possible de lire depuis <paramref name="stream" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, defaultEncoding As Encoding, detectEncoding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path, System::Text::Encoding ^ defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string * System.Text.Encoding * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (path, defaultEncoding, detectEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. Chemin d'accès complet au fichier à analyser.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Encodage de caractères à utiliser si l'encodage n'est pas déterminé à partir du fichier. La valeur par défaut est <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Indique s'il faut rechercher les marques d'ordre des octets au début du fichier. La valeur par défaut est <see langword="True" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un nouveau `TextFieldParser` objet à analyser le fichier spécifié par le `path` paramètre.  
  
 Si le `detectEncoding` paramètre est `True`, ce constructeur essaie de détecter l’encodage en examinant les trois premiers octets du fichier ou du flux de données. Il reconnaît automatiquement Unicode UTF-8, little-endian et big-endian Unicode texte si le fichier démarre avec les marques d’ordre d’octet appropriées. Dans le cas contraire, l’encodage spécifié par `defaultEncoding` est utilisée.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est une chaîne vide ou <paramref name="defaultEncoding" /> est <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding, bool detectEncoding, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding * bool * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding, detectEncoding, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Flux à analyser.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Encodage de caractères à utiliser si l'encodage n'est pas déterminé à partir du fichier. La valeur par défaut est <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Indique s'il faut rechercher les marques d'ordre des octets au début du fichier. La valeur par défaut est <see langword="True" />.</param>
        <param name="leaveOpen">
          <see langword="Boolean" />. <c>Indique si </c> doit être laissé ouvert lorsque l’objet <see langword="TextFieldParser" /> est fermé. La valeur par défaut est <see langword="False" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un nouveau `TextFieldParser` objet pour analyser le fichier ou un flux qui est représenté par la `stream` paramètre.  
  
 Si le `detectEncoding` paramètre est `True`, ce constructeur essaie de détecter l’encodage en examinant les trois premiers octets du fichier ou du flux de données. Il reconnaît automatiquement Unicode UTF-8, little-endian et big-endian Unicode texte si le fichier démarre avec les marques d’ordre d’octet appropriées. Dans le cas contraire, l’encodage spécifié par `defaultEncoding` est utilisée.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="defaultEncoding" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">Il n'est pas possible de lire depuis <paramref name="stream" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="textFieldParser.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme l'objet <see langword="TextFieldParser" /> en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple ferme le `TextFieldParser.FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CommentTokens">
      <MemberSignature Language="C#" Value="public string[] CommentTokens { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] CommentTokens" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.CommentTokens" />
      <MemberSignature Language="VB.NET" Value="Public Property CommentTokens As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ CommentTokens { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommentTokens : string[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.CommentTokens" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit des jetons de commentaire. Un jeton de commentaire est une chaîne qui, lorsqu'elle est placée au début d'une ligne, indique que la ligne est un commentaire et doit être ignorée par l'analyseur.</summary>
        <value>Tableau de chaînes qui contient tous les jetons de commentaires pour l'objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un membre avancé ; Il n’affiche pas dans IntelliSense, sauf si vous cliquez sur le **tous les** onglet.  
  
 Les jetons de commentaire de longueur nulle sont ignorés.  
  
   
  
## Examples  
 Cet exemple spécifie que pour les `TextFieldParser`, `FileReader` les lignes commençant par un guillemet simple (') doivent être ignorées.  
  
 [!code-vb[VbVbalrTextFieldParser#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un jeton de commentaire contient un espace blanc.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Delimiters">
      <MemberSignature Language="C#" Value="public string[] Delimiters { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Delimiters" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
      <MemberSignature Language="VB.NET" Value="Public Property Delimiters As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Delimiters { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Delimiters : string[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit les séparateurs pour un fichier texte.</summary>
        <value>Tableau de chaînes qui contient tous séparateurs de champs pour l'objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est significative uniquement si la <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> est définie sur `FieldType.Delimited`.  
  
 Définir les délimiteurs d’un fichier texte peut également être effectué avec la <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters%2A> (méthode).  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `Delimiters` propriété.  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d’un fichier texte délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
  
   
  
## Examples  
 Cet exemple spécifie que le délimiteur pour les `TextFieldParser` objet, `FileReader`, est une virgule (,).  
  
 [!code-vb[VbVbalrTextFieldParser#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une valeur de séparateur est un caractère de saut de ligne, une chaîne vide ou <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère les ressources utilisées par l’objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</summary>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="textFieldParser.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par l’objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="textFieldParser.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Propriété booléenne. <see langword="True" /> libère les ressources managées et non managées ; <see langword="False" /> libère uniquement les ressources non managées.</param>
        <summary>Libère les ressources utilisées par l’objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndOfData">
      <MemberSignature Language="C#" Value="public bool EndOfData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfData" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.EndOfData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfData : bool" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.EndOfData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne <see langword="True" /> s'il n'y a aucune ligne non vide, sans commentaire, entre la position actuelle du curseur et la fin du fichier.</summary>
        <value>
          <see langword="True" /> s'il n'y a plus de données à lire ; sinon, <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut être utilisée lors de la lecture à partir de fichiers pour déterminer la fin des données en cours de lecture.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `EndOfData` propriété.  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d’un fichier délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire à partir d’un fichier de longueur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Cet exemple utilise le `EndofData` propriété pour parcourir tous les champs dans le fichier avec le `TextFieldReader`, `FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ErrorLine">
      <MemberSignature Language="C#" Value="public string ErrorLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorLine" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ErrorLine : string" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne la ligne qui a provoqué l'exception <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> la plus récente.</summary>
        <value>Ligne qui a provoqué l'exception <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> la plus récente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucun <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> exceptions ont été levées, une chaîne vide est retournée.  
  
 Le <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber%2A> propriété peut être utilisée pour afficher le numéro de la ligne qui a provoqué l’exception.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `ErrorLine` propriété.  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d’un fichier délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire à partir d’un fichier de longueur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Cet exemple utilise le `ErrorLine` propriété pour afficher la ligne qui provoque l’actuel <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> exception.  
  
 [!code-vb[VbVbalrTextFieldParser#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ErrorLineNumber">
      <MemberSignature Language="C#" Value="public long ErrorLineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ErrorLineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorLineNumber As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ErrorLineNumber { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ErrorLineNumber : int64" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne le numéro de la ligne qui a provoqué l'exception <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> la plus récente.</summary>
        <value>Numéro de la ligne qui a provoqué l'exception <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> la plus récente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucun <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> exceptions ont été levées, -1 est retourné.  
  
 Le <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine%2A> propriété peut être utilisée pour afficher le numéro de la ligne qui a provoqué l’exception. Lignes vides et les commentaires ne sont pas ignorés lors de la détermination du numéro de ligne.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `ErrorLineNumber` propriété.  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d’un fichier délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire à partir d’un fichier de longueur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Cet exemple utilise le `ErrorLineNumber` propriété pour afficher l’emplacement de la ligne qui provoque l’actuel <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> exception.  
  
 [!code-vb[VbVbalrTextFieldParser#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="FieldWidths">
      <MemberSignature Language="C#" Value="public int[] FieldWidths { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] FieldWidths" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
      <MemberSignature Language="VB.NET" Value="Public Property FieldWidths As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ FieldWidths { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FieldWidths : int[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Désigne la largeur de chaque colonne du fichier texte en cours d'analyse.</summary>
        <value>Tableau d'entiers qui contient la largeur de chaque colonne dans le fichier texte en cours d'analyse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est significative uniquement si la <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> est définie sur `FieldType.FixedWidth`. Si la dernière entrée du tableau est inférieure ou égale à zéro, le champ est supposé pour être de largeur variable.  
  
 Le <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths%2A> méthode peut également être utilisée pour définir des largeurs de champ.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `FieldWidths` propriété.  
  
|À|Voir|  
|--------|---------|  
|Lire un fichier texte de largeur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Cet exemple lit le fichier `ParserText.txt`, en spécifiant les largeurs ; la première colonne est de 5 caractères, la deuxième de 10, la troisième de 11 et la quatrième a une largeur variable  
  
 [!code-vb[VbVbalrTextFieldParser#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une valeur de largeur dans un emplacement autre que la dernière entrée du tableau est inférieure ou égale à zéro.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FieldType" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TextFieldParser ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TextFieldParser ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="textFieldParser.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permet à l'objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> de tenter de libérer des ressources et d'effectuer d'autres opérations de nettoyage avant d'être récupéré par l'opération garbage collection.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="HasFieldsEnclosedInQuotes">
      <MemberSignature Language="C#" Value="public bool HasFieldsEnclosedInQuotes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasFieldsEnclosedInQuotes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.HasFieldsEnclosedInQuotes" />
      <MemberSignature Language="VB.NET" Value="Public Property HasFieldsEnclosedInQuotes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasFieldsEnclosedInQuotes { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HasFieldsEnclosedInQuotes : bool with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.HasFieldsEnclosedInQuotes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si les champs sont placés entre guillemets lorsqu'un fichier délimité est analysé.</summary>
        <value>
          <see langword="True" /> si les champs sont placés entre guillemets ; sinon, <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un membre avancé ; Il n’affiche pas dans IntelliSense, sauf si vous cliquez sur le **tous les** onglet.  
  
 Si la propriété est `True`, l’analyseur suppose que les champs sont placés entre guillemets (« ») et peuvent contenir des fins de ligne.  
  
 Si un champ est placé entre guillemets, par exemple, `abc, "field2a,field2b", field3` et cette propriété est `True`, puis tout le texte entourée guillemets sera renvoyé telle quelle ; cet exemple retourne `abc|field2a,field2b|field3`. Si cette propriété `False` que cet exemple retourne `abc|"field2a|field2b"|field3`.  
  
   
  
## Examples  
 Cet exemple définit le `HasFieldsEnclosedInQuotes` propriété `True` pour `myReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public long LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.LineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LineNumber As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LineNumber { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LineNumber : int64" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.LineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne le nombre de lignes en cours, ou retourne -1 si aucun caractère n'est disponible dans le flux.</summary>
        <value>Numéro de ligne active.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un membre avancé ; Il n’affiche pas dans IntelliSense, sauf si vous cliquez sur le **tous les** onglet.  
  
 Lignes vides et les commentaires ne sont pas ignorés lors de la détermination du numéro de ligne.  
  
   
  
## Examples  
 Cet exemple recherche le nom « Jones » dans le fichier texte et indique la ligne où il se trouve.  
  
 [!code-vb[VbVbalrTextFieldParser#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PeekChars">
      <MemberSignature Language="C#" Value="public string PeekChars (int numberOfChars);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string PeekChars(int32 numberOfChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.PeekChars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekChars (numberOfChars As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PeekChars(int numberOfChars);" />
      <MemberSignature Language="F#" Value="member this.PeekChars : int -&gt; string" Usage="textFieldParser.PeekChars numberOfChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numberOfChars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="numberOfChars">
          <see langword="Int32" />. Nombre de caractères à lire. Obligatoire.</param>
        <summary>Lit le nombre spécifié de caractères sans avancer le curseur.</summary>
        <returns>Chaîne qui contient le nombre spécifié de caractères à lire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `numberOfChars` valeur doit être inférieur au nombre total de caractères dans la ligne. Si elle n’est pas le cas, la chaîne retournée par `PeekChars` sera tronquée à la longueur de la ligne.  
  
 Les lignes vides sont ignorées.  
  
 Caractères de fin de ligne ne sont pas retournés.  
  
 Le `PeekChars` méthode n’effectue aucune analyse ; un caractère de fin de ligne dans un champ délimité est interprété comme la fin de la ligne.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `PeekChars` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Déterminer le format d’un champ avant de l’analyser|[Guide pratique : lire des fichiers texte avec plusieurs formats](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple utilise `PeekChars` pour rechercher la fin des données et arrêter l’analyse du fichier à ce stade.  
  
 [!code-vb[VbVbalrTextFieldParser#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="numberOfChars" /> est inférieur à 0.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadFields">
      <MemberSignature Language="C#" Value="public string[] ReadFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string[] ReadFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadFields () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ ReadFields();" />
      <MemberSignature Language="F#" Value="member this.ReadFields : unit -&gt; string[]" Usage="textFieldParser.ReadFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit tous les champs sur la ligne active, les retourne sous la forme d'un tableau de chaînes et avance le curseur vers la ligne suivante contenant des données.</summary>
        <returns>Tableau de chaînes qui contient les valeurs de champs pour la ligne active.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour permettre aux utilisateurs d’analyser les fichiers texte dans plusieurs formats, la `ReadFields` méthode examine les valeurs de `TextFieldType`, `Delimiters`, et `FieldWidths`, si elles sont spécifiées, chaque fois qu’elle est appelée. Les utilisateurs doivent configurer correctement le `TextFieldType` et `FieldWidths` ou `Delimiters` propriétés, selon vos besoins. Si `TextFieldType` a la valeur `Delimited`, et `Delimiters` n’est pas définie, ou si `TextFieldType` a la valeur `FixedWidth` et `FieldWidths`, une exception est levée.  
  
 Si `ReadFields` rencontre des lignes vides, elles sont ignorées et la prochaine ligne non vide est retournée.  
  
 Si le `ReadFields` méthode ne peut pas analyser la ligne en cours, elle lève une exception et ne déplace pas vers la ligne suivante. Cela permet à votre application tente d’analyser la ligne à nouveau.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `ReadFields` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d’un fichier délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire à partir d’un fichier de longueur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Cet exemple utilise le `ReadFields` méthode pour lire à partir du fichier CSV `ParserText.txt`. L’exemple écrit les champs à `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Un champ ne peut pas être analysé à l'aide du format spécifié.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="member this.ReadLine : unit -&gt; string" Usage="textFieldParser.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la ligne active en tant que chaîne et avance le curseur vers la ligne suivante.</summary>
        <returns>Ligne active du fichier ou du flux.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ReadLine` méthode n’effectue aucune analyse ; un caractère de fin de ligne dans un champ délimité est interprété comme la fin de la ligne.  
  
 `Nothing` est retourné si la fin du fichier est atteinte.  
  
   
  
## Examples  
 Cet exemple lit le fichier `ParserText.txt` et écrit dans `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#15)]  
  
 Si `Testfile.txt` n’existe pas, il est créé par le `WriteAllText` (méthode).  
  
 Cet exemple écrit les champs sous forme de chaîne unique ; Pour que chaque ligne s’affiche sur sa propre ligne dans le fichier de destination, une `VbCrLf` caractère doit être ajouté à la fin de chaque ligne.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadToEnd" />
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="member this.ReadToEnd : unit -&gt; string" Usage="textFieldParser.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le reste du fichier texte et le retourne en tant que chaîne.</summary>
        <returns>Texte restant du fichier ou du flux.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un membre avancé ; Il n’affiche pas dans IntelliSense, sauf si vous cliquez sur le **tous les** onglet.  
  
 Si aucune n’est plus à lire parce que la fin du fichier a été atteinte, `Nothing` est retourné.  
  
 Le `ReadToEnd` méthode n’ignore pas les lignes vides et des commentaires.  
  
   
  
## Examples  
 Cet exemple utilise le `ReadToEnd` méthode pour lire l’intégralité du fichier `ParserText.txt` et les écrire dans le fichier `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#10)]  
  
 Si `Testfile.txt` n’existe pas, il est créé par le `WriteAllText` (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      </Docs>
    </Member>
    <Member MemberName="SetDelimiters">
      <MemberSignature Language="C#" Value="public void SetDelimiters (params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetDelimiters(string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDelimiters (ParamArray delimiters As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDelimiters(... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="member this.SetDelimiters : string[] -&gt; unit" Usage="textFieldParser.SetDelimiters delimiters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delimiters">Tableau de type <see langword="String" />.</param>
        <summary>Affecte les valeurs spécifiées aux séparateurs pour le lecteur et la valeur <see langword="Delimited" /> au type de champ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le contenu existant de la `Delimiters` propriété est effacé lorsque cette méthode est définie.  
  
 Cette méthode fournit un moyen de définir des délimiteurs sans créer de tableau.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `SetDelimiters` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Analyser un fichier texte|[Analyse des fichiers texte avec l’objet TextFieldParser](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 Cet exemple ouvre un analyseur de champ de texte et définit le délimiteur comme `vbTab`.  
  
 [!code-vb[VbVbalrTextFieldParser#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#4)]  
  
 Remplacez le chemin d’accès `C:\logs\test.log` avec le chemin d’accès et le nom du fichier à analyser.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un délimiteur est de longueur nulle.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths(System.Int32[])" />
      </Docs>
    </Member>
    <Member MemberName="SetFieldWidths">
      <MemberSignature Language="C#" Value="public void SetFieldWidths (params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetFieldWidths(int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFieldWidths (ParamArray fieldWidths As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFieldWidths(... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="member this.SetFieldWidths : int[] -&gt; unit" Usage="textFieldParser.SetFieldWidths fieldWidths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="fieldWidths">Tableau d'<see langword="Integer" />.</param>
        <summary>Affecte les valeurs spécifiées aux séparateurs pour le lecteur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le contenu existant de la `Delimiters` propriété sont désactivées lorsque ce paramètre est défini.  
  
 Cette méthode fournit un moyen de définir des délimiteurs sans créer de tableau.  
  
 Le tableau suivant répertorie l’exemple de tâches impliquant la `SetFieldWidths` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Analyser un fichier texte.|[Analyse des fichiers texte avec l’objet TextFieldParser](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 Cet exemple ouvre un analyseur de champ de texte et définit la largeur du champ en tant que `5`.  
  
 [!code-vb[VbVbalrTextFieldParser#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#12)]  
  
 Remplacez le chemin d’accès `C:\logs\test.log` avec le chemin d’accès et le nom du fichier à analyser.  
  
 L’exemple suivant ouvre un analyseur de champ de texte et définit la largeur de champ en tant que `5`, `10`et la variable.  
  
 [!code-vb[VbVbalrTextFieldParser#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#13)]  
  
 Remplacez le chemin d’accès `C:\logs\test.log` avec le chemin d’accès et le nom du fichier à analyser.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="TextFieldType">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.FieldType TextFieldType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.FileIO.FieldType TextFieldType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
      <MemberSignature Language="VB.NET" Value="Public Property TextFieldType As FieldType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::FileIO::FieldType TextFieldType { Microsoft::VisualBasic::FileIO::FieldType get(); void set(Microsoft::VisualBasic::FileIO::FieldType value); };" />
      <MemberSignature Language="F#" Value="member this.TextFieldType : Microsoft.VisualBasic.FileIO.FieldType with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.FieldType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si le fichier à analyser est délimité ou à largeur fixe.</summary>
        <value>Valeur <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" /> qui indique si le fichier à analyser est délimité ou de longueur fixe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut de cette propriété est délimitée.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `TextFieldType` propriété.  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d’un fichier texte délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire à partir d’un fichier texte avec plusieurs formats|[Guide pratique : lire des fichiers texte avec plusieurs formats](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple crée un `TextFieldParser`, `FileReader`et spécifie qu’il est délimité.  
  
 [!code-vb[VbVbalrTextFieldParser#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#19)]  
  
 Cet exemple crée un `TextFieldParser`, `FileReader`et spécifie qu’il est à largeur fixe.  
  
 [!code-vb[VbVbalrTextFieldParser#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FieldType" />
      </Docs>
    </Member>
    <Member MemberName="TrimWhiteSpace">
      <MemberSignature Language="C#" Value="public bool TrimWhiteSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimWhiteSpace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TrimWhiteSpace" />
      <MemberSignature Language="VB.NET" Value="Public Property TrimWhiteSpace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimWhiteSpace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrimWhiteSpace : bool with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.TrimWhiteSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si les espaces blancs de début et de fin doivent être supprimés des valeurs de champs.</summary>
        <value>
          <see langword="True" /> si les espaces blancs de début et de fin doivent être supprimés des valeurs de champs ; sinon, <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut de cette propriété est `True`.  
  
   
  
## Examples  
 Cet exemple crée un `TextFieldParser`, `FileReader`et définit les `TrimWhiteSpace` propriété `True`.  
  
 [!code-vb[VbVbalrTextFieldParser#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>