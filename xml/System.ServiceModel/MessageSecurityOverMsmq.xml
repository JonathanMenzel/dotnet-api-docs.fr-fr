<Type Name="MessageSecurityOverMsmq" FullName="System.ServiceModel.MessageSecurityOverMsmq">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6946a6ec0a64980610c3930bf56c0458ab16ecb7" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48769643" /></Metadata><TypeSignature Language="C#" Value="public sealed class MessageSecurityOverMsmq" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MessageSecurityOverMsmq extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.MessageSecurityOverMsmq" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MessageSecurityOverMsmq" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageSecurityOverMsmq sealed" />
  <TypeSignature Language="F#" Value="type MessageSecurityOverMsmq = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Permet de définir des propriétés de sécurité au niveau du message sur la liaison <see cref="T:System.ServiceModel.NetMsmqBinding" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet objet est accessible depuis la liaison au moyen de la propriété <xref:System.ServiceModel.NetMsmqBinding.Security%2A>, qui retourne un objet <xref:System.ServiceModel.NetMsmqSecurity>. L'objet a une propriété <xref:System.ServiceModel.NetMsmqSecurity.Message%2A> qui fournit une référence à l'objet <xref:System.ServiceModel.MessageSecurityOverMsmq>.  
  
   
  
## Examples  
 [!code-csharp[UEMessageSecurityOverMsmq#1](~/samples/snippets/csharp/VS_Snippets_CFX/uemessagesecurityovermsmq/cs/program.cs#1)]
 [!code-vb[UEMessageSecurityOverMsmq#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/uemessagesecurityovermsmq/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageSecurityOverMsmq ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.MessageSecurityOverMsmq.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageSecurityOverMsmq();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.MessageSecurityOverMsmq" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlgorithmSuite">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.SecurityAlgorithmSuite AlgorithmSuite { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Security.SecurityAlgorithmSuite AlgorithmSuite" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageSecurityOverMsmq.AlgorithmSuite" />
      <MemberSignature Language="VB.NET" Value="Public Property AlgorithmSuite As SecurityAlgorithmSuite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::SecurityAlgorithmSuite ^ AlgorithmSuite { System::ServiceModel::Security::SecurityAlgorithmSuite ^ get(); void set(System::ServiceModel::Security::SecurityAlgorithmSuite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AlgorithmSuite : System.ServiceModel.Security.SecurityAlgorithmSuite with get, set" Usage="System.ServiceModel.MessageSecurityOverMsmq.AlgorithmSuite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.ServiceModel.Security.SecurityAlgorithmSuite), "Default")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.SecurityAlgorithmSuite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie la suite d’algorithmes utilisée pour les messages de sécurité au niveau du SOAP.</summary>
        <value>Paramètre <see cref="T:System.ServiceModel.Security.SecurityAlgorithmSuite" /> pour les messages envoyés sur la liaison <see cref="T:System.ServiceModel.NetMsmqBinding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Security.SecurityAlgorithmSuite> définit divers algorithmes, comme la canonicalisation, Digest, KeyWrap, la signature, le chiffrement et KeyDerivation. Cette propriété est particulièrement importante lorsque vous travaillez avec une plateforme qui utilise un ensemble d'algorithmes différent de l'ensemble par défaut. Vous devez connaître les forces et les faiblesses des algorithmes concernés lorsque vous modifiez cette propriété.  
  
   
  
## Examples  
 [!code-csharp[UEMessageSecurityOverMsmq#2](~/samples/snippets/csharp/VS_Snippets_CFX/uemessagesecurityovermsmq/cs/program.cs#2)]
 [!code-vb[UEMessageSecurityOverMsmq#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/uemessagesecurityovermsmq/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCredentialType">
      <MemberSignature Language="C#" Value="public System.ServiceModel.MessageCredentialType ClientCredentialType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.MessageCredentialType ClientCredentialType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageSecurityOverMsmq.ClientCredentialType" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCredentialType As MessageCredentialType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::MessageCredentialType ClientCredentialType { System::ServiceModel::MessageCredentialType get(); void set(System::ServiceModel::MessageCredentialType value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCredentialType : System.ServiceModel.MessageCredentialType with get, set" Usage="System.ServiceModel.MessageSecurityOverMsmq.ClientCredentialType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.MessageCredentialType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le paramètre de sécurité <see cref="T:System.ServiceModel.MessageCredentialType" /> pour les messages envoyés sur le transport MSMQ.</summary>
        <value>Paramètre de sécurité <see cref="T:System.ServiceModel.MessageCredentialType" /> pour les messages envoyés sur le transport MSMQ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut prendre les valeurs suivantes :  
  
-   **Aucun**: Cela permet au service d’interagir avec les clients anonymes. Ni le service ni le client n'exigent d'informations d'identification.  
  
-   **Windows**: Cela permet aux échanges SOAP d’être sous le contexte authentifié d’informations d’identification Windows. Exécute toujours une authentification basée sur Kerberos.  
  
-   **Nom d’utilisateur**: Cela permet au service d’exiger que le client soit authentifié à l’aide des informations d’identification de nom d’utilisateur. Ces informations d'identification doivent être spécifiées à l'aide de la classe <xref:System.ServiceModel.Description.ClientCredentials>.  
  
> [!NOTE]
>  WCF ne prend pas en charge l’envoi d’un mot de passe digest ou de dérivation de clés à l’aide du mot de passe et à l’aide de ces clés pour la sécurité de message. Par conséquent, WCF impose que l’échange est sécurisé lors de l’utilisation des informations d’identification UserName. Ce mode requiert que le certificat de service soit spécifié sur le client à l’aide de `ClientCredential` comportement et `serviceCertificate`:  
  
-   `Certificate` : autorise le service à exiger une authentification du client via un certificat. Dans ce cas, les informations d'identification du client doivent être spécifiées à l'aide de la classe <xref:System.ServiceModel.Description.ClientCredentials> ou du comportement `ClientCredentials`. Les informations d'identification du service dans ce cas doivent être spécifiées à l'aide de la classe <xref:System.ServiceModel.Description.ClientCredentials> ou du comportement `ClientCredentials` en spécifiant le `serviceCertificate`.  
  
-   `InfoCard` : permet au service d'exiger que le client soit authentifié à l'aide d'une InfoCard. Le `serviceCertificate` doit être configuré dans le comportement `ClientCredential`.  
  
-   Les informations d'identification du certificat pour le `MessageSecurityOverMsmq` sont pertinentes uniquement lorsque `Both` ou `Message` est affecté au mode de sécurité.  
  
   
  
## Examples  
 [!code-csharp[UEMessageSecurityOverMsmq#3](~/samples/snippets/csharp/VS_Snippets_CFX/uemessagesecurityovermsmq/cs/program.cs#3)]
 [!code-vb[UEMessageSecurityOverMsmq#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/uemessagesecurityovermsmq/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>