<Type Name="OperationContractAttribute" FullName="System.ServiceModel.OperationContractAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c56fba279f163da238b22c2ae40e554faded4b28" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39804841" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OperationContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OperationContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.OperationContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OperationContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class OperationContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type OperationContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indique qu’une méthode définit une opération qui fait partie d’un contrat de service dans une application Windows Communication Foundation (WCF).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appliquez l'<xref:System.ServiceModel.OperationContractAttribute> à une méthode pour indiquer que la méthode implémente une opération de service dans le cadre d'un contrat de service (spécifié par un attribut <xref:System.ServiceModel.ServiceContractAttribute> ).  
  
 Utilisez les propriétés <xref:System.ServiceModel.OperationContractAttribute> pour contrôler la structure de l'opération et les valeurs exprimées dans les métadonnées :  
  
-   La propriété <xref:System.ServiceModel.OperationContractAttribute.Action%2A> spécifie l'action qui identifie cette opération de façon unique. WCF distribue des messages de demande aux méthodes basées sur leur action.  
  
-   La propriété <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> indique que l'opération est implémentée ou peut être appelée de façon asynchrone à l'aide d'une paire de méthodes Begin/End.  
  
-   La propriété <xref:System.ServiceModel.OperationContractAttribute.HasProtectionLevel%2A> indique si la propriété <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> a été explicitement définie.  
  
-   La propriété <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> indique que l'opération se compose uniquement d'un message d'entrée. Aucun message de sortie n'est associé à l'opération.  
  
-   La propriété <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> spécifie si cette opération peut être l'opération initiale dans une session.  
  
-   Le <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> propriété spécifie si WCF essaie de mettre fin à la session active, une fois l’opération terminée.  
  
-   La propriété <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> spécifie la sécurité au niveau du message qu'une opération requiert au moment de l'exécution.  
  
-   La propriété <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> spécifie l'action du message de réponse pour l'opération.  
  
 L'attribut <xref:System.ServiceModel.OperationContractAttribute> déclare qu'une méthode est une opération dans un contrat de service. Seules les méthodes qui possèdent l'attribut <xref:System.ServiceModel.OperationContractAttribute> sont exposées comme opérations de service. Un contrat de service sans méthode marquée avec l'<xref:System.ServiceModel.OperationContractAttribute> n'expose aucune opération.  
  
 Le <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> propriété indique qu’une paire de `Begin` \< *Nom_méthode*> et `End` \< *Nom_méthode*> méthodes forment une seule opération implémentée de façon asynchrone (sur le client ou le service). La capacité d'un service à implémenter des opérations de façon asynchrone est un détail d'implémentation du service et n'est pas exposée dans les métadonnées (comme WSDL (Web Services Description Language)).  
  
 De même, les clients peuvent choisir d'appeler des opérations de façon asynchrone indépendantes de la façon dont la méthode de service est implémentée. Appeler des opérations de service de façon asynchrone dans le client est recommandé lorsqu'une méthode de service prend du temps mais qu'elle doit retourner directement des informations au client. Pour plus d'informations, consultez <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>.  
  
 La propriété <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> indique qu'une méthode ne retourne pas de valeur du tout, y compris un message de réponse sous-jacent vide. Ce type de méthode est utile pour les notifications ou la communication de style événement. Les méthodes de ce type ne peuvent pas retourner de message de réponse. La déclaration de la méthode doit donc retourner `void`.  
  
> [!IMPORTANT]
>  Lorsque vous récupérez par programmation la banque d’informations dans cet attribut, utilisez la <xref:System.ServiceModel.Description.ContractDescription> classe au lieu de la réflexion.  
  
> [!NOTE]
>  Si la propriété <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> a la valeur `false` (valeur par défaut), même les méthodes qui retournent `void` sont des méthodes bidirectionnelles au niveau de messages sous-jacents. Dans ce cas, l'infrastructure crée et envoie un message vide pour indiquer à l'appelant que la méthode a été retournée. Cette approche permet à l'application et à l'infrastructure de retourner des informations sur l'erreur (comme une erreur SOAP) au client. Affecter <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> à `true` est la seule méthode pour éviter la création et la distribution d'un message de réponse. Pour plus d’informations, consultez [unidirectionnel Services](~/docs/framework/wcf/feature-details/one-way-services.md).  
  
 Les propriétés <xref:System.ServiceModel.OperationContractAttribute.Action%2A> et <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> peuvent être utilisées non seulement pour modifier l'action par défaut des messages SOAP, mais également pour créer des gestionnaires pour les messages non reconnus ou désactiver les actions d'ajout pour la programmation de message directe. Utilisez la propriété <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> pour éviter que les clients appellent une opération de service particulière avant d'autres opérations. Utilisez le <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> propriété dispose à WCF de fermer le canal une fois que les clients appeler une opération de service particulier. Pour plus d’informations, consultez [à l’aide de Sessions](~/docs/framework/wcf/using-sessions.md).  
  
 La propriété <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> vous permet de spécifier sur le contrat d'opération si les messages d'opération sont signés, chiffrés ou signés et chiffrés. Si une liaison ne peut pas fournir le niveau de sécurité requis par le contrat, une exception est levée au moment de l’exécution. Pour plus d’informations, consultez <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> et [niveau de Protection de présentation](~/docs/framework/wcf/understanding-protection-level.md).  
  
   
  
## Examples  
 L'exemple de code suivant présente un contrat de service simple avec une opération.  
  
 [!code-csharp[OperationContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute/vb/services.vb#1)]  
  
 L'exemple suivant est un service qui implémente un contrat de service implicite qui spécifie trois opérations. Deux des opérations sont des opérations bidirectionnelles, qui retournent des messages de réponse sous-jacents à l'appelant, quelle que soit la valeur de retour. La troisième opération reçoit un appel, un message entrant sous-jacent, mais ne retourne aucun message de réponse sous-jacent.  
  
```csharp  
[ServiceContractAttribute]  
public class OneAndTwoWay  
{  
  // The client waits until a response message appears.  
  [OperationContractAttribute]  
  public int MethodOne (int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  // The client waits until an empty response message appears.  
  [OperationContractAttribute]  
  public void MethodTwo (int x)  
  {  
    return;  
  }  
  
  // The client returns as soon as an outbound message  
  // is dispatched to the service; no response  
  // message is generated or sent from the service.  
  [OperationContractAttribute(IsOneWay=true)]  
  public void MethodThree (int x)  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OperationContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.OperationContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OperationContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.OperationContractAttribute" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Action">
      <MemberSignature Language="C#" Value="public string Action { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Action" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.Action" />
      <MemberSignature Language="VB.NET" Value="Public Property Action As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Action { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Action : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.Action" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'action WS-Addressing du message de demande.</summary>
        <value>Action à utiliser pour générer l'en-tête de l'action WS-Addressing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.ServiceModel.OperationContractAttribute.Action%2A> message d’entrée de propriété pour contrôler l’action de la méthode. Étant donné que WCF utilise cette action pour distribuer un message entrant à la méthode appropriée, les messages utilisés dans une opération de contrat doivent avoir des actions uniques. La valeur d’action par défaut est une combinaison de l’espace de noms de contrat (la valeur par défaut est «http://tempuri.org/»), le nom de contrat (nom de l’interface ou le nom de classe, si aucune interface de service explicite n’est utilisée), le nom d’opération et une chaîne supplémentaire (« réponse ») si le message est une réponse corrélée. Vous pouvez substituer cette valeur par défaut avec la propriété <xref:System.ServiceModel.OperationContractAttribute.Action%2A>.  
  
 Pour indiquer qu'une opération de service gère tous les messages que le service reçoit mais ne peut pas être dirigée vers une opération de service, spécifiez la valeur « * » (astérisque). Ce type d'opération, appelé gestionnaire de messages non appariés, doit avoir l'une des signatures de méthode suivantes, sans quoi une <xref:System.InvalidOperationException> est levée :  
  
-   L'opération de service peut prendre uniquement un objet <xref:System.ServiceModel.Channels.Message> et retourner un objet <xref:System.ServiceModel.Channels.Message>.  
  
-   L'opération de service peut prendre uniquement un objet <xref:System.ServiceModel.Channels.Message> et ne rien retourner (autrement dit, retourner `void`).  
  
> [!NOTE]
>  Un contrat de service peut avoir une seule opération de service avec la valeur « * » affectée à la propriété <xref:System.ServiceModel.OperationContractAttribute.Action%2A>. Tout groupe de contrats de service hébergé sur le même listenUri qu’une classe de service implémente peut avoir de nombreuses opérations de service avec le <xref:System.ServiceModel.OperationContractAttribute.Action%2A> propriété définie sur «\*» lors de la <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> propriété est définie sur `false`. Toutefois, une seule de ces opérations de service peut avoir la <xref:System.ServiceModel.OperationContractAttribute.Action%2A> propriété définie sur «\*» et le <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> propriété définie sur true. Pour plus d'informations, consultez <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>.  
  
   
  
## Examples  
 L'exemple suivant est un service qui utilise les propriétés <xref:System.ServiceModel.OperationContractAttribute.Action%2A> et <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> pour contrôler explicitement les actions SOAP des messages d'entrée et de sortie (ou de réponse) et la propriété <xref:System.ServiceModel.OperationContractAttribute.Name%2A> pour contrôler le nom de l'opération dans les métadonnées. Enfin, l'application utilise également une valeur d'<xref:System.ServiceModel.OperationContractAttribute.Action%2A> de « * » pour indiquer une méthode qui gère les messages non reconnus.  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 Un service qui implémente ce contrat envoie des messages qui ressemblent à l'exemple suivant :  
  
 [!code-csharp[OperationContractAttribute_Properties#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncPattern">
      <MemberSignature Language="C#" Value="public bool AsyncPattern { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncPattern" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.AsyncPattern" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPattern As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AsyncPattern { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPattern : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.AsyncPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique qu’une opération est implémentée de façon asynchrone à l’aide d’une paire de méthodes <see langword="Begin" />&lt;*NomMéthode*&gt; et <see langword="End" />&lt;*NomMéthode*&gt; dans un contrat de service.</summary>
        <value>
          <see langword="true" /> Si le <see langword="Begin" /> &lt; *Nom_méthode*&gt;méthode est mis en correspondance par une <see langword="End" /> &lt; *Nom_méthode* &gt; (méthode) et peut être traitée par le infrastructure en tant qu’opération qui est implémentée comme une paire de méthodes asynchrones sur l’interface de service ; Sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> pour générer des opérations de service qui peuvent être appelées de façon asynchrone sur le serveur, le client ou les deux. La propriété <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> informe l'exécution qu'une méthode `Begin` a une méthode `End` correspondante qui se conforme au modèle de design de méthode asynchrone du .NET Framework. La génération de méthodes asynchrones de serveur qui implémentent une opération de service augmente l'évolutivité et les performances du serveur sans affecter les clients du service, et est recommandée lorsqu'une opération de service doit retourner quelque chose au client après avoir l'exécution d'une longue opération qui peut être exécutée de façon asynchrone.  
  
 Les clients restent non affectés car la paire de méthodes asynchrones sur le serveur est un détail d'implémentation qui n'affecte pas la description WSDL (Web Services Description Language) sous-jacente de l'opération. Ces méthodes apparaissent aux clients comme une seule opération avec `<input>` et corrélés `<output>` messages. WCF achemine automatiquement les messages entrants vers le `Begin` \< *Nom_méthode*> méthode et route les résultats de la `End` \< *Nom_méthode*> appeler dans le message sortant. Par conséquent, les canaux clients peuvent représenter la paire de méthodes en tant qu’opération synchrone unique ou comme une paire d’opérations asynchrones. Dans tous les cas, la représentation du client n'affecte en aucune façon l'implémentation asynchrone sur le serveur.  
  
 Les contrats de client peuvent utiliser la propriété <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> pour indiquer une paire de méthodes asynchrones que le client peut utiliser pour appeler l'opération de façon asynchrone. En règle générale, les applications clientes utilisent le [ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) outil et le `/async` option pour générer un `Begin` \< *Nom_méthode*> et `End` \< *Nom_méthode*> paire de méthodes que le client peut utiliser pour appeler l’opération de façon asynchrone.  
  
> [!NOTE]
>  Si une opération de service a à la fois une version asynchrone et une version synchrone, le comportement par défaut sur le service est d’appeler la version synchrone.  
  
   
  
## Examples  
 L'exemple de code suivant présente un canal client à un contrat de service qui inclut à la fois une version synchrone de `Add` et une version asynchrone. Si l'interface de contrat est utilisée sur le client, l'opération `BeginAdd` et l'opération `Add` appellent une méthode sur le serveur qui peut ou peut ne pas être synchrone. Si le contrat est utilisé pour implémenter le service, la valeur par défaut est que les requêtes entrantes sont distribuées à la méthode synchrone.  
  
```csharp  
[ServiceContract]  
public interface IAddTwoNumbers  
{  
    // If the asynchronous method pair  
    // appears on the client channel, the client can call   
    // them asynchronously to prevent blocking.  
    [OperationContract (AsyncPattern=true)]  
    IAsyncResult BeginAdd(int a, int b, AsyncCallback cb, AsyncState s);  
  
    [OperationContract]  
    int EndAdd(IAsyncResult r);  
  
    // This is a synchronous version of the BeginAdd/EndAdd pair.  
    // It appears in the client channel code by default.   
    [OperationContract]  
    int Add(int a, int b);  
   }  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.OperationContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les messages pour cette opération doivent être chiffrés, signés ou les deux.</summary>
        <value>
          <see langword="true" /> si la propriété <see cref="P:System.ServiceModel.OperationContractAttribute.ProtectionLevel" /> a une valeur autre que <see cref="F:System.Net.Security.ProtectionLevel.None" /> ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.OperationContractAttribute.HasProtectionLevel%2A> pour déterminer si un niveau de protection spécifique est requis par les messages de cette opération.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitiating">
      <MemberSignature Language="C#" Value="public bool IsInitiating { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitiating" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsInitiating" />
      <MemberSignature Language="VB.NET" Value="Public Property IsInitiating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitiating { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsInitiating : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsInitiating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la méthode implémente une opération qui peut initialiser une session sur le serveur (si une telle session existe).</summary>
        <value>
          <see langword="true" /> si l'opération est autorisée à initialiser une session sur le serveur ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> contrôle si une opération peut être la première appelée lors de la création d'une session.  
  
> [!NOTE]
>  La valeur de <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> doit être <xref:System.ServiceModel.SessionMode.Allowed> ou <xref:System.ServiceModel.SessionMode.Required> et la liaison utilisée doit requérir ou autoriser des sessions pour que la propriété <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> fonctionne correctement.  
  
 La valeur par défaut est `true`, ce qui signifie qu'une opération peut être la première appelée sur un canal. Excepté l'appel à la méthode, les appels suivants vers la méthode d'initialisation sont sans effet. Aucune autre session n'est créée. Si le contrat n'utilise pas de session, l'affectation de la valeur <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> `false` est ignorée.  
  
 En général, vous affectez <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> à `false` pour forcer les clients à appeler une autre méthode sur le service avant qu'ils ne puissent invoquer celle-ci. Par exemple, si votre service a une série d'opérations qui dépendent d'un numéro d'ID d'ordre, vous pouvez affectez à <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> la valeur `true` pour une opération de service `GetOrderId` et affecter à toutes les opérations de service restantes la valeur `false`. Cela garantit que chaque nouveau client obtient un ID d'ordre avant d'utiliser les autres méthodes exposées par le service.  
  
> [!NOTE]
>  Il existe une interaction entre <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> et la propriété <xref:System.ServiceModel.OperationContractAttribute.Action%2A>. Un contrat de service peut avoir une seule opération de service avec la valeur « * » affectée à la propriété <xref:System.ServiceModel.OperationContractAttribute.Action%2A>. Tout groupe de contrats de service hébergé sur le même URI d’écoute qu’une classe de service implémente peut avoir de nombreuses opérations de service avec le <xref:System.ServiceModel.OperationContractAttribute.Action%2A> propriété définie sur «\*» lors de la <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> propriété est définie sur `false`. Toutefois, une seule de ces méthodes de service peut avoir la <xref:System.ServiceModel.OperationContractAttribute.Action%2A> propriété définie sur «\*» et le <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> propriété définie sur `true`.  
  
 Si un service reçoit un message pour une opération qui n'est pas une opération d'initialisation, le service retourne une erreur SOAP ActionNotSupported. Le client rencontre ceci comme une <xref:System.ServiceModel.FaultException>. Si un client appelle d'abord une opération qui n'est pas une opération d'initialisation, l'exécution du client lève une <xref:System.InvalidOperationException?displayProperty=nameWithType>.  
  
 Pour plus d’informations, consultez [à l’aide de Sessions](~/docs/framework/wcf/using-sessions.md).  
  
   
  
## Examples  
 L'exemple suivant est un service qui implémente un contrat de service qui spécifie trois méthodes. Le service requiert une session. Si le premier appel d'un appelant est destiné à une opération autre que `MethodOne`, le canal est refusé et une exception est levée. Lorsqu'un appelant démarre une session en appelant `MethodOne`, cet appelant peut arrêter la session de communication à tout moment en appelant `MethodThree`. `MethodTwo` peut être appelé sans limite au cours d'une session.  
  
```csharp  
[ServiceContract(SessionMode=SessionMode.Required)]  
public class InitializeAndTerminateService  
{  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=true,  
    IsTerminating=false  
  )]  
  public void MethodOne()  
  {  
    return;  
  }  
  
  [OperationContract(  
    IsInitiating=false,  
    IsTerminating=false  
  )]  
  public int MethodTwo(int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=false,  
    IsTerminating=true  
  )]  
  public void MethodThree()  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public bool IsOneWay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOneWay" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsOneWay" />
      <MemberSignature Language="VB.NET" Value="Public Property IsOneWay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOneWay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsOneWay : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsOneWay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une opération retourne un message de réponse.</summary>
        <value>
          <see langword="true" /> si cette méthode reçoit un message de demande et ne retourne aucun message de réponse ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> pour indiquer qu'une opération ne retourne aucun message de réponse. Ce type d'opération est utile pour les notifications ou la communication de style d'événement, notamment dans la communication bidirectionnelle. Sans attendre de message de réponse sous-jacent, les appelants d'opérations unidirectionnelles n'ont aucun moyen direct de détecter une défaillance au cours du traitement du message de demande. (Les applications de service qui utilisent des canaux fiables et des opérations unidirectionnelles peuvent détecter un échec de remise de message au niveau du canal. Pour plus d’informations, consultez [vue d’ensemble des Sessions fiables](~/docs/framework/wcf/feature-details/reliable-sessions-overview.md).)  
  
 Dans les applications de services en duplex (ou bidirectionnels) dans lesquelles le client et le serveur communiquent indépendamment l'un avec l'autre, un canal client peut utiliser la propriété <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> sur ses méthodes pour indiquer que le service peut effectuer des appels unidirectionnels au client que le client peut traiter en tant qu'événements. Aucun appel de retour ou message n'est généré étant donné que le service n'attend pas de message de réponse.  
  
 Si la propriété <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> a la valeur `false` (valeur par défaut), même les méthodes qui retournent `void` génèrent un message de réponse. Dans ce cas, l'infrastructure crée et envoie un message vide pour indiquer à l'appelant que la méthode a été retournée. (L'utilisation de cette approche permet à l'infrastructure de retourner des erreurs SOAP au client.) L'affectation de <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> à `true` est la seule façon d'annuler la création et la distribution d'un message de réponse.  
  
 Les méthodes unidirectionnelles ne doivent pas retourner de valeur ou avoir de paramètres `ref` ou `out` ; sinon, une exception <xref:System.InvalidOperationException?displayProperty=nameWithType> est levée.  
  
 Spécifier qu'une opération est une opération unidirectionnelle signifie uniquement qu'il n'y a pas de message de réponse. Il est possible de bloquer si une connexion ne peut pas être établie, ou si le message sortant est très grand, ou si le service ne peut pas lire les informations entrantes assez rapidement. Si un client a besoin d'un appel non bloquant, générez des opérations <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>. Pour plus d’informations, consultez [unidirectionnel Services](~/docs/framework/wcf/feature-details/one-way-services.md) et [Services d’accès à l’aide d’un Client WCF](~/docs/framework/wcf/feature-details/accessing-services-using-a-client.md).  
  
   
  
## Examples  
 L'exemple suivant est un service qui implémente un contrat de service qui spécifie trois opérations. Deux des méthodes implémentent des opérations bidirectionnelles, qui retournent des messages de réponse sous-jacents à l'appelant, quelle que soit la valeur de retour. La troisième méthode implémente une opération qui reçoit un appel (un message entrant sous-jacent) mais ne retourne aucun message de réponse sous-jacent.  
  
```csharp  
[ServiceContract]  
public class OneAndTwoWay  
{  
  // The client waits until a response message appears.  
  [OperationContract]  
  public int MethodOne (int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  // The client waits until an empty response message appears.  
  [OperationContract]  
  public void MethodTwo (int x)  
  {  
    return;  
  }  
  
  // The client returns as soon as an outbound message  
  // is queued for dispatch to the service; no response  
  // message is generated or sent.  
  [OperationContract(IsOneWay=true)]  
  public void MethodThree (int x)  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTerminating">
      <MemberSignature Language="C#" Value="public bool IsTerminating { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminating" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsTerminating" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTerminating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTerminating { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTerminating : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsTerminating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l'opération de service conduit le serveur à fermer la session après l'envoi du message de réponse (le cas échéant).</summary>
        <value>
          <see langword="true" /> si l'opération conduit le serveur à fermer la session ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> pour indiquer que l'appel d'une opération de service termine la session de communication.  
  
 Dans une application cliente, une valeur de <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> la valeur `true` indique à WCF de fermer le canal une fois que la réponse est arrivée.  
  
 Dans un service, un minuteur est défini et le canal abandonne si le client ne ferme pas le canal avant la fin du délai.  
  
 Pour plus d’informations sur l’utilisation de cette propriété dans des sessions, consultez [à l’aide de Sessions](~/docs/framework/wcf/using-sessions.md).  
  
> [!NOTE]
>  Si un appelant écoute l'événement <xref:System.ServiceModel.OperationContext.OperationCompleted?displayProperty=nameWithType> pour une opération <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A?displayProperty=nameWithType>, il est possible de bloquer lors de la réception de la réponse. Pour gérer correctement cela, il convient de planifier des travaux sur un autre thread lorsque <xref:System.ServiceModel.OperationContext.OperationCompleted> est déclenché, puis de retourner immédiatement à partir de ce gestionnaire d'événements.  
  
   
  
## Examples  
 L'exemple suivant est un service qui implémente un contrat de service qui spécifie trois opérations. Le service requiert une connexion avec état. Si le premier appel d'un appelant est destiné à une opération autre que `MethodOne`, le canal est refusé et une exception est levée. Lorsqu'un appelant démarre une session en appelant `MethodOne`, cet appelant peut arrêter la session de communication à tout moment en appelant `MethodThree`. `MethodTwo` peut être appelé sans limite au cours d'une session.  
  
```csharp  
[ServiceContractAttribute(SessionMode=SessionMode.Required)]  
public class InitializeAndTerminateService  
{  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=true,  
    IsTerminating=false  
  )]  
  public void MethodOne()  
  {  
    return;  
  }  
  
  [OperationContract(  
    IsInitiating=false,  
    IsTerminating=false  
  )]  
  public int MethodTwo(int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=false  
    IsTerminating=true  
  )]  
  public void MethodThree()  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de l'opération.</summary>
        <value>Nom de l'opération.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.ServiceModel.OperationContractAttribute.Name%2A> propriété à substituer le <`operation`> nom de l’élément dans WSDL. Le nom d'opération par défaut est celui de la méthode d'implémentation.  
  
   
  
## Examples  
 L'exemple de code suivant utilise la propriété <xref:System.ServiceModel.OperationContractAttribute.Name%2A> pour déclarer le nom de l'opération comme exposée dans les métadonnées.  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.ServiceModel.OperationContractAttribute.Name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur est une chaîne vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.OperationContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie si les messages d'une opération doivent être chiffrés, signés ou les deux.</summary>
        <value>Une des valeurs de <see cref="T:System.Net.Security.ProtectionLevel" />. La valeur par défaut est <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> pour contrôler si les messages d'une opération doivent être chiffrés, signés ou les deux. La valeur définie ici est la valeur par défaut pour tous les messages spécifiés pour cette opération, sauf si une portée plus restreinte se substitue à cette valeur.  
  
 Il est important de se rappeler que le comportement de protection au moment de l'exécution est la combinaison des valeurs de niveau de protection affectées aux propriétés suivantes. Ces propriétés ont une structure hiérarchique. La définition de la valeur la plus à l'extérieur établit le paramètre par défaut pour toutes les portées plus restreintes, sauf si une valeur différente est définie explicitement pour une portée plus restreinte. Dans ce cas, la valeur externe reste la valeur par défaut pour toutes les portées plus restreintes à l'exception de celles qui sont spécifiquement définies.  
  
 Par exemple, si <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> a la valeur <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> et qu'aucune autre portée plus étroite n'a de paramètres de niveau de protection, tous les messages dans un contrat d'opération sont chiffrés et signés, y compris les messages d'erreur. Toutefois, si vous affectez au jeu <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> de l'une de ces opérations, la valeur <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, les messages pour cette opération sont signés mais tous les autres messages dans le contrat sont chiffrés et signés.  
  
 Pour plus d’informations sur les niveaux de protection et leurs hypothèses et les étendues, consultez [niveau de Protection de présentation](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Les portées auxquelles ces valeurs sont affectées sont les suivantes :  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 Propriété <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> sur <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.  
  
 Propriété <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> sur <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.  
  
 Lorsque aucun niveau de protection n'est spécifié explicitement sur le contrat et que la liaison sous-jacente prend en charge la sécurité (au niveau du transport ou du message), le niveau de protection effectif pour l'ensemble du contrat est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Si la liaison ne prend pas en charge la sécurité (comme <xref:System.ServiceModel.BasicHttpBinding>), le <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> effectif est <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> pour l'ensemble du contrat. Le résultat est que selon la liaison du point de terminaison, les clients peuvent avoir besoin d'une protection de sécurité au niveau du message ou du transport différente même lorsque le contrat spécifie <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur ne fait pas partie des valeurs <see cref="T:System.Net.Security.ProtectionLevel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReplyAction">
      <MemberSignature Language="C#" Value="public string ReplyAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ReplyAction" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.ReplyAction" />
      <MemberSignature Language="VB.NET" Value="Public Property ReplyAction As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ReplyAction { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReplyAction : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.ReplyAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l'action SOAP pour le message de réponse de l'opération.</summary>
        <value>Valeur de l'action SOAP pour le message de réponse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En plus de spécifier une valeur particulière pour l'en-tête d'action du message de réponse, vous pouvez également spécifier la chaîne « * » (astérisque). Spécification d’un astérisque dans le service indique à WCF ne pas d’ajouter une action de réponse au message, ce qui est utile si vous programmez directement par rapport aux messages. Spécification d’un astérisque dans une application cliente indique à WCF non ne pas pour valider l’action de réponse.  
  
   
  
## Examples  
 L'exemple suivant est un service qui utilise les propriétés <xref:System.ServiceModel.OperationContractAttribute.Action%2A> et <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> pour contrôler explicitement les actions SOAP des messages d'entrée et de sortie (ou de réponse). Il utilise également la propriété <xref:System.ServiceModel.OperationContractAttribute.Name%2A> pour déclarer le nom de l'opération comme exposé dans les métadonnées.  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.ServiceModel.OperationContractAttribute.ReplyAction" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>