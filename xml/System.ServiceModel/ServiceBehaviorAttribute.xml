<Type Name="ServiceBehaviorAttribute" FullName="System.ServiceModel.ServiceBehaviorAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="50331392363256e74f896d27155738cc69fd5c32" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53294796" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceBehaviorAttribute : Attribute, System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceBehaviorAttribute extends System.Attribute implements class System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceBehaviorAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceBehaviorAttribute&#xA;Inherits Attribute&#xA;Implements IServiceBehavior" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBehaviorAttribute sealed : Attribute, System::ServiceModel::Description::IServiceBehavior" />
  <TypeSignature Language="F#" Value="type ServiceBehaviorAttribute = class&#xA;    inherit Attribute&#xA;    interface IServiceBehavior" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IServiceBehavior</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Spécifie le comportement d'exécution interne d'une implémentation de contrat de service.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appliquez l'attribut <xref:System.ServiceModel.ServiceBehaviorAttribute> à une implémentation de service afin de spécifier le comportement d'exécution à l'échelle du service. (Pour spécifier le comportement d'exécution au niveau de la méthode, utilisez l'attribut <xref:System.ServiceModel.OperationBehaviorAttribute>.) Cet attribut peut uniquement être appliqué à des implémentations de service. Pour obtenir des exemples fonctionnels, consultez le [Service : Exemples de comportements](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)).  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute> les propriétés sont la fonctionnalité modèle de programmation Windows Communication Foundation (WCF) qui active des fonctions courantes que les développeurs devraient sinon doivent implémenter. Pour plus d’informations sur ces formats et autres comportements, consultez [spécifiant le comportement de runtime du Service](~/docs/framework/wcf/specifying-service-run-time-behavior.md). Pour plus d’informations sur les propriétés d’exécution sous-jacent que j’avais du jeu de propriétés suivant, consultez [Extending ServiceHost and the Service Model Layer](~/docs/framework/wcf/extending/extending-servicehost-and-the-service-model-layer.md).  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> spécifie le type de filtre utilisé par le système de répartiteur pour localiser le point de terminaison qui gère des demandes.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> ferme automatiquement la session lorsque le canal est fermé et que le service a fini de traiter les messages restants.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> contrôle le modèle de thread interne et permet ainsi la prise en charge des services réentrants ou multithread.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> est utilisée pour déclarer un nom en vue de son utilisation dans l'attribut `name` de l'élément `<service>` dans un fichier de configuration.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> permet au temps d'exécution d'ignorer les informations de sérialisation supplémentaires qui ne sont pas requises pour le traitement du message.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> détermine si les exceptions non gérées dans un service sont retournées en tant qu'erreurs SOAP. Elle est utilisée à des fins de débogage uniquement.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> spécifie si et quand les services et leurs objets du service sont recyclés pendant un échange avec un client.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> limite le nombre d'éléments sérialisés dans un graphique d'objets.  
  
-   Les propriétés <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> et <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> contrôlent le nom et l'espace de noms de l'expression WSDL de l'élément de service.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> spécifie si l’objet de service est recyclé au terme de l’exécution d’une transaction.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> spécifie si les transactions en attente sont exécutées lorsque la session se ferme.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> spécifie le niveau d'isolation de la transaction que le contrat prend en charge.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> spécifie le délai au cours duquel une transaction doit être exécutée, faute de quoi elle sera abandonnée.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> spécifie si les appels de méthode entrants doivent être automatiquement synchronisés avec le thread d'interface utilisateur.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> informe le système s'il doit confirmer que les en-têtes SOAP marqués comme `MustUnderstand` ont effectivement été compris.  
  
 La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> peut également être définie à l'aide d'un fichier de configuration de l'application. Pour plus d'informations, consultez <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A>.  
  
   
  
## Examples  
 L'exemple de code suivant illustre les propriétés <xref:System.ServiceModel.ServiceBehaviorAttribute>. La classe `BehaviorService` utilise l'attribut <xref:System.ServiceModel.ServiceBehaviorAttribute> pour indiquer que :  
  
-   L'objet du service est recyclé au terme de la transaction.  
  
-   Il existe un objet du service pour chaque session.  
  
-   Le service est monothread et ne prend pas en charge les appels réentrants.  
  
 En outre, au niveau de l’opération, les valeurs <xref:System.ServiceModel.OperationBehaviorAttribute> indiquent que la méthode `TxWork` s’inscrit automatiquement dans les transactions passées ou crée une transaction pour faire le travail, et que la transaction est validée automatiquement si aucune exception non gérée ne se produit.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 La liaison sous-jacente doit prendre en charge les transactions passées pour l’exemple de code suivant pour s’exécuter correctement. Pour prendre en charge les transactions passées à l’aide de <xref:System.ServiceModel.WSHttpBinding>, par exemple, affectez la valeur <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> à la propriété `true` dans le code ou dans un fichier de configuration de l’application. L'exemple de code suivant montre le fichier de configuration pour l'exemple précédent :  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationBehaviorAttribute" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)">Service : Exemples de comportements</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBehaviorAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBehaviorAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.ServiceBehaviorAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les valeurs par défaut pour la propriété <xref:System.ServiceModel.ServiceBehaviorAttribute> sont :  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> a la valeur <xref:System.ServiceModel.AddressFilterMode.Exact>.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> est `true`.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> a la valeur <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> est le nom qualifié de l'espace de noms du type sans les informations d'assemblage.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> est `false`.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> a la valeur 64 Ko.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> est le nom du type de service, sans espace de noms ni information d'assemblage.  
  
-   Le <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> propriété est «http://tempuri.org».  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> est `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> est `false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> est `true`.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> est `false`.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> est <xref:System.Transactions.IsolationLevel.Unspecified>.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> a pour valeur <xref:System.TimeSpan.Zero>.  
  
-   La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> est `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressFilterMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AddressFilterMode AddressFilterMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AddressFilterMode AddressFilterMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AddressFilterMode As AddressFilterMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AddressFilterMode AddressFilterMode { System::ServiceModel::AddressFilterMode get(); void set(System::ServiceModel::AddressFilterMode value); };" />
      <MemberSignature Language="F#" Value="member this.AddressFilterMode : System.ServiceModel.AddressFilterMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AddressFilterMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la propriété <see cref="T:System.ServiceModel.AddressFilterMode" /> utilisée par le répartiteur afin de router les messages entrants vers le point de terminaison correct.</summary>
        <value>Objet <see cref="T:System.ServiceModel.AddressFilterMode" /> utilisé par le répartiteur pour router les messages entrants vers le point de terminaison correct.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur ne fait pas partie des valeurs de <see cref="T:System.ServiceModel.AddressFilterMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutomaticSessionShutdown">
      <MemberSignature Language="C#" Value="public bool AutomaticSessionShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticSessionShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticSessionShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutomaticSessionShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticSessionShutdown : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie si une session doit être fermée automatiquement lorsqu'un client ferme une session de sortie.</summary>
        <value><see langword="true" /> si les services ferment automatiquement une session lorsque le client clôture une session de sortie ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, lorsqu'un client ferme une session de sortie et que le service a terminé le traitement des messages restants, le serveur ferme la session. L'affectation de la valeur <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> à `false` empêche le serveur de fermer automatiquement la session et active le contrôle personnalisé des durées de vie de session.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcurrencyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ConcurrencyMode ConcurrencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ConcurrencyMode ConcurrencyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ConcurrencyMode As ConcurrencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ConcurrencyMode ConcurrencyMode { System::ServiceModel::ConcurrencyMode get(); void set(System::ServiceModel::ConcurrencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.ConcurrencyMode : System.ServiceModel.ConcurrencyMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit si un service prend en charge un thread, plusieurs threads ou des appels réentrants.</summary>
        <value>L'une des valeurs <see cref="T:System.ServiceModel.ConcurrencyMode" /> ; la valeur par défaut est <see cref="F:System.ServiceModel.ConcurrencyMode.Single" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété indique si une instance d'un service peut gérer un ou plusieurs threads exécutés simultanément et si, en cas d'utilisation monothread, la réentrance est prise en charge.  
  
> [!NOTE]
>  La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> interagit avec plusieurs autres paramètres. Par exemple, si <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> a la valeur <xref:System.ServiceModel.InstanceContextMode.Single>, votre service ne peut traiter qu'un message à la fois, excepté si vous affectez la valeur <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> à <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Cette propriété produit également un comportement en association avec la propriété <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType>. Pour plus d’informations, consultez [Sessions, Instancing et la concurrence](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Le fait d'affecter à <xref:System.ServiceModel.ConcurrencyMode> la valeur <xref:System.ServiceModel.ConcurrencyMode.Single> permet de demander au système de restreindre les instances du service à un thread d'exécution à la fois, ce qui vous évite d'avoir à gérer des problèmes de thread. La valeur <xref:System.ServiceModel.ConcurrencyMode.Multiple> signifie que plusieurs threads à la fois peuvent exécuter les objets de service. Dans ce cas, vous devez garantir la sécurité des threads.  
  
 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> restreint également l’accès à un seul thread à la fois. lors du traitement de l’opération, aucun autre message ne pouvez entrer l’opération. Si, pendant l'opération, un appel à un autre service est envoyé, le message actuel désactive le verrouillage de l'opération, qui est alors libre de traiter d'autres messages. Lorsque l'appel de service revient, le verrouillage est rétabli et le message d'origine peut continuer à traiter jusqu'à son terme ou jusqu'à ce qu'un autre appel soit lancé par l'opération.  
  
> [!IMPORTANT]
>  Même si <xref:System.ServiceModel.ConcurrencyMode.Single> limite les instances du service à un thread d’exécution à la fois, vous devez également définir <xref:System.ServiceModel.Description.ServiceThrottlingBehavior.MaxConcurrentCalls%2A> sur 1 afin de ne garantir aucun message de désordre.  
>   
>  En outre, il vous incombe de laisser votre état de l’objet cohérente avant les appels sortants et vous devez confirmer que les données locales de l’opération sont valides après des appels sortants. Notez que l’instance de service est déverrouillée uniquement en appelant un autre service sur un canal WCF. Dans ce cas, le service appelé peut réentrer le premier service via un rappel. Si le premier service n'est pas réentrant, la séquence des appels provoque un interblocage. Pour plus d'informations, consultez <xref:System.ServiceModel.ConcurrencyMode>.  
  
 Lors de tout appel sortant à partir d'une opération de traitement, il est possible de modifier les données non locales de l'opération. (La validité des données d'état locales est ainsi garantie lorsque le traitement du message d'origine reprend.) Par conséquent, avant votre appel sortant, vous devez vérifier que les données non locales sont valides pour d'autres appels entrants et revalider les données non locales après que l'appel sortant a été retourné.  
  
 Le pseudo-code suivant illustre le modèle requis pour la prise en charge des appels réentrants.  
  
```csharp  
public void MyMethod()  
{  
  this.SomeNonLocalDataState;  
  // Here you need to clean nonlocal state for other users  
  OutboundProxy proxy = new OutboundProxy();  
  int returnValue = proxy.CallOutOfOperation();  
  // Ensure that this.SomeNonLocalDataState is valid for continued use.  
  this.ModifyNonLocalState;  
  return returnValue;  
}  
  
```  
  
 L’utilisation du modèle d’appel asynchrone Begin/End pour un appel sortant lorsque le <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> a la valeur <xref:System.ServiceModel.ConcurrencyMode.Reentrant> déclenche une exception. Les appels sortants asynchrones requièrent une opération dans laquelle le <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> a la valeur <xref:System.ServiceModel.ConcurrencyMode.Multiple>, auquel cas vous devez gérer les problèmes de synchronisation.  
  
 En règle générale, si un message est reçu pour une instance qui enfreint son mode d'accès concurrentiel, le message patiente jusqu'à ce que l'instance soit disponible ou expire.  
  
 Qui plus est, si <xref:System.ServiceModel.ConcurrencyMode> a la valeur <xref:System.ServiceModel.ConcurrencyMode.Single> et qu'un appel réentrant est bloqué jusqu'à ce que l'instance soit libérée, le système détecte l'interblocage et lève une exception.  
  
> [!NOTE]
>  Une <xref:System.InvalidOperationException> est levée au moment de l'exécution si <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> a la valeur `true` lorsque la propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> a la valeur <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 Notez que vous devez affecter explicitement la valeur <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> à `false` s'il existe une opération avec <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> dont la valeur est true et que vous affectez la valeur <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> à <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. Sinon, une exception de validation est levée car la valeur par défaut de <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> est `true`.  
  
 Il existe une interaction des <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> et d'autres propriétés qui peut altérer le comportement au moment de l'exécution. Pour obtenir une description complète de ces interactions, consultez [Sessions, Instancing et la concurrence](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
   
  
## Examples  
 L'exemple de code suivant illustre la différence entre l'utilisation de <xref:System.ServiceModel.ConcurrencyMode.Single>, <xref:System.ServiceModel.ConcurrencyMode.Reentrant> et <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Cet exemple ne se compile pas sans une vraie implémentation, mais ne montre pas le genre de threading garanties par Windows Communication Foundation (WCF) et ce que cela signifie pour votre code d’opération.  
  
 [!code-csharp[C_BestPractices-Concurrency#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_bestpractices-concurrency/cs/reentrantandmultiple.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur ne fait pas partie des valeurs de <see cref="T:System.ServiceModel.ConcurrencyMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur utilisée pour localiser l'élément de service dans un fichier de configuration de l'application.</summary>
        <value>Valeur à localiser dans le fichier de configuration. La valeur par défaut est le nom de type qualifié complet sans aucune information d'assemblage.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette valeur pour spécifier un service particulier dans le fichier de configuration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur est Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur est une chaîne vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la distribution classée par service est garantie.</summary>
        <value><see langword="true" /> si la distribution classée par service est garantie ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public object GetWellKnownSingleton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetWellKnownSingleton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.GetWellKnownSingleton" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWellKnownSingleton () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetWellKnownSingleton();" />
      <MemberSignature Language="F#" Value="member this.GetWellKnownSingleton : unit -&gt; obj" Usage="serviceBehaviorAttribute.GetWellKnownSingleton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère un objet qui implémente le service et qui est utilisé comme instance singleton du service, ou <see langword="null" /> s'il n'existe aucune instance de singleton.</summary>
        <returns>Implémentation du service. La valeur par défaut est <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une valeur non `null` renseigne l'instance de service à laquelle tous les messages adressés au service seront distribués.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si des données de sérialisation inconnues doivent être envoyées sur le réseau.</summary>
        <value><see langword="true" /> si les données de sérialisation inconnues ne sont jamais envoyées ; sinon <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un type implémente le <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, il stocke toutes il ne connaît pas les données supplémentaires transmises sur le réseau lors de la désérialisation en ce type. Par exemple, si un type `Person` contient des membres `FirstName` et `LastName` et un élément appelé `PhoneNumber` apparaît, il est stocké. Lors de la sérialisation ultérieure du type, `PhoneNumber` est mis à nouveau. Le problème est que le schéma pour `Person` exporté par ce service comporte uniquement `FirstName` et `LastName`, de sorte que Windows Communication Foundation (WCF) génère une instance de schéma non valide ! Si la stricte conformité du schéma est primordiale, vous pouvez définir <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> sur `true` pour désactiver ce comportement d'émission réitérée.  
  
 Quel que soit <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> définissant, WCF toujours traite les données connues (entrantes et sortantes) et ne lève pas d’exceptions lorsque des données supplémentaires lui parviennent. Vous pouvez également définir cette propriété à l’aide de la [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) élément dans un fichier de configuration d’application.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> et une implémentation de <xref:System.Runtime.Serialization.IExtensibleDataObject>. Dans cet exemple, comme <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> a la valeur `false`, les données supplémentaires connues par le client font l'objet d'un aller-retour vers le client.  
  
 [!code-csharp[DCAContainerNoValidation#1](~/samples/snippets/csharp/VS_Snippets_CFX/dcacontainernovalidation/cs/services.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique que les exceptions d'exécution générales non prises en charge doivent être converties en <see cref="T:System.ServiceModel.FaultException`1" /> de type <see cref="T:System.ServiceModel.ExceptionDetail" /> et envoyées en tant que message d'erreur. Affectez la valeur <see langword="true" /> uniquement lors du développement afin de dépanner un service.</summary>
        <value><see langword="true" /> si les exceptions non gérées doivent être retournées en tant qu'erreurs SOAP ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Affectez la valeur <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> à `true` pour permettre aux informations sur les exceptions d'être transmises aux clients à des fins de débogage. Cette propriété requiert une liaison qui prend en charge la messagerie en mode demande-réponse ou duplex.  
  
 Dans toutes les applications managées, les erreurs de traitement sont représentées par des objets <xref:System.Exception>. Dans les applications basées sur SOAP telles que les applications WCF, les méthodes qui implémentent les opérations de service communiquent des informations d’erreur à l’aide de messages d’erreur SOAP. Étant donné que les applications WCF s’exécutent sous les deux types de systèmes d’erreur, les informations d’exception gérées qui doivent être envoyé au client doivent être converties à partir d’exceptions en fautes SOAP. Pour plus d’informations, consultez [spécification et gestion des erreurs dans les contrats et Services](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).  
  
 Durant le développement, vous pouvez souhaiter que votre service renvoie également d'autres exceptions au client afin de vous aider lors du débogage. Cette fonctionnalité est réservée au développement et ne doit être pas employée dans le cadre de services déployés.  
  
 Pour faciliter le développement de débogage, affectez la <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> à `true` soit dans le code ou à l’aide d’un fichier de configuration d’application.  
  
 En cas d'activation, le service retourne automatiquement des informations plus sûres sur les exceptions à l'appelant. Ces erreurs apparaissent au client sous la forme d'objets <xref:System.ServiceModel.FaultException%601> de type <xref:System.ServiceModel.ExceptionDetail>.  
  
> [!IMPORTANT]
>  Paramètre <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> à `true` exceptions des méthodes de service permet aux clients d’obtenir des informations sur interne ; elle est uniquement recommandée comme une façon de déboguer temporairement une application de service. De plus, le WSDL pour une méthode qui retourne des exceptions managées non prises en charge de cette façon ne contient pas le contrat pour le <xref:System.ServiceModel.FaultException%601> de type <xref:System.ServiceModel.ExceptionDetail>. Les clients doivent attendre une erreur SOAP inconnue pour obtenir correctement les informations de débogage.  
  
 Si cette propriété `true` peut également être effectuée à l’aide d’un fichier de configuration d’application et le [ &lt;serviceDebug&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicedebug.md) élément, comme l’exemple de code suivant.  
  
 [!code-xml[OperationBehaviorAttribute1#10](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#10)]   
   
  
## Examples  
 L'exemple de code suivant illustre les propriétés <xref:System.ServiceModel.ServiceBehaviorAttribute>. La classe `BehaviorService` utilise l'attribut <xref:System.ServiceModel.ServiceBehaviorAttribute> pour indiquer que :  
  
-   Les méthodes d'implémentation sont appelées sur le thread d'interface utilisateur.  
  
-   Il existe un objet du service pour chaque session.  
  
-   Le service est monothread et ne prend pas en charge les appels réentrants.  
  
 En outre, au niveau de l’opération, les valeurs <xref:System.ServiceModel.OperationBehaviorAttribute> indiquent que la méthode `TxWork` s’inscrit automatiquement dans les transactions passées ou crée une transaction pour faire le travail, et que la transaction est validée automatiquement si aucune exception non gérée ne se produit.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 La liaison sous-jacente doit prendre en charge les transactions passées pour l’exemple de code suivant pour s’exécuter correctement. Pour prendre en charge les transactions passées à l’aide de <xref:System.ServiceModel.WSHttpBinding>, par exemple, affectez la valeur <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> à la propriété `true` dans le code ou dans un fichier de configuration de l’application. L'exemple de code suivant montre le fichier de configuration pour l'exemple précédent :  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContextMode InstanceContextMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.InstanceContextMode InstanceContextMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceContextMode As InstanceContextMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContextMode InstanceContextMode { System::ServiceModel::InstanceContextMode get(); void set(System::ServiceModel::InstanceContextMode value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextMode : System.ServiceModel.InstanceContextMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContextMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur qui indique à quel moment de nouveaux objets de service sont créés.</summary>
        <value>Une des valeurs de <see cref="T:System.ServiceModel.InstanceContextMode" /> ; la valeur par défaut est <see cref="F:System.ServiceModel.InstanceContextMode.PerSession" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.InstanceContextMode> pour spécifier à quel moment de nouveaux objets de service sont créés. Comme l'objet de service n'est pas directement connecté au canal de communication, la durée de vie des objets de service est indépendante de la durée de vie du canal entre un client et l'application de service. La valeur par défaut, <xref:System.ServiceModel.InstanceContextMode.PerSession>, demande à l'application de service de créer un objet du service lorsqu'une nouvelle session de communication est ouverte entre un client et l'application de service. Les appels ultérieurs au cours de cette session sont gérés par le même objet.  
  
 <xref:System.ServiceModel.InstanceContextMode.PerSession> indique que chaque objet de service gère les demandes d'un seul canal client.  
  
> [!NOTE]
>  La propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> interagit avec plusieurs autres paramètres. Par exemple, si <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> a la valeur <xref:System.ServiceModel.InstanceContextMode.Single>, votre service ne peut traiter qu'un message à la fois, excepté si vous affectez la valeur <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> à <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Cette propriété produit également un comportement en association avec la propriété <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType>. Pour plus d’informations, consultez [Sessions, Instancing et la concurrence](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Dans le cas du comportement de durée de vie singleton (par exemple, si l'application hôte appelle le constructeur <xref:System.ServiceModel.ServiceHost.%23ctor%2A> et passe un objet à utiliser en tant que service), la classe de service doit affecter la valeur <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> à `Single`. Sinon, une exception sera levée au moment de l'exécution.  
  
   
  
## Examples  
 L'exemple de code suivant illustre les propriétés <xref:System.ServiceModel.ServiceBehaviorAttribute>. La classe `BehaviorService` utilise l'attribut <xref:System.ServiceModel.ServiceBehaviorAttribute> pour indiquer que :  
  
-   Les méthodes d'implémentation sont appelées sur le thread d'interface utilisateur.  
  
-   Il existe un objet du service pour chaque session.  
  
-   Le service est monothread et ne prend pas en charge les appels réentrants.  
  
 En outre, au niveau de l’opération, les valeurs <xref:System.ServiceModel.OperationBehaviorAttribute> indiquent que la méthode `TxWork` s’inscrit automatiquement dans les transactions passées ou crée une transaction pour faire le travail, et que la transaction est validée automatiquement si aucune exception non gérée ne se produit.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 La liaison sous-jacente doit prendre en charge les transactions passées pour l’exemple de code suivant pour s’exécuter correctement. Pour prendre en charge les transactions passées à l’aide de <xref:System.ServiceModel.WSHttpBinding>, par exemple, affectez la valeur <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> à la propriété `true` dans le code ou dans un fichier de configuration de l’application. L'exemple de code suivant montre le fichier de configuration pour l'exemple précédent :  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur ne fait pas partie des valeurs de <see cref="T:System.ServiceModel.InstanceContextMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre maximal d'éléments autorisés dans un objet sérialisé.</summary>
        <value>Nombre maximal d'éléments autorisés dans un objet. La valeur par défaut est 65 536 octets (64 Ko).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> pour définir le nombre d'éléments sérialisés maximum dans un graphique d'objets. Vous pouvez également définir cette propriété à l’aide de la [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) élément dans un fichier de configuration d’application.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l'attribut du nom correspondant à l'élément de service dans l'outil relatif au langage descriptif de services Web (WSDL, Web Services Description Language).</summary>
        <value>Valeur de l'attribut de nom dans l'élément <see langword="&lt;wsdl:service&gt;" /> au moment de l'exportation.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l'espace de noms cible correspondant au service dans WSDL (Web Services Description Language).</summary>
        <value>Valeur de l'attribut <see langword="targetNamespace" /> pour l'élément <see langword="&lt;wsdl:definitions&gt;" /> qui contient l'élément <see langword="&lt;wsdl:service&gt;" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ReleaseServiceInstanceOnTransactionComplete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Property ReleaseServiceInstanceOnTransactionComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReleaseServiceInstanceOnTransactionComplete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReleaseServiceInstanceOnTransactionComplete : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie si l'objet du service est libéré au terme de la transaction actuelle.</summary>
        <value><see langword="true" /> si l'objet de service doit être libéré ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que vous devez affecter explicitement la valeur <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> à `false` s'il existe une opération avec <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> dont la valeur est true et que vous affectez la valeur <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> à <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. Sinon, une exception de validation est levée car la valeur par défaut de <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> est `true`.  
  
 De plus, il est important de garder à l'esprit que si le service est créé en passant un objet de service au constructeur <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType>, la valeur de cette propriété est traitée comme si elle était `false`.  
  
   
  
## Examples  
 L’exemple de code suivant affecte au niveau d’isolation des transactions la valeur <xref:System.Transactions.IsolationLevel.ReadCommitted>, désactive la prise en charge des transactions concurrentes, exige une transaction passée à partir de l’appel de l’opération et valide automatiquement la transaction sur le service si aucune exception non gérée ne se produit.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 La liaison sous-jacente doit prendre en charge les transactions passées pour l’exemple de code suivant pour s’exécuter correctement. Pour prendre en charge les transactions passées à l'aide de <xref:System.ServiceModel.WSHttpBinding>, par exemple, affectez la valeur <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> à la propriété `true` dans le code ou dans un fichier de configuration de l'application. L'exemple de code suivant montre un fichier de configuration pour l'exemple précédent.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public void SetWellKnownSingleton (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetWellKnownSingleton(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetWellKnownSingleton (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetWellKnownSingleton(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetWellKnownSingleton : obj -&gt; unit" Usage="serviceBehaviorAttribute.SetWellKnownSingleton value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Instance singleton du service.</param>
        <summary>Spécifie un objet qui implémente le service et qui est utilisé comme instance singleton du service.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elle renseigne l'instance de service à laquelle tous les messages adressés au service seront distribués.  
  
 Si <xref:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton%2A> a une valeur non `null`, <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> doit avoir la valeur <xref:System.ServiceModel.InstanceContextMode.Single>. Sinon, une exception <xref:System.InvalidOperationException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur définie est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeConfigurationName">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeConfigurationName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeConfigurationName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeConfigurationName () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeConfigurationName();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeConfigurationName : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeConfigurationName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si la propriété <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> utilise une autre valeur que sa valeur par défaut et doit être sérialisée.</summary>
        <returns><see langword="true" /> si la valeur de la propriété <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> doit être sérialisée ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReleaseServiceInstanceOnTransactionComplete () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReleaseServiceInstanceOnTransactionComplete : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si la propriété <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> utilise une autre valeur que sa valeur par défaut et doit être sérialisée.</summary>
        <returns><see langword="true" /> si la valeur de la propriété <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> doit être sérialisée ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionAutoCompleteOnSessionClose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionAutoCompleteOnSessionClose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionAutoCompleteOnSessionClose () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionAutoCompleteOnSessionClose();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionAutoCompleteOnSessionClose : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si la propriété <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> utilise une autre valeur que sa valeur par défaut et doit être sérialisée.</summary>
        <returns><see langword="true" /> si la valeur de la propriété <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> doit être sérialisée ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionIsolationLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionIsolationLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionIsolationLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionIsolationLevel();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionIsolationLevel : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si la propriété <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> utilise une autre valeur que sa valeur par défaut et doit être sérialisée.</summary>
        <returns><see langword="true" /> si la valeur de la propriété <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> doit être sérialisée ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionTimeout">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionTimeout () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionTimeout();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionTimeout : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionTimeout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si la propriété <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> utilise une autre valeur que sa valeur par défaut et doit être sérialisée.</summary>
        <returns><see langword="true" /> si la valeur de la propriété <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> doit être sérialisée ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.AddBindingParameters">
      <MemberSignature Language="C#" Value="void IServiceBehavior.AddBindingParameters (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase, class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase, System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^ endpoints, System::ServiceModel::Channels::BindingParameterCollection ^ parameters) = System::ServiceModel::Description::IServiceBehavior::AddBindingParameters;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
        <Parameter Name="endpoints" Type="System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <param name="description">Description du service.</param>
        <param name="serviceHostBase">Hôte du service.</param>
        <param name="endpoints">Points de terminaison de service.</param>
        <param name="parameters">Objets de données requis par les liaisons pour prendre en charge le comportement.</param>
        <summary>Passe des objets de données personnalisés aux liaisons qui prennent en charge les propriétés de comportement.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior">
      <MemberSignature Language="C#" Value="void IServiceBehavior.ApplyDispatchBehavior (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::ApplyDispatchBehavior;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Description du service.</param>
        <param name="serviceHostBase">Hôte du service.</param>
        <summary>Personnalise le moment d'exécution du service afin de prendre en charge les propriétés de comportement.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.Validate">
      <MemberSignature Language="C#" Value="void IServiceBehavior.Validate (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.Validate(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.Validate(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::Validate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Description du service.</param>
        <param name="serviceHostBase">Hôte du service.</param>
        <summary>Vérifie que la description du service et l'hôte du service sont capables de prendre en charge le comportement.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool TransactionAutoCompleteOnSessionClose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionAutoCompleteOnSessionClose As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionAutoCompleteOnSessionClose { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionAutoCompleteOnSessionClose : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie si les transactions en attente sont exécutées lorsque la session active se ferme sans erreur.</summary>
        <value><see langword="true" /> si les transactions en attente doivent être exécutées lorsque la session active se ferme sans erreur ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie le niveau d'isolation des nouvelles transactions créées à l'intérieur du service et des transactions entrantes transmises à partir d'un client.</summary>
        <value>Valeur <see cref="T:System.Transactions.IsolationLevel" /> précisant le niveau d'isolation de la transaction. La valeur par défaut est <see cref="F:System.Transactions.IsolationLevel.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le niveau d’isolation sous lequel votre transaction est exécutée détermine la manière dont les données sont traitées lorsque vous apportez des modifications à d’autres transactions, ainsi que la durée pendant laquelle votre transaction doit conserver des verrous pour se protéger contre ces modifications. Par exemple, la valeur par défaut, <xref:System.Transactions.IsolationLevel.Unspecified>, indique qu'aucune mise à jour ou insertion ne peut intervenir tant que la transaction n'est pas terminée.  
  
 Cette propriété peut également être utilisée pour restreindre le niveau d'isolation de transactions entrantes transmises à partir d'un client.  
  
   
  
## Examples  
 L’exemple de code suivant affecte au niveau d’isolation des transactions la valeur <xref:System.Transactions.IsolationLevel.ReadCommitted>, ne prend pas en charge les transactions concurrentes, exige une transaction passée à partir de l’appel de méthode et valide automatiquement la transaction si aucune exception non gérée ne se produit.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 La liaison sous-jacente doit prendre en charge les transactions passées pour l’exemple de code suivant pour s’exécuter correctement. Pour prendre en charge les transactions passées à l'aide de <xref:System.ServiceModel.WSHttpBinding>, par exemple, affectez la valeur <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> à la propriété `true` dans le code ou dans un fichier de configuration de l'application. L'exemple de code suivant montre un fichier de configuration pour l'exemple précédent.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur ne fait pas partie des valeurs de <see cref="T:System.Transactions.IsolationLevel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public string TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionTimeout { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la période au cours de laquelle une transaction doit se terminer.</summary>
        <value>Objet <see cref="T:System.TimeSpan" /> qui représente l'intervalle de temps au cours duquel les transactions doivent se terminer ou être automatiquement abandonnées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur définit la propriété <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout%2A?displayProperty=nameWithType>. Vous pouvez également définir cette propriété à l’aide de la [ &lt;serviceTimeouts&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicetimeouts.md) élément dans un fichier de configuration d’application.  
  
   
  
## Examples  
 Le fichier de configuration suivant spécifie un délai d’attente de trois minutes pour la transaction.  
  
 [!code-csharp[SBA.TransactionTimeout#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactiontimeout/cs/services.cs#2)]
 [!code-vb[SBA.TransactionTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactiontimeout/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur est Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur est inférieure à <see cref="F:System.TimeSpan.Zero" /> ou supérieure à <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSynchronizationContext">
      <MemberSignature Language="C#" Value="public bool UseSynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSynchronizationContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSynchronizationContext { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSynchronizationContext : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie si le contexte de synchronisation actuel doit être utilisé pour sélectionner le thread d'exécution.</summary>
        <value><see langword="true" /> si tous les appels au service doivent être exécutés sur le thread spécifié par le <see cref="T:System.Threading.SynchronizationContext" /> ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour préciser l'affinité de thread d'interface utilisateur qu'exigent certaines applications. Par exemple, une application Windows Forms peut être enregistrée en tant qu'objet de service singleton. Dans ce cas, tous les appels dans le service doivent être exécutés sur le thread Windows Forms. Par défaut, lorsque <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> a la valeur `true`, tous les appels au service sont synchronisés pour être exécutés sur le thread capturé à partir du <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie si le système ou l'application applique le traitement d'en-tête <see langword="MustUnderstand" /> SOAP.</summary>
        <value><see langword="true" /> si le système doit exécuter le traitement <see langword="MustUnderstand" /> d'en-tête SOAP ; sinon, <see langword="false" />, qui indique que l'application exécute ce traitement. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> pour désactiver la validation appliquée aux en-têtes de message entrants. En mode d'exécution normale, les en-têtes de messages sont comparés à la propriété <xref:System.ServiceModel.Channels.MessageHeaders.UnderstoodHeaders%2A> pour vérifier que les en-têtes entrants sont explicitement traités par le service. Affectez la valeur `false` à cette propriété pour désactiver la vérification. Lorsqu'elle a la valeur `false`, l'application doit contrôler les en-têtes marqués avec MustUnderstand="true" et retourner une erreur si au moins l'un d'entre eux n'était pas compris. Cette fonction est utile lorsque l'application doit accepter tous les messages SOAP entrants (par exemple, lors de l'utilisation de messages typés ou non typés) et exécuter le traitement d'en-tête personnalisé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>