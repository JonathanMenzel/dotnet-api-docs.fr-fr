<Type Name="OperationContext" FullName="System.ServiceModel.OperationContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="670ba4c65aea9218d8c73b56858ca4cef693273a" /><Meta Name="ms.sourcegitcommit" Value="7461f9e28c2f184bd1596e6f07c25a3f34984516" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/28/2019" /><Meta Name="ms.locfileid" Value="58552669" /></Metadata><TypeSignature Language="C#" Value="public sealed class OperationContext : System.ServiceModel.IExtensibleObject&lt;System.ServiceModel.OperationContext&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OperationContext extends System.Object implements class System.ServiceModel.IExtensibleObject`1&lt;class System.ServiceModel.OperationContext&gt;" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.OperationContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OperationContext&#xA;Implements IExtensibleObject(Of OperationContext)" />
  <TypeSignature Language="C++ CLI" Value="public ref class OperationContext sealed : System::ServiceModel::IExtensibleObject&lt;System::ServiceModel::OperationContext ^&gt;" />
  <TypeSignature Language="F#" Value="type OperationContext = class&#xA;    interface IExtensibleObject&lt;OperationContext&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
    <AssemblyVersion>4.5.0.3</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.IExtensibleObject&lt;System.ServiceModel.OperationContext&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit l'accès au contexte d'exécution d'une méthode de service.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.ServiceModel.OperationContext> à partir d'une opération de service pour accéder à l'environnement d'exécution de l'opération actuelle. En particulier, le contexte d'opération est utilisé pour accéder aux canaux de rappel dans les services duplex, pour stocker les données d'état supplémentaires dans l'ensemble des parties des opérations et pour accéder aux en-têtes et aux propriétés de message entrant ainsi que pour ajouter des en-têtes et des propriétés de message sortant.  
  
 Pour plus d’informations sur l’utilisation des extensions pour stocker les données d’état, consultez [objets extensibles](~/docs/framework/wcf/extending/extensible-objects.md).  
  
 <xref:System.ServiceModel.OperationContext> dispose des propriétés et méthodes suivantes :  
  
-   La propriété <xref:System.ServiceModel.OperationContext.Current%2A> retourne l'objet <xref:System.ServiceModel.OperationContext> représentant le contexte d'exécution actuel.  
  
-   La propriété <xref:System.ServiceModel.OperationContext.ServiceSecurityContext%2A> retourne l'environnement de sécurité sous lequel la méthode s'exécute.  
  
-   La propriété <xref:System.ServiceModel.OperationContext.EndpointDispatcher%2A> obtient le <xref:System.ServiceModel.Dispatcher.EndpointDispatcher?displayProperty=nameWithType>de l'opération.  
  
-   La propriété <xref:System.ServiceModel.OperationContext.Extensions%2A> retourne une collection d’extensions pour le <xref:System.ServiceModel.OperationContext>actuel.  
  
-   La propriété <xref:System.ServiceModel.OperationContext.Host%2A> retourne l'objet <xref:System.ServiceModel.ServiceHostBase> qui gère le service.  
  
-   La propriété <xref:System.ServiceModel.OperationContext.HasSupportingTokens%2A> retourne une valeur qui indique si la méthode a des jetons de prise en charge, et si c'est le cas, la propriété <xref:System.ServiceModel.OperationContext.SupportingTokens%2A> les obtient.  
  
-   Les propriétés <xref:System.ServiceModel.OperationContext.IncomingMessageHeaders%2A>, <xref:System.ServiceModel.OperationContext.IncomingMessageProperties%2A>et <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> obtiennent ces éléments du message entrant.  
  
-   L'événement <xref:System.ServiceModel.OperationContext.OperationCompleted> est déclenché à la fin de l'opération.  
  
-   Les propriétés <xref:System.ServiceModel.OperationContext.OutgoingMessageHeaders%2A> et <xref:System.ServiceModel.OperationContext.OutgoingMessageProperties%2A> reçoivent ces éléments pour le message sortant.  
  
-   La propriété <xref:System.ServiceModel.OperationContext.RequestContext%2A> retourne l'implémentation <xref:System.ServiceModel.Channels.RequestContext> pour la méthode.  
  
-   La propriété <xref:System.ServiceModel.OperationContext.InstanceContext%2A> retourne le <xref:System.ServiceModel.InstanceContext> associé à l'opération.  
  
-   La propriété <xref:System.ServiceModel.OperationContext.SessionId%2A> retourne l'identificateur de session pour le canal et l'objet en cours.  
  
-   La méthode <xref:System.ServiceModel.OperationContext.GetCallbackChannel%2A> retourne un canal de rappel à l'appelant dans le cas d'une communication duplex.  
  
-   La méthode <xref:System.ServiceModel.OperationContext.SetTransactionComplete%2A> valide la transaction en cours.  
  
   
  
## Examples  
 L'exemple de code suivant utilise la propriété <xref:System.ServiceModel.OperationContext.Current%2A> et la méthode <xref:System.ServiceModel.OperationContext.GetCallbackChannel%2A> pour retourner le canal à l'appelant à partir d'une méthode. Toutes les méthodes de cet exemple sont des méthodes unidirectionnelles, permettant au service et au client de communiquer indépendamment dans les deux sens. Dans ce cas, l'application cliente d'exemple attend un seul appel de retour avant de quitter, mais un autre client, par exemple un client Windows Forms, peut recevoir n'importe quel nombre d'appels du service.  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 Le client suivant implémente le `SampleDuplexHelloCallback` pour recevoir le message de rappel. Le contrat de rappel importé n'a pas le même nom que celui du service, en raison de l'utilisation de la propriété <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> dans l'exemple précédent. Notez que le client ne fait aucune hypothèse quant à la possibilité ou au moment où il peut recevoir un rappel ; le rappel de serveur est entièrement indépendant de l'appel sortant du client.  
  
> [!NOTE]
>  Pour un exemple qui utilise la classe <xref:System.ServiceModel.OperationContext> dans un scénario client, consultez <xref:System.ServiceModel.OperationContextScope>.  
  
 [!code-csharp[SCA.CallbackContract#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/client.cs#3)]
 [!code-vb[SCA.CallbackContract#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OperationContext (System.ServiceModel.IContextChannel channel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.IContextChannel channel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.OperationContext.#ctor(System.ServiceModel.IContextChannel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (channel As IContextChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OperationContext(System::ServiceModel::IContextChannel ^ channel);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.OperationContext : System.ServiceModel.IContextChannel -&gt; System.ServiceModel.OperationContext" Usage="new System.ServiceModel.OperationContext channel" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="channel" Type="System.ServiceModel.IContextChannel" />
      </Parameters>
      <Docs>
        <param name="channel"><see cref="T:System.ServiceModel.IContextChannel" /> utilisé pour créer un client <see cref="T:System.ServiceModel.OperationContext" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.OperationContext" /> qui utilise le <see cref="T:System.ServiceModel.IContextChannel" /> spécifié dans une application cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le constructeur <xref:System.ServiceModel.OperationContext.%23ctor%2A> pour créer un contexte d'opération dans la portée duquel le proxy est associé pour modifier des éléments sortants, tels que des en-têtes.  
  
   
  
## Examples  
 L'exemple suivant indique comment utiliser la <xref:System.ServiceModel.OperationContextScope> pour créer un contexte dans une application cliente afin d'ajouter un en-tête personnalisé au message sortant.  
  
 [!code-csharp[OperationContextScope#4](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontextscope/cs/client.cs#4)]
 [!code-vb[OperationContextScope#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontextscope/vb/client.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le canal a la valeur Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Channel">
      <MemberSignature Language="C#" Value="public System.ServiceModel.IContextChannel Channel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.IContextChannel Channel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.Channel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Channel As IContextChannel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::IContextChannel ^ Channel { System::ServiceModel::IContextChannel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Channel : System.ServiceModel.IContextChannel" Usage="System.ServiceModel.OperationContext.Channel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.IContextChannel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le canal associé à l'objet <see cref="T:System.ServiceModel.OperationContext" /> en cours.</summary>
        <value><see cref="T:System.ServiceModel.IContextChannel" /> associé au <see cref="T:System.ServiceModel.OperationContext" /> en cours.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClaimsPrincipal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal ClaimsPrincipal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal ClaimsPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.ClaimsPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClaimsPrincipal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ ClaimsPrincipal { System::Security::Claims::ClaimsPrincipal ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClaimsPrincipal : System.Security.Claims.ClaimsPrincipal" Usage="System.ServiceModel.OperationContext.ClaimsPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'entité basée sur les revendications associée à l'opération.</summary>
        <value>Principal des revendications.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.OperationContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.ServiceModel.OperationContext Current" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As OperationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::ServiceModel::OperationContext ^ Current { System::ServiceModel::OperationContext ^ get(); void set(System::ServiceModel::OperationContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.ServiceModel.OperationContext with get, set" Usage="System.ServiceModel.OperationContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.OperationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contexte d'exécution du thread actuel.</summary>
        <value><see cref="T:System.ServiceModel.OperationContext" /> qui représente la messagerie et le contexte d'exécution de la méthode en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.OperationContext.Current%2A> pour obtenir l'exécution et le contexte de message pour la méthode en cours.  
  
   
  
## Examples  
 L'exemple de code suivant utilise la propriété <xref:System.ServiceModel.OperationContext.Current%2A> et la méthode <xref:System.ServiceModel.OperationContext.GetCallbackChannel%2A> pour retourner un canal à l'appelant à partir d'une méthode. Toutes les méthodes de cet exemple sont des méthodes unidirectionnelles, permettant au service et au client de communiquer indépendamment dans les deux sens. Dans ce cas, l'application cliente d'exemple attend un seul appel de retour avant de quitter, mais un autre client, par exemple un client Windows Forms, peut recevoir n'importe quel nombre d'appels du service.  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndpointDispatcher">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.EndpointDispatcher EndpointDispatcher { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.EndpointDispatcher EndpointDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.EndpointDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Property EndpointDispatcher As EndpointDispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::EndpointDispatcher ^ EndpointDispatcher { System::ServiceModel::Dispatcher::EndpointDispatcher ^ get(); void set(System::ServiceModel::Dispatcher::EndpointDispatcher ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EndpointDispatcher : System.ServiceModel.Dispatcher.EndpointDispatcher with get, set" Usage="System.ServiceModel.OperationContext.EndpointDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.EndpointDispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le répartiteur de points de terminaison pour le point de terminaison à inspecter ou modifier.</summary>
        <value>Répartiteur de points de terminaison pour le point de terminaison à inspecter ou modifier.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.ServiceModel.IExtensionCollection&lt;System.ServiceModel.OperationContext&gt; Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.IExtensionCollection`1&lt;class System.ServiceModel.OperationContext&gt; Extensions" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As IExtensionCollection(Of OperationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::IExtensionCollection&lt;System::ServiceModel::OperationContext ^&gt; ^ Extensions { System::ServiceModel::IExtensionCollection&lt;System::ServiceModel::OperationContext ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.ServiceModel.IExtensionCollection&lt;System.ServiceModel.OperationContext&gt;" Usage="System.ServiceModel.OperationContext.Extensions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.IExtensibleObject`1.Extensions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.IExtensionCollection&lt;System.ServiceModel.OperationContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection d'extensions de service du contexte de message actuel.</summary>
        <value>Collection d'extensions de <see cref="T:System.ServiceModel.OperationContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.OperationContext.Extensions%2A> pour obtenir une collection de toutes les extensions du <xref:System.ServiceModel.OperationContext> utilisée pour modifier le contexte ou ajouter un état personnalisé. Pour plus d’informations sur les extensions, consultez [objets extensibles](~/docs/framework/wcf/extending/extensible-objects.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackChannel&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetCallbackChannel&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetCallbackChannel&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.OperationContext.GetCallbackChannel``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackChannel(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; T GetCallbackChannel();" />
      <MemberSignature Language="F#" Value="member this.GetCallbackChannel : unit -&gt; 'T" Usage="operationContext.GetCallbackChannel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Type de canal utilisé pour rappeler le client.</typeparam>
        <summary>Obtient un canal à l'instance du client qui a appelé l'opération en cours.</summary>
        <returns>Canal à l'instance du client qui a appelé l'opération du type spécifié dans la propriété <see cref="P:System.ServiceModel.ServiceContractAttribute.CallbackContract" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la propriété <xref:System.ServiceModel.OperationContext.GetCallbackChannel%2A> pour obtenir un canal que vous pouvez utiliser pour appeler des opérations sur l'instance du client qui a appelé le service.  
  
   
  
## Examples  
 L'exemple de code suivant utilise la propriété <xref:System.ServiceModel.OperationContext.Current%2A> et la méthode <xref:System.ServiceModel.OperationContext.GetCallbackChannel%2A> pour retourner un canal à l'appelant à partir d'une opération. Toutes les opérations de cet exemple sont des opérations unidirectionnelles, permettant au service et au client de communiquer indépendamment dans les deux sens. Dans ce cas, l'application cliente d'exemple attend un seul appel de retour avant de quitter, mais un autre client, par exemple un client Windows Forms, peut recevoir n'importe quel nombre d'appels du service.  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 Le client suivant implémente le `SampleDuplexHelloCallback` pour recevoir le message de rappel. Le contrat de rappel importé n'a pas le même nom que celui du service, en raison de l'utilisation de la propriété <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> dans l'exemple précédent. Notez que le client ne fait aucune hypothèse quant à la possibilité ou au moment où il peut recevoir un rappel ; le rappel de serveur est entièrement indépendant de l'appel sortant du client.  
  
> [!NOTE]
>  Pour un exemple qui utilise la classe <xref:System.ServiceModel.OperationContext> dans un scénario client, consultez <xref:System.ServiceModel.OperationContextScope>.  
  
 [!code-csharp[SCA.CallbackContract#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/client.cs#3)]
 [!code-vb[SCA.CallbackContract#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasSupportingTokens">
      <MemberSignature Language="C#" Value="public bool HasSupportingTokens { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasSupportingTokens" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.HasSupportingTokens" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasSupportingTokens As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasSupportingTokens { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasSupportingTokens : bool" Usage="System.ServiceModel.OperationContext.HasSupportingTokens" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le message entrant a des jetons de prise en charge.</summary>
        <value><see langword="true" /> si le message entrant a des jetons de prise en charge ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ServiceHostBase Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ServiceHostBase Host" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As ServiceHostBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ServiceHostBase ^ Host { System::ServiceModel::ServiceHostBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : System.ServiceModel.ServiceHostBase" Usage="System.ServiceModel.OperationContext.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ServiceHostBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'<see cref="T:System.ServiceModel.ServiceHost" /> pour l'objet de service en cours.</summary>
        <value>Objet <see cref="T:System.ServiceModel.ServiceHost" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncomingMessageHeaders">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageHeaders IncomingMessageHeaders { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageHeaders IncomingMessageHeaders" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.IncomingMessageHeaders" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IncomingMessageHeaders As MessageHeaders" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageHeaders ^ IncomingMessageHeaders { System::ServiceModel::Channels::MessageHeaders ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncomingMessageHeaders : System.ServiceModel.Channels.MessageHeaders" Usage="System.ServiceModel.OperationContext.IncomingMessageHeaders" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageHeaders</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les en-têtes de message entrant pour le <see cref="T:System.ServiceModel.OperationContext" />.</summary>
        <value>Objet <see cref="T:System.ServiceModel.Channels.MessageHeaders" /> qui contient les en-têtes de message entrant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour inspecter ou modifier les en-têtes de demande qui arrivent à une opération de service ou les en-têtes de réponse qui arrivent à un proxy client.  
  
   
  
## Examples  
 L'exemple de code suivant montre comment lire les en-têtes de message entrant dans une opération de service.  
  
 [!code-csharp[OperationContextScope#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontextscope/cs/services.cs#2)]
 [!code-vb[OperationContextScope#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontextscope/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncomingMessageProperties">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageProperties IncomingMessageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageProperties IncomingMessageProperties" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.IncomingMessageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IncomingMessageProperties As MessageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageProperties ^ IncomingMessageProperties { System::ServiceModel::Channels::MessageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncomingMessageProperties : System.ServiceModel.Channels.MessageProperties" Usage="System.ServiceModel.OperationContext.IncomingMessageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les propriétés de message pour le message entrant dans le <see cref="T:System.ServiceModel.OperationContext" />.</summary>
        <value>Objet <see cref="T:System.ServiceModel.Channels.MessageProperties" /> qui contient les propriétés de message sur le message entrant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour inspecter ou modifier les propriétés de message pour un message de demande dans une opération de service ou un message de réponse dans un proxy client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncomingMessageVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageVersion IncomingMessageVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageVersion IncomingMessageVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.IncomingMessageVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IncomingMessageVersion As MessageVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageVersion ^ IncomingMessageVersion { System::ServiceModel::Channels::MessageVersion ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncomingMessageVersion : System.ServiceModel.Channels.MessageVersion" Usage="System.ServiceModel.OperationContext.IncomingMessageVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la version du message SOAP entrant pour le <see cref="T:System.ServiceModel.OperationContext" />.</summary>
        <value>Version SOAP du message entrant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour inspecter la version SOAP du message de demande qui arrive à une opération de service ou la version SOAP du message de réponse qui arrive à un proxy client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContext">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContext InstanceContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.InstanceContext InstanceContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.InstanceContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceContext As InstanceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContext ^ InstanceContext { System::ServiceModel::InstanceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContext : System.ServiceModel.InstanceContext" Usage="System.ServiceModel.OperationContext.InstanceContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.ServiceModel.InstanceContext" /> qui gère l'instance de service en cours.</summary>
        <value>Objet <see cref="T:System.ServiceModel.InstanceContext" /> pour le service en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.OperationContext.InstanceContext%2A> pour accéder à l'objet d'exécution qui gère l'objet de service en cours.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUserContext">
      <MemberSignature Language="C#" Value="public bool IsUserContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUserContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.IsUserContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUserContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUserContext { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUserContext : bool" Usage="System.ServiceModel.OperationContext.IsUserContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette propriété est réservée au système et ne doit pas être appelée par les utilisateurs.</summary>
        <value><see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OperationCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler OperationCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler OperationCompleted" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.OperationContext.OperationCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OperationCompleted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ OperationCompleted;" />
      <MemberSignature Language="F#" Value="member this.OperationCompleted : EventHandler " Usage="member this.OperationCompleted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'opération est terminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez l'événement <xref:System.ServiceModel.OperationContext.OperationCompleted> pour supprimer des paramètres ou une valeur de retour si vous affectez <xref:System.ServiceModel.OperationBehaviorAttribute.AutoDisposeParameters%2A?displayProperty=nameWithType> à `false`. Normalement, vous définissez <xref:System.ServiceModel.OperationBehaviorAttribute.AutoDisposeParameters%2A?displayProperty=nameWithType> à `false` pour empêcher l’appel WCF <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> sur les objets de valeur de paramètre et de retour.  Toutefois, si certains paramètres doivent être conservés alors que d'autres doivent être supprimés, cet événement est l'endroit idéal pour supprimer ces paramètres.  
  
 De même, avec les liaisons duplex, cet événement peut être utilisé pour envoyer une demande sur le canal de rappel une fois que la réponse pour l'opération en cours est envoyée.  
  
> [!NOTE]
>  Si un appelant écoute l'événement <xref:System.ServiceModel.OperationContext.OperationCompleted?displayProperty=nameWithType> pour une opération <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A?displayProperty=nameWithType>, il est possible de bloquer lors de la réception de la réponse. Pour gérer correctement cela, il convient de planifier des travaux sur un autre thread lorsque <xref:System.ServiceModel.OperationContext.OperationCompleted> est déclenché, puis de retourner immédiatement à partir de ce gestionnaire d'événements.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutgoingMessageHeaders">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageHeaders OutgoingMessageHeaders { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageHeaders OutgoingMessageHeaders" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.OutgoingMessageHeaders" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutgoingMessageHeaders As MessageHeaders" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageHeaders ^ OutgoingMessageHeaders { System::ServiceModel::Channels::MessageHeaders ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutgoingMessageHeaders : System.ServiceModel.Channels.MessageHeaders" Usage="System.ServiceModel.OperationContext.OutgoingMessageHeaders" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageHeaders</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les en-têtes de message sortant pour le <see cref="T:System.ServiceModel.OperationContext" /> actif.</summary>
        <value>Objet <see cref="T:System.ServiceModel.Channels.MessageHeaders" /> qui contient les en-têtes de message sortants pour le <see cref="T:System.ServiceModel.OperationContext" /> actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété permet d’ajouter des en-têtes de réponse sont envoyés par une opération de service ou les en-têtes de demande sont envoyés par un objet de client WCF.  
  
   
  
## Examples  
 L'exemple suivant indique comment utiliser la <xref:System.ServiceModel.OperationContextScope> pour créer un contexte dans une application cliente afin d'ajouter un en-tête personnalisé au message sortant.  
  
 [!code-csharp[OperationContextScope#4](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontextscope/cs/client.cs#4)]
 [!code-vb[OperationContextScope#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontextscope/vb/client.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutgoingMessageProperties">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageProperties OutgoingMessageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageProperties OutgoingMessageProperties" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.OutgoingMessageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutgoingMessageProperties As MessageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageProperties ^ OutgoingMessageProperties { System::ServiceModel::Channels::MessageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutgoingMessageProperties : System.ServiceModel.Channels.MessageProperties" Usage="System.ServiceModel.OperationContext.OutgoingMessageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les propriétés de message pour le message sortant dans le <see cref="T:System.ServiceModel.OperationContext" /> actif.</summary>
        <value>Objet <see cref="T:System.ServiceModel.Channels.MessageProperties" /> qui contient les propriétés de message sur le message sortant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour ajouter des propriétés de message pour un message de réponse d'une opération de service ou des propriétés de message pour un message de demande d'un proxy client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext RequestContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.RequestContext" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestContext As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::RequestContext ^ RequestContext { System::ServiceModel::Channels::RequestContext ^ get(); void set(System::ServiceModel::Channels::RequestContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.ServiceModel.Channels.RequestContext with get, set" Usage="System.ServiceModel.OperationContext.RequestContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'implémentation <see cref="T:System.ServiceModel.Channels.RequestContext" /> pour cette méthode.</summary>
        <value>Implémentation <see cref="T:System.ServiceModel.Channels.RequestContext" /> ou valeur Null s'il n'y a aucun contexte de demande.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les traitements unidirectionnels n'ont pas de contexte de demande.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceSecurityContext">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ServiceSecurityContext ServiceSecurityContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ServiceSecurityContext ServiceSecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.ServiceSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServiceSecurityContext As ServiceSecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ServiceSecurityContext ^ ServiceSecurityContext { System::ServiceModel::ServiceSecurityContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceSecurityContext : System.ServiceModel.ServiceSecurityContext" Usage="System.ServiceModel.OperationContext.ServiceSecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ServiceSecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.ServiceModel.ServiceSecurityContext" /> dans lequel s'exécute cette méthode.</summary>
        <value>Objet <see cref="T:System.ServiceModel.ServiceSecurityContext" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public string SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SessionId" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SessionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : string" Usage="System.ServiceModel.OperationContext.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la <see cref="T:System.String" /> utilisée pour identifier la session active.</summary>
        <value>Identificateur de session.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTransactionComplete">
      <MemberSignature Language="C#" Value="public void SetTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.OperationContext.SetTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTransactionComplete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.SetTransactionComplete : unit -&gt; unit" Usage="operationContext.SetTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Valide la transaction en cours d'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce type est utile uniquement dans les opérations qui affectent <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionAutoComplete%2A?displayProperty=nameWithType> à `false`. En général, les services font ceci sur certaines opérations, mais pas sur toutes. Lorsque <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionAutoComplete%2A?displayProperty=nameWithType> a la valeur false, la transaction se termine automatiquement. Utilisez <xref:System.ServiceModel.OperationContext.SetTransactionComplete%2A> dans les cas où il n’est pas possible de déterminer au moment du design si une opération doit terminer la transaction.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il n'y a aucune transaction dans le contexte.</exception>
      </Docs>
    </Member>
    <Member MemberName="SupportingTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.ServiceModel.Security.SupportingTokenSpecification&gt; SupportingTokens { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Security.SupportingTokenSpecification&gt; SupportingTokens" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.SupportingTokens" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportingTokens As ICollection(Of SupportingTokenSpecification)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::ServiceModel::Security::SupportingTokenSpecification ^&gt; ^ SupportingTokens { System::Collections::Generic::ICollection&lt;System::ServiceModel::Security::SupportingTokenSpecification ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportingTokens : System.Collections.Generic.ICollection&lt;System.ServiceModel.Security.SupportingTokenSpecification&gt;" Usage="System.ServiceModel.OperationContext.SupportingTokens" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.ServiceModel.Security.SupportingTokenSpecification&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Collections.Generic.ICollection`1" /> de type <see cref="T:System.IdentityModel.Tokens.SecurityToken" />.</summary>
        <value>Collection de jetons de sécurité.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>