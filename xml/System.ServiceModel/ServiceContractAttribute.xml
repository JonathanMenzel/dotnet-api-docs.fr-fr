<Type Name="ServiceContractAttribute" FullName="System.ServiceModel.ServiceContractAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bc7da9c7d356483570677d227277a7a50b6d8755" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48775688" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ServiceContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type ServiceContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, AllowMultiple=false, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indique qu’une interface ou une classe définit un contrat de service dans une application Windows Communication Foundation (WCF).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez l'attribut <xref:System.ServiceModel.ServiceContractAttribute> sur une interface (ou une classe) pour définir un contrat de service. Puis utilisez l'attribut <xref:System.ServiceModel.OperationContractAttribute> sur une ou plusieurs méthodes de classe (ou d'interface) pour définir les opérations de service du contrat. Lorsque le contrat de service est implémenté et associé un [liaisons](~/docs/framework/wcf/bindings.md) et un <xref:System.ServiceModel.EndpointAddress> de l’objet, le contrat de service est exposé pour une utilisation par les clients. Pour une vue d’ensemble du processus à l’aide des exemples simples, consultez [Getting Started Tutorial](~/docs/framework/wcf/getting-started-tutorial.md). Pour plus d’informations sur la création de contrats de service, consultez [conception et implémentation de Services](~/docs/framework/wcf/designing-and-implementing-services.md).  
  
 Les informations exprimées par une <xref:System.ServiceModel.ServiceContractAttribute> et son interface sont faiblement mises en rapport avec l'élément `<portType>` WSDL (Web Services Description Language). Un contrat de service est utilisé sur le côté service pour spécifier ce que le point de terminaison de service expose aux appelants. Il est également utilisé sur le côté client pour spécifier le contrat du point de terminaison avec lequel le client communique et, dans le cas de contrats duplex, pour spécifier le contrat de rappel (à l'aide de la propriété <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>) que le client doit implémenter afin de participer à une conversation duplex.  
  
> [!NOTE]
>  Une interface ou une classe qui est décorée avec <xref:System.ServiceModel.ServiceContractAttribute> doit également avoir au moins une méthode marquée avec l'attribut <xref:System.ServiceModel.OperationContractAttribute> pour exposer toutes les fonctionnalités. Consultez la section Exemples pour obtenir un exemple de code de l'utilisation la plus simple des deux attributs pour définir et implémenter un service.  
  
 Utilisez les propriétés <xref:System.ServiceModel.ServiceContractAttribute> pour modifier le contrat de service.  
  
-   La propriété <xref:System.ServiceModel.ServiceContractAttribute.ConfigurationName%2A> spécifie le nom de l'élément de service dans le fichier de configuration à utiliser.  
  
-   Les propriétés <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> et <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> contrôlent le nom et l'espace de noms du contrat dans l'élément `<portType>` WSDL.  
  
-   La propriété <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> spécifie si le contrat requiert une liaison qui prend en charge des sessions.  
  
-   La propriété <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> spécifie le contrat de retour dans une conversation bidirectionnelle (duplex).  
  
-   Les propriétés <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> et <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> indiquent si tous les messages qui prennent en charge le contrat ont une valeur <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> explicite, et le cas échéant, quel est le niveau.  
  
 Les services implémentent des contrats de service qui représentent l'échange de données qu'un type de service prend en charge. Une classe de service peut implémenter un contrat de service (en implémentant une interface marquée avec <xref:System.ServiceModel.ServiceContractAttribute> qui a des méthodes marquées avec <xref:System.ServiceModel.OperationContractAttribute>) ou elle peut être marquée avec la <xref:System.ServiceModel.ServiceContractAttribute> et appliquer l'attribut <xref:System.ServiceModel.OperationContractAttribute> à ses propres méthodes. Si une classe implémente une interface marquée avec <xref:System.ServiceModel.ServiceContractAttribute>, elle ne peut pas être marquée avec <xref:System.ServiceModel.ServiceContractAttribute>. Les méthodes sur les types de service qui sont marqués avec le <xref:System.ServiceModel.OperationContractAttribute> sont traitées dans le cadre d'un contrat de service par défaut spécifié par le type de service lui-même. Pour plus d'informations sur les opérations de service, consultez <xref:System.ServiceModel.OperationContractAttribute>.  
  
 Par défaut, les propriétés <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> et <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> correspondent au nom du type de contrat et de `http://tempuri.org`, respectivement, et <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> a la valeur <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>. Il est recommandé que les contrats de service définissent explicitement leurs noms, espaces de noms et niveaux de protection à l'aide de ces propriétés. Cela permet d'assurer deux fonctions. D'une part, cela génère un contrat qui n'est pas directement connecté aux informations de type managé, en vous permettant de refactoriser votre code managé et vos espaces de noms sans rompre le contrat comme cela est exprimé dans WSDL. D’autre part, exiger de façon explicite un certain niveau de protection sur le contrat permet à l’exécution de valider si la configuration de liaison prend en charge ce niveau de sécurité, ce qui permet d’éviter d’exposer des informations sensibles en raison d’une mauvaise configuration. Pour plus d’informations sur les niveaux de protection, consultez [niveau de Protection de présentation](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Pour exposer un service à utiliser par les applications clientes, créez une application hôte pour inscrire votre point de terminaison de service avec Windows Communication Foundation (WCF). Vous pouvez héberger des services WCF à l’aide de Windows Activation Services (WAS) dans les applications de console, applications de Service de Windows, les applications ASP.NET, les applications Windows Forms ou tout autre type de domaine d’application.  
  
 L'hébergement dans WAS est extrêmement similaire à la création d'une application ASP.NET. Pour plus d’informations, consultez [Comment : héberger un Service WCF dans IIS](~/docs/framework/wcf/feature-details/how-to-host-a-wcf-service-in-iis.md).  
  
 Les clients utilisent l'interface de contrat de service (l'interface marquée avec <xref:System.ServiceModel.ServiceContractAttribute>) pour créer un canal au service ou ils utilisent les objets clients (qui associent les informations de type de l'interface de contrat de service avec la classe <xref:System.ServiceModel.ClientBase%601>) pour communiquer avec votre service. Pour plus d’informations sur les canaux clients aux services, consultez le <xref:System.ServiceModel.ChannelFactory%601> classe et [WCF Client Overview](~/docs/framework/wcf/wcf-client-overview.md).  
  
 L'utilisation d'une classe ou d'une interface <xref:System.ServiceModel.ServiceContractAttribute> pour hériter d'une autre classe ou interface <xref:System.ServiceModel.ServiceContractAttribute> étend le contrat parent. Par exemple, si une interface `IChildContract` est marquée avec <xref:System.ServiceModel.ServiceContractAttribute> et héritée d'une autre interface de contrat de service, `IParentContract`, le contrat de service `IChildContract` contient les méthodes de `IParentContract` et de `IChildContract`. L'extension des contrats (sur les classes ou les interfaces) est extrêmement similaire à l'extension des classes et des interfaces managées.  
  
 L'approche la plus flexible en termes de création de services consiste à définir tout d'abord des interfaces de contrat de service, puis de faire implémenter cette interface par votre contrat de service. C'est également la méthode la plus simple pour générer vos services si vous devez implémenter des contrats de service définis par d'autres. Générer directement des services en marquant une classe avec <xref:System.ServiceModel.ServiceContractAttribute> et ses méthodes avec <xref:System.ServiceModel.OperationContractAttribute> fonctionne lorsque le service expose uniquement un seul contrat (mais ce contrat peut être exposé par plusieurs points de terminaison).  
  
 Utilisez le <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> propriété pour indiquer un autre contrat de service qui, lorsqu’il est associé le contrat de service d’origine, définissent un échange de messages qui peut circuler indépendamment de deux manières. Pour plus d'informations, consultez <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>.  
  
   
  
## Examples  
 L'exemple de code suivant indique comment appliquer la <xref:System.ServiceModel.ServiceContractAttribute> à une interface pour définir un contrat de service avec une méthode de service, tel qu'indiqué par la <xref:System.ServiceModel.OperationContractAttribute>. Dans ce cas, le niveau de protection requis des liaisons pour tous les messages est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.  
  
 L'exemple de code implémente ensuite ce contrat sur la classe `SampleService`.  
  
 [!code-csharp[ServiceContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/services.cs#1)]
 [!code-vb[ServiceContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/services.vb#1)]  
  
 L'exemple de code suivant présente un fichier de configuration simple pour le service précédent qui crée un point de terminaison.  
  
 [!code-xml[ServiceContractAttribute#2](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/hostapplication.exe.config#2)]   
  
 L'exemple de code suivant affiche un client simple qui appelle le `SampleService` précédent.  
  
 [!code-csharp[ServiceContractAttribute#3](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/client.cs#3)]
 [!code-vb[ServiceContractAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationContractAttribute" />
    <related type="Article" href="http://msdn.microsoft.com/library/036fae20-7c55-4002-b71d-ac4466e167a3">Définition des contrats de service</related>
    <related type="Article" href="http://msdn.microsoft.com/library/192be927-6be2-4fda-98f0-e513c4881acc">Hébergement d’un Service</related>
    <related type="Article" href="http://msdn.microsoft.com/library/7cf21bfe-23bd-46aa-8033-609f851dbf76">Vue d’ensemble de la création de service</related>
    <related type="Article" href="http://msdn.microsoft.com/library/28dfff47-d95b-4cc2-9d5c-b3b9ba71fd50">Création d’un Client</related>
    <related type="Article" href="http://msdn.microsoft.com/library/d780af9f-73c5-42db-9e52-077a5e4de7fe">Vue d’ensemble de la création de proxy</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.ServiceContractAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur crée une instance de l’attribut sans exigences pour la session et contrat de rappel ainsi que le nom et l’espace de noms par défaut.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallbackContract">
      <MemberSignature Language="C#" Value="public Type CallbackContract { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type CallbackContract" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberSignature Language="VB.NET" Value="Public Property CallbackContract As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ CallbackContract { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CallbackContract : Type with get, set" Usage="System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type de contrat de rappel lorsque le contrat est un contrat duplex.</summary>
        <value>
          <see cref="T:System.Type" /> qui indique le contrat de rappel. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécifiez une interface dans la propriété <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> qui représente le contrat opposé requis dans un échange de messages bidirectionnel (ou duplex). Cela permet aux applications clientes d'écouter les appels d'opération entrants que l'application de service côté serveur peut envoyer indépendamment des activités clientes. Les contrats de rappel qui ont des opérations unidirectionnelles représentent les appels du service que le client peut gérer.  
  
> [!NOTE]
>  L'attribut <xref:System.ServiceModel.ServiceContractAttribute> est ignoré sur les contrats de rappel. Pour configurer le comportement d'exécution des objets de rappel, utilisez la <xref:System.ServiceModel.CallbackBehaviorAttribute?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L'exemple de code suivant présente un service qui spécifie un contrat de rappel. Il indique qu'un service de type `IDuplexHello` doit avoir un correspondant qui implémente un service de type `IHelloCallbackContract`. De plus, `IHelloCallbackContract` implémente une méthode de rappel unidirectionnelle, ce qui permet au service d'appeler le client sans attendre une réponse pour prendre en charge un client distribué et piloté par des événements.  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom utilisé pour localiser le service dans un fichier de configuration de l'application.</summary>
        <value>Nom utilisé pour localiser l'élément de service dans un fichier de configuration de l'application. Par défaut, il s'agit du nom de la classe d'implémentation du service.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour définir la valeur qui permet au système de configuration de localiser une valeur de contrat dans le fichier de configuration, consultez <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur est Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur est une chaîne vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si un niveau de protection a été assigné au membre.</summary>
        <value>
          <see langword="true" /> si la propriété <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" /> n'a pas la valeur <see cref="F:System.Net.Security.ProtectionLevel.None" /> ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> indique si une valeur de niveau de protection autre que `false` a été définie pour le contrat.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom pour l'élément <see langword="&lt;portType&gt;" /> dans WSDL (Web Services Description Language).</summary>
        <value>La valeur par défaut est le nom de la classe ou de l'interface à laquelle la <see cref="T:System.ServiceModel.ServiceContractAttribute" /> est appliquée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez les propriétés <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> et <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> pour contrôler le nom et l'espace de noms de l'élément `<portType>` dans WSDL.  
  
   
  
## Examples  
 L'exemple de code suivant montre comment utiliser les propriétés <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> et <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> de <xref:System.ServiceModel.ServiceContractAttribute> pour définir les valeurs correspondantes dans WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 L’exemple de code suivant montre un client Windows Communication Foundation (WCF) pour le service précédent qui importé WSDL à l’aide du [ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Ce client utilise un client `HelloWorldProxy` plutôt qu'un client `SampleServiceProxy` (comme dans le cas de l'exemple de la section Exemple de <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur est Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur est une chaîne vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'espace de noms de l'élément <see langword="&lt;portType&gt;" /> dans WSDL (Web Services Description Language).</summary>
        <value>L'espace de noms WSDL de l'élément <see langword="&lt;portType&gt;" />. La valeur par défaut est « http://tempuri.org ».</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple de code suivant montre comment utiliser les propriétés <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> et <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> de <xref:System.ServiceModel.ServiceContractAttribute> pour définir les valeurs correspondantes dans WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 L’exemple de code suivant montre un client Windows Communication Foundation (WCF) pour le service précédent qui importé WSDL à l’aide du [ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Ce client utilise un client `HelloWorldClient` plutôt qu'un client `SampleServiceClient` (comme dans le cas de l'exemple de la section Exemple de <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie si la liaison pour le contrat doit prendre en charge la valeur de la propriété <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />.</summary>
        <value>Une des valeurs de <see cref="T:System.Net.Security.ProtectionLevel" />. La valeur par défaut est <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> pour spécifier le degré pour lequel la liaison de contrat requiert le chiffrement, les signatures numériques ou les deux à la fois pour les points de terminaison qui exposent le contrat. La valeur définie ici est la valeur par défaut pour tous les messages d'opération y compris les erreurs.  
  
 Il est important de se rappeler que le comportement de protection au moment de l'exécution est la combinaison des valeurs de niveau de protection affectées aux propriétés suivantes. Ces propriétés ont une structure hiérarchique. La définition de la valeur la plus à l'extérieur établit le paramètre par défaut pour toutes les portées plus restreintes, sauf si une valeur différente est définie explicitement pour une portée plus restreinte. Dans ce cas, la valeur externe reste la valeur par défaut pour toutes les portées plus restreintes à l'exception de celles qui sont spécifiquement définies.  
  
 Par exemple, si <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> a la valeur <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> et qu'aucune autre portée plus étroite n'a de paramètres de niveau de protection, tous les messages dans un contrat d'opération sont chiffrés et signés, y compris les messages d'erreur. Toutefois, si vous affectez au jeu <xref:System.ServiceModel.OperationContractAttribute> de l'une de ces opérations, la valeur <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, les messages pour cette opération sont signés mais tous les autres messages dans le contrat sont chiffrés et signés.  
  
 Pour plus d’informations sur les niveaux de protection et leurs hypothèses et les étendues, consultez [niveau de Protection de présentation](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Les portées auxquelles ces valeurs sont affectées sont les suivantes :  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 Propriété <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> sur <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.  
  
 Propriété <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> sur <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.  
  
 Lorsque aucun niveau de protection n'est spécifié explicitement sur le contrat et que la liaison sous-jacente prend en charge la sécurité (au niveau du transport ou du message), le niveau de protection effectif pour l'ensemble du contrat est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Si la liaison ne prend pas en charge la sécurité (comme <xref:System.ServiceModel.BasicHttpBinding>), le <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> effectif est <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> pour l'ensemble du contrat. Le résultat est que selon la liaison du point de terminaison, les clients peuvent avoir besoin d'une protection de sécurité au niveau du message ou du transport différente même lorsque le contrat spécifie <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur ne fait pas partie des valeurs <see cref="T:System.Net.Security.ProtectionLevel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.SessionMode SessionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.SessionMode SessionMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SessionMode As SessionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::SessionMode SessionMode { System::ServiceModel::SessionMode get(); void set(System::ServiceModel::SessionMode value); };" />
      <MemberSignature Language="F#" Value="member this.SessionMode : System.ServiceModel.SessionMode with get, set" Usage="System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.SessionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit si les sessions sont autorisées, ne sont pas autorisées ou sont requises.</summary>
        <value>
          <see cref="T:System.ServiceModel.SessionMode" /> qui indique si les sessions sont autorisées, non autorisées ou requises.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> pour requérir des liaisons qui prennent en charge des sessions entre des points de terminaison. Une session est une façon de faire correspondre un ensemble de messages échangés entre deux points de terminaison ou plus. Si votre service prend en charge les sessions de canal, vous pouvez donc utiliser la propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> pour spécifier la relation entre les instances de votre implémentation de contrat de service et la session de canal. Si une liaison ne prend pas en charge les sessions, une exception est levée.  
  
 Par exemple, si la propriété <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> a la valeur <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType> et la propriété <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> a la valeur <xref:System.ServiceModel.InstanceContextMode.PerSession>, les clients peuvent utiliser la même connexion pour faire des appels répétés au même objet du service.  
  
 Pour plus d’informations sur les sessions et instances de service, consultez [à l’aide de Sessions](~/docs/framework/wcf/using-sessions.md) et [Sessions, Instancing et la concurrence](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
> [!NOTE]
>  Un canal qui prend en charge les sessions prend en charge l'association par défaut d'une instance de service avec une session particulière. Toutefois, différentes implémentations de session prennent en charge des fonctionnalités différentes en plus des contrôles d’instance basés sur une session. WCF fournit quatre types de sessions que vous pouvez utiliser pour fournir un comportement de l’application de session ; chaque type de session fournit le comportement supplémentaire spécifique au type de session.  
  
1.  <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> prend en charge des sessions de sécurité dans lesquelles les deux extrémités de communication ont convenu d'un chiffrement et/ou d'un processus de signature numérique ; tous les messages sont mis en corrélation avec cette conversation sécurisée spécifique. Pour plus d’informations, consultez [sécurisation des Services](~/docs/framework/wcf/securing-services.md). Par exemple, <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType> qui contient la prise en charge des sessions de sécurité et des sessions fiables utilise par défaut uniquement une session sécurisée qui chiffre et signe numériquement les messages.  
  
2.  <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> prend en charge les sessions exposées par les connexions TCP/IP pour garantir que tous les messages sont corrélés par la session de connexion au niveau du socket.  
  
3.  <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> qui implémente la spécification WS-ReliableMessaging fournit la prise en charge des sessions fiables dans lesquelles les messages sont remis en ordre et exactement une fois, ce qui permet d'être confiant même lorsque les messages passent par plusieurs nœuds pendant la conversation. Pour plus d’informations, consultez [Sessions fiables](~/docs/framework/wcf/feature-details/reliable-sessions.md).  
  
4.  <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> fournit des sessions de datagramme MSMQ. Pour plus d’informations, consultez [files d’attente dans WCF](~/docs/framework/wcf/feature-details/queues-in-wcf.md).  
  
 Souvenez-vous que la définition de la propriété <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> ne spécifie pas le type de session que le contrat requiert mais uniquement qu'il requiert un type de session.  
  
   
  
## Examples  
 Le contrat de service suivant requiert que les liaisons configurées utilisent des sessions lors de l'interaction avec les implémentations de service `SampleDuplexHello`.  
  
 [!code-csharp[SCA.Session#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.session/cs/services.cs#1)]
 [!code-vb[SCA.Session#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.session/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur ne fait pas partie des valeurs <see cref="T:System.ServiceModel.SessionMode" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>