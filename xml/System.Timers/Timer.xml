<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Timer.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5618b69c9a4d91151391fe5e2c79054e0441f4aec.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">618b69c9a4d91151391fe5e2c79054e0441f4aec</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Timers.Timer">
          <source>Generates an event after a set interval, with an option to generate recurring events.</source>
          <target state="translated">Génère un événement au bout d'un intervalle défini, avec la possibilité de générer des événements récurrents.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> component is a server-based timer that raises an <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event in your application after the number of milliseconds in the <ph id="ph3">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property has elapsed.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> composant est un composant timer serveur qui déclenche un <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événements dans votre application après le nombre de millisecondes dans le <ph id="ph3">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> propriété s’est écoulé.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>You can configure the <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> object to raise the event just once or repeatedly using the <ph id="ph2">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> property.</source>
          <target state="translated">Vous pouvez configurer le <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> objet pour déclencher l’événement une seule fois ou à plusieurs reprises à l’aide du <ph id="ph2">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>Typically, a <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> object is declared at the class level so that it stays in scope as long as it is needed.</source>
          <target state="translated">En règle générale, un <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> objet est déclaré au niveau de la classe afin qu’elle reste dans la portée tant que cela est nécessaire.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>You can then handle its <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event to provide regular processing.</source>
          <target state="translated">Vous pouvez ensuite gérer ses <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement afin de fournir le traitement normal.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>For example, suppose you have a critical server that must be kept running 24 hours a day, 7 days a week.</source>
          <target state="translated">Par exemple, supposons que vous disposez d’un serveur critique qui doit être conservé 24 heures sur 24, 7 jours par semaine en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>You could create a service that uses a <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> object to periodically check the server and ensure that the system is up and running.</source>
          <target state="translated">Vous pouvez créer un service qui utilise un <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> objet régulièrement Vérifiez que le serveur et vérifiez que le système est en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>If the system is not responding, the service could attempt to restart the server or notify an administrator.</source>
          <target state="translated">Si le système ne répond pas, le service peut tenter de redémarrer le serveur ou avertir un administrateur.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> class is not available for all .NET implementations and versions, such as .NET Standard 1.6 and lower versions.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> classe n’est pas disponible pour toutes les implémentations de .NET et les versions, telles que la version 1.6 Standard de .NET et les versions antérieures.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>In these cases, you can use the <ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph> class instead.</source>
          <target state="translated">Dans ce cas, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph> classe à la place.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Ce type implémente le <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Lorsque vous avez fini d’utiliser le type, vous devez la supprimer directement ou indirectement.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Pour supprimer le type directement, vous devez appeler sa <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> méthode dans un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> bloc.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Pour la supprimer indirectement, utiliser une construction de langage telles que <ph id="ph1">`using`</ph> (en c#) ou <ph id="ph2">`Using`</ph> (en Visual Basic).</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> rubrique de l’interface.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The server-based <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> class is designed for use with worker threads in a multithreaded environment.</source>
          <target state="translated">Basée sur le serveur <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> classe a été conçue pour une utilisation avec des threads de travail dans un environnement multithread.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>Server timers can move among threads to handle the raised <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event, resulting in more accuracy than Windows timers in raising the event on time.</source>
          <target state="translated">Minuteries serveur peuvent se déplacer entre les threads pour gérer le relief <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement plus de précision que les minuteurs Windows en déclenchant l’événement sur l’heure.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> component raises the <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event, based on the value (in milliseconds) of the <ph id="ph3">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> composant déclenche le <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement, en fonction de la valeur (en millisecondes) de la <ph id="ph3">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>You can handle this event to perform the processing you need.</source>
          <target state="translated">Vous pouvez gérer cet événement pour exécuter le traitement que vous avez besoin.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>For example, suppose that you have an online sales application that continuously posts sales orders to a database.</source>
          <target state="translated">Par exemple, supposons que vous disposez d’une application de vente en ligne qui publie continuellement des commandes à une base de données.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The service that compiles the instructions for shipping operates on a batch of orders rather than processing each order individually.</source>
          <target state="translated">Le service qui compile les instructions pour l’envoi de journaux fonctionne sur un lot de commandes plutôt que de traiter chaque commande individuellement.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>You could use a <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> to start the batch processing every 30 minutes.</source>
          <target state="translated">Vous pouvez utiliser un <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> pour démarrer le traitement de toutes les 30 minutes par lots.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The System.Timers.Timer class has the same resolution as the system clock.</source>
          <target state="translated">La classe System.Timers.Timer a la même résolution que l’horloge système.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>This means that the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event will fire at an interval defined by the resolution of the system clock if the <ph id="ph2">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property is less than the resolution of the system clock.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement se déclenche selon un intervalle défini par la résolution de l’horloge système si le <ph id="ph2">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> propriété est inférieure à la résolution de l’horloge système.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property.</source>
          <target state="translated">Pour plus d'informations, consultez la propriété <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>When <ph id="ph1">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> is set to <ph id="ph2">`false`</ph>, a <ph id="ph3">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> object raises the <ph id="ph4">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event only once, after the first <ph id="ph5">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> has elapsed.</source>
          <target state="translated">Lors de la <ph id="ph1">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> a la valeur <ph id="ph2">`false`</ph>, un <ph id="ph3">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> objet déclenche le <ph id="ph4">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement une seule fois, après la première <ph id="ph5">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> s’est écoulé.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>To keep raising the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event regularly at the interval defined by the <ph id="ph2">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph>, set <ph id="ph3">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> to <ph id="ph4">`true`</ph>, which is the default value.</source>
          <target state="translated">Pour conserver le déclenchement du <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement régulièrement à l’intervalle défini par le <ph id="ph2">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph>, définissez <ph id="ph3">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> à <ph id="ph4">`true`</ph>, qui est la valeur par défaut.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> component catches and suppresses all exceptions thrown by event handlers for the <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> composant intercepte et supprime toutes les exceptions levées par les gestionnaires d’événements pour le <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>This behavior is subject to change in future releases of the .NET Framework.</source>
          <target state="translated">Ce comportement est susceptible de changer dans les futures versions du .NET Framework.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>Note, however, that this is not true of event handlers that execute asynchronously and include the <ph id="ph1">`await`</ph> operator (in C#)  or the <ph id="ph2">`Await`</ph> operator (in Visual Basic).</source>
          <target state="translated">Notez, toutefois, cela n’est pas vrai pour les gestionnaires d’événements qui s’exécutent de façon asynchrone et incluent le <ph id="ph1">`await`</ph> (opérateur) (en c#) ou <ph id="ph2">`Await`</ph> (opérateur) (en Visual Basic).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>Exceptions thrown in these event handlers are propagated back to the calling thread, as the following example illustrates.</source>
          <target state="translated">Les exceptions levées dans ces gestionnaires d’événements sont propagées vers le thread appelant, comme l’illustre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>For more information on exceptions thrown in asynchronous methods, see   <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les exceptions levées dans les méthodes asynchrones, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>If the <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> property is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is raised on a <ph id="ph4">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> propriété <ph id="ph2">`null`</ph>, le <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est déclenché sur un <ph id="ph4">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>If processing of the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event lasts longer than <ph id="ph2">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph>, the event might be raised again on another <ph id="ph3">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</source>
          <target state="translated">Si le traitement de la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> dure événement plus longtemps que <ph id="ph2">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph>, l’événement peut être déclenché à nouveau sur un autre <ph id="ph3">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>In this situation, the event handler should be reentrant.</source>
          <target state="translated">Dans ce cas, le Gestionnaire d’événements doit être réentrant.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The event-handling method might run on one thread at the same time that another thread calls the <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method or sets the <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">La méthode de gestion d’événements peut s’exécuter sur un thread en même temps qu’un autre thread appelle la <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode ou définit le <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>This might result in the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event being raised after the timer is stopped.</source>
          <target state="translated">Cela peut entraîner la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement déclenché après l’arrêt du minuteur.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The example code for the <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method shows one way to avoid this race condition.</source>
          <target state="translated">L’exemple de code pour le <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode montre une manière d’éviter cette condition de concurrence critique.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>Even if <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> is not <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> events can occur after the <ph id="ph4">&lt;xref:System.Timers.Timer.Dispose%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method has been called or after the <ph id="ph6">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property has been set to <ph id="ph7">`false`</ph>, because the signal to raise the <ph id="ph8">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is always queued for execution on a thread pool thread.</source>
          <target state="translated">Même si <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> n’est pas <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événements peuvent se produire après la <ph id="ph4">&lt;xref:System.Timers.Timer.Dispose%2A&gt;</ph> ou <ph id="ph5">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode a été appelée ou après le <ph id="ph6">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété a été définie sur <ph id="ph7">`false`</ph>, car le signal pour déclencher le <ph id="ph8">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est toujours en file d’attente pour l’exécution sur un thread de pool de threads.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>One way to resolve this race condition is to set a flag that tells the event handler for the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event to ignore subsequent events.</source>
          <target state="translated">Une façon de résoudre cette condition d’engorgement consiste à définir un indicateur qui indique le Gestionnaire d’événements pour le <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement à ignorer les événements suivants.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>If you use the <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> class with a user interface element, such as a form or control, without placing the timer on that user interface element, assign the form or control that contains the <ph id="ph2">&lt;xref:System.Timers.Timer&gt;</ph> to the <ph id="ph3">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> property, so that the event is marshaled to the user interface thread.</source>
          <target state="translated">Si vous utilisez la <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> classe avec un élément d’interface utilisateur, tels qu’un formulaire ou un contrôle, sans placer la minuterie sur cet élément d’interface utilisateur, assignez le formulaire ou un contrôle qui contient le <ph id="ph2">&lt;xref:System.Timers.Timer&gt;</ph> à la <ph id="ph3">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> propriété, afin que l’événement est marshalés vers le thread d’interface utilisateur.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>For a list of default property values for an instance of <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph>, see the <ph id="ph2">&lt;xref:System.Timers.Timer.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">Pour obtenir la liste des valeurs de propriété par défaut d’une instance de <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph>, consultez la <ph id="ph2">&lt;xref:System.Timers.Timer.%23ctor%2A&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>Be aware that .NET includes four classes named <ph id="ph1">`Timer`</ph>, each of which offers different functionality:</source>
          <target state="translated">Gardez à l’esprit que .NET inclut quatre classes nommées <ph id="ph1">`Timer`</ph>, chaque de qui offre des fonctionnalités différentes :</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source><ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> (this topic): fires an event at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> (cette rubrique) : déclenche un événement à intervalles réguliers.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</source>
          <target state="translated">La classe est destinée à en tant que la basée sur un serveur ou les composants de service dans un environnement multithread ; Il ne dispose d’aucune interface utilisateur et n’est pas visible lors de l’exécution.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph>: executes a single callback method on a thread pool thread at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph>: exécute une méthode de rappel unique sur un thread de pool de threads à intervalles réguliers.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The callback method is defined when the timer is instantiated and cannot be changed.</source>
          <target state="translated">La méthode de rappel est définie lorsque la minuterie est instanciée et ne peut pas être modifiée.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>Like the <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> class, this class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</source>
          <target state="translated">Comme le <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> (classe), cette classe est destinée à être utilisée comme un composant basé sur le serveur ou le service dans un environnement multithread ; elle ne dispose d’aucune interface utilisateur et n’est pas visible lors de l’exécution.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> (.NET Framework only): a Windows Forms component that fires an event at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> (.NET framework uniquement) : un composant Windows Forms qui déclenche un événement à intervalles réguliers.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The component has no user interface and is designed for use in a single-threaded environment.</source>
          <target state="translated">Le composant a pas d’interface utilisateur et est conçu pour une utilisation dans un environnement monothread.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source><ph id="ph1">&lt;xref:System.Web.UI.Timer?displayProperty=nameWithType&gt;</ph> (.NET Framework only): an ASP.NET component that performs asynchronous or synchronous web page postbacks at a regular interval.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Timer?displayProperty=nameWithType&gt;</ph> (.NET framework uniquement) : un composant ASP.NET qui effectue des publications de pages web asynchrones ou synchrones à intervalles réguliers.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The following example instantiates a <ph id="ph1">`System.Timers.Timer`</ph> object that fires its <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer.</source>
          <target state="translated">L’exemple suivant instancie un <ph id="ph1">`System.Timers.Timer`</ph> objet qui déclenche son <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>The event handler displays the value of the <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> property each time it is raised.</source>
          <target state="translated">Le Gestionnaire d’événements affiche la valeur de la <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> propriété chaque fois qu’il est déclenché.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>Any public <ph id="ph1">&lt;see langword="static" /&gt;</ph> members of this type are thread safe.</source>
          <target state="translated">N’importe quel public <ph id="ph1">&lt;see langword="static" /&gt;</ph> de ce type sont thread-safe.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Timers.Timer">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">Il n'est pas garanti que les membres d'instance soient thread-safe.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="T:System.Timers.Timer">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> class, and sets all the properties to their initial values.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> et affecte à toutes les propriétés leurs valeurs initiales.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.#ctor">
          <source>The following table shows initial property values for an instance of <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph>.</source>
          <target state="translated">Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.#ctor">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.#ctor">
          <source>Initial value</source>
          <target state="translated">Valeur initiale</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.#ctor">
          <source>100 milliseconds</source>
          <target state="translated">100 millisecondes</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.#ctor">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).</source>
          <target state="translated">Référence Null (<ph id="ph1">`Nothing`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.#ctor">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> object that fires its <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer.</source>
          <target state="translated">L’exemple suivant instancie un <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> objet qui déclenche son <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.#ctor">
          <source>The event handler displays the value of the <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> property each time it is raised.</source>
          <target state="translated">Le Gestionnaire d’événements affiche la valeur de la <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> propriété chaque fois qu’il est déclenché.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.#ctor(System.Double)">
          <source>The time, in milliseconds, between events.</source>
          <target state="translated">Intervalle, en millisecondes, entre les événements.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.#ctor(System.Double)">
          <source>The value must be greater than zero and less than or equal to <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La valeur doit être supérieure à zéro et inférieure ou égale à <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.#ctor(System.Double)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> class, and sets the <ph id="ph2">&lt;see cref="P:System.Timers.Timer.Interval" /&gt;</ph> property to the specified number of milliseconds.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> et affecte le nombre spécifié de millisecondes à la propriété <ph id="ph2">&lt;see cref="P:System.Timers.Timer.Interval" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.#ctor(System.Double)">
          <source>This constructor sets the <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property of the new timer instance, but does not enable the timer.</source>
          <target state="translated">Ce constructeur définit la <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> propriété de la nouvelle instance de la minuterie, mais n’active ne pas la minuterie.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.#ctor(System.Double)">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> object that fires its <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer.</source>
          <target state="translated">L’exemple suivant instancie un <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> objet qui déclenche son <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.#ctor(System.Double)">
          <source>The event handler displays the value of the <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> property each time it is raised.</source>
          <target state="translated">Le Gestionnaire d’événements affiche la valeur de la <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> propriété chaque fois qu’il est déclenché.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.#ctor(System.Double)">
          <source>The value of the <ph id="ph1">&lt;paramref name="interval" /&gt;</ph> parameter is less than or equal to zero, or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La valeur du paramètre <ph id="ph1">&lt;paramref name="interval" /&gt;</ph> doit être inférieure ou égale à zéro, ou supérieure à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="P:System.Timers.Timer.AutoReset">
          <source>Gets or sets a Boolean indicating whether the <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> should raise the <ph id="ph2">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> event only once (<ph id="ph3">&lt;see langword="false" /&gt;</ph>) or repeatedly (<ph id="ph4">&lt;see langword="true" /&gt;</ph>).</source>
          <target state="translated">Obtient ou définit une valeur booléenne indiquant si <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> doit déclencher l'événement <ph id="ph2">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> une seule fois (<ph id="ph3">&lt;see langword="false" /&gt;</ph>) ou de façon répétée (<ph id="ph4">&lt;see langword="true" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.AutoReset">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> should raise the <ph id="ph3">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> event each time the interval elapses; <ph id="ph4">&lt;see langword="false" /&gt;</ph> if it should raise the <ph id="ph5">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> event only once, after the first time the interval elapses.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> doit déclencher l'événement <ph id="ph3">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> chaque fois que l'intervalle expire ; <ph id="ph4">&lt;see langword="false" /&gt;</ph> s'il doit déclencher l'événement <ph id="ph5">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> une seule fois, à la première expiration de l'intervalle.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.AutoReset">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.AutoReset">
          <source>If the <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> is already enabled when the <ph id="ph2">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> method is called, the interval is reset.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> est déjà activé lorsque la <ph id="ph2">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> est appelée, l’intervalle est réinitialisé.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.AutoReset">
          <source>If <ph id="ph1">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> is <ph id="ph2">`false`</ph>, the <ph id="ph3">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> method must be called in order to start the count again.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> est <ph id="ph2">`false`</ph>, le <ph id="ph3">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> méthode doit être appelée afin de redémarrer le compteur.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.AutoReset">
          <source>Resetting the interval affects when the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is raised.</source>
          <target state="translated">Réinitialisation de l’intervalle prend effet lorsque les <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est déclenché.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.AutoReset">
          <source>For example, if you set the interval to 5 seconds and then set the <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property to <ph id="ph2">`true`</ph>, the count starts at the time <ph id="ph3">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> is set.</source>
          <target state="translated">Par exemple, si vous définissez l’intervalle à 5 secondes, puis affectez le <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>, le compteur démarre à l’heure <ph id="ph3">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> est définie.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.AutoReset">
          <source>If you reset the interval to 10 seconds when the count is 3 seconds, the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is raised for the first time 13 seconds after the <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property was set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Si vous réinitialisez l’intervalle à 10 secondes lorsque le compteur est à 3 secondes, la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est déclenché pour la première fois 13 secondes après que le <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> a pris la valeur de propriété <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.AutoReset">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> whose <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event fires after 1.5 seconds.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> dont <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement se déclenche après 1,5 seconde.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.AutoReset">
          <source>Its event handler then displays "Hello World!"</source>
          <target state="translated">Puis, son gestionnaire d’événements affiche « Hello World ! »</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.AutoReset">
          <source>on the console.</source>
          <target state="translated">sur la console.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.BeginInit">
          <source>Begins the run-time initialization of a <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> that is used on a form or by another component.</source>
          <target state="translated">Débute l'initialisation au moment de l'exécution d'un <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> utilisé sur un formulaire ou par un autre composant.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.BeginInit">
          <source>The <ph id="ph1">[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]</ph> design environment uses this method to start the initialization of a component that is used on a form or by another component.</source>
          <target state="translated">Le <ph id="ph1">[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]</ph> environnement utilise cette méthode pour démarrer l’initialisation d’un composant qui est utilisé dans un formulaire ou par un autre composant de conception.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.BeginInit">
          <source>The <ph id="ph1">&lt;xref:System.Timers.Timer.EndInit%2A&gt;</ph> method ends the initialization.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Timers.Timer.EndInit%2A&gt;</ph> méthode termine l’initialisation.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.BeginInit">
          <source>Using the <ph id="ph1">&lt;xref:System.Timers.Timer.BeginInit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Timers.Timer.EndInit%2A&gt;</ph> methods prevents the control from being used before it is fully initialized.</source>
          <target state="translated">À l’aide de la <ph id="ph1">&lt;xref:System.Timers.Timer.BeginInit%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Timers.Timer.EndInit%2A&gt;</ph> méthodes empêche le contrôle avant son initialisation complète.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.Close">
          <source>Releases the resources used by the <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph>.</source>
          <target state="translated">Libère les ressources utilisées par le <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Close">
          <source>The <ph id="ph1">&lt;xref:System.Timers.Timer.Close%2A&gt;</ph> method in turn calls the <ph id="ph2">`Dispose`</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Timers.Timer.Close%2A&gt;</ph> méthode appelle à son tour le <ph id="ph2">`Dispose`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour libérer les ressources managées et non managées ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour ne libérer que les ressources non managées.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.Dispose(System.Boolean)">
          <source>Releases all resources used by the current <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph>.</source>
          <target state="translated">Libère toutes les ressources utilisées par le <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="E:System.Timers.Timer.Elapsed">
          <source>Occurs when the interval elapses.</source>
          <target state="translated">Se produit quand l'intervalle est écoulé.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>The <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is raised if the <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property is <ph id="ph3">`true`</ph> and the time interval (in milliseconds) defined by the <ph id="ph4">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property elapses.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est déclenché si la <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété est <ph id="ph3">`true`</ph> et l’intervalle de temps (en millisecondes) défini par le <ph id="ph4">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> au terme de la propriété.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>If the <ph id="ph1">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> property is <ph id="ph2">`true`</ph>, the event is raised repeatedly at an interval defined by the <ph id="ph3">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property; otherwise, the event is raised only once, the first time the <ph id="ph4">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> value elapses.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> propriété est <ph id="ph2">`true`</ph>, l’événement est déclenché à plusieurs reprises à un intervalle défini par le <ph id="ph3">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> propriété ; sinon, l’événement est déclenché qu’une seule fois, la première fois le <ph id="ph4">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> valeur d’expiration.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>If <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> is set after the <ph id="ph2">&lt;xref:System.Timers.Timer&gt;</ph> has started, the count is reset.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> est défini après le <ph id="ph2">&lt;xref:System.Timers.Timer&gt;</ph> a démarré, le compteur est réinitialisé.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>For example, if you set the interval to 5 seconds and then set <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> to <ph id="ph2">`true`</ph>, the count starts at the time <ph id="ph3">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> is set.</source>
          <target state="translated">Par exemple, si vous définissez l’intervalle à 5 secondes, puis affectez <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> à <ph id="ph2">`true`</ph>, le compteur démarre à l’heure <ph id="ph3">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> est définie.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>If you reset the interval to 10 seconds when count is 3 seconds, the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is raised for the first time 13 seconds after <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> was set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Si vous réinitialisez l’intervalle à 10 secondes lorsque le compteur est trois secondes, la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est déclenché pour la première fois 13 secondes après que <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> a été défini sur <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>If the <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> property is <ph id="ph2">`null`</ph>,the <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is raised on a <ph id="ph4">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> propriété <ph id="ph2">`null`</ph>, le <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est déclenché sur un <ph id="ph4">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>If the processing of the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event lasts longer than <ph id="ph2">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph>, the event might be raised again on another <ph id="ph3">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</source>
          <target state="translated">Si le traitement de la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> dure événement plus longtemps que <ph id="ph2">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph>, l’événement peut être déclenché à nouveau sur un autre <ph id="ph3">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>In this situation, the event handler should be reentrant.</source>
          <target state="translated">Dans ce cas, le Gestionnaire d’événements doit être réentrant.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>The event-handling method might run on one thread at the same time that another thread calls the <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method or sets the <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">La méthode de gestion d’événements peut s’exécuter sur un thread en même temps qu’un autre thread appelle la <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode ou définit le <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>This might result in the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event being raised after the timer is stopped.</source>
          <target state="translated">Cela peut entraîner la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement déclenché après l’arrêt du minuteur.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>The example code for the <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method shows one way to avoid this race condition.</source>
          <target state="translated">L’exemple de code pour le <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode montre une manière d’éviter cette condition de concurrence critique.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>Even if <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> is not <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> events can occur after the <ph id="ph4">&lt;xref:System.Timers.Timer.Dispose%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method has been called or after the <ph id="ph6">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property has been set to <ph id="ph7">`false`</ph>, because the signal to raise the <ph id="ph8">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is always queued for execution on a thread pool thread.</source>
          <target state="translated">Même si <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> n’est pas <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événements peuvent se produire après la <ph id="ph4">&lt;xref:System.Timers.Timer.Dispose%2A&gt;</ph> ou <ph id="ph5">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode a été appelée ou après le <ph id="ph6">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété a été définie sur <ph id="ph7">`false`</ph>, car le signal pour déclencher le <ph id="ph8">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est toujours en file d’attente pour l’exécution sur un thread de pool de threads.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>One way to resolve this race condition is to set a flag that tells the event handler for the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event to ignore subsequent events.</source>
          <target state="translated">Une façon de résoudre cette condition d’engorgement consiste à définir un indicateur qui indique le Gestionnaire d’événements pour le <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement à ignorer les événements suivants.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>The <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> component catches and suppresses all exceptions thrown by event handlers for the <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> composant intercepte et supprime toutes les exceptions levées par les gestionnaires d’événements pour le <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>This behavior is subject to change in future releases of the .NET Framework.</source>
          <target state="translated">Ce comportement est susceptible de changer dans les futures versions du .NET Framework.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> object that fires its <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer.</source>
          <target state="translated">L’exemple suivant instancie un <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> objet qui déclenche son <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Timers.Timer.Elapsed">
          <source>The event handler displays the value of the <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> property each time it is raised.</source>
          <target state="translated">Le Gestionnaire d’événements affiche la valeur de la <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> propriété chaque fois qu’il est déclenché.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="P:System.Timers.Timer.Enabled">
          <source>Gets or sets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> should raise the <ph id="ph2">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> event.</source>
          <target state="translated">Obtient ou définit une valeur indiquant si <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> doit déclencher l'événement <ph id="ph2">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> should raise the <ph id="ph3">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> event; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> doit déclencher l'événement <ph id="ph3">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>Setting <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> to <ph id="ph2">`true`</ph> is the same as calling <ph id="ph3">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph>, while setting <ph id="ph4">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> to <ph id="ph5">`false`</ph> is the same as calling <ph id="ph6">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph>.</source>
          <target state="translated">Paramètre <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> à <ph id="ph2">`true`</ph> est le même que l’appel <ph id="ph3">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph>, tandis que le paramètre <ph id="ph4">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> à <ph id="ph5">`false`</ph> est le même que l’appel <ph id="ph6">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>The signal to raise the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is always queued for execution on a <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</source>
          <target state="translated">Le signal pour déclencher le <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est toujours en file d’attente pour l’exécution sur un <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>This might result in the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event being raised after the <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property is set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Cela peut entraîner la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement déclenché après la <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> est définie sur <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>The code example for the <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method shows one way to work around this race condition.</source>
          <target state="translated">L’exemple de code pour le <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode montre une façon de contourner cette condition d’engorgement.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>If <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> is set to <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> is set to <ph id="ph4">`false`</ph>, the <ph id="ph5">&lt;xref:System.Timers.Timer&gt;</ph> raises the <ph id="ph6">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event only once, the first time the interval elapses.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> a la valeur <ph id="ph2">`true`</ph> et <ph id="ph3">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> a la valeur <ph id="ph4">`false`</ph>, le <ph id="ph5">&lt;xref:System.Timers.Timer&gt;</ph> déclenche le <ph id="ph6">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement une seule fois, la première fois que l’intervalle est écoulé.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>If the interval is set after the <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> has started, the count is reset.</source>
          <target state="translated">Si l’intervalle est défini après le <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> a démarré, le compteur est réinitialisé.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>For example, if you set the interval to 5 seconds and then set the <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property to <ph id="ph2">`true`</ph>, the count starts at the time <ph id="ph3">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> is set.</source>
          <target state="translated">Par exemple, si vous définissez l’intervalle à 5 secondes, puis affectez le <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>, le compteur démarre à l’heure <ph id="ph3">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> est définie.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>If you reset the interval to 10 seconds when count is 3 seconds, the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is raised for the first time 13 seconds after <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> was set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Si vous réinitialisez l’intervalle à 10 secondes lorsque le compteur est trois secondes, la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est déclenché pour la première fois 13 secondes après que <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> a été défini sur <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>Some visual designers, such as those in Microsoft Visual Studio, set the <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property to <ph id="ph2">`true`</ph> when inserting a new <ph id="ph3">&lt;xref:System.Timers.Timer&gt;</ph>.</source>
          <target state="translated">Certains concepteurs visuels, telles que celles dans Microsoft Visual Studio, définissent la <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété <ph id="ph2">`true`</ph> lors de l’insertion d’un nouveau <ph id="ph3">&lt;xref:System.Timers.Timer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> object that fires its <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> event every two seconds (2000 milliseconds), sets up an event handler for the  event, and starts the timer.</source>
          <target state="translated">L’exemple suivant instancie un <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> objet qui déclenche son <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Enabled">
          <source>The event handler displays the value of the <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> property each time it is raised.</source>
          <target state="translated">Le Gestionnaire d’événements affiche la valeur de la <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> propriété chaque fois qu’il est déclenché.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="P:System.Timers.Timer.Enabled">
          <source>This property cannot be set because the timer has been disposed.</source>
          <target state="translated">Cette propriété ne peut pas être définie, car la minuterie a été supprimée.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="P:System.Timers.Timer.Enabled">
          <source>The <ph id="ph1">&lt;see cref="P:System.Timers.Timer.Interval" /&gt;</ph> property was set to a value greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> before the timer was enabled.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.Timers.Timer.Interval" /&gt;</ph> a eu une valeur supérieure à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> avant que la minuterie ait été activée.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.EndInit">
          <source>Ends the run-time initialization of a <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> that is used on a form or by another component.</source>
          <target state="translated">Met fin à l'initialisation au moment de l'exécution d'un <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> utilisé sur un formulaire ou par un autre composant.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.EndInit">
          <source>The <ph id="ph1">[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]</ph> design environment uses this method to end the initialization of a component that is used on a form or by another component.</source>
          <target state="translated">Le <ph id="ph1">[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]</ph> environnement utilise cette méthode pour terminer l’initialisation d’un composant qui est utilisé dans un formulaire ou par un autre composant de conception.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.EndInit">
          <source>The <ph id="ph1">&lt;xref:System.Timers.Timer.BeginInit%2A&gt;</ph> method starts the initialization.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Timers.Timer.BeginInit%2A&gt;</ph> méthode démarre l’initialisation.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.EndInit">
          <source>Using the <ph id="ph1">&lt;xref:System.Timers.Timer.BeginInit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Timers.Timer.EndInit%2A&gt;</ph> methods prevents the control from being used before it is fully initialized.</source>
          <target state="translated">À l’aide de la <ph id="ph1">&lt;xref:System.Timers.Timer.BeginInit%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Timers.Timer.EndInit%2A&gt;</ph> méthodes empêche le contrôle avant son initialisation complète.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="P:System.Timers.Timer.Interval">
          <source>Gets or sets the interval, expressed in milliseconds, at which to raise the <ph id="ph1">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> event.</source>
          <target state="translated">Obtient ou définit l'intervalle, exprimé en millisecondes, auquel l'événement <ph id="ph1">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> doit être déclenché.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>The time, in milliseconds, between <ph id="ph1">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> events.</source>
          <target state="translated">Intervalle en millisecondes séparant les événements <ph id="ph1">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>The value must be greater than zero, and less than or equal to <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La valeur doit être supérieure à zéro et inférieure ou égale à <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>The default is 100 milliseconds.</source>
          <target state="translated">La valeur par défaut est 100 millisecondes.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>You use the <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property to determine the frequency at which the <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is fired.</source>
          <target state="translated">Vous utilisez la <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> propriété pour déterminer la fréquence à laquelle le <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est déclenché.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>Because the <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> class depends on the system clock, it has the same resolution as the system clock.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> classe dépend de l’horloge système, il a la même résolution que l’horloge système.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>This means that the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event will fire at an interval defined by the resolution of the system clock if the <ph id="ph2">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property is less than the resolution of the system clock.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement se déclenche selon un intervalle défini par la résolution de l’horloge système si le <ph id="ph2">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> propriété est inférieure à la résolution de l’horloge système.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>The following example sets the <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property to 5 milliseconds.</source>
          <target state="translated">L’exemple suivant définit le <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> propriété 5 millisecondes.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>When run on a <ph id="ph1">[!INCLUDE[win7](~/includes/win7-md.md)]</ph> system whose system clock has a resolution of approximately 15 milliseconds, the event fires approximately every 15 milliseconds rather than every 5 milliseconds.</source>
          <target state="translated">Sur un <ph id="ph1">[!INCLUDE[win7](~/includes/win7-md.md)]</ph> système dont l’horloge système a une résolution d’environ 15 millisecondes, l’événement se déclenche toutes les 15 millisecondes environ plutôt que toutes les 5 millisecondes.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>You can use the following code to determine the resolution of the system clock on the current system:</source>
          <target state="translated">Vous pouvez utiliser le code suivant pour déterminer la résolution de l’horloge système sur le système actuel :</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>If your app requires greater resolution than that offered by the <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> class or the system clock, use the high-resolution multimedia timers; see <bpt id="p1">[</bpt>How to: Use the High-Resolution Timer<ept id="p1">](http://msdn.microsoft.com/library/aa964692.aspx)</ept>.</source>
          <target state="translated">Si votre application nécessite une résolution supérieure à celle offerte par le <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> classe ou l’horloge système, utilisez les minuteurs de haute résolution, consultez <bpt id="p1">[</bpt>Comment : utiliser le minuteur haute résolution<ept id="p1">](http://msdn.microsoft.com/library/aa964692.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>If the interval is set after the <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> has started, the count is reset.</source>
          <target state="translated">Si l’intervalle est défini après le <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> a démarré, le compteur est réinitialisé.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>For example, if you set the interval to 5 seconds and then set the <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property to <ph id="ph2">`true`</ph>, the count starts at the time <ph id="ph3">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> is set.</source>
          <target state="translated">Par exemple, si vous définissez l’intervalle à 5 secondes, puis affectez le <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>, le compteur démarre à l’heure <ph id="ph3">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> est définie.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>If you reset the interval to 10 seconds when count is 3 seconds, the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is raised for the first time 13 seconds after <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> was set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Si vous réinitialisez l’intervalle à 10 secondes lorsque le compteur est trois secondes, la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est déclenché pour la première fois 13 secondes après que <ph id="ph2">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> a été défini sur <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>If <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> is set to <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> is set to <ph id="ph4">`false`</ph>, the <ph id="ph5">&lt;xref:System.Timers.Timer&gt;</ph> raises the <ph id="ph6">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event only once, the first time the interval elapses.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> a la valeur <ph id="ph2">`true`</ph> et <ph id="ph3">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> a la valeur <ph id="ph4">`false`</ph>, le <ph id="ph5">&lt;xref:System.Timers.Timer&gt;</ph> déclenche le <ph id="ph6">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement une seule fois, la première fois que l’intervalle est écoulé.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source><ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> is then set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> est ensuite affectée à <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>If <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> are both set to <ph id="ph3">`false`</ph>, and the timer has previously been enabled, setting the <ph id="ph4">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property causes the <ph id="ph5">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event to be raised once, as if the <ph id="ph6">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property had been set to <ph id="ph7">`true`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> sont toutes deux définies sur <ph id="ph3">`false`</ph>, et le minuteur a été précédemment activé, définition de la <ph id="ph4">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> causes de la propriété le <ph id="ph5">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement soit déclenché une fois, comme si le <ph id="ph6">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété a été définie pour <ph id="ph7">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>To set the interval without raising the event, you can temporarily set the <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property to <ph id="ph2">`true`</ph>, set the <ph id="ph3">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property to the desired time interval, and then immediately set the <ph id="ph4">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property back to <ph id="ph5">`false`</ph>.</source>
          <target state="translated">Pour définir l’intervalle sans déclencher l’événement, vous pouvez temporairement définir le <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>, définissez le <ph id="ph3">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> propriété pour l’intervalle de temps de votre choix, puis immédiatement définissez le <ph id="ph4">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété sauvegarder sur <ph id="ph5">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> object that fires its <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer.</source>
          <target state="translated">L’exemple suivant instancie un <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> objet qui déclenche son <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Interval">
          <source>The event handler displays the value of the <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> property each time it is raised.</source>
          <target state="translated">Le Gestionnaire d’événements affiche la valeur de la <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> propriété chaque fois qu’il est déclenché.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.Timers.Timer.Interval">
          <source>The interval is less than or equal to zero.</source>
          <target state="translated">L'intervalle est inférieur ou égal à zéro.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="P:System.Timers.Timer.Interval">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="P:System.Timers.Timer.Interval">
          <source>The interval is greater than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, and the timer is currently enabled.</source>
          <target state="translated">L'intervalle est supérieur à <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> et la minuterie est actuellement activée.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="P:System.Timers.Timer.Interval">
          <source>(If the timer is not currently enabled, no exception is thrown until it becomes enabled.)</source>
          <target state="translated">(Si la minuterie n'est pas activée actuellement, aucune exception n'est levée jusqu'à ce qu'elle soit activée.)</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.Timers.Timer.Site">
          <source>Gets or sets the site that binds the <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> to its container in design mode.</source>
          <target state="translated">Obtient ou définit le site qui lie <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> à son conteneur en mode design.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Site">
          <source>An <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> interface representing the site that binds the <ph id="ph2">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> object to its container.</source>
          <target state="translated">Interface <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> représentant le site qui lie l'objet <ph id="ph2">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> à son conteneur.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.Site">
          <source>Sites bind a <ph id="ph1">&lt;xref:System.ComponentModel.Component&gt;</ph> to a <ph id="ph2">&lt;xref:System.ComponentModel.Container&gt;</ph> and enable communication between them, as well as providing a way for the container to manage its components.</source>
          <target state="translated">Sites lient un <ph id="ph1">&lt;xref:System.ComponentModel.Component&gt;</ph> à un <ph id="ph2">&lt;xref:System.ComponentModel.Container&gt;</ph> et activer la communication entre eux, ainsi que fournir un moyen pour le conteneur de gérer ses composants.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.Start">
          <source>Starts raising the <ph id="ph1">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> event by setting <ph id="ph2">&lt;see cref="P:System.Timers.Timer.Enabled" /&gt;</ph> to <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Lance le déclenchement de l'événement <ph id="ph1">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> en affectant à <ph id="ph2">&lt;see cref="P:System.Timers.Timer.Enabled" /&gt;</ph> la valeur <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Start">
          <source>If <ph id="ph1">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> is called and <ph id="ph2">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> is set to <ph id="ph3">`false`</ph>, the <ph id="ph4">&lt;xref:System.Timers.Timer&gt;</ph> raises the <ph id="ph5">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event only once, the first time the interval elapses.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> est appelée et <ph id="ph2">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> a la valeur <ph id="ph3">`false`</ph>, le <ph id="ph4">&lt;xref:System.Timers.Timer&gt;</ph> déclenche le <ph id="ph5">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement une seule fois, la première fois que l’intervalle est écoulé.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Start">
          <source>If <ph id="ph1">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> is called and <ph id="ph2">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> is <ph id="ph3">`true`</ph>, the <ph id="ph4">&lt;xref:System.Timers.Timer&gt;</ph> raises the <ph id="ph5">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event the first time the interval elapses and continues to raise the event on the specified interval.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> est appelée et <ph id="ph2">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> est <ph id="ph3">`true`</ph>, le <ph id="ph4">&lt;xref:System.Timers.Timer&gt;</ph> déclenche le <ph id="ph5">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> heure d’événement du premier l’intervalle est écoulé et continue à déclencher l’événement sur l’intervalle spécifié.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Start">
          <source>You can also start timing by setting <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Vous pouvez également démarrer la minuterie en définissant <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> à <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Start">
          <source>If <ph id="ph1">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> is <ph id="ph2">`false`</ph>, the <ph id="ph3">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> method must be called in order to start the count again.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Timers.Timer.AutoReset%2A&gt;</ph> est <ph id="ph2">`false`</ph>, le <ph id="ph3">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> méthode doit être appelée afin de redémarrer le compteur.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Start">
          <source>A call to the <ph id="ph1">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> method when the timer is enabled has no effect.</source>
          <target state="translated">Un appel à la <ph id="ph1">&lt;xref:System.Timers.Timer.Start%2A&gt;</ph> méthode lorsque la minuterie est activée n’a aucun effet.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.Start">
          <source>The <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> is created with an interval equal to or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> + 1, or set to an interval less than zero.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Timers.Timer" /&gt;</ph> est créé avec un intervalle égal ou supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> + 1, ou est défini à un intervalle inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Timers.Timer.Stop">
          <source>Stops raising the <ph id="ph1">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> event by setting <ph id="ph2">&lt;see cref="P:System.Timers.Timer.Enabled" /&gt;</ph> to <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Arrête le déclenchement de l'événement <ph id="ph1">&lt;see cref="E:System.Timers.Timer.Elapsed" /&gt;</ph> en affectant à <ph id="ph2">&lt;see cref="P:System.Timers.Timer.Enabled" /&gt;</ph> la valeur <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>You can also stop timing by setting <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Vous pouvez également arrêter la temporisation en définissant <ph id="ph1">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> à <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The signal to raise the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is always queued for execution on a <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread, so the event-handling method might run on one thread at the same time that a call to the <ph id="ph3">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method runs on another thread.</source>
          <target state="translated">Le signal pour déclencher le <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est toujours en file d’attente pour l’exécution sur un <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> de threads, donc la méthode de gestion d’événements peut s’exécuter sur un thread en même temps qu’un appel à la <ph id="ph3">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode s’exécute sur un autre thread.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>This might result in the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event being raised after the <ph id="ph2">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method is called.</source>
          <target state="translated">Cela peut entraîner la <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement déclenché après la <ph id="ph2">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The code example in the next section shows one way to work around this race condition.</source>
          <target state="translated">L’exemple de code dans la section suivante montre une façon de contourner cette condition d’engorgement.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The following example instantiates a <ph id="ph1">`System.Timers.Timer`</ph> object that fires its <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer.</source>
          <target state="translated">L’exemple suivant instancie un <ph id="ph1">`System.Timers.Timer`</ph> objet qui déclenche son <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType&gt;</ph> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The event handler displays the value of the <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> property each time it is raised.</source>
          <target state="translated">Le Gestionnaire d’événements affiche la valeur de la <ph id="ph1">&lt;xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType&gt;</ph> propriété chaque fois qu’il est déclenché.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>When the user presses the Enter key, the application calls the  <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method before terminating the application.</source>
          <target state="translated">Lorsque l’utilisateur appuie sur la touche entrée, l’application appelle la <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode avant de mettre fin à l’application.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The following code example shows one way to prevent the thread that calls the <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method from continuing until a currently executing <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event ends, and also to prevent two <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> events from executing the event handler at the same time (often referred to as reentrancy).</source>
          <target state="translated">L’exemple de code suivant montre une façon d’empêcher le thread qui appelle la <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode de se poursuivre jusqu'à ce qu’un en cours d’exécution <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> fin de l’événement et d’empêcher également deux <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événements à partir de l’exécution du Gestionnaire d’événements au niveau du même heure (communément appelée réentrance).</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The example executes 100 test runs.</source>
          <target state="translated">L’exemple exécute 100 séries de tests.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>Each time the test is run, the timer is started with an interval of 150 milliseconds.</source>
          <target state="translated">Chaque fois que le test est exécuté, la minuterie est démarrée avec un intervalle de 150 millisecondes.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The event handler uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to simulate a task that randomly varies in length from 50 to 200 milliseconds.</source>
          <target state="translated">Le Gestionnaire d’événements utilise le <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> méthode pour simuler une tâche qui varie aléatoirement compris entre 50 et 200 millisecondes.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The test method also starts a control thread that waits for a second and then stops the timer.</source>
          <target state="translated">La méthode de test démarre également un thread de contrôle qui attend une seconde, puis arrête la minuterie.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>If an event is being handled when the control thread stops the timer, the control thread must wait until the event is finished before proceeding.</source>
          <target state="translated">Si un événement est traitée lorsque le thread de contrôle arrête la minuterie, le thread de contrôle doit patienter jusqu'à la fin de l’événement avant de continuer.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method overload is used to avoid reentrancy and to prevent the control thread from continuing until an executing event ends.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> surcharge de méthode est utilisée pour éviter la réentrance et pour empêcher le thread de contrôle de continuer jusqu'à la fin d’un événement en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The event handler uses the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method to set a control variable to 1, but only if the value is currently zero.</source>
          <target state="translated">Le Gestionnaire d’événements utilise le <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> méthode pour définir un contrôle variable 1, mais uniquement si la valeur est actuellement zéro.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>This is an atomic operation.</source>
          <target state="translated">Il s’agit d’une opération atomique.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>If the return value is zero, the control variable has been set to 1 and the event handler proceeds.</source>
          <target state="translated">Si la valeur de retour est zéro, la variable de contrôle a été définie sur 1 et le Gestionnaire d’événements se déroule.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>If the return value is non-zero, the event is simply discarded to avoid reentrancy.</source>
          <target state="translated">Si la valeur de retour est différente de zéro, l’événement est simplement ignoré, pour éviter la réentrance.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>(If it were necessary to execute every event, the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class would be a better way to synchronize the events.) When the event handler ends, it sets the control variable back to zero.</source>
          <target state="translated">(S’il s’agissait nécessaire pour l’exécution de chaque événement, le <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> classe serait une meilleure méthode de synchronisation des événements.) Lorsque le Gestionnaire d’événements se termine, il redéfinit la variable de contrôle à zéro.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The example records the total number of events that executed, that were discarded because of reentrancy, and that occurred after the <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method was called.</source>
          <target state="translated">L’exemple enregistre le nombre total d’événements exécutés, qui ont été rejetés en raison de la réentrance, et qui s’est produite après la <ph id="ph1">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode a été appelée.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The control thread uses the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method to set the control variable to -1 (minus one), but only if the value is currently zero.</source>
          <target state="translated">Le thread de contrôle utilise le <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> méthode pour définir le contrôle de la variable en -1 (moins un), mais uniquement si la valeur est actuellement zéro.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>If the atomic operation returns non-zero, an event is currently executing.</source>
          <target state="translated">Si l’opération atomique retourne zéro, un événement est en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The control thread waits and tries again.</source>
          <target state="translated">Le thread de contrôle attend et essaie à nouveau.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Timers.Timer.Stop">
          <source>The example records the number of times the control thread had to wait for an event to finish.</source>
          <target state="translated">L’exemple enregistre le nombre de fois où que le thread de contrôle a dû attendre un événement à la fin.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>Gets or sets the object used to marshal event-handler calls that are issued when an interval has elapsed.</source>
          <target state="translated">Obtient ou définit l'objet utilisé pour marshaler les appels du gestionnaire d'événements émis quand un intervalle a expiré.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>The <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISynchronizeInvoke" /&gt;</ph> representing the object used to marshal the event-handler calls that are issued when an interval has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.ComponentModel.ISynchronizeInvoke" /&gt;</ph> représentant l'objet utilisé pour marshaler les appels du gestionnaire d'événements émis quand un intervalle a expiré.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>The default is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>When <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> is <ph id="ph2">`null`</ph>, the method that handles the <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is called on a thread from the system-thread pool.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> est <ph id="ph2">`null`</ph>, la méthode qui gère le <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est appelé sur un thread du pool de threads système.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>For more information on system-thread pools, see <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur les pools de threads système, consultez <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>When the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is handled by a visual Windows Forms component, such as a button, accessing the component through the system-thread pool might result in an exception or just might not work.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est géré par un composant Windows Forms visuel, tel qu’un bouton, l’accès au composant par le biais du pool de threads système peut les résultats dans une exception ou simplement peut ne pas fonctionner.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>Avoid this effect by setting <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> to a Windows Forms component, which causes the method that handles the <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event to be called on the same thread that the component was created on.</source>
          <target state="translated">Éviter cet effet en définissant <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> à un composant Windows Forms, ce qui entraîne la méthode qui gère le <ph id="ph2">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement à être appelé sur le même thread que le composant a été créé.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>Even if the <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> property is not <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> events can occur after the <ph id="ph4">&lt;xref:System.Timers.Timer.Dispose%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> method has been called or after the <ph id="ph6">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> property has been set to <ph id="ph7">`false`</ph>, because the signal to raise the <ph id="ph8">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event is always queued for execution on a thread pool thread.</source>
          <target state="translated">Même si le <ph id="ph1">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> propriété n’est pas <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événements peuvent se produire après la <ph id="ph4">&lt;xref:System.Timers.Timer.Dispose%2A&gt;</ph> ou <ph id="ph5">&lt;xref:System.Timers.Timer.Stop%2A&gt;</ph> méthode a été appelée ou après le <ph id="ph6">&lt;xref:System.Timers.Timer.Enabled%2A&gt;</ph> propriété a été définie sur <ph id="ph7">`false`</ph>, car le signal pour déclencher le <ph id="ph8">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement est toujours en file d’attente pour l’exécution sur un thread de pool de threads.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>One way to resolve this race condition is to set a flag that tells the event handler for the <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> event to ignore subsequent events.</source>
          <target state="translated">Une façon de résoudre cette condition d’engorgement consiste à définir un indicateur qui indique le Gestionnaire d’événements pour le <ph id="ph1">&lt;xref:System.Timers.Timer.Elapsed&gt;</ph> événement à ignorer les événements suivants.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>If the <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> is used inside Visual Studio in a Windows Forms designer, <ph id="ph2">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> is automatically set to the control that contains the <ph id="ph3">&lt;xref:System.Timers.Timer&gt;</ph>.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> est utilisé dans Visual Studio dans un concepteur Windows Forms, <ph id="ph2">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> est automatiquement défini sur le contrôle qui contient le <ph id="ph3">&lt;xref:System.Timers.Timer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>For example, if you place a <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> on a designer for <ph id="ph2">`Form1`</ph> (which inherits from <ph id="ph3">&lt;xref:System.Windows.Forms.Form&gt;</ph>), the <ph id="ph4">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> property of <ph id="ph5">&lt;xref:System.Timers.Timer&gt;</ph> is set to the instance of <ph id="ph6">`Form1`</ph>.</source>
          <target state="translated">Par exemple, si vous placez un <ph id="ph1">&lt;xref:System.Timers.Timer&gt;</ph> sur un concepteur pour <ph id="ph2">`Form1`</ph> (qui hérite de <ph id="ph3">&lt;xref:System.Windows.Forms.Form&gt;</ph>), la <ph id="ph4">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> propriété du <ph id="ph5">&lt;xref:System.Timers.Timer&gt;</ph> est définie sur l’instance de <ph id="ph6">`Form1`</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>The following example is a Windows Forms app that serves as a very simple text file editor.</source>
          <target state="translated">L’exemple suivant est une application Windows Forms qui sert d’un éditeur de texte simple.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>When the text in the text box has not been saved, the app asks the user at one-minute intervals whether he or she wants to save the contents of the text box.</source>
          <target state="translated">Lorsque le texte dans la zone de texte n’a pas été enregistré, l’application demande à l’utilisateur à des intervalles d’une minute souhaite enregistrer le contenu de la zone de texte.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>To do this, the <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> property is set to one minute (60,000 milliseconds), and the <ph id="ph2">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> property is set to the <ph id="ph3">&lt;xref:System.Windows.Forms.Form&gt;</ph> object.</source>
          <target state="translated">Pour ce faire, le <ph id="ph1">&lt;xref:System.Timers.Timer.Interval%2A&gt;</ph> est définie sur 1 minute (60 000 millisecondes) et le <ph id="ph2">&lt;xref:System.Timers.Timer.SynchronizingObject%2A&gt;</ph> est définie sur la <ph id="ph3">&lt;xref:System.Windows.Forms.Form&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>The example requires that you add the following controls to the form:</source>
          <target state="translated">L’exemple requiert que vous ajoutez les contrôles suivants au formulaire :</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Forms.TextBox&gt;</ph> control named <ph id="ph2">`TextBox1`</ph> (its default name).</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.Forms.TextBox&gt;</ph> contrôle nommé <ph id="ph2">`TextBox1`</ph> (son nom par défaut).</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Forms.Button&gt;</ph> control named <ph id="ph2">`Button1`</ph> (its default name).</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.Forms.Button&gt;</ph> contrôle nommé <ph id="ph2">`Button1`</ph> (son nom par défaut).</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Timers.Timer.SynchronizingObject">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Forms.SaveFileDialog&gt;</ph> control named <ph id="ph2">`SaveSaveFileDialog1`</ph> (its default name) .</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.Forms.SaveFileDialog&gt;</ph> contrôle nommé <ph id="ph2">`SaveSaveFileDialog1`</ph> (son nom par défaut).</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>