<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="79a6b0af70c0710c65111696c47831bcfbd33e64" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39830068" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Génère un événement au bout d'un intervalle défini, avec la possibilité de générer des événements récurrents.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Timers.Timer> composant est un composant timer serveur qui déclenche un <xref:System.Timers.Timer.Elapsed> événements dans votre application après le nombre de millisecondes dans le <xref:System.Timers.Timer.Interval%2A> propriété s’est écoulé. Vous pouvez configurer le <xref:System.Timers.Timer> objet pour déclencher l’événement qu’une seule fois ou à plusieurs reprises à l’aide du <xref:System.Timers.Timer.AutoReset%2A> propriété. En règle générale, un <xref:System.Timers.Timer> objet est déclaré au niveau de la classe afin qu’elle reste dans la portée tant que cela est nécessaire. Vous pouvez ensuite gérer ses <xref:System.Timers.Timer.Elapsed> événement afin de fournir le traitement normal. Par exemple, supposons que vous avez un serveur critique qui doit être conservé en cours d’exécution 24 heures sur 24, 7 jours par semaine. Vous pouvez créer un service qui utilise un <xref:System.Timers.Timer> objet régulièrement de vérifier le serveur et de vous assurer que le système est en cours d’exécution. Si le système ne répond pas, le service peut tenter de redémarrer le serveur ou avertir un administrateur.  
  
> [!IMPORTANT]
> Le <xref:System.Timers.Timer> classe n’est pas disponible pour toutes les implémentations de .NET et les versions, telles que .NET Standard 1.6 et versions inférieures.
> Dans ce cas, vous pouvez utiliser la <xref:System.Threading.Timer?displayProperty=nameWithType> classe à la place.
  
 Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.  
  
 Basée sur le serveur <xref:System.Timers.Timer?displayProperty=nameWithType> classe est conçue pour une utilisation avec des threads de travail dans un environnement multithread. Minuteries serveur peuvent se déplacer entre les threads pour gérer le relief <xref:System.Timers.Timer.Elapsed> événement, ce qui entraîne plus précises que les minuteurs Windows dans le déclenchement de l’événement sur l’heure.  
  
 Le <xref:System.Timers.Timer?displayProperty=nameWithType> composant déclenche le <xref:System.Timers.Timer.Elapsed> événement, basée sur la valeur (en millisecondes) de la <xref:System.Timers.Timer.Interval%2A> propriété. Vous pouvez gérer cet événement pour exécuter le traitement que vous avez besoin. Par exemple, supposons que vous disposez d’une application de vente en ligne qui publie en permanence des commandes à une base de données. Le service qui compile les instructions pour l’expédition exécute un lot de commandes plutôt que de traiter chaque commande individuellement. Vous pouvez utiliser un <xref:System.Timers.Timer> pour démarrer toutes les 30 minutes de traitement par lots.  
  
> [!IMPORTANT]
>  La classe System.Timers.Timer a la même résolution que l’horloge système. Cela signifie que le <xref:System.Timers.Timer.Elapsed> événement se déclenche selon un intervalle défini par la résolution de l’horloge système si le <xref:System.Timers.Timer.Interval%2A> propriété est inférieure à la résolution de l’horloge système. Pour plus d'informations, consultez la propriété <xref:System.Timers.Timer.Interval%2A>.  
  
 Lorsque <xref:System.Timers.Timer.AutoReset%2A> a la valeur `false`, un <xref:System.Timers.Timer?displayProperty=nameWithType> objet déclenche le <xref:System.Timers.Timer.Elapsed> événement une seule fois, après le premier <xref:System.Timers.Timer.Interval%2A> s’est écoulé. Conserver qui déclenche le <xref:System.Timers.Timer.Elapsed> événements régulièrement à l’intervalle défini par le <xref:System.Timers.Timer.Interval%2A>, affectez la valeur <xref:System.Timers.Timer.AutoReset%2A> à `true`, qui est la valeur par défaut.  
  
 Le <xref:System.Timers.Timer> composant intercepte et supprime toutes les exceptions levées par les gestionnaires d’événements pour le <xref:System.Timers.Timer.Elapsed> événement. Ce comportement est susceptible de changer dans les futures versions du .NET Framework. Notez, cependant, qu’il ne s’agit pas d’un vrai des gestionnaires d’événements exécuter de façon asynchrone et incluent la `await` opérateur (en c#) ou le `Await` opérateur (en Visual Basic). Exceptions levées dans ces gestionnaires d’événements sont propagées vers le thread appelant, comme l’illustre l’exemple suivant. Pour plus d’informations sur les exceptions levées dans les méthodes asynchrones, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Si le <xref:System.Timers.Timer.SynchronizingObject%2A> propriété est `null`, le <xref:System.Timers.Timer.Elapsed> événement est déclenché sur un <xref:System.Threading.ThreadPool> thread. Si le traitement de la <xref:System.Timers.Timer.Elapsed> événement dure plus longtemps que <xref:System.Timers.Timer.Interval%2A>, l’événement peut être déclenché à nouveau sur un autre <xref:System.Threading.ThreadPool> thread. Dans ce cas, le Gestionnaire d’événements doit être réentrant.  
  
> [!NOTE]
>  La méthode de gestion d’événements peut s’exécuter sur un thread en même temps qu’un autre thread appelle la <xref:System.Timers.Timer.Stop%2A> méthode ou définit le <xref:System.Timers.Timer.Enabled%2A> propriété `false`. Cela peut entraîner la <xref:System.Timers.Timer.Elapsed> événement déclenché après l’arrêt du minuteur. L’exemple de code pour le <xref:System.Timers.Timer.Stop%2A> méthode montre une manière d’éviter cette condition de concurrence.  
  
 Même si <xref:System.Timers.Timer.SynchronizingObject%2A> n’est pas `null`, <xref:System.Timers.Timer.Elapsed> événements peuvent se produire après la <xref:System.Timers.Timer.Dispose%2A> ou <xref:System.Timers.Timer.Stop%2A> méthode a été appelée ou après le <xref:System.Timers.Timer.Enabled%2A> propriété a été définie sur `false`, car le signal pour déclencher le <xref:System.Timers.Timer.Elapsed> événement est toujours en file d’attente pour l’exécution sur un thread de pool de threads. Une façon de résoudre cette condition de concurrence consiste à définir un indicateur qui indique le Gestionnaire d’événements pour le <xref:System.Timers.Timer.Elapsed> événement à ignorer les événements suivants.  
  
 Si vous utilisez le <xref:System.Timers.Timer?displayProperty=nameWithType> classe avec un élément d’interface utilisateur, tel qu’un formulaire ou un contrôle, sans placer la minuterie sur cet élément d’interface utilisateur, assignez le formulaire ou un contrôle qui contient le <xref:System.Timers.Timer> à la <xref:System.Timers.Timer.SynchronizingObject%2A> propriété, afin que l’événement est marshalés vers le thread d’interface utilisateur.  
  
 Pour obtenir la liste de valeurs de propriété par défaut d’une instance de <xref:System.Timers.Timer>, consultez le <xref:System.Timers.Timer.%23ctor%2A> constructeur.  
  
> [!TIP]
>  N’oubliez pas que .NET inclut quatre classes nommées `Timer`, chacun de qui offre des fonctionnalités différentes :  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (cette rubrique) : déclenche un événement à intervalles réguliers. La classe est destinée à servir basée sur un serveur ou un composant de service dans un environnement multithread ; Il ne possède aucune interface utilisateur et n’est pas visible lors de l’exécution.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: exécute une méthode de rappel unique sur un thread de pool de threads à intervalles réguliers. La méthode de rappel est définie lors de la minuterie est instanciée et ne peut pas être modifiée. Comme le <xref:System.Timers.Timer?displayProperty=nameWithType> (classe), cette classe est destinée à être utilisée comme un composant basé sur le serveur ou service dans un environnement multithread ; il ne possède aucune interface utilisateur et n’est pas visible lors de l’exécution.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (.NET framework uniquement) : un composant Windows Forms qui déclenche un événement à intervalles réguliers. Le composant ne possède pas d’interface utilisateur et est conçu pour une utilisation dans un environnement à thread unique.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (.NET framework uniquement) : un composant ASP.NET qui effectue des publications de page web asynchrones ou synchrones à intervalles réguliers.  

## Examples  
 L’exemple suivant instancie un `System.Timers.Timer` objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), configure un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tout membre <see langword="static" /> de ce type sont thread-safe. Il n'est pas garanti que les membres d'instance soient thread-safe.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Timers.Timer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Timers.Timer" /> et affecte à toutes les propriétés leurs valeurs initiales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Timers.Timer>.  
  
|Property|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 millisecondes|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Référence Null (`Nothing` en Visual Basic).|  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Timers.Timer> objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), configure un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberSignature Language="F#" Value="new System.Timers.Timer : double -&gt; System.Timers.Timer" Usage="new System.Timers.Timer interval" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">Intervalle, en millisecondes, entre les événements. La valeur doit être supérieure à zéro et inférieure ou égale à <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Timers.Timer" /> et affecte le nombre spécifié de millisecondes à la propriété <see cref="P:System.Timers.Timer.Interval" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur affecte la <xref:System.Timers.Timer.Interval%2A> propriété de la nouvelle instance de la minuterie, mais n’active ne pas la minuterie.  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Timers.Timer> objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), configure un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur du paramètre <paramref name="interval" /> doit être inférieure ou égale à zéro, ou supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoReset : bool with get, set" Usage="System.Timers.Timer.AutoReset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Timers.TimersDescription("TimerAutoReset")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur booléenne indiquant si <see cref="T:System.Timers.Timer" /> doit déclencher l'événement <see cref="E:System.Timers.Timer.Elapsed" /> une seule fois (<see langword="false" />) ou de façon répétée (<see langword="true" />).</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Timers.Timer" /> doit déclencher l'événement <see cref="E:System.Timers.Timer.Elapsed" /> chaque fois que l'intervalle expire ; <see langword="false" /> s'il doit déclencher l'événement <see cref="E:System.Timers.Timer.Elapsed" /> une seule fois, à la première expiration de l'intervalle. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Timers.Timer> est déjà activé lorsque la <xref:System.Timers.Timer.Start%2A> est appelée, l’intervalle est réinitialisé. Si <xref:System.Timers.Timer.AutoReset%2A> est `false`, le <xref:System.Timers.Timer.Start%2A> méthode doit être appelée afin de redémarrer le compteur.  
  
 Réinitialisation de l’intervalle prend effet lorsque la <xref:System.Timers.Timer.Elapsed> événement est déclenché. Par exemple, si vous définissez l’intervalle de 5 secondes, puis affectez le <xref:System.Timers.Timer.Enabled%2A> propriété `true`, le compteur démarre au moment <xref:System.Timers.Timer.Enabled%2A> est définie. Si vous réinitialisez l’intervalle à 10 secondes lorsque le compteur est à 3 secondes, le <xref:System.Timers.Timer.Elapsed> événement est déclenché pour la première fois 13 secondes après le <xref:System.Timers.Timer.Enabled%2A> propriété a été définie sur `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Timers.Timer> dont <xref:System.Timers.Timer.Elapsed> événement est déclenché après 1,5 secondes. Son gestionnaire d’événements puis affiche « Hello World ! » sur la console.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="timer.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Débute l'initialisation au moment de l'exécution d'un <see cref="T:System.Timers.Timer" /> utilisé sur un formulaire ou par un autre composant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] environnement utilise cette méthode pour démarrer l’initialisation d’un composant qui est utilisé dans un formulaire ou par un autre composant de conception. Le <xref:System.Timers.Timer.EndInit%2A> méthode termine l’initialisation. À l’aide de la <xref:System.Timers.Timer.BeginInit%2A> et <xref:System.Timers.Timer.EndInit%2A> méthodes empêche le contrôle de l’utilisation avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="timer.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par le <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Timers.Timer.Close%2A> méthode appelle à son tour le `Dispose` (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère toutes les ressources utilisées par le <see cref="T:System.Timers.Timer" /> actuel.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberSignature Language="F#" Value="member this.Elapsed : System.Timers.ElapsedEventHandler " Usage="member this.Elapsed : System.Timers.ElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Timers.TimersDescription("TimerIntervalElapsed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l'intervalle est écoulé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Timers.Timer.Elapsed> événement est déclenché si le <xref:System.Timers.Timer.Enabled%2A> propriété est `true` et l’intervalle de temps (en millisecondes) défini par le <xref:System.Timers.Timer.Interval%2A> au terme de la propriété. Si le <xref:System.Timers.Timer.AutoReset%2A> propriété est `true`, l’événement est déclenché à plusieurs reprises à un intervalle défini par le <xref:System.Timers.Timer.Interval%2A> propriété ; sinon, l’événement est déclenché une seule fois, la première fois le <xref:System.Timers.Timer.Interval%2A> valeur d’expiration.  
  
 Si <xref:System.Timers.Timer.Interval%2A> est définie après la <xref:System.Timers.Timer> a démarré, le nombre est réinitialisé. Par exemple, si vous définissez l’intervalle de 5 secondes, puis affectez <xref:System.Timers.Timer.Enabled%2A> à `true`, le compteur démarre au moment <xref:System.Timers.Timer.Enabled%2A> est définie. Si vous réinitialisez l’intervalle à 10 secondes lorsque le nombre est 3 secondes, le <xref:System.Timers.Timer.Elapsed> événement est déclenché pour la première fois 13 secondes après <xref:System.Timers.Timer.Enabled%2A> a été défini sur `true`.  
  
 Si le <xref:System.Timers.Timer.SynchronizingObject%2A> propriété est `null`, le <xref:System.Timers.Timer.Elapsed> événement est déclenché sur un <xref:System.Threading.ThreadPool> thread. Si le traitement de la <xref:System.Timers.Timer.Elapsed> événement dure plus longtemps que <xref:System.Timers.Timer.Interval%2A>, l’événement peut être déclenché à nouveau sur un autre <xref:System.Threading.ThreadPool> thread. Dans ce cas, le Gestionnaire d’événements doit être réentrant.  
  
> [!NOTE]
>  La méthode de gestion d’événements peut s’exécuter sur un thread en même temps qu’un autre thread appelle la <xref:System.Timers.Timer.Stop%2A> méthode ou définit le <xref:System.Timers.Timer.Enabled%2A> propriété `false`. Cela peut entraîner la <xref:System.Timers.Timer.Elapsed> événement déclenché après l’arrêt du minuteur. L’exemple de code pour le <xref:System.Timers.Timer.Stop%2A> méthode montre une manière d’éviter cette condition de concurrence.  
  
 Même si <xref:System.Timers.Timer.SynchronizingObject%2A> n’est pas `null`, <xref:System.Timers.Timer.Elapsed> événements peuvent se produire après la <xref:System.Timers.Timer.Dispose%2A> ou <xref:System.Timers.Timer.Stop%2A> méthode a été appelée ou après le <xref:System.Timers.Timer.Enabled%2A> propriété a été définie sur `false`, car le signal pour déclencher le <xref:System.Timers.Timer.Elapsed> événement est toujours en file d’attente pour l’exécution sur un thread de pool de threads. Une façon de résoudre cette condition de concurrence consiste à définir un indicateur qui indique le Gestionnaire d’événements pour le <xref:System.Timers.Timer.Elapsed> événement à ignorer les événements suivants.  
  
 Le <xref:System.Timers.Timer> composant intercepte et supprime toutes les exceptions levées par les gestionnaires d’événements pour le <xref:System.Timers.Timer.Elapsed> événement. Ce comportement est susceptible de changer dans les futures versions du .NET Framework.  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Timers.Timer> objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), configure un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Timers.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Timers.TimersDescription("TimerEnabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si <see cref="T:System.Timers.Timer" /> doit déclencher l'événement <see cref="E:System.Timers.Timer.Elapsed" />.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Timers.Timer" /> doit déclencher l'événement <see cref="E:System.Timers.Timer.Elapsed" /> ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Paramètre <xref:System.Timers.Timer.Enabled%2A> à `true` est le même que si vous appelez <xref:System.Timers.Timer.Start%2A>, tandis que le paramètre <xref:System.Timers.Timer.Enabled%2A> à `false` est le même que si vous appelez <xref:System.Timers.Timer.Stop%2A>.  
  
> [!NOTE]
>  Le signal pour déclencher le <xref:System.Timers.Timer.Elapsed> événement est toujours en file d’attente pour l’exécution sur un <xref:System.Threading.ThreadPool> thread. Cela peut entraîner la <xref:System.Timers.Timer.Elapsed> événement déclenché après le <xref:System.Timers.Timer.Enabled%2A> propriété est définie sur `false`. L’exemple de code pour le <xref:System.Timers.Timer.Stop%2A> méthode illustre une façon de contourner cette condition de concurrence.  
  
 Si <xref:System.Timers.Timer.Enabled%2A> a la valeur `true` et <xref:System.Timers.Timer.AutoReset%2A> a la valeur `false`, le <xref:System.Timers.Timer> déclenche le <xref:System.Timers.Timer.Elapsed> événement une seule fois, la première fois que l’intervalle est écoulé.  
  
 Si l’intervalle est défini après la <xref:System.Timers.Timer> a démarré, le nombre est réinitialisé. Par exemple, si vous définissez l’intervalle de 5 secondes, puis affectez le <xref:System.Timers.Timer.Enabled%2A> propriété `true`, le compteur démarre au moment <xref:System.Timers.Timer.Enabled%2A> est définie. Si vous réinitialisez l’intervalle à 10 secondes lorsque le nombre est 3 secondes, le <xref:System.Timers.Timer.Elapsed> événement est déclenché pour la première fois 13 secondes après <xref:System.Timers.Timer.Enabled%2A> a été défini sur `true`.  
  
> [!NOTE]
>  Certains concepteurs visuels, telles que celles dans Microsoft Visual Studio, définissent le <xref:System.Timers.Timer.Enabled%2A> propriété `true` lorsque vous insérez un nouveau <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Timers.Timer> objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), configure un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cette propriété ne peut pas être définie, car la minuterie a été supprimée.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Timers.Timer.Interval" /> a eu une valeur supérieure à <see cref="F:System.Int32.MaxValue" /> avant que la minuterie ait été activée.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="timer.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met fin à l'initialisation au moment de l'exécution d'un <see cref="T:System.Timers.Timer" /> utilisé sur un formulaire ou par un autre composant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] environnement utilise cette méthode pour terminer l’initialisation d’un composant qui est utilisé dans un formulaire ou par un autre composant de conception. Le <xref:System.Timers.Timer.BeginInit%2A> méthode démarre l’initialisation. À l’aide de la <xref:System.Timers.Timer.BeginInit%2A> et <xref:System.Timers.Timer.EndInit%2A> méthodes empêche le contrôle de l’utilisation avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : double with get, set" Usage="System.Timers.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Timers.TimersDescription("TimerInterval")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'intervalle, exprimé en millisecondes, auquel l'événement <see cref="E:System.Timers.Timer.Elapsed" /> doit être déclenché.</summary>
        <value>Intervalle en millisecondes séparant les événements <see cref="E:System.Timers.Timer.Elapsed" />. La valeur doit être supérieure à zéro et inférieure ou égale à <see cref="F:System.Int32.MaxValue" />. La valeur par défaut est 100 millisecondes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez le <xref:System.Timers.Timer.Interval%2A> propriété afin de déterminer la fréquence à laquelle le <xref:System.Timers.Timer.Elapsed> événement est déclenché. Étant donné que la <xref:System.Timers.Timer> classe dépendant de l’horloge système, il a la même résolution que l’horloge système. Cela signifie que le <xref:System.Timers.Timer.Elapsed> événement se déclenche selon un intervalle défini par la résolution de l’horloge système si le <xref:System.Timers.Timer.Interval%2A> propriété est inférieure à la résolution de l’horloge système. L’exemple suivant définit le <xref:System.Timers.Timer.Interval%2A> propriété 5 millisecondes. Lorsque vous travaillez sur un [!INCLUDE[win7](~/includes/win7-md.md)] système dont l’horloge système a une résolution d’environ 15 millisecondes, l’événement se déclenche toutes les 15 millisecondes environ plutôt que toutes les 5 millisecondes.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 Vous pouvez utiliser le code suivant pour déterminer la résolution de l’horloge système sur le système actuel :  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Si votre application requiert une résolution supérieure à celle offerte par le <xref:System.Timers.Timer> classe ou l’horloge système, utilisez les minuteurs multimédias haute résolution, consultez [Comment : utiliser le chronomètre à haute résolution](http://msdn.microsoft.com/library/aa964692.aspx).  
  
 Si l’intervalle est défini après la <xref:System.Timers.Timer> a démarré, le nombre est réinitialisé. Par exemple, si vous définissez l’intervalle de 5 secondes, puis affectez le <xref:System.Timers.Timer.Enabled%2A> propriété `true`, le compteur démarre au moment <xref:System.Timers.Timer.Enabled%2A> est définie. Si vous réinitialisez l’intervalle à 10 secondes lorsque le nombre est 3 secondes, le <xref:System.Timers.Timer.Elapsed> événement est déclenché pour la première fois 13 secondes après <xref:System.Timers.Timer.Enabled%2A> a été défini sur `true`.  
  
 Si <xref:System.Timers.Timer.Enabled%2A> a la valeur `true` et <xref:System.Timers.Timer.AutoReset%2A> a la valeur `false`, le <xref:System.Timers.Timer> déclenche le <xref:System.Timers.Timer.Elapsed> événement une seule fois, la première fois que l’intervalle est écoulé. <xref:System.Timers.Timer.Enabled%2A> est ensuite définie sur `false`.  
  
> [!NOTE]
>  Si <xref:System.Timers.Timer.Enabled%2A> et <xref:System.Timers.Timer.AutoReset%2A> sont toutes deux définies sur `false`, et le minuteur a été précédemment activé, définissant le <xref:System.Timers.Timer.Interval%2A> causes de la propriété le <xref:System.Timers.Timer.Elapsed> événement est déclenché une fois, comme si le <xref:System.Timers.Timer.Enabled%2A> propriété a été définie sur `true`. Pour définir l’intervalle sans déclencher l’événement, vous pouvez temporairement définir le <xref:System.Timers.Timer.Enabled%2A> propriété `true`, définissez le <xref:System.Timers.Timer.Interval%2A> propriété pour l’intervalle de temps souhaitée, puis définissez immédiatement la <xref:System.Timers.Timer.Enabled%2A> propriété retour au `false`.  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Timers.Timer> objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), configure un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'intervalle est inférieur ou égal à zéro.  
  
- ou - 
L'intervalle est supérieur à <see cref="F:System.Int32.MaxValue" /> et la minuterie est actuellement activée. (Si la minuterie n'est pas activée actuellement, aucune exception n'est levée jusqu'à ce qu'elle soit activée.)</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Timers.Timer.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le site qui lie <see cref="T:System.Timers.Timer" /> à son conteneur en mode design.</summary>
        <value>Interface <see cref="T:System.ComponentModel.ISite" /> représentant le site qui lie l'objet <see cref="T:System.Timers.Timer" /> à son conteneur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites lient un <xref:System.ComponentModel.Component> à un <xref:System.ComponentModel.Container> et activer la communication entre eux, ainsi que fournir un moyen pour le conteneur gérer ses composants.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lance le déclenchement de l'événement <see cref="E:System.Timers.Timer.Elapsed" /> en affectant à <see cref="P:System.Timers.Timer.Enabled" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Timers.Timer.Start%2A> est appelée et <xref:System.Timers.Timer.AutoReset%2A> a la valeur `false`, le <xref:System.Timers.Timer> déclenche le <xref:System.Timers.Timer.Elapsed> événement une seule fois, la première fois que l’intervalle est écoulé. Si <xref:System.Timers.Timer.Start%2A> est appelée et <xref:System.Timers.Timer.AutoReset%2A> est `true`, le <xref:System.Timers.Timer> déclenche le <xref:System.Timers.Timer.Elapsed> heure de l’événement le premier l’intervalle s’écoule et continue à déclencher l’événement sur l’intervalle spécifié.  
  
 Vous pouvez également démarrer la minuterie en définissant <xref:System.Timers.Timer.Enabled%2A> à `true`.  
  
> [!NOTE]
>  Si <xref:System.Timers.Timer.AutoReset%2A> est `false`, le <xref:System.Timers.Timer.Start%2A> méthode doit être appelée afin de redémarrer le compteur.  
  
 Un appel à la <xref:System.Timers.Timer.Start%2A> méthode lors de la minuterie est activée n’a aucun effet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le <see cref="T:System.Timers.Timer" /> est créé avec un intervalle égal ou supérieur à <see cref="F:System.Int32.MaxValue" /> + 1, ou est défini à un intervalle inférieur à zéro.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arrête le déclenchement de l'événement <see cref="E:System.Timers.Timer.Elapsed" /> en affectant à <see cref="P:System.Timers.Timer.Enabled" /> la valeur <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez également arrêter la minuterie en définissant <xref:System.Timers.Timer.Enabled%2A> à `false`.  
  
> [!NOTE]
>  Le signal pour déclencher le <xref:System.Timers.Timer.Elapsed> événement est toujours en file d’attente pour l’exécution sur un <xref:System.Threading.ThreadPool> de threads, donc la méthode de gestion des événements peut s’exécuter sur un thread en même temps qu’un appel à la <xref:System.Timers.Timer.Stop%2A> méthode s’exécute sur un autre thread. Cela peut entraîner la <xref:System.Timers.Timer.Elapsed> événement déclenché après le <xref:System.Timers.Timer.Stop%2A> méthode est appelée. L’exemple de code dans la section suivante montre une façon de contourner cette condition de concurrence.  
  
   
  
## Examples  
 L’exemple suivant instancie un `System.Timers.Timer` objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), configure un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché. Lorsque l’utilisateur appuie sur la touche entrée, l’application appelle la <xref:System.Timers.Timer.Stop%2A> méthode avant de mettre fin à l’application.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 L’exemple de code suivant montre une façon d’empêcher le thread qui appelle le <xref:System.Timers.Timer.Stop%2A> méthode de se poursuivre jusqu'à ce qu’un en cours d’exécution <xref:System.Timers.Timer.Elapsed> événement se termine et d’empêcher également deux <xref:System.Timers.Timer.Elapsed> événements à partir de l’exécution du Gestionnaire d’événements au même heure (communément appelée réentrance).  
  
 L’exemple exécute 100 séries de tests. Chaque fois que le test est exécuté, la minuterie est démarrée avec un intervalle de 150 millisecondes. Le Gestionnaire d’événements utilise la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode pour simuler une tâche qui varie de façon aléatoire dans la longueur de 50 à 200 millisecondes. La méthode de test démarre également un thread de contrôle qui attend une seconde, puis arrête la minuterie. Si un événement est géré lorsque le thread de contrôle arrête la minuterie, le thread de contrôle doit attendre la fin de l’événement avant de continuer.  
  
 Le <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> surcharge de méthode est utilisée pour éviter la réentrance et pour empêcher le thread de contrôle de continuer jusqu'à la fin d’un événement en cours d’exécution. Le Gestionnaire d’événements utilise la <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> méthode pour définir un contrôle variable à 1, mais uniquement si la valeur est actuellement zéro. Il s’agit d’une opération atomique. Si la valeur de retour est zéro, la variable de contrôle a été définie sur 1 et le Gestionnaire d’événements s’exécute. Si la valeur de retour est différent de zéro, l’événement est simplement ignoré, pour éviter la réentrance. (S’il s’agissait nécessaire pour l’exécution de chaque événement, le <xref:System.Threading.Monitor> classe serait une meilleure méthode de synchronisation des événements.) Lorsque le Gestionnaire d’événements se termine, il définit la variable de contrôle précédent à zéro. L’exemple enregistre le nombre total d’événements exécutés, qui ont été ignorés en raison de la réentrance, et qui se produit après la <xref:System.Timers.Timer.Stop%2A> méthode a été appelée.  
  
 Le thread de contrôle utilise la <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> méthode pour définir le contrôle de la variable en -1 (moins un), mais uniquement si la valeur est actuellement zéro. Si l’opération atomique retourne zéro, un événement est en cours d’exécution. Le thread de contrôle attend et essaie à nouveau. L’exemple enregistre le nombre de fois que le thread de contrôle a dû attendre un événement se termine.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Timers.Timer.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Timers.TimersDescription("TimerSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet utilisé pour marshaler les appels du gestionnaire d'événements émis quand un intervalle a expiré.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> représentant l'objet utilisé pour marshaler les appels du gestionnaire d'événements émis quand un intervalle a expiré. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Timers.Timer.SynchronizingObject%2A> est `null`, la méthode qui gère le <xref:System.Timers.Timer.Elapsed> événement est appelé sur un thread du pool de threads système. Pour plus d’informations sur les pools de threads système, consultez <xref:System.Threading.ThreadPool>.  
  
 Lorsque le <xref:System.Timers.Timer.Elapsed> événement est géré par un composant Windows Forms visuel, tel qu’un bouton, l’accès au composant par le biais du pool de threads système peut les résultats dans une exception ou simplement peut ne pas fonctionner. Éviter cet effet en définissant <xref:System.Timers.Timer.SynchronizingObject%2A> à un composant Windows Forms, ce qui entraîne la méthode qui gère le <xref:System.Timers.Timer.Elapsed> événement à appeler sur le même thread que le composant a été créé.  
  
> [!NOTE]
>  Même si le <xref:System.Timers.Timer.SynchronizingObject%2A> propriété n’est pas `null`, <xref:System.Timers.Timer.Elapsed> événements peuvent se produire après la <xref:System.Timers.Timer.Dispose%2A> ou <xref:System.Timers.Timer.Stop%2A> méthode a été appelée ou après le <xref:System.Timers.Timer.Enabled%2A> propriété a été définie sur `false`, car le signal pour déclencher le <xref:System.Timers.Timer.Elapsed> événement est toujours en file d’attente pour l’exécution sur un thread de pool de threads. Une façon de résoudre cette condition de concurrence consiste à définir un indicateur qui indique le Gestionnaire d’événements pour le <xref:System.Timers.Timer.Elapsed> événement à ignorer les événements suivants.  
  
 Si le <xref:System.Timers.Timer> est utilisé à l’intérieur de Visual Studio dans un concepteur Windows Forms, <xref:System.Timers.Timer.SynchronizingObject%2A> est automatiquement défini sur le contrôle qui contient le <xref:System.Timers.Timer>. Par exemple, si vous placez un <xref:System.Timers.Timer> sur un concepteur pour `Form1` (qui hérite <xref:System.Windows.Forms.Form>), la <xref:System.Timers.Timer.SynchronizingObject%2A> propriété du <xref:System.Timers.Timer> est défini sur l’instance de `Form1`.  
  
   
  
## Examples  
 L’exemple suivant est une application Windows Forms qui sert d’un éditeur de fichier texte très simple. Lorsque le texte dans la zone de texte n’a pas été enregistré, l’application demande à l’utilisateur à des intervalles d’une minute souhaite enregistrer le contenu de la zone de texte.  Pour ce faire, le <xref:System.Timers.Timer.Interval%2A> propriété est définie sur une minute (60 000 millisecondes) et le <xref:System.Timers.Timer.SynchronizingObject%2A> propriété est définie sur le <xref:System.Windows.Forms.Form> objet.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 L’exemple nécessite que vous ajoutez les contrôles suivants au formulaire :  
  
-   Un <xref:System.Windows.Forms.TextBox> contrôle nommé `TextBox1` (son nom par défaut).  
  
-   Un <xref:System.Windows.Forms.Button> contrôle nommé `Button1` (son nom par défaut).  
  
-   Un <xref:System.Windows.Forms.SaveFileDialog> contrôle nommé `SaveSaveFileDialog1` (son nom par défaut).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>