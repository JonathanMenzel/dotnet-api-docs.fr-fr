<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="618b69c9a4d91151391fe5e2c79054e0441f4aec" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530803" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Génère un événement au bout d'un intervalle défini, avec la possibilité de générer des événements récurrents.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Timers.Timer> composant est un composant timer serveur qui déclenche un <xref:System.Timers.Timer.Elapsed> événements dans votre application après le nombre de millisecondes dans le <xref:System.Timers.Timer.Interval%2A> propriété s’est écoulé. Vous pouvez configurer le <xref:System.Timers.Timer> objet pour déclencher l’événement une seule fois ou à plusieurs reprises à l’aide du <xref:System.Timers.Timer.AutoReset%2A> propriété. En règle générale, un <xref:System.Timers.Timer> objet est déclaré au niveau de la classe afin qu’elle reste dans la portée tant que cela est nécessaire. Vous pouvez ensuite gérer ses <xref:System.Timers.Timer.Elapsed> événement afin de fournir le traitement normal. Par exemple, supposons que vous disposez d’un serveur critique qui doit être conservé 24 heures sur 24, 7 jours par semaine en cours d’exécution. Vous pouvez créer un service qui utilise un <xref:System.Timers.Timer> objet régulièrement Vérifiez que le serveur et vérifiez que le système est en cours d’exécution. Si le système ne répond pas, le service peut tenter de redémarrer le serveur ou avertir un administrateur.  
  
> [!IMPORTANT]
> La <xref:System.Timers.Timer> classe n’est pas disponible pour toutes les implémentations de .NET et les versions, telles que la version 1.6 Standard de .NET et les versions antérieures.
> Dans ce cas, vous pouvez utiliser la <xref:System.Threading.Timer?displayProperty=nameWithType> classe à la place.
  
 Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez la supprimer directement ou indirectement. Pour supprimer le type directement, vous devez appeler sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour la supprimer indirectement, utiliser une construction de langage telles que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <xref:System.IDisposable> rubrique de l’interface.  
  
 Basée sur le serveur <xref:System.Timers.Timer?displayProperty=nameWithType> classe a été conçue pour une utilisation avec des threads de travail dans un environnement multithread. Minuteries serveur peuvent se déplacer entre les threads pour gérer le relief <xref:System.Timers.Timer.Elapsed> événement plus de précision que les minuteurs Windows en déclenchant l’événement sur l’heure.  
  
 Le <xref:System.Timers.Timer?displayProperty=nameWithType> composant déclenche le <xref:System.Timers.Timer.Elapsed> événement, en fonction de la valeur (en millisecondes) de la <xref:System.Timers.Timer.Interval%2A> propriété. Vous pouvez gérer cet événement pour exécuter le traitement que vous avez besoin. Par exemple, supposons que vous disposez d’une application de vente en ligne qui publie continuellement des commandes à une base de données. Le service qui compile les instructions pour l’envoi de journaux fonctionne sur un lot de commandes plutôt que de traiter chaque commande individuellement. Vous pouvez utiliser un <xref:System.Timers.Timer> pour démarrer le traitement de toutes les 30 minutes par lots.  
  
> [!IMPORTANT]
>  La classe System.Timers.Timer a la même résolution que l’horloge système. Cela signifie que la <xref:System.Timers.Timer.Elapsed> événement se déclenche selon un intervalle défini par la résolution de l’horloge système si le <xref:System.Timers.Timer.Interval%2A> propriété est inférieure à la résolution de l’horloge système. Pour plus d'informations, consultez la propriété <xref:System.Timers.Timer.Interval%2A>.  
  
 Lors de la <xref:System.Timers.Timer.AutoReset%2A> a la valeur `false`, un <xref:System.Timers.Timer?displayProperty=nameWithType> objet déclenche le <xref:System.Timers.Timer.Elapsed> événement une seule fois, après la première <xref:System.Timers.Timer.Interval%2A> s’est écoulé. Pour conserver le déclenchement du <xref:System.Timers.Timer.Elapsed> événement régulièrement à l’intervalle défini par le <xref:System.Timers.Timer.Interval%2A>, définissez <xref:System.Timers.Timer.AutoReset%2A> à `true`, qui est la valeur par défaut.  
  
 Le <xref:System.Timers.Timer> composant intercepte et supprime toutes les exceptions levées par les gestionnaires d’événements pour le <xref:System.Timers.Timer.Elapsed> événement. Ce comportement est susceptible de changer dans les futures versions du .NET Framework. Notez, toutefois, cela n’est pas vrai pour les gestionnaires d’événements qui s’exécutent de façon asynchrone et incluent le `await` (opérateur) (en c#) ou `Await` (opérateur) (en Visual Basic). Les exceptions levées dans ces gestionnaires d’événements sont propagées vers le thread appelant, comme l’illustre l’exemple suivant. Pour plus d’informations sur les exceptions levées dans les méthodes asynchrones, consultez [la gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Si le <xref:System.Timers.Timer.SynchronizingObject%2A> propriété `null`, le <xref:System.Timers.Timer.Elapsed> événement est déclenché sur un <xref:System.Threading.ThreadPool> thread. Si le traitement de la <xref:System.Timers.Timer.Elapsed> dure événement plus longtemps que <xref:System.Timers.Timer.Interval%2A>, l’événement peut être déclenché à nouveau sur un autre <xref:System.Threading.ThreadPool> thread. Dans ce cas, le Gestionnaire d’événements doit être réentrant.  
  
> [!NOTE]
>  La méthode de gestion d’événements peut s’exécuter sur un thread en même temps qu’un autre thread appelle la <xref:System.Timers.Timer.Stop%2A> méthode ou définit le <xref:System.Timers.Timer.Enabled%2A> propriété `false`. Cela peut entraîner la <xref:System.Timers.Timer.Elapsed> événement déclenché après l’arrêt du minuteur. L’exemple de code pour le <xref:System.Timers.Timer.Stop%2A> méthode montre une manière d’éviter cette condition de concurrence critique.  
  
 Même si <xref:System.Timers.Timer.SynchronizingObject%2A> n’est pas `null`, <xref:System.Timers.Timer.Elapsed> événements peuvent se produire après la <xref:System.Timers.Timer.Dispose%2A> ou <xref:System.Timers.Timer.Stop%2A> méthode a été appelée ou après le <xref:System.Timers.Timer.Enabled%2A> propriété a été définie sur `false`, car le signal pour déclencher le <xref:System.Timers.Timer.Elapsed> événement est toujours en file d’attente pour l’exécution sur un thread de pool de threads. Une façon de résoudre cette condition d’engorgement consiste à définir un indicateur qui indique le Gestionnaire d’événements pour le <xref:System.Timers.Timer.Elapsed> événement à ignorer les événements suivants.  
  
 Si vous utilisez la <xref:System.Timers.Timer?displayProperty=nameWithType> classe avec un élément d’interface utilisateur, tels qu’un formulaire ou un contrôle, sans placer la minuterie sur cet élément d’interface utilisateur, assignez le formulaire ou un contrôle qui contient le <xref:System.Timers.Timer> à la <xref:System.Timers.Timer.SynchronizingObject%2A> propriété, afin que l’événement est marshalés vers le thread d’interface utilisateur.  
  
 Pour obtenir la liste des valeurs de propriété par défaut d’une instance de <xref:System.Timers.Timer>, consultez la <xref:System.Timers.Timer.%23ctor%2A> constructeur.  
  
> [!TIP]
>  Gardez à l’esprit que .NET inclut quatre classes nommées `Timer`, chaque de qui offre des fonctionnalités différentes :  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (cette rubrique) : déclenche un événement à intervalles réguliers. La classe est destinée à en tant que la basée sur un serveur ou les composants de service dans un environnement multithread ; Il ne dispose d’aucune interface utilisateur et n’est pas visible lors de l’exécution.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: exécute une méthode de rappel unique sur un thread de pool de threads à intervalles réguliers. La méthode de rappel est définie lorsque la minuterie est instanciée et ne peut pas être modifiée. Comme le <xref:System.Timers.Timer?displayProperty=nameWithType> (classe), cette classe est destinée à être utilisée comme un composant basé sur le serveur ou le service dans un environnement multithread ; elle ne dispose d’aucune interface utilisateur et n’est pas visible lors de l’exécution.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (.NET framework uniquement) : un composant Windows Forms qui déclenche un événement à intervalles réguliers. Le composant a pas d’interface utilisateur et est conçu pour une utilisation dans un environnement monothread.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (.NET framework uniquement) : un composant ASP.NET qui effectue des publications de pages web asynchrones ou synchrones à intervalles réguliers.  

## Examples  
 L’exemple suivant instancie un `System.Timers.Timer` objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>N’importe quel public <see langword="static" /> de ce type sont thread-safe. Il n'est pas garanti que les membres d'instance soient thread-safe.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Timers.Timer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Timers.Timer" /> et affecte à toutes les propriétés leurs valeurs initiales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Timers.Timer>.  
  
|Property|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 millisecondes|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Référence Null (`Nothing` en Visual Basic).|  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Timers.Timer> objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">Intervalle, en millisecondes, entre les événements. La valeur doit être supérieure à zéro et inférieure ou égale à <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Timers.Timer" /> et affecte le nombre spécifié de millisecondes à la propriété <see cref="P:System.Timers.Timer.Interval" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur définit la <xref:System.Timers.Timer.Interval%2A> propriété de la nouvelle instance de la minuterie, mais n’active ne pas la minuterie.  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Timers.Timer> objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur du paramètre <paramref name="interval" /> doit être inférieure ou égale à zéro, ou supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur booléenne indiquant si <see cref="T:System.Timers.Timer" /> doit déclencher l'événement <see cref="E:System.Timers.Timer.Elapsed" /> une seule fois (<see langword="false" />) ou de façon répétée (<see langword="true" />).</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Timers.Timer" /> doit déclencher l'événement <see cref="E:System.Timers.Timer.Elapsed" /> chaque fois que l'intervalle expire ; <see langword="false" /> s'il doit déclencher l'événement <see cref="E:System.Timers.Timer.Elapsed" /> une seule fois, à la première expiration de l'intervalle. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Timers.Timer> est déjà activé lorsque la <xref:System.Timers.Timer.Start%2A> est appelée, l’intervalle est réinitialisé. Si <xref:System.Timers.Timer.AutoReset%2A> est `false`, le <xref:System.Timers.Timer.Start%2A> méthode doit être appelée afin de redémarrer le compteur.  
  
 Réinitialisation de l’intervalle prend effet lorsque les <xref:System.Timers.Timer.Elapsed> événement est déclenché. Par exemple, si vous définissez l’intervalle à 5 secondes, puis affectez le <xref:System.Timers.Timer.Enabled%2A> propriété `true`, le compteur démarre à l’heure <xref:System.Timers.Timer.Enabled%2A> est définie. Si vous réinitialisez l’intervalle à 10 secondes lorsque le compteur est à 3 secondes, la <xref:System.Timers.Timer.Elapsed> événement est déclenché pour la première fois 13 secondes après que le <xref:System.Timers.Timer.Enabled%2A> a pris la valeur de propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Timers.Timer> dont <xref:System.Timers.Timer.Elapsed> événement se déclenche après 1,5 seconde. Puis, son gestionnaire d’événements affiche « Hello World ! » sur la console.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Débute l'initialisation au moment de l'exécution d'un <see cref="T:System.Timers.Timer" /> utilisé sur un formulaire ou par un autre composant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] environnement utilise cette méthode pour démarrer l’initialisation d’un composant qui est utilisé dans un formulaire ou par un autre composant de conception. Le <xref:System.Timers.Timer.EndInit%2A> méthode termine l’initialisation. À l’aide de la <xref:System.Timers.Timer.BeginInit%2A> et <xref:System.Timers.Timer.EndInit%2A> méthodes empêche le contrôle avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par le <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Timers.Timer.Close%2A> méthode appelle à son tour le `Dispose` (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère toutes les ressources utilisées par le <see cref="T:System.Timers.Timer" /> actuel.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l'intervalle est écoulé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Timers.Timer.Elapsed> événement est déclenché si la <xref:System.Timers.Timer.Enabled%2A> propriété est `true` et l’intervalle de temps (en millisecondes) défini par le <xref:System.Timers.Timer.Interval%2A> au terme de la propriété. Si le <xref:System.Timers.Timer.AutoReset%2A> propriété est `true`, l’événement est déclenché à plusieurs reprises à un intervalle défini par le <xref:System.Timers.Timer.Interval%2A> propriété ; sinon, l’événement est déclenché qu’une seule fois, la première fois le <xref:System.Timers.Timer.Interval%2A> valeur d’expiration.  
  
 Si <xref:System.Timers.Timer.Interval%2A> est défini après le <xref:System.Timers.Timer> a démarré, le compteur est réinitialisé. Par exemple, si vous définissez l’intervalle à 5 secondes, puis affectez <xref:System.Timers.Timer.Enabled%2A> à `true`, le compteur démarre à l’heure <xref:System.Timers.Timer.Enabled%2A> est définie. Si vous réinitialisez l’intervalle à 10 secondes lorsque le compteur est trois secondes, la <xref:System.Timers.Timer.Elapsed> événement est déclenché pour la première fois 13 secondes après que <xref:System.Timers.Timer.Enabled%2A> a été défini sur `true`.  
  
 Si le <xref:System.Timers.Timer.SynchronizingObject%2A> propriété `null`, le <xref:System.Timers.Timer.Elapsed> événement est déclenché sur un <xref:System.Threading.ThreadPool> thread. Si le traitement de la <xref:System.Timers.Timer.Elapsed> dure événement plus longtemps que <xref:System.Timers.Timer.Interval%2A>, l’événement peut être déclenché à nouveau sur un autre <xref:System.Threading.ThreadPool> thread. Dans ce cas, le Gestionnaire d’événements doit être réentrant.  
  
> [!NOTE]
>  La méthode de gestion d’événements peut s’exécuter sur un thread en même temps qu’un autre thread appelle la <xref:System.Timers.Timer.Stop%2A> méthode ou définit le <xref:System.Timers.Timer.Enabled%2A> propriété `false`. Cela peut entraîner la <xref:System.Timers.Timer.Elapsed> événement déclenché après l’arrêt du minuteur. L’exemple de code pour le <xref:System.Timers.Timer.Stop%2A> méthode montre une manière d’éviter cette condition de concurrence critique.  
  
 Même si <xref:System.Timers.Timer.SynchronizingObject%2A> n’est pas `null`, <xref:System.Timers.Timer.Elapsed> événements peuvent se produire après la <xref:System.Timers.Timer.Dispose%2A> ou <xref:System.Timers.Timer.Stop%2A> méthode a été appelée ou après le <xref:System.Timers.Timer.Enabled%2A> propriété a été définie sur `false`, car le signal pour déclencher le <xref:System.Timers.Timer.Elapsed> événement est toujours en file d’attente pour l’exécution sur un thread de pool de threads. Une façon de résoudre cette condition d’engorgement consiste à définir un indicateur qui indique le Gestionnaire d’événements pour le <xref:System.Timers.Timer.Elapsed> événement à ignorer les événements suivants.  
  
 Le <xref:System.Timers.Timer> composant intercepte et supprime toutes les exceptions levées par les gestionnaires d’événements pour le <xref:System.Timers.Timer.Elapsed> événement. Ce comportement est susceptible de changer dans les futures versions du .NET Framework.  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Timers.Timer> objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si <see cref="T:System.Timers.Timer" /> doit déclencher l'événement <see cref="E:System.Timers.Timer.Elapsed" />.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Timers.Timer" /> doit déclencher l'événement <see cref="E:System.Timers.Timer.Elapsed" /> ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Paramètre <xref:System.Timers.Timer.Enabled%2A> à `true` est le même que l’appel <xref:System.Timers.Timer.Start%2A>, tandis que le paramètre <xref:System.Timers.Timer.Enabled%2A> à `false` est le même que l’appel <xref:System.Timers.Timer.Stop%2A>.  
  
> [!NOTE]
>  Le signal pour déclencher le <xref:System.Timers.Timer.Elapsed> événement est toujours en file d’attente pour l’exécution sur un <xref:System.Threading.ThreadPool> thread. Cela peut entraîner la <xref:System.Timers.Timer.Elapsed> événement déclenché après la <xref:System.Timers.Timer.Enabled%2A> est définie sur `false`. L’exemple de code pour le <xref:System.Timers.Timer.Stop%2A> méthode montre une façon de contourner cette condition d’engorgement.  
  
 Si <xref:System.Timers.Timer.Enabled%2A> a la valeur `true` et <xref:System.Timers.Timer.AutoReset%2A> a la valeur `false`, le <xref:System.Timers.Timer> déclenche le <xref:System.Timers.Timer.Elapsed> événement une seule fois, la première fois que l’intervalle est écoulé.  
  
 Si l’intervalle est défini après le <xref:System.Timers.Timer> a démarré, le compteur est réinitialisé. Par exemple, si vous définissez l’intervalle à 5 secondes, puis affectez le <xref:System.Timers.Timer.Enabled%2A> propriété `true`, le compteur démarre à l’heure <xref:System.Timers.Timer.Enabled%2A> est définie. Si vous réinitialisez l’intervalle à 10 secondes lorsque le compteur est trois secondes, la <xref:System.Timers.Timer.Elapsed> événement est déclenché pour la première fois 13 secondes après que <xref:System.Timers.Timer.Enabled%2A> a été défini sur `true`.  
  
> [!NOTE]
>  Certains concepteurs visuels, telles que celles dans Microsoft Visual Studio, définissent la <xref:System.Timers.Timer.Enabled%2A> propriété `true` lors de l’insertion d’un nouveau <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Timers.Timer> objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cette propriété ne peut pas être définie, car la minuterie a été supprimée.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Timers.Timer.Interval" /> a eu une valeur supérieure à <see cref="F:System.Int32.MaxValue" /> avant que la minuterie ait été activée.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met fin à l'initialisation au moment de l'exécution d'un <see cref="T:System.Timers.Timer" /> utilisé sur un formulaire ou par un autre composant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] environnement utilise cette méthode pour terminer l’initialisation d’un composant qui est utilisé dans un formulaire ou par un autre composant de conception. Le <xref:System.Timers.Timer.BeginInit%2A> méthode démarre l’initialisation. À l’aide de la <xref:System.Timers.Timer.BeginInit%2A> et <xref:System.Timers.Timer.EndInit%2A> méthodes empêche le contrôle avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'intervalle, exprimé en millisecondes, auquel l'événement <see cref="E:System.Timers.Timer.Elapsed" /> doit être déclenché.</summary>
        <value>Intervalle en millisecondes séparant les événements <see cref="E:System.Timers.Timer.Elapsed" />. La valeur doit être supérieure à zéro et inférieure ou égale à <see cref="F:System.Int32.MaxValue" />. La valeur par défaut est 100 millisecondes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez la <xref:System.Timers.Timer.Interval%2A> propriété pour déterminer la fréquence à laquelle le <xref:System.Timers.Timer.Elapsed> événement est déclenché. Étant donné que la <xref:System.Timers.Timer> classe dépend de l’horloge système, il a la même résolution que l’horloge système. Cela signifie que la <xref:System.Timers.Timer.Elapsed> événement se déclenche selon un intervalle défini par la résolution de l’horloge système si le <xref:System.Timers.Timer.Interval%2A> propriété est inférieure à la résolution de l’horloge système. L’exemple suivant définit le <xref:System.Timers.Timer.Interval%2A> propriété 5 millisecondes. Sur un [!INCLUDE[win7](~/includes/win7-md.md)] système dont l’horloge système a une résolution d’environ 15 millisecondes, l’événement se déclenche toutes les 15 millisecondes environ plutôt que toutes les 5 millisecondes.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 Vous pouvez utiliser le code suivant pour déterminer la résolution de l’horloge système sur le système actuel :  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Si votre application nécessite une résolution supérieure à celle offerte par le <xref:System.Timers.Timer> classe ou l’horloge système, utilisez les minuteurs de haute résolution, consultez [Comment : utiliser le minuteur haute résolution](http://msdn.microsoft.com/library/aa964692.aspx).  
  
 Si l’intervalle est défini après le <xref:System.Timers.Timer> a démarré, le compteur est réinitialisé. Par exemple, si vous définissez l’intervalle à 5 secondes, puis affectez le <xref:System.Timers.Timer.Enabled%2A> propriété `true`, le compteur démarre à l’heure <xref:System.Timers.Timer.Enabled%2A> est définie. Si vous réinitialisez l’intervalle à 10 secondes lorsque le compteur est trois secondes, la <xref:System.Timers.Timer.Elapsed> événement est déclenché pour la première fois 13 secondes après que <xref:System.Timers.Timer.Enabled%2A> a été défini sur `true`.  
  
 Si <xref:System.Timers.Timer.Enabled%2A> a la valeur `true` et <xref:System.Timers.Timer.AutoReset%2A> a la valeur `false`, le <xref:System.Timers.Timer> déclenche le <xref:System.Timers.Timer.Elapsed> événement une seule fois, la première fois que l’intervalle est écoulé. <xref:System.Timers.Timer.Enabled%2A> est ensuite affectée à `false`.  
  
> [!NOTE]
>  Si <xref:System.Timers.Timer.Enabled%2A> et <xref:System.Timers.Timer.AutoReset%2A> sont toutes deux définies sur `false`, et le minuteur a été précédemment activé, définition de la <xref:System.Timers.Timer.Interval%2A> causes de la propriété le <xref:System.Timers.Timer.Elapsed> événement soit déclenché une fois, comme si le <xref:System.Timers.Timer.Enabled%2A> propriété a été définie pour `true`. Pour définir l’intervalle sans déclencher l’événement, vous pouvez temporairement définir le <xref:System.Timers.Timer.Enabled%2A> propriété `true`, définissez le <xref:System.Timers.Timer.Interval%2A> propriété pour l’intervalle de temps de votre choix, puis immédiatement définissez le <xref:System.Timers.Timer.Enabled%2A> propriété sauvegarder sur `false`.  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Timers.Timer> objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'intervalle est inférieur ou égal à zéro.  
  
 - ou -  
  
 L'intervalle est supérieur à <see cref="F:System.Int32.MaxValue" /> et la minuterie est actuellement activée. (Si la minuterie n'est pas activée actuellement, aucune exception n'est levée jusqu'à ce qu'elle soit activée.)</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le site qui lie <see cref="T:System.Timers.Timer" /> à son conteneur en mode design.</summary>
        <value>Interface <see cref="T:System.ComponentModel.ISite" /> représentant le site qui lie l'objet <see cref="T:System.Timers.Timer" /> à son conteneur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites lient un <xref:System.ComponentModel.Component> à un <xref:System.ComponentModel.Container> et activer la communication entre eux, ainsi que fournir un moyen pour le conteneur de gérer ses composants.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lance le déclenchement de l'événement <see cref="E:System.Timers.Timer.Elapsed" /> en affectant à <see cref="P:System.Timers.Timer.Enabled" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Timers.Timer.Start%2A> est appelée et <xref:System.Timers.Timer.AutoReset%2A> a la valeur `false`, le <xref:System.Timers.Timer> déclenche le <xref:System.Timers.Timer.Elapsed> événement une seule fois, la première fois que l’intervalle est écoulé. Si <xref:System.Timers.Timer.Start%2A> est appelée et <xref:System.Timers.Timer.AutoReset%2A> est `true`, le <xref:System.Timers.Timer> déclenche le <xref:System.Timers.Timer.Elapsed> heure d’événement du premier l’intervalle est écoulé et continue à déclencher l’événement sur l’intervalle spécifié.  
  
 Vous pouvez également démarrer la minuterie en définissant <xref:System.Timers.Timer.Enabled%2A> à `true`.  
  
> [!NOTE]
>  Si <xref:System.Timers.Timer.AutoReset%2A> est `false`, le <xref:System.Timers.Timer.Start%2A> méthode doit être appelée afin de redémarrer le compteur.  
  
 Un appel à la <xref:System.Timers.Timer.Start%2A> méthode lorsque la minuterie est activée n’a aucun effet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le <see cref="T:System.Timers.Timer" /> est créé avec un intervalle égal ou supérieur à <see cref="F:System.Int32.MaxValue" /> + 1, ou est défini à un intervalle inférieur à zéro.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arrête le déclenchement de l'événement <see cref="E:System.Timers.Timer.Elapsed" /> en affectant à <see cref="P:System.Timers.Timer.Enabled" /> la valeur <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez également arrêter la temporisation en définissant <xref:System.Timers.Timer.Enabled%2A> à `false`.  
  
> [!NOTE]
>  Le signal pour déclencher le <xref:System.Timers.Timer.Elapsed> événement est toujours en file d’attente pour l’exécution sur un <xref:System.Threading.ThreadPool> de threads, donc la méthode de gestion d’événements peut s’exécuter sur un thread en même temps qu’un appel à la <xref:System.Timers.Timer.Stop%2A> méthode s’exécute sur un autre thread. Cela peut entraîner la <xref:System.Timers.Timer.Elapsed> événement déclenché après la <xref:System.Timers.Timer.Stop%2A> méthode est appelée. L’exemple de code dans la section suivante montre une façon de contourner cette condition d’engorgement.  
  
   
  
## Examples  
 L’exemple suivant instancie un `System.Timers.Timer` objet qui déclenche son <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> événement toutes les deux secondes (2 000 millisecondes), définit un gestionnaire d’événements pour l’événement et démarre la minuterie. Le Gestionnaire d’événements affiche la valeur de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriété chaque fois qu’il est déclenché. Lorsque l’utilisateur appuie sur la touche entrée, l’application appelle la <xref:System.Timers.Timer.Stop%2A> méthode avant de mettre fin à l’application.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 L’exemple de code suivant montre une façon d’empêcher le thread qui appelle la <xref:System.Timers.Timer.Stop%2A> méthode de se poursuivre jusqu'à ce qu’un en cours d’exécution <xref:System.Timers.Timer.Elapsed> fin de l’événement et d’empêcher également deux <xref:System.Timers.Timer.Elapsed> événements à partir de l’exécution du Gestionnaire d’événements au niveau du même heure (communément appelée réentrance).  
  
 L’exemple exécute 100 séries de tests. Chaque fois que le test est exécuté, la minuterie est démarrée avec un intervalle de 150 millisecondes. Le Gestionnaire d’événements utilise le <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode pour simuler une tâche qui varie aléatoirement compris entre 50 et 200 millisecondes. La méthode de test démarre également un thread de contrôle qui attend une seconde, puis arrête la minuterie. Si un événement est traitée lorsque le thread de contrôle arrête la minuterie, le thread de contrôle doit patienter jusqu'à la fin de l’événement avant de continuer.  
  
 Le <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> surcharge de méthode est utilisée pour éviter la réentrance et pour empêcher le thread de contrôle de continuer jusqu'à la fin d’un événement en cours d’exécution. Le Gestionnaire d’événements utilise le <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> méthode pour définir un contrôle variable 1, mais uniquement si la valeur est actuellement zéro. Il s’agit d’une opération atomique. Si la valeur de retour est zéro, la variable de contrôle a été définie sur 1 et le Gestionnaire d’événements se déroule. Si la valeur de retour est différente de zéro, l’événement est simplement ignoré, pour éviter la réentrance. (S’il s’agissait nécessaire pour l’exécution de chaque événement, le <xref:System.Threading.Monitor> classe serait une meilleure méthode de synchronisation des événements.) Lorsque le Gestionnaire d’événements se termine, il redéfinit la variable de contrôle à zéro. L’exemple enregistre le nombre total d’événements exécutés, qui ont été rejetés en raison de la réentrance, et qui s’est produite après la <xref:System.Timers.Timer.Stop%2A> méthode a été appelée.  
  
 Le thread de contrôle utilise le <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> méthode pour définir le contrôle de la variable en -1 (moins un), mais uniquement si la valeur est actuellement zéro. Si l’opération atomique retourne zéro, un événement est en cours d’exécution. Le thread de contrôle attend et essaie à nouveau. L’exemple enregistre le nombre de fois où que le thread de contrôle a dû attendre un événement à la fin.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet utilisé pour marshaler les appels du gestionnaire d'événements émis quand un intervalle a expiré.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> représentant l'objet utilisé pour marshaler les appels du gestionnaire d'événements émis quand un intervalle a expiré. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Timers.Timer.SynchronizingObject%2A> est `null`, la méthode qui gère le <xref:System.Timers.Timer.Elapsed> événement est appelé sur un thread du pool de threads système. Pour plus d’informations sur les pools de threads système, consultez <xref:System.Threading.ThreadPool>.  
  
 Lorsque le <xref:System.Timers.Timer.Elapsed> événement est géré par un composant Windows Forms visuel, tel qu’un bouton, l’accès au composant par le biais du pool de threads système peut les résultats dans une exception ou simplement peut ne pas fonctionner. Éviter cet effet en définissant <xref:System.Timers.Timer.SynchronizingObject%2A> à un composant Windows Forms, ce qui entraîne la méthode qui gère le <xref:System.Timers.Timer.Elapsed> événement à être appelé sur le même thread que le composant a été créé.  
  
> [!NOTE]
>  Même si le <xref:System.Timers.Timer.SynchronizingObject%2A> propriété n’est pas `null`, <xref:System.Timers.Timer.Elapsed> événements peuvent se produire après la <xref:System.Timers.Timer.Dispose%2A> ou <xref:System.Timers.Timer.Stop%2A> méthode a été appelée ou après le <xref:System.Timers.Timer.Enabled%2A> propriété a été définie sur `false`, car le signal pour déclencher le <xref:System.Timers.Timer.Elapsed> événement est toujours en file d’attente pour l’exécution sur un thread de pool de threads. Une façon de résoudre cette condition d’engorgement consiste à définir un indicateur qui indique le Gestionnaire d’événements pour le <xref:System.Timers.Timer.Elapsed> événement à ignorer les événements suivants.  
  
 Si le <xref:System.Timers.Timer> est utilisé dans Visual Studio dans un concepteur Windows Forms, <xref:System.Timers.Timer.SynchronizingObject%2A> est automatiquement défini sur le contrôle qui contient le <xref:System.Timers.Timer>. Par exemple, si vous placez un <xref:System.Timers.Timer> sur un concepteur pour `Form1` (qui hérite de <xref:System.Windows.Forms.Form>), la <xref:System.Timers.Timer.SynchronizingObject%2A> propriété du <xref:System.Timers.Timer> est définie sur l’instance de `Form1`.  
  
   
  
## Examples  
 L’exemple suivant est une application Windows Forms qui sert d’un éditeur de texte simple. Lorsque le texte dans la zone de texte n’a pas été enregistré, l’application demande à l’utilisateur à des intervalles d’une minute souhaite enregistrer le contenu de la zone de texte.  Pour ce faire, le <xref:System.Timers.Timer.Interval%2A> est définie sur 1 minute (60 000 millisecondes) et le <xref:System.Timers.Timer.SynchronizingObject%2A> est définie sur la <xref:System.Windows.Forms.Form> objet.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 L’exemple requiert que vous ajoutez les contrôles suivants au formulaire :  
  
-   A <xref:System.Windows.Forms.TextBox> contrôle nommé `TextBox1` (son nom par défaut).  
  
-   A <xref:System.Windows.Forms.Button> contrôle nommé `Button1` (son nom par défaut).  
  
-   A <xref:System.Windows.Forms.SaveFileDialog> contrôle nommé `SaveSaveFileDialog1` (son nom par défaut).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>