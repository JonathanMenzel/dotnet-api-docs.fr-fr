<Type Name="GenerateMetadata" FullName="System.EnterpriseServices.Internal.GenerateMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="77e9e6c7a8702427ea1dfc5af6972e96cd8a845a" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39972768" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class GenerateMetadata : System.EnterpriseServices.Internal.IComSoapMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GenerateMetadata extends System.Object implements class System.EnterpriseServices.Internal.IComSoapMetadata" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.GenerateMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class GenerateMetadata&#xA;Implements IComSoapMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class GenerateMetadata : System::EnterpriseServices::Internal::IComSoapMetadata" />
  <TypeSignature Language="F#" Value="type GenerateMetadata = class&#xA;    interface IComSoapMetadata" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.EnterpriseServices.Internal.IComSoapMetadata</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.Guid("d8013ff1-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Génère les métadonnées CLR (Common Language Runtime) pour un composant COM+.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si nécessaire, le <xref:System.EnterpriseServices.Internal.GenerateMetadata> classe génère un assembly qui contient les métadonnées CLR pour une bibliothèque de types spécifiée.  
  
 <xref:System.EnterpriseServices.Internal.GenerateMetadata> est utilisé en interne par le .NET Framework. Vous n’avez pas besoin d’utiliser la classe directement dans votre code.  
  
 ]]></format>
    </remarks>
    <forInternalUseOnly />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GenerateMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.GenerateMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GenerateMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.EnterpriseServices.Internal.GenerateMetadata" />.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Generate">
      <MemberSignature Language="C#" Value="public string Generate (string strSrcTypeLib, string outPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string Generate(string strSrcTypeLib, string outPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.GenerateMetadata.Generate(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Generate (strSrcTypeLib As String, outPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ Generate(System::String ^ strSrcTypeLib, System::String ^ outPath);" />
      <MemberSignature Language="F#" Value="abstract member Generate : string * string -&gt; string&#xA;override this.Generate : string * string -&gt; string" Usage="generateMetadata.Generate (strSrcTypeLib, outPath)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapMetadata.Generate(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strSrcTypeLib" Type="System.String" />
        <Parameter Name="outPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strSrcTypeLib">Nom de la bibliothèque de types pour laquelle générer un assembly.</param>
        <param name="outPath">Dossier dans lequel générer un assembly ou rechercher un assembly existant.</param>
        <summary>Génère ou recherche un assembly qui contient les métadonnées CLR (Common Language Runtime) pour un composant COM+ représenté par la bibliothèque de types spécifiée.</summary>
        <returns>Nom de l'assembly généré ; sinon, une chaîne vide si les entrées ne sont pas valides.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si nécessaire, le <xref:System.EnterpriseServices.Internal.GenerateMetadata.Generate%2A> méthode génère un assembly qui contient les métadonnées CLR pour une bibliothèque de types spécifiée. Pour ce faire, il appelle le <xref:System.EnterpriseServices.Internal.GenerateMetadata.GenerateMetaData%2A> (méthode).  
  
 Ces méthodes n’avez pas besoin d’être appelée directement depuis votre code.  
  
 ]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="GenerateMetaData">
      <MemberSignature Language="C#" Value="public string GenerateMetaData (string strSrcTypeLib, string outPath, byte[] PublicKey, System.Reflection.StrongNameKeyPair KeyPair);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GenerateMetaData(string strSrcTypeLib, string outPath, unsigned int8[] PublicKey, class System.Reflection.StrongNameKeyPair KeyPair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.GenerateMetadata.GenerateMetaData(System.String,System.String,System.Byte[],System.Reflection.StrongNameKeyPair)" />
      <MemberSignature Language="VB.NET" Value="Public Function GenerateMetaData (strSrcTypeLib As String, outPath As String, PublicKey As Byte(), KeyPair As StrongNameKeyPair) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GenerateMetaData(System::String ^ strSrcTypeLib, System::String ^ outPath, cli::array &lt;System::Byte&gt; ^ PublicKey, System::Reflection::StrongNameKeyPair ^ KeyPair);" />
      <MemberSignature Language="F#" Value="member this.GenerateMetaData : string * string * byte[] * System.Reflection.StrongNameKeyPair -&gt; string" Usage="generateMetadata.GenerateMetaData (strSrcTypeLib, outPath, PublicKey, KeyPair)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strSrcTypeLib" Type="System.String" />
        <Parameter Name="outPath" Type="System.String" />
        <Parameter Name="PublicKey" Type="System.Byte[]" />
        <Parameter Name="KeyPair" Type="System.Reflection.StrongNameKeyPair" />
      </Parameters>
      <Docs>
        <param name="strSrcTypeLib">Nom de la bibliothèque de types pour laquelle générer un assembly.</param>
        <param name="outPath">Dossier dans lequel générer un assembly ou rechercher un assembly existant.</param>
        <param name="PublicKey">Clé publique utilisée pour importer des informations de bibliothèque de types dans un assembly.</param>
        <param name="KeyPair">Paire de clés avec nom fort utilisée pour signer l'assembly généré.</param>
        <summary>Génère ou recherche un assembly qui contient les métadonnées CLR pour un composant COM+ représenté par la bibliothèque de types spécifiée, signe l'assembly avec une paire de clés avec nom fort et l'installe dans le Global Assembly Cache.</summary>
        <returns>Nom de l'assembly généré ; sinon, une chaîne vide si les entrées ne sont pas valides.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si nécessaire, le <xref:System.EnterpriseServices.Internal.GenerateMetadata.GenerateMetaData%2A> méthode génère un assembly qui contient les métadonnées CLR pour une bibliothèque de types spécifiée. Il ne génère pas un assembly si un assembly portant le nom généré existe déjà dans la chaîne `outPath` dossier.  
  
 <xref:System.EnterpriseServices.Internal.GenerateMetadata.GenerateMetaData%2A> n’a pas besoin d’être appelée directement depuis votre code. Elle est appelée par les deux le <xref:System.EnterpriseServices.Internal.GenerateMetadata.Generate%2A> et <xref:System.EnterpriseServices.Internal.GenerateMetadata.GenerateSigned%2A> méthodes.  
  
 Si elle est appelée <xref:System.EnterpriseServices.Internal.GenerateMetadata.GenerateSigned%2A>, <xref:System.EnterpriseServices.Internal.GenerateMetadata.GenerateMetaData%2A> également génère une paire de clés avec nom fort, signe l’assembly et l’installe dans le global assembly cache.  
  
 ]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="GenerateSigned">
      <MemberSignature Language="C#" Value="public string GenerateSigned (string strSrcTypeLib, string outPath, bool InstallGac, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GenerateSigned(string strSrcTypeLib, string outPath, bool InstallGac, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.GenerateMetadata.GenerateSigned(System.String,System.String,System.Boolean,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GenerateSigned (strSrcTypeLib As String, outPath As String, InstallGac As Boolean, ByRef Error As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GenerateSigned(System::String ^ strSrcTypeLib, System::String ^ outPath, bool InstallGac, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member GenerateSigned : string * string * bool *  -&gt; string&#xA;override this.GenerateSigned : string * string * bool *  -&gt; string" Usage="generateMetadata.GenerateSigned (strSrcTypeLib, outPath, InstallGac, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapMetadata.GenerateSigned(System.String,System.String,System.Boolean,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strSrcTypeLib" Type="System.String" />
        <Parameter Name="outPath" Type="System.String" />
        <Parameter Name="InstallGac" Type="System.Boolean" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="strSrcTypeLib">Nom de la bibliothèque de types pour laquelle générer un assembly.</param>
        <param name="outPath">Dossier dans lequel générer un assembly ou rechercher un assembly existant.</param>
        <param name="InstallGac">Ignoré.</param>
        <param name="Error">Chaîne dans laquelle un message d'erreur peut être écrit.</param>
        <summary>Génère ou recherche un assembly qui contient les métadonnées CLR pour un composant COM+ représenté par la bibliothèque de types spécifiée, signe l'assembly avec une paire de clés avec nom fort et l'installe dans le Global Assembly Cache.</summary>
        <returns>Nom de l'assembly généré ; sinon, une chaîne vide si les entrées ne sont pas valides.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si nécessaire, le <xref:System.EnterpriseServices.Internal.GenerateMetadata.GenerateSigned%2A> méthode génère un assembly qui contient les métadonnées CLR pour une bibliothèque de types spécifiée. Il génère une paire de clés avec nom fort et signe l’assembly.  
  
 Pour ce faire, il appelle le <xref:System.EnterpriseServices.Internal.GenerateMetadata.GenerateMetaData%2A> (méthode). Ces méthodes n’avez pas besoin d’être appelée directement depuis votre code.  
  
 Le `InstallGac` paramètre indique s’il faut installer l’assembly dans le global assembly cache. Toutefois, l’implémentation ignore cette valeur et essaie toujours d’installer l’assembly signé dans le global assembly cache.  
  
 ]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="SearchPath">
      <MemberSignature Language="C#" Value="public static int SearchPath (string path, string fileName, string extension, int numBufferChars, string buffer, int[] filePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;kernel32.dll&quot; as &quot;SearchPath&quot; unicode winapi lasterr)int32 SearchPath(string path, string fileName, string extension, int32 numBufferChars, string buffer, int32[] filePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.GenerateMetadata.SearchPath(System.String,System.String,System.String,System.Int32,System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SearchPath (path As String, fileName As String, extension As String, numBufferChars As Integer, buffer As String, filePart As Integer()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SearchPath(System::String ^ path, System::String ^ fileName, System::String ^ extension, int numBufferChars, System::String ^ buffer, cli::array &lt;int&gt; ^ filePart);" />
      <MemberSignature Language="F#" Value="static member SearchPath : string * string * string * int * string * int[] -&gt; int" Usage="System.EnterpriseServices.Internal.GenerateMetadata.SearchPath (path, fileName, extension, numBufferChars, buffer, filePart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
        <Parameter Name="numBufferChars" Type="System.Int32" />
        <Parameter Name="buffer" Type="System.String" />
        <Parameter Name="filePart" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès dans lequel rechercher le fichier.</param>
        <param name="fileName">Nom du fichier à rechercher.</param>
        <param name="extension">Extension à ajouter au nom de fichier pour la recherche du fichier.</param>
        <param name="numBufferChars">Taille de la mémoire tampon qui reçoit le chemin d’accès et le nom de fichier valides.</param>
        <param name="buffer">Mémoire tampon qui reçoit le chemin d’accès et le nom du fichier trouvé.</param>
        <param name="filePart">Variable qui reçoit l’adresse du dernier composant du chemin d’accès et du nom de fichier valides.</param>
        <summary>Recherche un fichier spécifié dans un chemin d’accès spécifié.</summary>
        <returns>Si la recherche aboutit, la valeur de retour est la longueur de la chaîne copiée dans <paramref name="buffer" />. Si la recherche échoue, la valeur de retour est 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez la documentation Platform SDK sur SearchPath à [ http://msdn.microsoft.com/library/default.asp?url=/library/fileio/base/searchpath.asp ](http://msdn.microsoft.com/library/default.asp?url=/library/fileio/base/searchpath.asp).  
  
 ]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
  </Members>
</Type>