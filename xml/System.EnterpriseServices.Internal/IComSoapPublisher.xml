<Type Name="IComSoapPublisher" FullName="System.EnterpriseServices.Internal.IComSoapPublisher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="27108ab5572e3d72aa2b7c6b0d1a777c188569fb" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36487503" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="VB.NET" Value="Public Interface IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public interface class IComSoapPublisher" />
  <TypeSignature Language="F#" Value="type IComSoapPublisher = interface" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eee-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Publie des interfaces COM pour les applications COM+ compatibles SOAP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de <xref:System.EnterpriseServices.Internal.IComSoapPublisher> est <xref:System.EnterpriseServices.Internal.Publish>; consultez la rubrique appropriée pour plus de détails.  
  
 <xref:System.EnterpriseServices.Internal.IComSoapPublisher> est utilisé en interne par le .NET Framework. Vous n’avez pas besoin utiliser directement dans votre code.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateMailBox : string * string *  *  *  *  -&gt; unit" Usage="iComSoapPublisher.CreateMailBox (RootMailServer, MailBox, SmtpName, Domain, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(6)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Domain" Type="System.String&amp;" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">URL du serveur de messagerie racine.</param>
        <param name="MailBox">La boîte aux lettres à créer.</param>
        <param name="SmtpName">Lorsque cette méthode est retournée, ce paramètre contient le nom du serveur SMTP (Simple Mail Transfer Protocol) comportant la boîte aux lettres.</param>
        <param name="Domain">Lorsque cette méthode est retournée, ce paramètre contient le domaine du serveur SMTP.</param>
        <param name="PhysicalPath">Lorsque cette méthode est retournée, ce paramètre contient le chemin d'accès du système de fichiers pour la boîte aux lettres.</param>
        <param name="Error">Lorsque cette méthode est retournée, le paramètre contient un message d'erreur si un problème a été rencontré.</param>
        <summary>Crée une boîte aux lettres d'application COM+ compatible SOAP à l'URL spécifiée. Non totalement implémenté.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non totalement implémenté ; ne crée pas actuellement d’une boîte aux lettres. Retourne le message d’erreur « Services COM + SOAP publication SMTP n’est pas pris en charge ».  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un appelant dans la chaîne d'appel ne dispose pas de l'autorisation requise pour accéder à du code non managé.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateVirtualRoot : string * string *  *  *  *  -&gt; unit" Usage="iComSoapPublisher.CreateVirtualRoot (Operation, FullUrl, BaseUrl, VirtualRoot, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(4)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String&amp;" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String&amp;" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">Opération à exécuter.</param>
        <param name="FullUrl">Adresse d'URL complète de la racine virtuelle.</param>
        <param name="BaseUrl">Lorsque cette méthode est retournée, ce paramètre contient l'adresse d'URL de base.</param>
        <param name="VirtualRoot">Lorsque cette méthode est retournée, ce paramètre contient le nom de la racine virtuelle.</param>
        <param name="PhysicalPath">Lorsque cette méthode est retournée, ce paramètre contient le chemin d'accès du fichier pour la racine virtuelle.</param>
        <param name="Error">Lorsque cette méthode est retournée, le paramètre contient un message d'erreur si un problème a été rencontré.</param>
        <summary>Crée une racine virtuelle d'application COM+ compatible SOAP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il est recommandé que <xref:System.EnterpriseServices.Internal.ISoapServerVRoot.CreateVirtualRootEx%2A> au lieu de <xref:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un appelant dans la chaîne d'appel ne dispose pas de l'autorisation requise pour accéder à du code non managé.  - ou - L’appelant n’est pas autorisé à accéder aux informations DNS (Domain Name System).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="FullUrl" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la résolution du nom d'hôte local.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="FullUrl" /> est vide.  - ou - Le schéma spécifié dans <paramref name="FullUrl" /> n’est pas valide.  - ou - <paramref name="FullUrl" /> contient plus de deux barres obliques consécutives.  - ou - Le mot de passe spécifié dans <paramref name="FullUrl" /> n’est pas valide.  - ou - Le nom d’hôte spécifié dans <paramref name="FullUrl" /> n’est pas valide.  - ou - Le nom de fichier spécifié dans <paramref name="FullUrl" /> n’est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteMailBox : string * string *  -&gt; unit" Usage="iComSoapPublisher.DeleteMailBox (RootMailServer, MailBox, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(7)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">URL du serveur de messagerie racine.</param>
        <param name="MailBox">La boîte aux lettres à supprimer.</param>
        <param name="Error">Lorsque cette méthode est retournée, le paramètre contient un message d'erreur si un problème a été rencontré.</param>
        <summary>Supprime une boîte aux lettres d'application COM+ compatible SOAP à l'URL spécifiée. Non totalement implémenté.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non totalement implémenté ; ne supprime pas la boîte aux lettres. Retourne le message d’erreur « Services COM + SOAP publication SMTP n’est pas pris en charge ».  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un appelant dans la chaîne d'appel ne dispose pas de l'autorisation requise pour accéder à du code non managé.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteVirtualRoot : string * string *  -&gt; unit" Usage="iComSoapPublisher.DeleteVirtualRoot (RootWebServer, FullUrl, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">Serveur Web racine.</param>
        <param name="FullUrl">Adresse d'URL complète de la racine virtuelle.</param>
        <param name="Error">Lorsque cette méthode est retournée, le paramètre contient un message d'erreur si un problème a été rencontré.</param>
        <summary>Supprime une racine virtuelle d'application COM+ compatible SOAP. Non totalement implémenté.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La fonctionnalité de <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> n’est pas encore disponible.  
  
> [!CAUTION]
>  La méthode retourne actuellement sans erreur, mais la racine virtuelle n’est pas supprimée.  
  
 Lorsque la fonctionnalité est disponible, la méthode recommandée sera <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un appelant dans la chaîne d'appel ne dispose pas de l'autorisation requise pour accéder à du code non managé.</exception>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacInstall(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacInstall : string -&gt; unit" Usage="iComSoapPublisher.GacInstall AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(13)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Chemin d'accès du système de fichiers pour l'assembly.</param>
        <summary>Installe un assembly dans le Global Assembly Cache.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Un appelant dans la chaîne d'appel ne dispose pas de l'autorisation requise pour accéder à du code non managé.</exception>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacRemove(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacRemove : string -&gt; unit" Usage="iComSoapPublisher.GacRemove AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(14)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Chemin d'accès du système de fichiers pour l'assembly.</param>
        <summary>Enlève un assembly du Global Assembly Cache.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="AssemblyPath" /> est vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> n’est pas un assembly valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblyNameForCache : string *  -&gt; unit" Usage="iComSoapPublisher.GetAssemblyNameForCache (TypeLibPath, CachePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(15)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">Chemin d'accès du fichier qui contient la typelib.</param>
        <param name="CachePath">Lorsque cette méthode est retournée, ce paramètre contient le chemin d'accès complet de l'assembly de proxy dans le répertoire SoapCache.</param>
        <summary>Retourne le chemin d'accès complet pour un assembly généré et signé avec un nom fort dans le répertoire SoapCache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour un composant COM + non managé à publier via .NET remoting en tant que point de terminaison SOAP, un proxy doit être généré pour mettre les composants non managés à la disposition de .NET Framework. Pour cela, le programme en effectuant les mêmes étapes en tant que Type Library Importer (Tlbimp.exe), le [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)] outil qui permet de convertir les bibliothèques de types COM + non managés à des assemblys de métadonnées de proxy. Toutefois, pour l’activation de client via SOAP réussisse, les ordinateurs client et serveur doivent partager les même proxies de métadonnées signés à nom fort. Pour cette raison, lorsqu’un assembly de proxy managé est généré pour un composant COM + non managé, une clé de nom fort est également générée et utilisée pour signer l’assembly de proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="TypeLibPath" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException">Le nom de fichier est vide, contient seulement des espaces blancs ou contient des caractères non valides.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à <paramref name="TypeLibPath" /> est refusé.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="TypeLibPath" /> contient un signe deux-points (:) au milieu de la chaîne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeNameFromProgId : string * string -&gt; string" Usage="iComSoapPublisher.GetTypeNameFromProgId (AssemblyPath, ProgId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(10)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Chemin d'accès du système de fichiers pour l'assembly.</param>
        <param name="ProgId">Identificateur programmatique de la classe.</param>
        <summary>Reflète un assembly et retourne le nom de type correspondant à ProgID.</summary>
        <returns>Nom de type correspondant à ProgID.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Un appelant dans la chaîne d'appel ne dispose pas de l'autorisation requise pour accéder à du code non managé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit" Usage="iComSoapPublisher.ProcessClientTlb (ProgId, SrcTlbPath, PhysicalPath, VRoot, BaseUrl, Mode, Transport, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(9)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="TypeName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identificateur programmatique de la classe.</param>
        <param name="SrcTlbPath">Chemin d'accès du fichier qui contient la typelib.</param>
        <param name="PhysicalPath">Répertoire d'applications Web.</param>
        <param name="VRoot">Nom de la racine virtuelle.</param>
        <param name="BaseUrl">URL de base qui contient la racine virtuelle.</param>
        <param name="Mode">Mode d'activation.</param>
        <param name="Transport">Non utilisé. Spécifiez <see langword="null" /> pour ce paramètre.</param>
        <param name="AssemblyName">Lorsque cette méthode est retournée, ce paramètre contient le nom complet de l'assembly.</param>
        <param name="TypeName">Lorsque cette méthode est retournée, ce paramètre contient le nom qualifié complet de l'assembly.</param>
        <param name="Error">Lorsque cette méthode est retournée, le paramètre contient un message d'erreur si un problème a été rencontré.</param>
        <summary>Traite une bibliothèque de types du client, en créant un fichier de configuration sur le client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée sur une importation de proxy client pour générer un fichier de configuration de la communication à distance.  
  
 Dans l’implémentation, si le `Mode` paramètre est « wellknownobject » ou une chaîne vide (« »), un objet connu est supposé ; Sinon, l’activation du client est supposée.  
  
 Il est recommandé que <xref:System.EnterpriseServices.Internal.ISoapClientImport.ProcessClientTlbEx%2A> au lieu de <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un appelant dans la chaîne d'appel ne dispose pas de l'autorisation requise pour accéder à du code non managé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit" Usage="iComSoapPublisher.ProcessServerTlb (ProgId, SrcTlbPath, PhysicalPath, Operation, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(8)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="TypeName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identificateur programmatique de la classe.</param>
        <param name="SrcTlbPath">Chemin d'accès du fichier qui contient la bibliothèque de types.</param>
        <param name="PhysicalPath">Répertoire d'applications Web.</param>
        <param name="Operation">Opération à exécuter.</param>
        <param name="AssemblyName">Lorsque cette méthode est retournée, ce paramètre contient le nom complet de l'assembly.</param>
        <param name="TypeName">Lorsque cette méthode est retournée, ce paramètre contient le nom qualifié complet de l'assembly.</param>
        <param name="Error">Lorsque cette méthode est retournée, le paramètre contient un message d'erreur si un problème a été rencontré.</param>
        <summary>Traite une bibliothèque de types serveur, en ajoutant ou en supprimant des entrées de composants dans les fichiers Web.config et Default.disco. Génère un proxy si nécessaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Génère les entrées du fichier Web.config et Default.disco pour les composants COM +. Génère un proxy si nécessaire.  
  
 Il est recommandé que <xref:System.EnterpriseServices.Internal.ISoapServerTlb.AddServerTlb%2A> et <xref:System.EnterpriseServices.Internal.ISoapServerTlb.DeleteServerTlb%2A> au lieu de <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un appelant dans la chaîne d'appel ne dispose pas de l'autorisation requise pour accéder à du code non managé.</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException">Le paramètre <paramref name="SrcTlbPath" /> référençait scrobj.dll ; par conséquent, la publication SOAP des composants de script n'est pas prise en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAssembly : string -&gt; unit" Usage="iComSoapPublisher.RegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(11)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Chemin d'accès du système de fichiers pour l'assembly.</param>
        <summary>Inscrit un assembly pour COM Interop.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de <xref:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly%2A> utilise l’outil Assembly Registration (Regasm.exe) pour inscrire les classes pouvant être créées dans l’assembly. Pour plus d’informations, consultez [Regasm.exe (outil Assembly Registration Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">L’assembly d’entrée ne possède pas de nom fort.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant dans la chaîne d'appel ne dispose pas de l'autorisation requise pour accéder à du code non managé.  - ou - Un code base qui ne commence pas par "file://" a été spécifié sans le <see cref="T:System.Net.WebPermission" /> requis.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> est introuvable, ou une extension de nom de fichier n'est pas spécifiée.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> n’est pas un assembly valide.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes, ou le nom de l’assembly dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode marquée avec <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> n’est pas <see langword="static" />.  - ou - Plusieurs méthodes sont marquées avec <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> à un niveau donné de la hiérarchie.  - ou - La signature de la méthode marquée avec <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> n’est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member UnRegisterAssembly : string -&gt; unit" Usage="iComSoapPublisher.UnRegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(12)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Chemin d'accès du système de fichiers pour l'assembly.</param>
        <summary>Annule l'inscription d'un assembly COM Interop.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de <xref:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly%2A> utilise Regasm.exe pour annuler l’inscription des classes pouvant être créées dans l’assembly. Pour plus d’informations, consultez [Regasm.exe (outil Assembly Registration Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un appelant dans la chaîne d'appel ne dispose pas de l'autorisation requise pour accéder à du code non managé.  - ou - Un code base qui ne commence pas par "file://" a été spécifié sans le <see cref="T:System.Net.WebPermission" /> requis.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> est introuvable, ou une extension de nom de fichier n'est pas spécifiée.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> n’est pas un assembly valide.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes, ou le nom de l’assembly dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode marquée avec <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> n’est pas <see langword="static" />.  - ou - Plusieurs méthodes sont marquées avec <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> à un niveau donné de la hiérarchie.  - ou - La signature de la méthode marquée avec <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> n’est pas valide.</exception>
      </Docs>
    </Member>
  </Members>
</Type>