<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="68657bcf291225564a735695474ef67da01c6dca" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683992" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Encapsule les informations de réponse HTTP issues d'une opération ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les méthodes et propriétés de la <xref:System.Web.HttpResponse> classe sont exposées via la <xref:System.Web.HttpApplication.Response%2A> propriété de la <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, et <xref:System.Web.UI.UserControl> classes.  
  
 Les méthodes suivantes de la <xref:System.Web.HttpResponse> classe sont pris en charge uniquement dans les scénarios de publication et non dans la publication asynchrone sauvegarder scénarios :  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Mises à jour de pages partielles sont activées lorsque vous utilisez <xref:System.Web.UI.UpdatePanel> contrôles pour mettre à jour certaines régions d’une page au lieu de la mise à jour de la page entière avec une publication. Pour plus d’informations, consultez [vue d’ensemble du contrôle UpdatePanel](http://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) et [vue d’ensemble du rendu de Page partiel](http://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 L’exemple suivant dessine trois rectangles qui se chevauchent lorsque la page est demandée. Le code commence en définissant le <xref:System.Web.HttpResponse.ContentType%2A> propriété image/JPEG, afin que la page entière soit rendue en tant qu’une image JPEG. Le code appelle ensuite la <xref:System.Web.HttpResponse.Clear%2A> pour s’assurer qu’aucun contenu étranger n’est envoyé avec cette réponse. Ensuite, le code définit le <xref:System.Web.HttpResponse.BufferOutput%2A> propriété sur true afin que la page est complètement traitée avant d’être envoyée au client demandeur. Deux objets utilisés pour dessiner les rectangles sont alors créés : un <xref:System.Drawing.Bitmap> et un <xref:System.Drawing.Graphics> objet. Les variables créées dans la page sont utilisés en tant que coordonnées pour dessiner des rectangles et une chaîne qui s’affiche dans le plus grand rectangle.  
  
 Lorsque les trois rectangles et la chaîne qui figure en leur sein sont dessinés, le <xref:System.Drawing.Bitmap> est enregistré dans le <xref:System.IO.Stream> objet auquel est associé le <xref:System.Web.HttpResponse.OutputStream%2A> propriété et son format est défini au format JPEG. Le code appelle la <xref:System.Drawing.Image.Dispose%2A> et <xref:System.Drawing.Graphics.Dispose%2A> méthodes pour libérer les ressources utilisées par les deux objets de dessin. Enfin, le code appelle la <xref:System.Web.HttpResponse.Flush%2A> méthode pour envoyer la réponse mise en mémoire tampon au client demandeur.  
  
> [!NOTE]
>  Dans le code, le <xref:System.Web.HttpResponse> objet est référencé par le mot clé `Response`. Par exemple, `Response.Clear()` fait référence à la <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> (méthode). Le <xref:System.Web.UI.Page> classe a une propriété nommée <xref:System.Web.UI.Page.Response%2A> qui expose l’instance actuelle de <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objet <see cref="T:System.IO.TextWriter" /> qui autorise une sortie HTTP personnalisée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.HttpResponse" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre prend en charge l'infrastructure .NET Framework et n'est pas destiné à être utilisé directement à partir de votre code.  
  
 Les méthodes et propriétés de la <xref:System.Web.HttpResponse> classe sont exposées via la fonction intrinsèque <xref:System.Web.HttpContext.Response%2A> objet dans ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">Fichier, clé de cache ou <see cref="T:System.Web.Caching.CacheDependency" /> à ajouter à la liste de dépendances d'application.</param>
        <summary>Associe un jeu de dépendances de cache à la réponse pour faciliter l'invalidation de cette dernière si elle est stockée dans le cache de sortie et si les dépendances spécifiées sont modifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.AddCacheDependency%2A> méthode permet aux dépendances d’être créés entre les réponses mises en cache et un <xref:System.Web.Caching.CacheDependency> objet.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une dépendance de cache à l’aide de la <xref:System.Web.HttpResponse.AddCacheDependency%2A> (méthode) et un <xref:System.Web.Caching.CacheDependency> objet.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="dependencies" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Cette méthode a été appelée trop tard dans le pipeline du traitement du cache, une fois la réponse mise en cache créée.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rend la validité d'une réponse mise en cache dépendante d'autres éléments présents dans le cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">
          <see cref="T:System.Collections.ArrayList" /> qui contient les clés des éléments dont dépend la réponse mise en cache actuelle.</param>
        <summary>Rend la validité d'une réponse mise en cache dépendante d'autres éléments présents dans le cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque les éléments référencés dans le `cacheKeys` paramètre sont supprimés du cache, la réponse mise en cache de l’élément actuel n’est pas valide.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser une page ASP.NET qui est mis en cache de sortie. Le code de la page crée un <xref:System.Collections.ArrayList> objet de clés qui sont associés à des éléments qui sont stockés dans le <xref:System.Web.Caching.Cache> objet. Ensuite, le code transmet la <xref:System.Collections.ArrayList> comme paramètre dans un appel à la <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> (méthode). Cela rend la réponse mise en cache de sortie n’est pas valide si un des fichiers spécifiés dans le <xref:System.Collections.ArrayList> modifier.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Tableau de clés d'élément dont dépend la réponse mise en cache.</param>
        <summary>Rend la validité d'un élément mis en cache dépendante d'un autre élément du cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un de le `cacheKey`s sont supprimés du cache, la réponse mise en cache de l’élément actuel n’est pas valide.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Clé de l'élément dont dépend la réponse mise en cache.</param>
        <summary>Rend la validité d'une réponse mise en cache dépendante d'un autre élément du cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’élément correspondant à la `cacheKey` paramètre est supprimé du cache, la réponse mise en cache de l’élément actuel n’est pas valide.  
  
   
  
## Examples  
 L’exemple suivant est un contrôle utilisateur ASP.NET mis en cache de sortie. Le code du contrôle appelle la <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> méthode avec la clé d’un élément stocké dans le <xref:System.Web.Caching.Cache> objet passé comme paramètre. Si l’élément n’existe pas dans le cache, la réponse du contrôle qui a été enregistrée dans le cache de sortie est invalidée. Cela signifie que pour la requête suivante, une nouvelle version de la réponse du contrôle sera ajoutée au cache de sortie.  
  
 Ensuite, le code vérifie si un élément associé à un `bookData` clé est stockée dans le `Cache` de l’objet et affiche l’un des deux lignes de texte en fonction du résultat. Le code définit ensuite la <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> propriété d’un <xref:System.Web.UI.WebControls.DataGrid> contrôle, qui est nommé `dgBooks`, avec un appel à une personnalisée `DataHelper` partagée de la classe `GetBookData` (méthode) et remplit la <xref:System.Web.UI.WebControls.DataGrid> avec la <xref:System.Web.UI.Control.DataBind%2A> (méthode).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute un groupe de noms de fichier à la collection de noms de fichier dont dépend la réponse actuelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Collection de fichiers à ajouter.</param>
        <summary>Ajoute un groupe de noms de fichier à la collection de noms de fichier dont dépend la réponse actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant est une page ASP.NET qui est mis en cache de sortie. Le code de la page crée un <xref:System.Collections.ArrayList> de chemins d’accès de fichier, puis passe le <xref:System.Collections.ArrayList> comme paramètre dans un appel à la <xref:System.Web.HttpResponse.AddFileDependencies%2A> (méthode). Cela rend la sortie mise en cache réponse non valide si un des fichiers spécifiés dans le <xref:System.Collections.ArrayList> modifications.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">Tableau de fichiers à ajouter.</param>
        <summary>Ajoute un tableau de noms de fichiers à la collection de noms de fichiers dont dépend la réponse actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant ajoute un tableau de noms de fichiers à la <xref:System.Web.HttpResponse.AddFileDependencies%2A> liste des dépendances de fichier. Si les fichiers sont modifiés, la réponse mise en cache est invalidée.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à ajouter.</param>
        <summary>Ajoute un seul nom de fichier à la collection de noms de fichiers dont dépend la réponse actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez le <xref:System.Web.HttpResponse.AddFileDependency%2A> pour ajouter une dépendance de fichier, vous devez également spécifier la mise en cache de sortie par programme ou de façon déclarative. Par exemple, pour spécifier la sortie mise en cache de façon déclarative, utilisez la directive. Pour plus d’informations, consultez [Comment : sortie de la Page du Cache avec des dépendances de fichier](http://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db).  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter un nom de fichier unique dans le <xref:System.Web.HttpResponse.AddFileDependency%2A> liste des dépendances de fichier. Si le fichier change, la réponse mise en cache est invalidée.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l’en-tête HTTP auquel ajouter <c>value</c>.</param>
        <param name="value">Chaîne à ajouter à l'en-tête.</param>
        <summary>Ajoute un en-tête HTTP au flux de sortie. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> est fourni pour des raisons de compatibilité avec les versions précédentes d'ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> est le même que <xref:System.Web.HttpResponse.AppendHeader%2A> et est fournie uniquement pour la compatibilité avec les versions antérieures d’ASP. Avec ASP.NET, utilisez <xref:System.Web.HttpResponse.AppendHeader%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Méthode de rappel.</param>
        <summary>[Pris en charge dans .NET Framework 4.5.2 et ultérieur]  
  
 Inscrit un rappel que le runtime ASP.NET appelle immédiatement avant l'envoi des en-têtes de réponse correspondant à cette requête.</summary>
        <returns>Objet <see cref="T:System.Web.ISubscriptionToken" /> qui représente l'abonnement au pseudo-événement OnSendingHeaders.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  La méthode AddOnSendingHeaders n’est pas appelée si le module natif vide la réponse en premier.  
  
 L’événement pseudo-aléatoire OnSendingHeaders diffère de l’événement de pipeline au niveau IHttpModule dans la mesure où il s’agit d’un abonnement par demande plutôt que d’un abonnement par application. Le but est que le rappel peut modifier le code d’état de réponse ou peut définir un en-tête ou un cookie de réponse. Autres remarques sur l’utilisation et les avertissements :  
  
-   Cette méthode est effective uniquement lorsque IIS s’exécute dans le pipeline de mode pipeline intégré et uniquement si les en-têtes de réponse n’ont pas encore été envoyés pour la requête actuelle.  
  
-   Le runtime ASP.NET ne garantit pas quoi que ce soit sur le thread que le rappel est appelé sur. Par exemple, le rappel peut être appelé de façon synchrone dans un thread d’arrière-plan si un vidage d’arrière-plan est en cours d’exécution. <xref:System.Web.HttpContext.Current%2A> n’est pas garanti d’être disponible dans ce type de thread.  
  
-   Le rappel ne doit pas appeler toute méthode qui manipule le corps d’entité de réponse ou qui entraîne un vidage. Par exemple, le rappel ne doit pas appeler <xref:System.Web.HttpResponse.Redirect%2A>, comme cette méthode peut manipuler le corps d’entité de réponse.  
  
-   Le rappel doit contenir uniquement du code synchrone exécution courte. Tentative d’appeler une opération asynchrone ou attendre une telle opération peut entraîner un blocage.  
  
-   Le rappel ne doit pas lever d’exception ; Sinon, le comportement est indéfini.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">
          <see cref="T:System.Web.HttpCookie" /> à ajouter au flux de sortie.</param>
        <summary>Ajoute un cookie HTTP à la collection de cookies intrinsèque.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un nouveau cookie nommé `LastVisit`, définit la valeur du cookie à la date et heure actuelles et ajoute à la collection de cookies en cours. Tous les cookies de la collection de cookies sont envoyés au client dans le `Set-Cookie` flux de sortie de l’en-tête avec le protocole HTTP.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Un cookie est ajouté après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l'en-tête HTTP à ajouter au flux de sortie.</param>
        <param name="value">Chaîne à ajouter à l'en-tête.</param>
        <summary>Ajoute un en-tête HTTP au flux de sortie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez la <xref:System.Web.HttpResponse.AppendHeader%2A> méthode pour envoyer des en-têtes spécifiques au cache et en même temps, utilisez le modèle objet de cache (<xref:System.Web.HttpResponse.Cache%2A>) pour définir la stratégie de cache, les en-têtes de réponse HTTP qui se rapportent à la mise en cache (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`, et `Vary`) peut être supprimé lorsque le modèle objet de cache est utilisé. Ce comportement permet à ASP.NET de conserver les paramètres les plus restrictifs. Par exemple, considérez une page qui inclut des contrôles utilisateur. Si ces contrôles sont en conflit de stratégies de cache, la stratégie de cache plus restrictive qui sera utilisée. Si un contrôle utilisateur définit l’en-tête «`Cache-Control: Public`« et un autre contrôle utilisateur définit l’en-tête plus restrictif »`Cache-Control: Private`» via des appels à <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, le «`Cache-Control: Private`« en-tête sera envoyé avec la réponse.  
  
 Pour obtenir la liste d’en-têtes HTTP/1.1 standard, consultez la section 14, « Définitions de champ d’en-tête », dans le [Hypertext Transfer Protocol--HTTP/1.1](http://go.microsoft.com/fwlink/?LinkID=73147) spécification sur le site Web de World Wide Web Consortium (W3C).  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Web.HttpResponse.AppendHeader%2A> méthode pour ajouter un en-tête personnalisé à la <xref:System.Web.HttpResponse> objet envoyé au client demandeur.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'en-tête est ajouté une fois que les en-têtes HTTP ont été envoyés.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Texte à ajouter au fichier journal.</param>
        <summary>Ajoute des informations personnalisées au fichier journal IIS (Internet Information Services).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour permettre la chaîne spécifiée à enregistrer dans le fichier journal, vous devez d’abord activer la **requête URI** option de le **propriétés de journalisation étendues** boîte de dialogue pour le site que vous souhaitez enregistrer l’activité dans IIS .  
  
 Pour personnaliser la journalisation étendue dans IIS 6.0, procédez comme suit :  
  
1.  Dans le Gestionnaire IIS, développez le nœud ordinateur local, développez le dossier Web ou Sites FTP, cliquez sur le site Web ou FTP, puis cliquez sur **propriétés**.  
  
2.  Cliquez sur le **Site Web ou FTP** onglet, puis sélectionnez le **activer la journalisation** case à cocher (si elle n’est pas déjà sélectionnée).  
  
3.  Dans le **format de journal actif** , cliquez sur **au Format de fichier journal étendu W3C**.  
  
4.  Cliquez sur **propriétés**.  
  
5.  Cliquez sur le **avancé** , sélectionnez les propriétés que vous souhaitez ouvrir une session, puis cliquez sur **OK**.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter une chaîne dans le journal.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Chemin d’accès virtuel d’une ressource.</param>
        <summary>Ajoute un ID de session au chemin d'accès virtuel si la session utilise un état de session <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> et retourne le chemin combiné. Si l'état de session <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> n'est pas utilisé, <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> retourne le chemin d'accès virtuel d'origine.</summary>
        <returns>
          <paramref name="virtualPath" /> avec l'ID de session inséré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> est utilisé uniquement avec les sessions sans cookies pour générer des href absolus.  
  
   
  
## Examples  
 L’exemple suivant déclare une variable chaîne nommée `urlConverted`et lui affecte le résultat d’une <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> appel de méthode. Le code passe ensuite la valeur de la variable à un <xref:System.Web.UI.WebControls.HyperLink> du contrôle <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> propriété.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Objet de rappel.</param>
        <param name="state">État de réponse.</param>
        <summary>Envoie la réponse actuellement en mémoire tampon au client.</summary>
        <returns>Objet du résultat asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’objet sous-jacent <xref:System.Web.HttpWorkerRequest> objet prend en charge les opérations de vidage asynchrones et cette méthode est appelée à partir d’un événement de module asynchrone ou à partir d’un gestionnaire asynchrone, l’opération de vidage est exécutée de façon asynchrone. Sinon, l’opération de vidage est effectuée de façon synchrone. Vidage asynchrone est prise en charge pour IIS 6.0 et versions ultérieures.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La réponse est déjà terminée.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Octets à écrire dans le flux de sortie.</param>
        <summary>Écrit une chaîne de caractères binaires dans le flux de sortie HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant lit un fichier texte dans une mémoire tampon et écrit la mémoire tampon dans le flux de sortie HTTP.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si la sortie doit être placée en mémoire tampon et envoyée une fois que la réponse a été complètement traitée.</summary>
        <value>
          <see langword="true" /> si la sortie destinée au client est placée en mémoire tampon ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.Buffer%2A> propriété a été déconseillée en faveur de la <xref:System.Web.HttpResponse.BufferOutput%2A> propriété et est fournie uniquement pour la compatibilité avec les versions antérieures d’ASP. Avec ASP.NET, utilisez <xref:System.Web.HttpResponse.BufferOutput%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si la sortie doit être placée en mémoire tampon et envoyée une fois que la page entière a été traitée.</summary>
        <value>
          <see langword="true" /> si la sortie destinée au client est placée en mémoire tampon ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant définit la <xref:System.Web.HttpResponse.ContentType%2A> propriété pour la réponse à une image/jpeg, appelle le <xref:System.Web.HttpResponse.Clear%2A> méthode pour supprimer tout autre contenu qui peut être associé à la réponse, puis définit la <xref:System.Web.HttpResponse.BufferOutput%2A> propriété la valeur true afin que la page entière traités avant l’envoi de tout contenu au client demandeur.  
  
 Pour obtenir un exemple complet, consultez la <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la stratégie de mise en cache d’une page web (délai d’expiration, paramètres de confidentialité, clauses diverses).</summary>
        <value>Objet <see cref="T:System.Web.HttpCachePolicy" /> qui contient les informations sur la stratégie de mise en cache de la réponse actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant écrit les propriétés de la stratégie de cache actuelle dans le flux de sortie HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'en-tête HTTP <see langword="Cache-Control" /> qui correspond à l'une des valeurs d'énumération<see cref="T:System.Web.HttpCacheability" /></summary>
        <value>Représentation sous forme de chaîne de la valeur d'énumération <see cref="T:System.Web.HttpCacheability" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les valeurs de `Private`, `Public`, et `No-Cache` sont des chaînes et doit être entourée de guillemets (« »). Si le <xref:System.Web.HttpResponse.CacheControl%2A> est définie sur une valeur qui ne correspond pas à une de la <xref:System.Web.HttpCacheability> valeurs d’énumération, alors un <xref:System.ArgumentException> est levée. Si le <xref:System.Web.HttpResponse.CacheControl%2A> propriété n’est pas définie, la capacité de la réponse est définie sur <xref:System.Web.HttpCacheability.NoCache>.  
  
 Le `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>, et <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> propriétés ont été déconseillées. Au lieu de cela, les méthodes de la <xref:System.Web.HttpCachePolicy> classe sont disponibles via le <xref:System.Web.HttpResponse.Cache%2A> objet intrinsèque pour contrôler les Internet Information Services (IIS) cache de sortie et les caches de client.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur définie pour la chaîne ne correspond pas à l'une des valeurs d'énumération <see cref="T:System.Web.HttpCacheability" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le jeu de caractères HTTP du flux de sortie.</summary>
        <value>Jeu de caractères HTTP du flux de sortie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Charset` propriété peut être définie sur `null` supprimer HTTP `Content-Type` en-tête.  
  
   
  
## Examples  
 L’exemple suivant vérifie si le jeu de caractères du flux de sortie est Europe centrale (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La propriété <see langword="Charset" /> a été définie après l'envoi d'en-têtes.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface le contenu de sortie du flux de la mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.Clear%2A> méthode n’efface pas les informations d’en-tête.  
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Web.HttpResponse.ContentType%2A> propriété pour la réponse à une image/jpeg, appelle le <xref:System.Web.HttpResponse.Clear%2A> méthode pour supprimer tout autre contenu qui peut être associé à la réponse, puis définit la <xref:System.Web.HttpResponse.BufferOutput%2A> propriété la valeur true afin que la page terminé traités avant l’envoi de tout contenu au client demandeur.  
  
 Pour obtenir un exemple complet, consultez la <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface le contenu de sortie du flux de la mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.ClearContent%2A> méthode n’efface pas les informations d’en-tête.  
  
   
  
## Examples  
 L’exemple suivant efface tout le contenu à partir du flux de mémoire tampon.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface tous les en-têtes dans le flux de la mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant appelle la <xref:System.Web.HttpResponse.ClearHeaders%2A> pour s’assurer qu’aucun en-tête ne soit envoyé avec la réponse actuelle. Cette technique peut être particulièrement importante si la réponse ASP.NET génère une image, telle qu’un fichier JPEG. Dans cet exemple le <xref:System.Web.HttpResponse.ContentType%2A> propriété a la valeur image/jpeg.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Les en-têtes sont effacés après l'envoi des en-têtes HTTP.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Threading.CancellationToken" /> dépassé lors de la déconnexion du client.</summary>
        <value>Jeton d'annulation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette API méthode est thread-safe. Toutefois, il existe des restrictions sur l’utilisation du jeton d’annulation doit être. À l’aide de manière incorrecte peut entraîner des conditions de concurrence, des blocages ou tout autre comportement inattendu. Gardez à l’esprit les recommandations suivantes :  
  
-   Assurez-vous que vous n’appelez pas dans cette API en dehors des limites d’une demande unique, car ASP.NET sera supprimer le jeton d’annulation à la fin de la demande. Il n’existe aucune garantie que le jeton jamais passera à un état annulé avant sa suppression. Par exemple, si la demande se termine sans le client ayant déconnecté, le jeton sera supprimé sans tout d’abord avoir été annulée.  
  
-   N’attendez pas la <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, comme cela annule l’effet d’une notification asynchrone et peut provoquer des blocages.  
  
-   N’appelez pas la <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> surcharges lequel appeler le rappel sur l’original <xref:System.Threading.SynchronizationContext> objet.  
  
-   N’utilisez pas le <xref:System.Web.HttpContext> objet ou autres non thread-safe objets intrinsèques ASP.NET à partir du rappel fourni à la <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> (méthode). Le rappel peut s’exécuter en même temps que les autres ASP.NET ou code d’application.  
  
-   Conservez les méthodes de rappel d’exécution courte et non bloquante.  
  
-   Mettre tout en oeuvre pour éviter de lever des exceptions à partir de dans les méthodes de rappel.  
  
 Cette propriété est uniquement applicable pour les services Internet (IIS) 7.5 en mode intégré. Si vous l’appelez sans le droit IIS version ou un pipeline mode, un <xref:System.PlatformNotSupportedException> est levée. Pour déterminer la version d’IIS, utilisez <xref:System.Web.HttpRuntime.IISVersion%2A>. Pour déterminer le mode de pipeline, utilisez <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme la connexion du socket à un client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode met fin à la connexion au client de manière brusque et n’est pas destinée pour traiter une demande HTTP normal. La méthode envoie un paquet de réinitialisation au client, ce qui peut entraîner des données de réponse qui sont en mémoire tampon sur le serveur, le client ou quelque part entre le point d’être supprimé.  
  
 Toutefois, en général, vous devez appeler <xref:System.Web.HttpApplication.CompleteRequest%2A> à la place si vous souhaitez passer directement à la <xref:System.Web.HttpApplication.EndRequest> événements et envoyer une réponse au client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le jeu de caractères HTTP du flux de sortie.</summary>
        <value>Objet <see cref="T:System.Text.Encoding" /> qui contient les informations sur le jeu de caractères de la réponse actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut `ContentEncoding` peut être spécifié dans un fichier de configuration ASP.NET dans le [globalisation, élément (schéma des paramètres ASP.NET)](http://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) section. Si <xref:System.Web.HttpResponse.ContentEncoding%2A> est spécifié par le client, les paramètres de configuration par défaut sont remplacés.  
  
   
  
## Examples  
 L’exemple suivant écrit une description explicite du caractère définir le codage dans le flux de sortie.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Tentative d’affectation de la valeur <see langword="null" /> à <see cref="P:System.Web.HttpResponse.ContentEncoding" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type MIME HTTP du flux de sortie.</summary>
        <value>Type MIME HTTP du flux de sortie. La valeur par défaut est « <see langword="text/html" /> ».</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant définit la <xref:System.Web.HttpResponse.ContentType%2A> propriété pour la réponse à une image/jpeg, appelle le <xref:System.Web.HttpResponse.Clear%2A> méthode pour supprimer tout autre contenu qui peut être associé à la réponse, puis définit la <xref:System.Web.HttpResponse.BufferOutput%2A> propriété la valeur true afin que la page terminé traités avant l’envoi de tout contenu au client demandeur.  
  
 Pour obtenir un exemple complet, consultez la <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La propriété <see cref="P:System.Web.HttpResponse.ContentType" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de cookies constituant la réponse.</summary>
        <value>Collection de cookies constituant la réponse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET inclut deux collections de cookies intrinsèque. La collection accédée via la <xref:System.Web.HttpRequest.Cookies%2A> collection de <xref:System.Web.HttpRequest> contient des cookies transmis par le client au serveur dans le `Cookie` en-tête. La collection accédée via la <xref:System.Web.HttpResponse.Cookies%2A> collection de <xref:System.Web.HttpResponse> contient de nouveaux cookies créés sur le serveur et transmis au client dans le `Set-Cookie` en-tête.  
  
 Après avoir ajouté un cookie à l’aide de la <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> collection, le cookie est immédiatement disponible dans le <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> collection, même si la réponse n’a pas été envoyée au client.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau cookie nommé `LastVisit`, définit la valeur du cookie à la date et heure actuelles et ajoute à la collection de cookies en cours. Tous les cookies de la collection de cookies sont envoyés au client dans le `Set-Cookie` flux de sortie de l’en-tête avec le protocole HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Désactive la mise en cache de noyau pour la réponse actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la mise en cache du noyau n’est pas pris en charge, cette méthode n’a aucun effet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Désactive la mise en cache en mode utilisateur IIS pour cette réponse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la mise en cache du mode utilisateur IIS n’est pas pris en charge, cette méthode retourne sans exécuter d’action.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Envoie l'ensemble de la sortie actuellement en mémoire tampon au client, arrête l'exécution de la page et déclenche l'événement <see cref="E:System.Web.HttpApplication.EndRequest" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie uniquement pour la compatibilité avec ASP, autrement dit, pour la compatibilité avec la technologie de programmation Web basé sur COM qui a précédé ASP.NET. Si vous souhaitez passer directement à la <xref:System.Web.HttpApplication.EndRequest> événements et envoyer une réponse au client, il est généralement préférable d’appeler <xref:System.Web.HttpApplication.CompleteRequest%2A> à la place.  
  
 Pour reproduire le comportement de la `End` méthode dans ASP, cette méthode essaie de déclencher une <xref:System.Threading.ThreadAbortException> exception. Si cette tentative réussit, le thread appelant est abandonné, c'est-à-dire nuire aux performances de votre site. Dans ce cas, aucun code après l’appel à la <xref:System.Web.HttpResponse.End%2A> méthode est exécutée.  
  
 Si le <xref:System.Web.HttpResponse.End%2A> méthode n’est pas en mesure de déclencher un <xref:System.Threading.ThreadAbortException>, elle vide à la place les octets de la réponse au client. Pour cela, de façon synchrone, ce qui peut également être nuit aux performances de votre site.  
  
 Dans les deux cas (ou non une <xref:System.Threading.ThreadAbortException> exception est levée avec succès), le pipeline de réponse passe directement à la <xref:System.Web.HttpApplication.EndRequest> événement.  
  
 Le <xref:System.Web.HttpApplication.CompleteRequest%2A> méthode sans lever une exception et de code après l’appel à la <xref:System.Web.HttpApplication.CompleteRequest%2A> méthode peut être exécutée. Si votre intention est d’éviter l’exécution de code suivant et si la baisse des performances de <xref:System.Web.HttpResponse.End%2A> est acceptable, vous pouvez appeler <xref:System.Web.HttpResponse.End%2A> au lieu de <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">L’appel à <see cref="M:System.Web.HttpResponse.End" /> a mis fin à la requête active.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objet du résultat asynchrone.</param>
        <summary>Termine une opération de vidage asynchrone.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le vidage asynchrone n'est pas pris en charge et le paramètre <paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le vidage asynchrone n’est pas pris en charge et le paramètre <paramref name="asyncResult" /> ne peut pas être casté en objet <c>FlushAsyncResult</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre de minutes avant l'expiration d'une page mise en cache dans un navigateur. Si l'utilisateur retourne à la même page avant qu'elle n'expire, la version mise en cache est affichée. <see cref="P:System.Web.HttpResponse.Expires" /> est fourni pour des raisons de compatibilité avec les versions précédentes d'ASP.</summary>
        <value>Nombre de minutes avant l'expiration de la page.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> et <xref:System.Web.HttpResponse.CacheControl%2A> propriétés ont été déconseillées au profit des méthodes de la <xref:System.Web.HttpCachePolicy> disponibles par le biais de la classe le <xref:System.Web.HttpResponse.Cache%2A> objet intrinsèque pour Internet Information Services (IIS) de contrôler le cache de sortie et met en cache du client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la date et l'heure absolues auxquelles supprimer des informations du cache. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> est fourni pour des raisons de compatibilité avec les versions précédentes d'ASP.</summary>
        <value>Date et heure auxquelles la page expire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>, et <xref:System.Web.HttpResponse.CacheControl%2A> propriétés ont été déconseillées au profit des méthodes de la <xref:System.Web.HttpCachePolicy> disponibles par le biais de la classe le <xref:System.Web.HttpResponse.Cache%2A> objet intrinsèque pour Internet Information Services (IIS) de contrôler le cache de sortie et met en cache du client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un objet de filtre de retour à la ligne utilisé pour modifier le corps d'une entité HTTP avant la transmission.</summary>
        <value>Objet <see cref="T:System.IO.Stream" /> qui fait office de filtre de sortie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous créez un `Stream` et définissez la <xref:System.Web.HttpResponse.Filter%2A> propriété le `Stream` objet, tous les HTTP sortie est envoyée par <xref:System.Web.HttpResponse.Write%2A> passent par le filtre.  
  
   
  
## Examples  
 L’exemple suivant est une page ASP.NET qui affecte le <xref:System.Web.HttpResponse.Filter%2A> propriété à une nouvelle instance de la `UpperCaseFilter` classe personnalisée <xref:System.IO.Stream> classe qui convertit tout texte qui transite par son biais en majuscules. Les informations sur la demande sont enregistrées dans un fichier texte, puis la <xref:System.Web.HttpResponse.Filter%2A> est définie. Une fois le filtre de réponse, le code appelle la <xref:System.Web.HttpRequest.MapPath%2A> méthode pour obtenir le chemin d’accès absolu à un fichier texte nommé `TestFile.txt` qui sert de source pour le contenu de la réponse. Le code crée ensuite un nouveau <xref:System.IO.StreamReader> objet à lire le fichier texte du début à la fin, puis appelle la <xref:System.Web.HttpResponse.Write%2A> méthode pour afficher le contenu du fichier sur la page.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le filtrage n'est pas autorisé avec cette entité.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Envoie au client l'ensemble de la sortie actuellement en mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Force mis tous actuellement en mémoire tampon de sortie à envoyer au client. Le <xref:System.Web.HttpResponse.Flush%2A> méthode peut être appelée plusieurs fois pendant le traitement de la requête.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Drawing.Graphics.Save%2A> méthode pour enregistrer un <xref:System.Drawing.Bitmap> de l’objet à le <xref:System.Web.HttpResponse.OutputStream%2A> propriété convertit l’image JPEG de format et. Le code appelle ensuite la `Dispose` méthode sur le <xref:System.Drawing.Bitmap> objet et un <xref:System.Drawing.Graphics> objet, en libérant les ressources qu’ils utilisaient. Il appelle ensuite la <xref:System.Web.HttpResponse.Flush%2A> méthode pour envoyer le contenu de la réponse au client demandeur.  
  
 Pour obtenir un exemple complet, consultez la <xref:System.Web.HttpResponse> classe.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le cache est vidé une fois la réponse envoyée.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Envoie de façon asynchrone l'ensemble de la sortie actuellement en mémoire tampon au client.</summary>
        <returns>
          <see cref="T:System.Threading.Tasks.Task" /> qui représente l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un objet <see cref="T:System.Text.Encoding" /> qui représente l'encodage du flux de sortie d'en-tête actuel.</summary>
        <value>
          <see cref="T:System.Text.Encoding" /> qui contient des informations sur le jeu de caractères de l'en-tête actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.HeaderEncoding%2A> propriété vous donne la possibilité de désactiver ou de modifier le <xref:System.Text.Encoding> objet sur un en-tête de réponse à l’aide de la <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>, ou <xref:System.Text.UTF8Encoding> objet. L’encodage de valeur par défaut est la <xref:System.Text.UTF8Encoding> classe.  
  
 En modifiant le type de la <xref:System.Web.HttpResponse.HeaderEncoding%2A> propriété, vous pouvez éventuellement augmenter le risque de certaines attaques malveillantes ou de la cause des données sensibles d’être envoyées via l’en-tête de réponse. Les attaques par injection d’en-tête peuvent être évitées, en partie, en laissant le <xref:System.Web.HttpResponse.HeaderEncoding%2A> propriété d’une réponse à la valeur par défaut. Une attaque contre une application vulnérable pourrait écho le retour de données approuvées dans le cadre d’un en-tête de réponse. Si la <xref:System.Web.HttpResponse.HeaderEncoding%2A> est désactivée en raison d’une exigence pour les lignes de continuation dans un en-tête ou si tout en-tête est construit en fonction du résultat de données non approuvées, les données d’en-tête doivent être validées avant l’envoi au flux de réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur d’encodage est <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">La valeur d’encodage est <see cref="P:System.Text.Encoding.Unicode" />.  
  
 \- ou -  
  
 Les en-têtes ont déjà été envoyés.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection d'en-têtes de réponse.</summary>
        <value>Collection <see cref="T:System.Collections.Specialized.NameValueCollection" /> d'en-têtes de réponse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.Headers%2A> propriété est uniquement prise en charge avec la [!INCLUDE[iisver](~/includes/iisver-md.md)] mode pipeline intégré et au moins .NET Framework 3.0. Lorsque vous essayez d’accéder à la <xref:System.Web.HttpResponse.Headers%2A> propriété et qu’une de ces deux conditions n’est pas remplie, un <xref:System.PlatformNotSupportedException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L’opération exige le mode pipeline intégré d’[!INCLUDE[iisver](~/includes/iisver-md.md)] et au moins le .NET Framework version 3.0.</exception>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Pris en charge dans .NET Framework 4.5.2 et ultérieur]  
  
 Obtient une valeur indiquant si les en-têtes de réponse ont été écrits.</summary>
        <value>
          <see langword="true" /> si les en-têtes de réponse ont été écrits ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le client est encore connecté au serveur.</summary>
        <value>
          <see langword="true" /> si le client est actuellement connecté ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.IsClientConnected%2A> propriété renvoie `false` lorsque les conditions suivantes sont vraies :  
  
-   Fin de la connexion au client. Cela peut se produire si le <xref:System.Web.HttpResponse.Close%2A> méthode a été appelée, ou si le client a arrêté l’exécution de la page Web ou accède à une autre page.  
  
-   Le <xref:System.Web.HttpWorkerRequest> objet qui gère la demande est `null` ou <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> méthode renvoie `false`. Si une personnalisée <xref:System.Web.HttpWorkerRequest> objet gère la demande, puis la <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> méthode peut être définie en fonction de critères personnalisés. Par exemple, la demande de traitement personnalisé peut forcer un délai d’attente après une période de temps.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Web.HttpResponse.IsClientConnected%2A> propriété pour vérifier si le client qui demande la page reste connecté au serveur. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> a la valeur true, le code appelle la <xref:System.Web.HttpResponse.Redirect%2A> (méthode) et le client afficheront une autre page. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> est false, le code appelle la <xref:System.Web.HttpResponse.End%2A> (méthode) et le traitement de la page se termine.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur booléenne qui indique si le client est transféré vers un nouvel emplacement.</summary>
        <value>
          <see langword="true" /> si la valeur de l'en-tête de réponse d'emplacement est différente de l'emplacement actuel ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> propriété avec le <xref:System.Web.HttpResponse.RedirectLocation%2A> propriété pour tester et déterminer si l’URI absolu qui est transmis au client dans le protocole HTTP `Location` en-tête est différent de celui de l’URI actuel, ainsi que du nouvel URI prévu est en cours transféré vers sera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Permet la sortie du texte dans le flux de réponse HTTP sortant.</summary>
        <value>Objet <see cref="T:System.IO.TextWriter" /> qui permet une sortie personnalisée vers le client.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant est une page ASP.NET qui contient un <xref:System.Web.UI.WebControls.TextBox> contrôle qui a son <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> propriété <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>. Code de la page prend le texte qu’un utilisateur entre dans le <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, utilise le <xref:System.Web.HttpServerUtility.HtmlEncode%2A> méthode au format HTML encoder et le <xref:System.Web.HttpResponse.Output%2A> propriété pour afficher la chaîne encodée à la page.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Permet une sortie binaire vers le corps du contenu HTTP sortant.</summary>
        <value>
          <see cref="T:System.IO.Stream" /> d'E/S représentant le contenu brut du corps du contenu HTTP sortant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En commençant avec le .NET Framework version 2.0, lorsque vous utilisez la <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode du flux d’e/s retourné par la <xref:System.Web.HttpResponse.OutputStream%2A> propriété, les exceptions suivantes peuvent être levées :  
  
-   <xref:System.ArgumentOutOfRangeException>, si le `offset` ou `count` paramètre est négatif ou si le `buffer` longueur du paramètre moins le `offset` paramètre est inférieur ou égal à zéro.  
  
-   <xref:System.ArgumentNullException>, si le `buffer` paramètre est `null`.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Drawing.Image.Save%2A> méthode pour enregistrer un <xref:System.Drawing.Bitmap> de l’objet à le <xref:System.Web.HttpResponse.OutputStream%2A> propriété et convertit l’image au format JPEG. Le code appelle ensuite la méthode Dispose sur le <xref:System.Drawing.Bitmap> objet et un <xref:System.Drawing.Graphics> objet, en libérant les ressources qu’ils utilisaient. Enfin, le code appelle la <xref:System.Web.HttpResponse.Flush%2A> méthode pour envoyer le contenu de la réponse au client demandeur.  
  
 Pour obtenir un exemple complet, consultez la <xref:System.Web.HttpResponse> classe.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="OutputStream" /> n’est pas disponible.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à ajouter à l'en-tête <see langword="PICS-Label" />.</param>
        <summary>Ajoute un en-tête <see langword="PICS-Label" /> HTTP au flux de sortie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plateforme pour la sélection de contenu Internet (PICS) est une norme World Wide Web Consortium (W3C) pour l’étiquetage de contenu. PICS est essentiellement un langage pour la création d’un système d’évaluation.  
  
 N’importe quelle valeur peut être une étiquette PICS ; ASP.NET ne valide pas l’étiquette. La longueur maximale de la chaîne est de 255 caractères. Pour plus d’informations sur la syntaxe et les normes de PICS, consultez le [World Wide Web Consortium](http://go.microsoft.com/fwlink/?LinkID=37125) site Web.  
  
   
  
## Examples  
 L’exemple suivant est une page ASP.NET qui affiche une image. La page de code appelle la <xref:System.Web.HttpResponse.Pics%2A> pour définir le protocole HTTP `PICS-Label` en-tête pour la réponse. La chaîne est passée comme paramètre à la <xref:System.Web.HttpResponse.Pics%2A> méthode représente une étiquette d’estimation générée à partir du site Web de contenu évaluation Association ICRA (Internet).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Promeut un objet promis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">URL de la demande d'opération push. Cela doit être le chemin d’accès virtuel de la ressource relative que le serveur souhaite envoyer au client en mode Push.</param>
        <summary>Cette API permet de prendre en charge les applications qui envoient des promesses push aux clients HTTP 2.0. Vous trouverez plus de détails concernant le mode Server Push Http2 dans [HTTP/2 Specification Section 8.2: Server Push](https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise est non déterministe et applications ne doivent pas avoir une logique qui en dépend. Son seul but est parti des performances dans certains cas. Il existe de nombreuses conditions (protocole et l’implémentation) qui peuvent conduire à ignorer les demandes de transmission complètement. L’attente est basé sur incendie initiale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">URL de la demande d'opération push. Cela doit être le chemin d’accès virtuel de la ressource relative que le serveur souhaite envoyer au client en mode Push.</param>
        <param name="method">Méthode de demande HTTP utilisée par la demande d'opération push.</param>
        <param name="headers">En-tête de demande HTTP utilisé par la demande d'opération push.</param>
        <summary>Cette API permet de prendre en charge les applications qui envoient des promesses push aux clients HTTP 2.0. Vous trouverez plus de détails concernant le mode Server Push Http2 dans [HTTP/2 Specification Section 8.2: Server Push](https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise est non déterministe et applications ne doivent pas avoir une logique qui en dépend. Son seul but est parti des performances dans certains cas. Il existe de nombreuses conditions (protocole et l’implémentation) qui peuvent conduire à ignorer les demandes de transmission complètement. L’attente est basé sur incendie initiale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirige un client vers une nouvelle URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Emplacement cible. Cela peut être un chemin virtuel relatif à l’application.</param>
        <summary>Redirige une requête vers une nouvelle URL en spécifiant celle-ci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Web.HttpResponse.Redirect%2A> équivaut à appeler la méthode <xref:System.Web.HttpResponse.Redirect%2A> avec le deuxième paramètre défini sur `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> appels <xref:System.Web.HttpResponse.End%2A> qui lève une <xref:System.Threading.ThreadAbortException> exception à l’achèvement. Cette exception a un effet négatif sur les performances des applications Web. Par conséquent, nous vous recommandons d’au lieu de cette surcharge utiliser le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge et le passer `false` pour le `endResponse` paramètre, puis appelez le <xref:System.Web.HttpApplication.CompleteRequest%2A> (méthode). Pour plus d'informations, voir la méthode <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Pour les pages mobiles uniquement, si votre application s’appuie sur les sessions sans cookies, ou il peut recevoir des requêtes à partir des appareils mobiles qui requièrent des sessions sans cookies, à l’aide d’un tilde (~) dans un chemin d’accès peut entraîner la création d’une nouvelle session et la perte potentielle de données de session. Pour définir une propriété sur un contrôle mobile avec un chemin d’accès tel que « ~ / chemin d’accès », résoudre le chemin d’accès à l’aide <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> « ~ / chemin d’accès » avant de l’assigner à la propriété.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302. Un autre moyen pour transférer le contrôle vers une autre page est le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode). Le <xref:System.Web.HttpServerUtility.Transfer%2A> méthode est généralement plus efficace, car elle n’entraîne pas un aller-retour vers le client. Pour plus d’informations, consultez [Comment : Rediriger les utilisateurs vers une autre Page](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 L’exemple suivant force une redirection inconditionnelle vers un autre site Web.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Une redirection a été tentée après l’envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Emplacement cible.</param>
        <param name="endResponse">Indique si l'exécution de la page active doit s'arrêter.</param>
        <summary>Redirige un client vers une nouvelle URL. Spécifie la nouvelle URL et indique si l'exécution de la page active doit s'arrêter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une URL absolue (par exemple, http://www.contoso.com/default.aspx) ou une URL relative (par exemple, Default.aspx) peut être spécifiée pour l’emplacement cible, mais certains navigateurs peuvent refuser une URL relative.  
  
 Lorsque vous utilisez cette méthode dans un gestionnaire de page pour mettre fin à une demande pour une page et démarrer une nouvelle demande d’une autre page, définissez `endResponse` à `false` , puis appelez le <xref:System.Web.HttpApplication.CompleteRequest%2A> (méthode). Si vous spécifiez `true` pour le `endResponse` paramètre, cette méthode appelle la <xref:System.Web.HttpResponse.End%2A> méthode pour la demande d’origine, qui lève une <xref:System.Threading.ThreadAbortException> exception quand elle se termine. Cette exception a un effet négatif sur les performances des applications Web, c’est pourquoi en passant `false` pour le `endResponse` est recommandé de paramètre. Pour plus d'informations, voir la méthode <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Pour les pages mobiles, si votre application s’appuie sur les sessions sans cookies, ou il peut recevoir des requêtes à partir des appareils mobiles qui requièrent des sessions sans cookies, à l’aide d’un tilde (~) dans un chemin d’accès peut créer une nouvelle session et perdre les données de session. Pour définir une propriété sur un contrôle mobile avec un chemin d’accès tel que « ~ / chemin d’accès », résoudre le chemin d’accès à l’aide <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> « ~ / chemin d’accès » avant de l’assigner à la propriété.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302. Un autre moyen pour transférer le contrôle vers une autre page est le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode). Le <xref:System.Web.HttpServerUtility.Transfer%2A> méthode est généralement plus efficace, car elle n’entraîne pas un aller-retour vers le client. Pour plus d’informations, consultez [Comment : Rediriger les utilisateurs vers une autre Page](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Web.HttpResponse.IsClientConnected%2A> propriété pour vérifier si le client qui demande la page reste connecté au serveur. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> a la valeur true, le code appelle la <xref:System.Web.HttpResponse.Redirect%2A> (méthode) et le client afficheront une autre page. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> est false, le code appelle la <xref:System.Web.HttpResponse.End%2A> (méthode) et le traitement de la page se termine.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> contient un caractère de saut de ligne.</exception>
        <exception cref="T:System.Web.HttpException">Une redirection a été tentée après l’envoi des en-têtes HTTP.</exception>
        <exception cref="T:System.ApplicationException">La demande de page est le résultat d’un rappel.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l'en-tête HTTP <see langword="Location" />.</summary>
        <value>URI absolu transmis au client dans l'en-tête HTTP <see langword="Location" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser cette propriété pour spécifier l’URL de redirection lorsque vous codez une redirection permanente à l’aide du code de réponse HTTP 301.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Les en-têtes HTTP ont déjà été écrits.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute une redirection permanente d'une URL demandée vers une URL spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Emplacement vers lequel la requête est redirigée.</param>
        <summary>Exécute une redirection permanente de l'URL demandée vers l'URL spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> surcharge de méthode fournit un code d’état HTTP 301 dans la réponse et inclut l’URL pour rediriger la demande. Un code d’état HTTP 301 est un code standard dans une réponse HTTP. Il indique qu’une redirection permanente existe, et il fournit l’emplacement de redirection.  
  
 Appel de la <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> la surcharge de méthode met fin à la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> inclut un caractère de saut de ligne (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Emplacement vers lequel la requête est redirigée.</param>
        <param name="endResponse">
          <see langword="true" /> pour terminer la réponse ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</param>
        <summary>Exécute une redirection permanente de l'URL demandée vers l'URL spécifiée et permet de compléter la réponse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> surcharge de méthode fournit un code d’état HTTP 301 dans la réponse et inclut l’URL pour rediriger la demande. Cette surcharge de méthode fournit également l’option pour spécifier s’il faut terminer ou compléter la réponse après que la redirection a été effectuée. Un code d’état HTTP 301 est un code standard dans une réponse HTTP. Il indique qu’une redirection permanente existe, et il fournit l’emplacement de redirection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> inclut un caractère de saut de ligne (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirige une requête vers une nouvelle URL en utilisant des valeurs de paramètres d'itinéraire, un nom d'itinéraire ou les deux.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Redirige une requête vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Elle équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit l’objet qui est passé dans `routeValues` à un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objet à l’aide de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructeur. Le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode est alors appelée pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <summary>Redirige une requête vers une nouvelle URL en utilisant un nom d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Elle équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit le nom d’itinéraire qui est passé dans `routeName` vers une URL à l’aide de la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> (méthode).  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui est nommé `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Redirige une requête vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Elle équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode appelle la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Redirige une requête vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire et un nom d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Elle équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit l’objet qui est passé dans `routeValues` à un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objet à l’aide de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructeur. Le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode est alors appelée pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui est nommé `Product` et qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Redirige une requête vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire et un nom d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Elle équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode est appelée pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui est nommé `Product` et qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire, un nom d'itinéraire, ou les deux.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Elle équivaut à appeler le <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit l’objet qui est passé dans `routeValues` à un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objet à l’aide de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructeur. Le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode est alors appelée pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 301.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant un nom d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Elle équivaut à appeler le <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit le nom d’itinéraire qui est passé dans `routeName` vers une URL à l’aide de la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> (méthode).  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 301.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui est nommé `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Elle équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode appelle la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 301.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire et le nom d'itinéraire qui correspondent à la nouvelle URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Elle équivaut à appeler le <xref:System.Web.HttpResponse.RedirectPermanent%2A> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit l’objet qui est passé dans `routeValues` à un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objet à l’aide de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructeur. Le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode est alors appelée pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 301.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui est nommé `Product` et qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire et un nom d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Elle équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode appelle la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 301.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui est nommé `Product` et qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime des éléments du cache de sortie à l'aide du fournisseur de cache de sortie par défaut.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès absolu virtuel des éléments retirés du cache.</param>
        <summary>Supprime du cache tous les éléments associés au fournisseur de cache de sortie par défaut. Cette méthode est statique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode pour supprimer des éléments de cache de sortie associés au fournisseur de cache de sortie par défaut. Appelez le <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> méthode pour supprimer des éléments de cache de sortie qui sont associés à des fournisseurs de cache de sortie personnalisés qui sont spécifiés dans le fichier de configuration de site Web.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> n'est pas un chemin d'accès virtuel absolu.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès virtuel des éléments retirés du cache.</param>
        <param name="providerName">Fournisseur utilisé pour supprimer les artefacts de cache de sortie associés au chemin d’accès spécifié.</param>
        <summary>Utilise le fournisseur de cache de sortie spécifié pour supprimer tous les éléments de cache de sortie associés au chemin d’accès spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode pour supprimer des éléments de cache de sortie qui sont associés les fournisseurs de cache de sortie personnalisés qui sont spécifiés dans le fichier de configuration de site Web. Pour supprimer des éléments de cache de sortie associés au fournisseur de cache de sortie par défaut, appelez le <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> n'est pas un chemin d'accès valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Cookie à mettre à jour dans la collection.</param>
        <summary>Dans la mesure où la méthode <b>HttpResponse.SetCookie</b> est exclusivement réservée à un usage interne, vous ne devez pas l’appeler dans votre code. Appelez plutôt la méthode <b>HttpResponse.Cookies.Set</b>, comme le montre l’exemple suivant.<br /> Met à jour un cookie existant dans la collection de cookies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant met à jour la valeur d’un cookie existant.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Tentative de définir le cookie après l'envoi des en-têtes HTTP.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit la ligne <see langword="Status" /> retournée au client.</summary>
        <value>Le fait de définir le code d'état provoque le retour au client d'une chaîne décrivant l'état de la sortie HTTP. La valeur par défaut est 200 (OK).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> a été déconseillé en faveur de <xref:System.Web.HttpResponse.StatusDescription%2A> et est fournie uniquement pour la compatibilité avec les versions antérieures d’ASP. Avec ASP.NET, utilisez <xref:System.Web.HttpResponse.StatusDescription%2A> à la place.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le code d'état spécifié n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le code d'état HTTP du résultat retourné au client.</summary>
        <value>Entier représentant l'état de la sortie HTTP retournée au client. La valeur par défaut est 200 (OK). Pour une liste des codes d’état valides, consultez [Codes d’état Http](http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie le code d’état du flux de sortie. Si le code d’état n’est pas égal à 200, code supplémentaire est exécuté.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.StatusCode" /> est défini une fois les en-têtes HTTP envoyés.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la chaîne d'état HTTP de la sortie retournée au client.</summary>
        <value>Chaîne qui décrit l'état de la sortie HTTP retournée au client. La valeur par défaut est « OK ». Pour une liste des codes d’état valides, consultez [Codes d’état Http](http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie la chaîne d’état du flux de sortie. Si l’état n’est pas égal à « OK », code supplémentaire est exécuté.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="StatusDescription" /> est défini une fois les en-têtes HTTP envoyés.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur sélectionnée a une longueur supérieure à 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui qualifie le code d'état de la réponse.</summary>
        <value>Valeur entière qui représente le code de sous-état [!INCLUDE[iisver](~/includes/iisver-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.SubStatusCode%2A> propriété est uniquement pris en charge avec le mode pipeline intégré dans [!INCLUDE[iisver](~/includes/iisver-md.md)] et au moins .NET Framework version 3.0. Lorsque vous définissez la <xref:System.Web.HttpResponse.SubStatusCode%2A> propriété, l’état est enregistré dans [!INCLUDE[iisver](~/includes/iisver-md.md)] si le traçage des demandes ayant échoué est configuré. Indépendamment de si le traçage est configuré, le code n’est jamais envoyé dans le cadre de la dernière réponse à la demande. Pour plus d’informations, consultez [dépannage Échec de demandes à l’aide d’Échec de suivi des demandes dans IIS 7.0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Web.HttpResponse.SubStatusCode%2A> propriété dans un gestionnaire d’événements pour le <xref:System.Web.HttpApplication> instance de la <xref:System.Web.HttpApplication.PostAuthenticateRequest> événement. Placez le fichier de code dans le dossier App_Code de votre application Web et configurer le fichier Web.config pour inscrire le module. Pour plus d’informations, consultez [procédure pas à pas : création et enregistrement d’un Module HTTP du personnalisé](http://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453).  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L’opération exige le mode pipeline intégré d’[!INCLUDE[iisver](~/includes/iisver-md.md)] et au moins le .NET Framework version 3.0.</exception>
        <exception cref="T:System.Web.HttpException">Le code d'état est défini une fois que tous les en-têtes HTTP ont été envoyés.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la connexion prend en charge les opérations de vidage asynchrones.</summary>
        <value>
          <see langword="true" /> si la connexion prend en charge les opérations de vidage asynchrones ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur de la <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le contenu HTTP doit être envoyé au client.</summary>
        <value>
          <see langword="true" /> pour supprimer la sortie, sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie si la <xref:System.Web.HttpRequest.IsSecureConnection%2A> est définie sur false. S’il s’agit, le <xref:System.Web.HttpResponse.SuppressContent%2A> est définie sur true pour arrêter l’envoi de réponse en cours.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Pris en charge dans .NET Framework 4.5.2 et ultérieur]  
  
 Obtient ou définit une valeur indiquant s’il faut supprimer l’en-tête <c>Cache Control: private</c> par défaut de la réponse HTTP actuelle.</summary>
        <value>
          <see langword="true" /> Pour supprimer la valeur par défaut <c>Cache Control : private</c> en-tête pour la réponse HTTP actuelle ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, ASP.NET envoie un `Cache-Control: private` en-tête de réponse, sauf si une stratégie de cache explicite a été spécifiée pour cette réponse. Cette propriété permet la suppression de cet en-tête de réponse par défaut sur une base par demande. L’en-tête peut toujours être supprimé pour toute l’application en définissant <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> dans [httpRuntime, élément (schéma des paramètres ASP.NET)](http://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) ou [outputCache, élément de mise en cache (schéma des paramètres ASP.NET)](http://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Soyez prudent lors de la suppression de la valeur par défaut `Cache-Control: private` en-tête, en tant que proxy et autres intermédiaires peuvent traiter des réponses sans cet en-tête comme la mise en cache par défaut. Ce traitement peut entraîner la mise en cache involontaire des informations sensibles. Consultez [le document RFC 2616, s 13.4](http://tools.ietf.org/html/rfc2616) pour plus d’informations.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la redirection d'authentification par formulaire à la page de connexion doit être supprimée.</summary>
        <value>
          <see langword="true" /> si la redirection d'authentification par formulaire doit être supprimée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, l’authentification par formulaire convertit les codes d’état HTTP 401 302 afin de rediriger vers la page de connexion. Cela n’est pas appropriée pour certains types d’erreurs, telles que lorsque l’authentification réussit, mais l’autorisation échoue, ou lorsque la demande en cours est une demande de service web ou AJAX. Cette propriété fournit un moyen de supprimer le comportement de redirection et d’envoyer le code d’état d’origine au client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit le fichier spécifié directement dans un flux de sortie de réponse HTTP sans le placer en mémoire tampon.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à écrire dans la sortie HTTP.</param>
        <summary>Écrit le fichier spécifié directement dans un flux de sortie de réponse HTTP sans le placer en mémoire tampon.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="filename" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à écrire dans la sortie HTTP.</param>
        <param name="offset">Position dans le fichier d'où commence l'écriture vers la sortie HTTP.</param>
        <param name="length">Nombre d'octets à transmettre.</param>
        <summary>Écrit la partie spécifiée d'un fichier directement dans un flux de sortie de réponse HTTP sans la placer en mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous spécifiez 0 comme le `offset` paramètre et -1 comme le `length` paramètre, le fichier entier est envoyé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="offset" /> est inférieur à zéro.  
  
 \- ou -  
  
 Le paramètre <paramref name="length" /> est inférieur à -1.  
  
 \- ou -  
  
 Le paramètre <paramref name="length" /> spécifie un nombre d'octets supérieur au nombre d'octets que le fichier contient (moins la valeur offset).</exception>
        <exception cref="T:System.PlatformNotSupportedException">La demande de travail hors processus n’est pas prise en charge.  
  
 \- ou -  
  
 La réponse n'utilise pas d'objet <see cref="T:System.Web.HttpWriter" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="offset" /> est inférieur à zéro ou supérieur à la taille du fichier.  
  
 \- ou -  
  
 Le paramètre <paramref name="length" /> est inférieur à -1 ou supérieur à la valeur du paramètre <paramref name="offset" /> plus la taille du fichier.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les erreurs personnalisées d'[!INCLUDE[iisver](~/includes/iisver-md.md)] sont désactivées.</summary>
        <value>
          <see langword="true" /> pour des erreurs personnalisées IIS désactivées ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> propriété est utilisée uniquement lorsque votre application est hébergée dans IIS 7.0. Lors de l’exécution en mode classique dans IIS 7.0 le <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> valeur de propriété par défaut est `true`. Lors de l’exécution en mode intégré, le <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> valeur de propriété par défaut est `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les informations dans un flux de sortie de réponse HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Caractère à écrire dans le flux de sortie HTTP.</param>
        <summary>Écrit un caractère dans un flux de sortie de réponse HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée une série de constantes qui sont écrites dans une page ASP.NET à l’aide de la méthode Write. Le code appelle cette version de la méthode Write pour écrire des constantes de caractère individuel dans la page.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Object" /> à écrire dans le flux de sortie HTTP.</param>
        <summary>Écrit un <see cref="T:System.Object" /> dans un flux de réponse HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne à écrire dans le flux de sortie HTTP.</param>
        <summary>Écrit une chaîne dans un flux de sortie de réponse HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pages HTML générées dynamiquement peuvent introduire des risques de sécurité si l’entrée provenance de clients Web n’est pas validée lorsqu’elle est reçue d’un client ou lorsqu’il est transmis à un client. Un script qui est incorporé dans l’entrée soumise à un site Web et réécrite sur un client malveillant semblent provenir d’une source approuvée. Ce risque de sécurité correspond à une attaque de script entre sites. Vous devez toujours valider les données reçues d’un client quand elles sont transmises à partir de votre site pour les navigateurs clients.  
  
 En outre, chaque fois que vous envoyez au format HTML des données reçues en entrée, vous devez les encoder à l’aide d’une technique comme <xref:System.Web.HttpServerUtility.HtmlEncode%2A> ou <xref:System.Web.HttpServerUtility.UrlEncode%2A> pour empêcher un script malveillant de l’exécution. Cette technique est utile pour les données qui n’a pas été validées lorsqu’elle a été reçue.  
  
 Lorsque vous codez ou filtrez les données, vous devez spécifier un jeu de caractères pour vos pages Web afin que votre filtre puisse identifier et supprimer toutes les séquences d’octets qui n’appartiennent pas à définir (par exemple, les séquences non alphanumériques) et sont susceptibles d’avoir un script malveillant incorporé dans les.  
  
 Pour plus d’informations sur les attaques de script entre sites, consultez l’article Q252985, « How to empêcher Cross-Site Scripting sécurité Issues » sur le [Base de connaissances Microsoft](http://go.microsoft.com/fwlink/?LinkID=37115) site Web.  
  
   
  
## Examples  
 L’exemple suivant renvoie le nom du client vers le navigateur du client. Le <xref:System.Web.HttpServerUtility.HtmlEncode%2A> méthode supprime tout script malveillant et les caractères non valides qui peuvent avoir été présentées dans le `UserName` champ d’entrée.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de caractères à écrire.</param>
        <param name="index">Emplacement dans le tableau de caractères où débute l'écriture.</param>
        <param name="count">Nombre de caractères à écrire à partir de <c>index</c>.</param>
        <summary>Écrit un tableau de caractères dans un flux de sortie de réponse HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée une série de constantes qui sont écrites dans une page ASP.NET à l’aide de la méthode Write. Le code appelle cette version de la méthode Write pour écrire des constantes de caractère individuel dans la page.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit le fichier spécifié directement dans un flux de sortie de réponse HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à écrire dans la sortie HTTP.</param>
        <summary>Écrit le contenu du fichier spécifié directement dans un flux de sortie de réponse HTTP sous forme de bloc de fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est utilisée avec des fichiers volumineux, l’appel de la méthode peut lever une exception. La taille du fichier qui peut être utilisé avec cette méthode dépend de la configuration matérielle du serveur Web. Pour plus d’informations, consultez l’article 812406, « PRB : Response.WriteFile ne peut pas télécharger de fichier volumineux » sur le [Base de connaissances Microsoft](http://go.microsoft.com/fwlink/?linkid=149903) site Web.  
  
   
  
## Examples  
 L’exemple suivant écrit le contenu d’un fichier texte nommé `Login.txt` (qui peut contenir des contrôles d’entrée et de texte littéral HTML) directement dans le flux de sortie.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="filename" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à écrire dans un bloc de mémoire.</param>
        <param name="readIntoMemory">Indique si le fichier sera écrit dans un bloc de mémoire.</param>
        <summary>Écrit le contenu du fichier spécifié directement dans un flux de sortie de réponse HTTP sous forme de bloc de mémoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est utilisée avec des fichiers volumineux, l’appel de la méthode peut lever une exception. La taille du fichier qui peut être utilisé avec cette méthode dépend de la configuration matérielle du serveur Web. Pour plus d’informations, consultez l’article 812406, « PRB : Response.WriteFile ne peut pas télécharger de fichier volumineux » sur le [Base de connaissances Microsoft](http://go.microsoft.com/fwlink/?linkid=149903) site Web.  
  
   
  
## Examples  
 L’exemple suivant écrit un fichier dans la mémoire.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="filename" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Handle du fichier à écrire dans le flux de sortie HTTP.</param>
        <param name="offset">Position de l'octet où l'écriture va commencer dans le fichier.</param>
        <param name="size">Nombre d'octets à écrire dans le flux de sortie.</param>
        <summary>Écrit le fichier spécifié directement dans un flux de sortie de réponse HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est utilisée avec des fichiers volumineux, l’appel de la méthode peut lever une exception. La taille du fichier qui peut être utilisé avec cette méthode dépend de la configuration matérielle du serveur Web. Pour plus d’informations, consultez l’article 812406, « PRB : Response.WriteFile ne peut pas télécharger de fichier volumineux » sur le [Base de connaissances Microsoft](http://go.microsoft.com/fwlink/?linkid=149903) site Web.  
  
   
  
## Examples  
 L’exemple suivant écrit le contenu d’un fichier texte nommé `Login.txt` (qui peut contenir des contrôles d’entrée et de texte littéral HTML) directement dans le flux de sortie.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileHandler" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> est inférieur à 0.  
  
 \- ou -  
  
 <paramref name="size" /> est supérieur à la taille du fichier moins <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à écrire dans le flux de sortie HTTP.</param>
        <param name="offset">Position de l'octet où commencer l'écriture dans le fichier.</param>
        <param name="size">Nombre d'octets à écrire dans le flux de sortie.</param>
        <summary>Écrit le fichier spécifié directement dans un flux de sortie de réponse HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est utilisée avec des fichiers volumineux, l’appel de la méthode peut lever une exception. La taille du fichier qui peut être utilisé avec cette méthode dépend de la configuration matérielle du serveur Web. Pour plus d’informations, consultez l’article 812406, « PRB : Response.WriteFile ne peut pas télécharger de fichier volumineux » sur le [Base de connaissances Microsoft](http://go.microsoft.com/fwlink/?linkid=149903) site Web.  
  
   
  
## Examples  
 L’exemple suivant écrit le contenu d’un fichier texte nommé `Login.txt` (qui peut contenir le texte littéral et du code HTML des contrôles d’entrée) directement dans le flux de sortie.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> est inférieur à 0.  
  
 \- ou -  
  
 <paramref name="size" /> est supérieur à la taille du fichier moins <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="filename" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Méthode, contrôle utilisateur ou objet à substituer.</param>
        <summary>Autorise l'insertion de blocs de substitution de réponse dans la réponse ; cette technique permet la génération dynamique de régions de réponse spécifiées pour les réponses de sortie mises en cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Web.HttpResponse.WriteSubstitution%2A> méthode de substitution post-cache dans vos pages mises en cache de sortie. En passant un <xref:System.Web.HttpContext> objet à une méthode de rappel avec une frontière <xref:System.Web.HttpResponseSubstitutionCallback> signature, vous pouvez remplacer mis en cache de sortie contenu à tout emplacement donné dans le cache de la page. Pour initialiser le remplacement, appelez le <xref:System.Web.HttpResponse.WriteSubstitution%2A> méthode, en lui passant la méthode de rappel, qui doit être thread-safe et peut être une des opérations suivantes :  
  
-   Une méthode statique sur le contrôle de page ou l’utilisateur du conteneur.  
  
-   Statique ou méthode d’instance sur un autre objet arbitraire.  
  
 Sur la première demande vers la page, le <xref:System.Web.HttpResponse.WriteSubstitution%2A> appelle la <xref:System.Web.HttpResponseSubstitutionCallback> délégué pour produire la sortie. Ensuite, il ajoute une mémoire tampon de substitution à la réponse qui conserve le délégué à appeler sur de futures demandes. Enfin, il diminue la capacité de côté client de public en serveur uniquement, garantissant les requêtes ultérieures à la page nouveau appeler le délégué en cache sur le client.  
  
> [!NOTE]
>  Substitution post-cache n’est pas prise en charge pour un contrôle utilisateur mis en cache où la mise en cache de sortie est appliquée au niveau de contrôle de l’utilisateur. Il s’agit également en tant que la mise en cache de fragment. Pour plus d’informations, consultez [mise en cache des parties d’une Page ASP.NET](http://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La cible du paramètre <paramref name="callback" /> est de type <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
      </Docs>
    </Member>
  </Members>
</Type>