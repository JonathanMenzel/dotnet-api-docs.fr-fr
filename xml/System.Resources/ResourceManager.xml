<Type Name="ResourceManager" FullName="System.Resources.ResourceManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d18e0d0b21e593733c17a8ad1b69a3fc64a6cfda" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30481393" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ResourceManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ResourceManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceManager" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un gestionnaire de ressources qui facilite l'accès aux ressources spécifiques à une culture au moment de l'exécution.  
  
 **Note de sécurité** : L’appel de méthodes dans cette classe avec des données non approuvées constitue un risque pour la sécurité. Appelez les méthodes dans la classe uniquement avec des données approuvées. Pour plus d’informations, consultez [Risques de sécurité liés aux données non approuvées](https://docs.com/rick-anderson-1/8710/untrusted-data-security-risks).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Resources.ResourceManager> classe récupère les ressources à partir d’un fichier .resources binaire qui est incorporé dans un assembly ou à partir d’un fichier .resources. Si une application a été localisée et de ressources localisées ont été déployés en [assemblys satellites](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md), il recherche des ressources spécifiques à la culture, qui fournit des ressources de secours lorsqu’une ressource localisée n’existe pas et prend en charge des ressources sérialisation.  
  
 Pour plus d’informations sur la création et la gestion des ressources dans les applications de bureau et [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, consultez les sections suivantes :  
  
-   [Applications de bureau](#desktop)  
  
    -   [Création de ressources](#creating_resources)  
  
    -   [Instanciation d’un objet ResourceManager](#instantiating)  
  
    -   [ResourceManager et des ressources spécifiques à la Culture](#CultureSpecific)  
  
    -   [Récupération de ressources](#retrieving)  
  
    -   [MissingManifestResourceException de gestion et les Exceptions MissingSatelliteAssemblyException](#exception)  
  
    -   [Versioning de ressources](#versioning)  
  
    -   [\<satelliteassemblies > nœud de fichier de Configuration](#config)  
  
-   [Applications du Windows Store](#ws)  
  
<a name="desktop"></a>   
## <a name="desktop-apps"></a>Applications de bureau  
 Pour les applications de bureau, le <xref:System.Resources.ResourceManager> classe récupère les ressources à partir des fichiers de ressources binaires (.resources). En règle générale, un compilateur de langage ou la [Assembly Linker (AL.exe)](~/docs/framework/tools/al-exe-assembly-linker.md) incorpore ces fichiers de ressources dans un assembly. Vous pouvez également utiliser un <xref:System.Resources.ResourceManager> objet pour récupérer des ressources directement à partir d’un fichier .resources qui n’est pas incorporé dans un assembly, en appelant le <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> (méthode).  
  
> [!CAUTION]
>  À l’aide de fichiers .resources autonomes dans une application ASP.NET interrompt le déploiement XCOPY, étant donné que les ressources restent verrouillées jusqu'à ce qu’elles soient libérées explicitement par le <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> (méthode). Si vous souhaitez déployer des ressources avec vos applications ASP.NET, vous devez compiler vos fichiers .resources en assemblys satellites.  
  
 Dans une application basée sur la ressource, un seul fichier .resources contient les ressources de la culture par défaut dont les ressources sont utilisées si aucune ressource spécifiques à la culture ne peut être trouvé. Par exemple, si la culture par défaut de l’application est anglais (en), les ressources de langue anglaise sont utilisées chaque fois que les ressources localisées ne peut pas être trouvés pour une culture spécifique, telles que l’anglais (États-Unis) (en-US) ou Français (France) (fr-FR). En règle générale, les ressources de la culture par défaut sont incorporées dans l’assembly principal de l’application et les ressources pour d’autres cultures localisées sont incorporées dans les assemblys satellites. Les assemblys satellites contiennent uniquement les ressources. Ils ont le même nom de fichier racine en tant que l’assembly principal et une extension. resources.dll. Pour les applications dont les assemblys ne sont pas inscrits dans le global assembly cache, les assemblys satellites sont stockés dans un sous-répertoire de l’application dont le nom correspond à la culture de l’assembly.  
  
<a name="creating_resources"></a>   
### <a name="creating-resources"></a>Création de ressources  
 Lorsque vous développez une application basée sur la ressource, vous stockez des informations sur les ressources dans les fichiers texte (fichiers qui ont une extension .txt ou .restext) ou XML (fichiers ayant une extension .resx). Vous compilez ensuite le texte ou les fichiers XML avec le [Resource File Generator (Resgen.exe)](~/docs/framework/tools/resgen-exe-resource-file-generator.md) pour créer un fichier .resources binaire. Vous pouvez ensuite incorporer le fichier .resources résultant dans un fichier exécutable ou une bibliothèque à l’aide d’une option du compilateur comme `/resources` pour les compilateurs c# et Visual Basic, ou vous pouvez l’incorporer dans un assembly satellite à l’aide de le. Si vous incluez un fichier .resx dans votre projet Visual Studio, Visual Studio gère la compilation et l’incorporation de valeur par défaut et les ressources localisées automatiquement dans le cadre du processus de génération.  
  
 Dans l’idéal, vous devez créer les ressources pour chaque langue votre application prend en charge, ou au moins un sous-ensemble significatif de chaque langage. Les noms de fichiers .resources binaires suivent la convention d’affectation de noms *basename*.* cultureName*.resources, où *basename* est le nom de l’application ou le nom d’une classe, en fonction du niveau de détail souhaité. Le <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType> propriété permet de déterminer *cultureName*. Une ressource de la culture de l’application par défaut doit être nommée *basename*.resources.  
  
 Par exemple, supposons qu’un assembly contenant plusieurs ressources dans un fichier de ressources portant le nom de base MyResources. Ces fichiers de ressources doivent avoir des noms tels que MyResources.ja-JP.Resources pour la culture Japonais (Japon), MyResources.de.resources pour la culture allemande, MyResources-CHS.Resources pour la culture en chinoise simplifiée, et MyResources-be.resources s’agit de la culture Français (Belgique). Le fichier de ressources par défaut doit être nommé MyResources.resources. Les fichiers de ressources spécifiques à la culture sont généralement livrés dans les assemblys satellites pour chaque culture. Le fichier de ressources par défaut doit être incorporé dans l’assembly principal de l’application.  
  
 Notez qui permet aux ressources d’être marquée comme privée, mais vous devez toujours les marquer comme publique afin qu’ils sont accessibles par d’autres assemblys. (Car un assembly satellite ne contient aucun code, les ressources qui sont marqués comme privés ne sont pas disponibles à votre application via un mécanisme quelconque.)  
  
 Pour plus d’informations sur la création, empaquetage et déploiement de ressources, consultez les articles [création de fichiers de ressources](~/docs/framework/resources/creating-resource-files-for-desktop-apps.md), [création d’assemblys satellites](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md), et [empaquetage et déploiement Ressources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
<a name="instantiating"></a>   
### <a name="instantiating-a-resourcemanager-object"></a>Instanciation d’un objet ResourceManager  
 Vous instanciez un <xref:System.Resources.ResourceManager> objet qui Récupère les ressources à partir d’un fichier .resources incorporé en appelant une de ses surcharges de constructeur de classe. Cela associe étroitement une <xref:System.Resources.ResourceManager> objet avec un fichier .resources particulier et associés localisée des fichiers .resources en assemblys satellites.  
  
 Les deux constructeurs plus communément appelées sont :  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> recherche des ressources en fonction de deux types d’informations que vous fournissez : le nom de base du fichier .resources et l’assembly dans lequel réside le fichier .resources par défaut. Le nom de base inclut le nom racine et espace de noms du fichier .resources, sans son extension ou de culture. Notez que les fichiers .resources qui sont compilés à partir de la ligne de commande en général n’incluent pas d’un espace de noms, alors que les fichiers .resources qui sont créés dans l’environnement Visual Studio. Par exemple, si un fichier de ressources nommé MyCompany.StringResources.resources et <xref:System.Resources.ResourceManager> constructeur est appelé à partir d’une méthode statique nommée `Example.Main`, le code suivant instancie un <xref:System.Resources.ResourceManager> objet qui peut récupérer des ressources à partir de la. fichier de ressources :  
  
     [!code-csharp[Conceptual.Resources.Retrieving#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#1)]
     [!code-vb[Conceptual.Resources.Retrieving#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#1)]  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> recherche des ressources dans les assemblys satellites en fonction des informations à partir d’un objet de type. Le nom du type qualifié complet correspond au nom du fichier .resources sans son extension de nom de fichier. Applications de bureau qui sont créées à l’aide du Concepteur de ressources Visual Studio, Visual Studio crée une classe wrapper dont le nom qualifié complet est le même que le nom de la racine du fichier .resources. Par exemple, si un fichier de ressources nommé MyCompany.StringResources.resources et il existe une classe wrapper nommée `MyCompany.StringResources`, le code suivant instancie un <xref:System.Resources.ResourceManager> objet qui peut récupérer des ressources à partir du fichier .resources :  
  
     [!code-csharp[Conceptual.Resources.Retrieving#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#2)]
     [!code-vb[Conceptual.Resources.Retrieving#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#2)]  
  
 S’il ne peut pas trouver les ressources appropriées, l’appel de constructeur crée un élément valide <xref:System.Resources.ResourceManager> objet. Toutefois, la tentative de récupération d’une ressource lève une <xref:System.Resources.MissingManifestResourceException> exception. Pour plus d’informations sur le traitement avec l’exception, consultez le [MissingManifestResourceException de gestion et les Exceptions MissingSatelliteAssembly](#exception) section plus loin dans cet article.  
  
 L’exemple suivant montre comment instancier un <xref:System.Resources.ResourceManager> objet. Il contient le code source pour un fichier exécutable nommé ShowTime.exe. Il inclut également le fichier texte suivant nommé Strings.txt qui contient une ressource de chaîne unique, `TimeHeader`:  
  
```  
TimeHeader=The current time is  
```  
  
 Vous pouvez utiliser un fichier de commandes pour générer le fichier de ressources et les incorporer dans le fichier exécutable. Voici le fichier de commandes pour générer un fichier exécutable à l’aide du compilateur c# :  
  
```  
  
resgen strings.txt  
csc ShowTime.cs /resource:strings.resources  
  
```  
  
 Pour le compilateur Visual Basic, vous pouvez utiliser le fichier de commandes suivant :  
  
```  
  
resgen strings.txt  
vbc ShowTime.vb /resource:strings.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showtime.cs#1)]
 [!code-vb[System.Resources.ResourceManager.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showtime.vb#1)]  
  
<a name="CultureSpecific"></a>   
### <a name="resourcemanager-and-culture-specific-resources"></a>ResourceManager et des ressources spécifiques à la Culture  
 Une application localisée nécessite des ressources pour le déploiement, comme indiqué dans l’article [empaquetage et déploiement de ressources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md). Si les assemblys sont correctement configurés, le Gestionnaire de ressources détermine les ressources à récupérer en fonction sur le thread actuel <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> propriété. (Cette propriété retourne également culture d’interface utilisateur du thread actuel). Par exemple, si une application est compilée avec les ressources par défaut en langue anglaise dans l’assembly principal et des ressources de langue Français et russe dans deux assemblys satellites et le <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> est définie sur fr-FR, le Gestionnaire de ressources récupère le Français ressources.  
  
 Vous pouvez définir le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> propriété explicitement ou implicitement. La façon dont vous la définissez détermine comment la <xref:System.Resources.ResourceManager> objet récupère les ressources selon culture :  
  
-   Si vous définissez explicitement la <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> propriété à une culture spécifique, le Gestionnaire de ressources est toujours extrait les ressources pour cette culture, quelle que soit la langue du navigateur ou du système d’exploitation l’utilisateur. Considérez une application qui est compilée avec les ressources de langue anglaise par défaut et trois assemblys satellites contenant des ressources pour l’anglais (États-Unis), Français (France) et russe (Russie). Si le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> est définie sur fr-FR, le <xref:System.Resources.ResourceManager> objet récupère toujours les ressources Français (France), même si l’utilisateur d’exploitation de langue du système n’est pas Français. Assurez-vous qu’il s’agit du comportement souhaité avant de définir explicitement la propriété.  
  
     Dans les applications ASP.NET, vous devez définir le <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> propriété explicitement, car il est peu probable que le paramètre du serveur corresponde aux demandes des clients. Une application ASP.NET peut définir le <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> langue acceptée par la propriété explicitement au navigateur de l’utilisateur.  
  
     Si vous affectez explicitement la <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> propriété définit la culture d’interface utilisateur actuelle pour ce thread. Il n’affecte pas la culture d’interface utilisateur actuelle de tous les autres threads dans une application.  
  
-   Vous pouvez définir la culture d’interface utilisateur de tous les threads dans un domaine d’application en assignant un <xref:System.Globalization.CultureInfo> objet qui représente cette culture à la méthode statique <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> propriété.  
  
-   Si vous ne définissez pas explicitement la culture d’interface utilisateur en cours et que vous ne définissez pas une culture par défaut pour le domaine d’application actuel, le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété est définie implicitement par Windows `GetUserDefaultUILanguage` (fonction). Cette fonction est fournie par l’utilisateur Interface multilingue (MUI), ce qui permet à l’utilisateur définir la langue par défaut. Si la langue d’interface utilisateur n’est pas définie par l’utilisateur, la valeur par défaut est la langue système installé, ce qui est la langue des ressources du système d’exploitation.  
  
 L’exemple « Hello world » simple suivant définit la culture d’interface utilisateur actuelle explicitement. Il contient des ressources pour les trois cultures : anglais (États-Unis) ou en-US, Français (France) ou fr-FR et russe (Russie) ou ru-RU. Les ressources en-US sont contenues dans un fichier texte nommé Greetings.txt :  
  
```  
HelloString=Hello world!  
```  
  
 Contenus dans un fichier texte nommé Greetings.fr les ressources fr-FR-FR.txt :  
  
```  
HelloString=Salut tout le monde!  
```  
  
 Les ressources ru-RU sont contenus dans un fichier texte nommé Greetings.ru-RU.txt :  
  
```  
HelloString=Всем привет!  
```  
  
 Voici le code source pour l’exemple (Example.vb pour la version Visual Basic) ou Example.cs pour la version c# :  
  
 [!code-csharp[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.currentculture/cs/example.cs#1)]
 [!code-vb[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.currentculture/vb/example.vb#1)]  
  
 Pour compiler cet exemple, créez un fichier de commandes (.bat) qui contient les commandes suivantes et exécutez-le à partir de l’invite de commandes. Si vous utilisez c#, spécifiez `csc` au lieu de `vbc` et `Example.cs` au lieu de `Example.vb`.  
  
```  
resgen Greetings.txt   
vbc Example.vb /resource:Greetings.resources  
  
resgen Greetings.fr-FR.txt  
Md fr-FR  
al /embed:Greetings.fr-FR.resources /culture:fr-FR /out:fr-FR\Example.resources.dll  
  
resgen Greetings.ru-RU.txt  
Md ru-RU  
al /embed:Greetings.ru-RU.resources /culture:ru-RU /out:ru-RU\Example.resources.dll  
```  
  
<a name="retrieving"></a>   
### <a name="retrieving-resources"></a>Récupération de ressources  
 Vous appelez le <xref:System.Resources.ResourceManager.GetObject%28System.String%29> et <xref:System.Resources.ResourceManager.GetString%28System.String%29> méthodes pour accéder à une ressource spécifique. Vous pouvez également appeler le <xref:System.Resources.ResourceManager.GetStream%28System.String%29> méthode pour récupérer des ressources sous la forme d’un tableau d’octets. Par défaut, dans une application qui a localisée des ressources, ces méthodes retournent la ressource pour la culture définie par la culture d’interface utilisateur actuelle du thread qui a effectué l’appel. Consultez la section précédente, [ResourceManager et des ressources spécifiques à la Culture](#CultureSpecific), pour plus d’informations sur la façon dont la culture d’interface utilisateur actuelle d’un thread est définie. Si le Gestionnaire de ressources ne peut pas trouver la ressource pour la culture d’interface utilisateur du thread actuel, il utilise un processus de secours pour récupérer la ressource spécifiée. Si le Gestionnaire de ressources ne peut pas trouver les ressources localisées, il utilise les ressources de la culture par défaut. Pour plus d’informations sur les règles de secours, consultez la section « Processus de secours » de l’article [empaquetage et déploiement de ressources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  Si le fichier .resources spécifié dans le <xref:System.Resources.ResourceManager> Impossible de trouver le constructeur de classe, la tentative de récupération d’une ressource lève une <xref:System.Resources.MissingManifestResourceException> ou <xref:System.Resources.MissingSatelliteAssemblyException> exception. Pour plus d’informations sur le traitement avec l’exception, consultez le [MissingManifestResourceException de gestion et les Exceptions MissingSatelliteAssemblyException](#exception) section plus loin dans cette rubrique.  
  
 L’exemple suivant utilise la <xref:System.Resources.ResourceManager.GetString%2A> méthode pour récupérer des ressources spécifiques à la culture. Il se compose de ressources compilés à partir de fichiers .txt pour l’anglais (en), Français (France) (fr-FR) et russe (Russie) (ru-RU) cultures. L’exemple modifie la culture actuelle et la culture d’interface utilisateur actuelle pour l’anglais (États-Unis), Français (France), russe (Russie) et suédois (Suède). Il appelle ensuite la <xref:System.Resources.ResourceManager.GetString%2A> pour récupérer la chaîne localisée, qu’elle affiche, ainsi que le jour actuel et le mois. Notez que la sortie affiche la chaîne localisée appropriée, sauf si la culture d’interface utilisateur actuelle est suédois (Suède). Étant donné que les ressources de langue suédoise ne sont pas disponibles, l’application utilise à la place les ressources de la culture par défaut, qui est l’anglais.  
  
 L’exemple requiert les fichiers de ressources texte répertoriées dans le tableau suivant. Chacun a une ressource de chaîne unique nommée `DateStart`.  
  
|culture|Nom de fichier|Nom de la ressource|Valeur de la ressource|  
|-------------|---------------|-------------------|--------------------|  
|fr-FR|DateStrings.txt|`DateStart`|Nous sommes|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 Voici le code source pour l’exemple (ShowDate.vb pour la version Visual Basic) ou ShowDate.cs pour la version c# du code.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 Pour compiler cet exemple, créez un fichier de commandes qui contient les commandes suivantes et exécutez-le à partir de l’invite de commandes. Si vous utilisez c#, spécifiez `csc` au lieu de `vbc` et `showdate.cs` au lieu de `showdate.vb`.  
  
```  
  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
  
```  
  
 Il existe deux façons de récupérer les ressources d’une culture spécifique autre que la culture d’interface utilisateur actuelle :  
  
-   Vous pouvez appeler la <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>, <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>, ou <xref:System.Resources.ResourceManager.GetStream%28System.String%2CSystem.Globalization.CultureInfo%29> pour récupérer une ressource pour une culture spécifique. Si une ressource localisée n’est trouvée, le Gestionnaire de ressources utilise le processus de secours pour localiser une ressource appropriée.  
  
-   Vous pouvez appeler la <xref:System.Resources.ResourceManager.GetResourceSet%2A> méthode pour obtenir un <xref:System.Resources.ResourceSet> objet qui représente les ressources d’une culture particulière. Dans l’appel de méthode, vous pouvez déterminer si le Gestionnaire de ressources tente de détecter les cultures parent s’il est impossible de trouver des ressources localisées, ou si elle simplement revient aux ressources de la culture par défaut. Vous pouvez ensuite utiliser le <xref:System.Resources.ResourceSet> méthodes pour accéder aux ressources (localisées pour cette culture) par nom, ou pour énumérer les ressources dans le jeu.  
  
<a name="exception"></a>   
### <a name="handling-missingmanifestresourceexception-and-missingsatelliteassemblyexception-exceptions"></a>MissingManifestResourceException de gestion et les Exceptions MissingSatelliteAssemblyException  
 Si vous essayez de récupérer une ressource spécifique, mais que le Gestionnaire de ressources ne peut pas trouver que ressource et soit aucune culture par défaut a été défini ou Impossible de trouver les ressources de la culture par défaut, le Gestionnaire de ressources lève une <xref:System.Resources.MissingManifestResourceException> exception si elle s’attend à trouver les ressources dans l’assembly principal ou un <xref:System.Resources.MissingSatelliteAssemblyException> si elle s’attend à trouver les ressources dans un assembly satellite. Notez que l’exception est levée lorsque vous appelez une méthode de récupération des ressources telles que <xref:System.Resources.ResourceManager.GetString%2A> ou <xref:System.Resources.ResourceManager.GetObject%2A>, et pas lorsque vous instanciez un <xref:System.Resources.ResourceManager> objet.  
  
 L’exception est généralement levée dans les conditions suivantes :  
  
-   L’assembly satellite ou de fichier de ressources approprié n’existe pas. Si le Gestionnaire de ressources attend des ressources par défaut de l’application à incorporer dans l’assembly principal de l’application, ils sont absents. Si le <xref:System.Resources.NeutralResourcesLanguageAttribute> attribut indique que les ressources par défaut de l’application résident dans un assembly satellite, que l’assembly ne peut pas être trouvé. Lorsque vous compilez votre application, assurez-vous que les ressources sont incorporées dans l’assembly principal ou que l’assembly satellite nécessaire est généré et est nommé de manière appropriée. Son nom doit prendre la forme *appName*. resources.dll et il doivent se trouver dans un répertoire nommé d’après la culture dont les ressources qu’il contient.  
  
-   Votre application n’a pas par défaut ou définie de culture neutre. Ajouter le <xref:System.Resources.NeutralResourcesLanguageAttribute> attribut pour un fichier de code source ou au fichier projet informations fichier (AssemblyInfo.vb pour une application Visual Basic) ou AssemblyInfo.cs pour une application c#.  
  
-   Le `baseName` paramètre dans le <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> constructeur ne spécifie pas le nom d’un fichier .resources. Le nom doit comprendre, espace de noms qualifié complet du fichier de ressources, mais pas son extension de nom de fichier. En règle générale, les fichiers de ressources qui sont créés dans Visual Studio incluent des noms d’espace de noms, mais les fichiers de ressources qui sont créés et compilés à l’invite de commandes ne sont pas. Vous pouvez déterminer les noms des fichiers .resources incorporés en compilant et en exécutant l’utilitaire suivant. Il s’agit d’une application console qui accepte le nom d’un assembly principal ou un assembly satellite en tant que paramètre de ligne de commande. Il affiche les chaînes qui doivent être fournis comme le `baseName` paramètre afin que le Gestionnaire de ressources peut identifier correctement la ressource.  
  
     [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
     [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 Si vous ne modifiez pas explicitement la culture actuelle de votre application, vous devez également vous rappeler que le Gestionnaire de ressources récupère un ensemble de ressources en fonction de la valeur de la <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété et non le <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriété. En règle générale, si vous modifiez une valeur, vous devez également modifier l’autre.  
  
<a name="versioning"></a>   
### <a name="resource-versioning"></a>Versioning de ressources  
 Étant donné que l’assembly principal qui contient des ressources d’une application par défaut est séparé des assemblys satellites de l’application, vous pouvez libérer une nouvelle version de votre assembly principal sans redéployer les assemblys satellites. Vous utilisez la <xref:System.Resources.SatelliteContractVersionAttribute> attribut afin d’utiliser des assemblys satellites existants et demandez ne pas de les redéployer avec une nouvelle version de votre assembly principal, le Gestionnaire de ressources  
  
 Pour plus d’informations sur la prise en charge le contrôle de version pour les assemblys satellites, consultez l’article [la récupération des ressources](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md).  
  
<a name="config"></a>   
### <a name="satelliteassemblies-configuration-file-node"></a>\<satelliteassemblies > nœud de fichier de Configuration  
 Pour les exécutables qui sont déployés et exécutez à partir d’un site Web (fichiers .exe HREF), le <xref:System.Resources.ResourceManager> objet peut détecter les assemblys satellites sur le web, ce qui peut nuire aux performances de votre application. Pour éliminer le problème de performances, vous pouvez limiter cette détection pour les assemblys satellites que vous avez déployé avec votre application. Pour ce faire, vous créez un `<satelliteassemblies>` nœud dans le fichier de configuration de votre application pour spécifier que vous avez déployé un jeu spécifique de cultures pour votre application et que le <xref:System.Resources.ResourceManager> objet ne doit pas tenter de détecter une culture qui n’est pas répertoriée dans ce nœud.  
  
> [!NOTE]
>  L’alternative recommandée à la création d’un `<satelliteassemblies>` nœud consiste à utiliser le [le manifeste de déploiement ClickOnce](http://msdn.microsoft.com/library/8457e615-e3b6-4990-8dcf-11bc590e4e9b) fonctionnalité.  
  
 Dans le fichier de configuration de votre application, créez une section similaire au suivant :  
  
```  
<?xml version ="1.0"?>  
<configuration>  
    <satelliteassemblies>  
        <assembly name="MainAssemblyName, Version=versionNumber, Culture=neutral, PublicKeyToken=null|yourPublicKeyToken">  
            <culture>cultureName1</culture>  
            <culture>cultureName2</culture>  
            <culture>cultureName3</culture>  
        </assembly>  
    </satelliteassemblies>  
</configuration>  
```  
  
 Modifiez les informations de configuration comme suit :  
  
-   Spécifiez un ou plusieurs `<assembly>` nœuds pour chaque assembly principal que vous déployez, où chaque nœud spécifie un nom d’assembly qualifié complet. Spécifiez le nom de votre assembly principal à la place de *MainAssemblyName*et spécifiez le `Version`, `PublicKeyToken`, et `Culture` valeurs d’attribut qui correspondent à votre assembly principal.  
  
     Pour le `Version` d’attribut, spécifiez le numéro de version de votre assembly. Par exemple, la première version de votre assembly peut être un numéro de version 1.0.0.0.  
  
     Pour le `PublicKeyToken` d’attribut, spécifiez le mot clé `null` si vous n’avez pas signé votre assembly avec un nom fort, ou spécifier votre jeton de clé publique si vous avez signé votre assembly.  
  
     Pour le `Culture` d’attribut, spécifiez le mot clé `neutral` pour désigner l’assembly principal et forcer la <xref:System.Resources.ResourceManager> classe à détecter uniquement les cultures répertoriées dans le `<culture>` nœuds.  
  
     Pour plus d’informations sur les noms d’assembly qualifié complet, consultez l’article [les noms d’assemblys](~/docs/framework/app-domains/assembly-names.md). Pour plus d’informations sur les assemblys avec nom fort, consultez l’article [création et assemblys avec nom fort](~/docs/framework/app-domains/create-and-use-strong-named-assemblies.md).  
  
-   Spécifiez un ou plusieurs `<culture>` nœuds avec un nom de culture spécifique, tel que « fr-FR », ou un nom de culture neutre, tel que « fr ».  
  
 Si les ressources sont nécessaires pour un assembly non répertorié sous le `<satelliteassemblies>` nœud, la <xref:System.Resources.ResourceManager> classe détecte les cultures à l’aide des règles de détection standard.  
  
<a name="ws"></a>   
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>Applications [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]  
  
> [!IMPORTANT]
>  Bien que le <xref:System.Resources.ResourceManager> classe est pris en charge dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, nous ne recommandons pas son utilisation. Utilisez cette classe uniquement lorsque vous développez [!INCLUDE[net_portable](~/includes/net-portable-md.md)] qui peuvent être utilisés avec les projets [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Pour récupérer des ressources à partir de [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] , les applications utilisent le [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182) classe à la place.  
  
 Pour [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, la <xref:System.Resources.ResourceManager> classe récupère les ressources à partir des fichiers de package resource index (PRI). Un seul fichier PRI (fichier PRI package d’application) contient les ressources pour la culture par défaut et les cultures de localisée. Vous utilisez l’utilitaire MakePRI pour créer un fichier PRI à partir d’un ou plusieurs fichiers de ressources qui sont au format de ressource (.resw) XML. Pour les ressources qui sont inclus dans un projet Visual Studio, Visual Studio gère le processus de création et d’empaqueter le fichier PRI automatiquement. Vous pouvez ensuite utiliser le .NET Framework <xref:System.Resources.ResourceManager> classe pour accéder aux ressources de la bibliothèque ou de l’application.  
  
 Vous pouvez instancier un <xref:System.Resources.ResourceManager> de l’objet pour un [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] application de la même façon que pour une application de bureau.  
  
 Vous pouvez ensuite accéder les ressources pour une culture spécifique en passant le nom de la ressource à récupérer à le <xref:System.Resources.ResourceManager.GetString%28System.String%29> (méthode). Par défaut, cette méthode retourne la ressource pour la culture définie par la culture d’interface utilisateur actuelle du thread qui a effectué l’appel. Vous pouvez également récupérer les ressources pour une culture spécifique en passant le nom de la ressource et un <xref:System.Globalization.CultureInfo> objet qui représente la culture dont la ressource doit être récupéré à le <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> (méthode). Si la ressource pour la culture d’interface utilisateur actuelle ou la culture spécifiée est introuvable, le Gestionnaire de ressources utilise une liste de secours de langue de l’interface utilisateur pour localiser une ressource appropriée.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser une culture explicite et la culture d’interface utilisateur actuelle implicite pour obtenir des ressources de type chaîne à partir d’un assembly principal et un assembly satellite. Pour plus d’informations, consultez la section « Emplacements pour répertoire d’assemblys satellites pas installé dans le Global Assembly Cache » de la [création d’assemblys satellites](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) rubrique.  
  
 Pour exécuter cet exemple :  
  
1.  Dans le répertoire de l’application, créez un fichier nommé rmc.txt qui contient les chaînes de ressources suivantes :  
  
    ```  
  
    day=Friday  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
2.  Utilisez le [Resource File Generator](~/docs/framework/tools/resgen-exe-resource-file-generator.md) pour générer le fichier de ressources rmc.resources à partir du fichier d’entrée rmc.txt comme suit :  
  
    ```  
    resgen rmc.txt  
    ```  
  
3.  Créer un sous-répertoire du répertoire de l’application et nommez-le « es-MX ». Il s’agit du nom de culture de l’assembly satellite que vous allez créer dans les trois étapes suivantes.  
  
4.  Créez un fichier nommé rmc.es-MX.txt dans le répertoire es-MX qui contient les chaînes de ressources suivantes :  
  
    ```  
  
    day=Viernes  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
5.  Utilisez le [Resource File Generator](~/docs/framework/tools/resgen-exe-resource-file-generator.md) pour générer le fichier de ressources rmc.es-MX.resources à partir du fichier d’entrée rmc.es-MX.txt comme suit :  
  
    ```  
    resgen rmc.es-MX.txt  
    ```  
  
6.  Supposons que le nom de fichier pour cet exemple est rmc.vb ou rmc.cs. Copiez le code source suivant dans un fichier. Ensuite, le compiler et incorporer le fichier de ressources d’assembly principal, rmc.resources, dans l’assembly exécutable. Si vous utilisez le compilateur Visual Basic, la syntaxe est :  
  
    ```  
    vbc rmc.vb /resource:rmc.resources  
    ```  
  
     La syntaxe correspondante pour le compilateur c# est la suivante :  
  
    ```  
    csc /resource:rmc.resources rmc.cs  
    ```  
  
7.  Utilisez le [Assembly Linker](~/docs/framework/tools/al-exe-assembly-linker.md) pour créer un assembly satellite. Si le nom de base de l’application est rmc, le nom de l’assembly satellite doit être rmc.resources.dll. L’assembly satellite doit être créé dans le répertoire es-MX. Es-MX est le répertoire actif, utilisez cette commande :  
  
    ```  
    al /embed:rmc.es-MX.resources /c:es-MX /out:rmc.resources.dll   
    ```  
  
8.  Exécutez rmc.exe pour obtenir et afficher les chaînes de ressource incorporée.  
  
 [!code-csharp[ResourceManager_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ResourceManager_Class/cs/rmc.cs#1)]
 [!code-vb[ResourceManager_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ResourceManager_Class/vb/rmc.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <altmember cref="T:System.Globalization.CultureInfo" />
    <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
    <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceManager" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ResourceManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ResourceManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceManager" /> avec des valeurs par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est utile uniquement si vous écrivez votre propre classe qui dérive de la <xref:System.Resources.ResourceManager> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (Type resourceSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type resourceSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resourceSource As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(Type ^ resourceSource);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resourceSource" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="resourceSource">Type à partir duquel le gestionnaire de ressources dérive toutes les informations utilisées pour la recherche des fichiers .resources.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceManager" /> qui recherche des ressources dans les assemblys satellites en fonction d'informations provenant de l'objet de type spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Applications de bureau  
 Dans les applications de bureau, le Gestionnaire de ressources utilise le `resourceSource` paramètre pour charger un fichier de ressources particulier comme suit :  
  
-   Si le <xref:System.Resources.NeutralResourcesLanguageAttribute> attribut n’est pas utilisé pour indiquer que les ressources de la culture par défaut se trouvent dans un assembly satellite, le Gestionnaire de ressources suppose que le fichier de ressources pour la culture par défaut se trouve dans le même assembly que le type spécifié par le `resourceSource` paramètre.  
  
-   Le Gestionnaire de ressources suppose que le fichier de ressources par défaut a le même nom que le type spécifié par le `resourceSource` paramètre.  
  
-   Le Gestionnaire de ressources utilise la valeur par défaut <xref:System.Resources.ResourceSet> classe pour manipuler le fichier de ressources.  
  
 Par exemple, le Gestionnaire de ressources donné d’un type nommé MyCompany.MyProduct.MyType, recherche un fichier .resources nommé MyCompany.MyProduct.MyType.resources dans l’assembly définissant MyType.  
  
 Dans Visual Studio, le Concepteur de ressources génère automatiquement le code qui définit un `internal` (en c#) ou `Friend` (en Visual Basic) de classe dont le nom est le même que le nom de base du fichier .resources pour la culture par défaut. Il est ainsi possible d’instancier un <xref:System.Resources.ResourceManager> de l’objet et associez-le à un ensemble particulier de ressources en obtenant un objet de type dont le nom correspond au nom de la ressource, car tant que la classe est visible par le compilateur, les ressources doivent être en tant que barre d’outils. Par exemple, si un fichier .resources nommé Resource1, l’instruction suivante instancie un <xref:System.Resources.ResourceManager> objet pour gérer le fichier .resources nommé Resource1 :  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/ctor1.cs#2)]  
  
 Si vous n’utilisez pas Visual Studio, vous pouvez créer une classe sans membres dont espace de noms et le nom est identique à celui du fichier .resources par défaut. Cet exemple en fournit une illustration.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>Applications [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]  
  
> [!IMPORTANT]
>  Bien que le <xref:System.Resources.ResourceManager> classe est pris en charge dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, nous ne recommandons pas son utilisation. Utilisez cette classe uniquement lorsque vous développez [!INCLUDE[net_portable](~/includes/net-portable-md.md)] qui peuvent être utilisés avec les projets [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Pour récupérer des ressources à partir de [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] , les applications utilisent le [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182) classe à la place.  
  
 Dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, <xref:System.Resources.ResourceManager> utilise le `resourceSource` paramètre déduire l’assembly, nom de base et l’espace de noms dans lequel les éléments de ressource peuvent être situés dans le fichier de l’index (PRI) de ressource de package de l’application. Par exemple, étant donné un type nommé MyCompany.MyProduct.MyType est défini dans `MyAssembly`, le Gestionnaire de ressources recherche une ressource définie identificateur nommé MyAssembly et recherche une étendue MyCompany.MyProduct.MyType au sein de ce jeu de ressources. Le Gestionnaire de ressources recherche les éléments de ressource dans le contexte par défaut (la culture actuelle, le paramètre de contraste élevé actuel et ainsi de suite) dans cette portée.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> constructeur pour instancier un <xref:System.Resources.ResourceManager> objet. Il se compose de ressources compilés à partir de fichiers .txt pour l’anglais (en), Français (France) (fr-FR) et russe (Russie) (ru-RU) cultures. L’exemple modifie la culture actuelle et la culture d’interface utilisateur actuelle pour l’anglais (États-Unis), Français (France), russe (Russie) et suédois (Suède). Il appelle ensuite la <xref:System.Resources.ResourceManager.GetString%28System.String%29> pour récupérer la chaîne localisée, qui affiche un message d’accueil qui dépend de l’heure du jour.  
  
 L’exemple requiert trois fichiers de ressources texte, comme indiqué dans le tableau suivant. Chaque fichier inclut des ressources de type chaîne nommées `Morning`, `Afternoon`, et `Evening`.  
  
|culture|Nom de fichier|Nom de la ressource|Valeur de la ressource|  
|-------------|---------------|-------------------|--------------------|  
|fr-FR|GreetingResources.txt|`Morning`|Bonjour|  
|fr-FR|GreetingResources.txt|`Afternoon`|Bonne après-midi|  
|fr-FR|GreetingResources.txt|`Evening`|Bonsoir|  
|fr-FR|GreetingResources.fr-FR.txt|`Morning`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Afternoon`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Evening`|Bonsoir|  
|ru-RU|GreetingResources.ru-RU.txt|`Morning`|ДОБРОЕ УТРО|  
|ru-RU|GreetingResources.ru-RU.txt|`Afternoon`|ДОБРЫЙ ДЕНЬ|  
|ru-RU|GreetingResources.ru-RU.txt|`Evening`|ДОБРЫЙ ВЕЧЕР|  
  
 Vous pouvez utiliser le fichier de commandes suivantes pour compiler l’exemple Visual Basic et de créer un fichier exécutable nommé Greet.exe. Pour compiler avec c#, changez le nom du compilateur de `vbc` à `csc` et l’extension de fichier `.vb` à `.cs`.  
  
```  
  
resgen GreetingResources.txt  
vbc Greet.vb /resource: GreetingResources.resources  
  
md fr-FR  
resgen GreetingResources.fr-FR.txt  
al /out:fr-FR\Greet.resources.dll /culture:fr-FR /embed: GreetingResources.fr-FR.resources   
  
md ru-RU  
resgen GreetingResources.ru-RU.txt  
al /out:ru-RU\Greet.resources.dll /culture:ru-RU /embed: GreetingResources.ru-RU.resources  
  
```  
  
 Voici le code source pour l’exemple (ShowDate.vb pour la version Visual Basic) ou ShowDate.cs pour la version c# du code.  
  
 [!code-csharp[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/greet.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/greet.vb#3)]  
  
 Outre la définition d’une classe d’application nommé `Example`, le code source définit une classe interne dont le nom, `GreetingResources`, est le même que le nom de base des fichiers de ressources. Il est ainsi possible d’instancier avec succès un <xref:System.Resources.ResourceManager> objet en appelant le <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> constructeur.  
  
 Notez que la sortie affiche localisée correcte de type chaîne, sauf si la culture d’interface utilisateur actuelle est suédois (Suède), auquel cas il utilise les ressources de langue anglaise. Étant donné que les ressources de langue suédoise ne sont pas disponibles, l’application utilise les ressources de la culture par défaut, comme défini par le <xref:System.Resources.NeutralResourcesLanguageAttribute> d’attribut, à la place.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="resourceSource" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="baseName">Le nom racine du fichier de ressources sans son extension, mais avec un nom quelconque d’espace de noms qualifié complet. Par exemple, le nom de la racine pour le fichier de ressources nommé MyApplication.MyResource.en-US.resources est MyApplication.MyResource.</param>
        <param name="assembly">Assembly principal des ressources.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceManager" /> qui recherche les ressources contenues dans les fichiers portant le nom racine spécifié dans l'assembly donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Applications de bureau  
 Dans les applications de bureau, les fichiers de ressources spécifiques à la culture doivent être contenus dans les assemblys satellites et fichier de ressources de la culture par défaut doit être contenu dans l’assembly principal. Un assembly satellite est supposé pour contenir des ressources pour une culture spécifiée dans le manifeste de cet assembly et est chargé en tant que nécessaire.  
  
> [!NOTE]
>  Pour extraire des ressources à partir des fichiers .resources directement au lieu de les récupérer à partir des assemblys, vous devez appeler la <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> méthode à la place pour instancier un <xref:System.Resources.ResourceManager> objet.  
  
 Si le fichier de ressources identifié par `baseName` ne figure pas dans `assembly`, la méthode instancie un <xref:System.Resources.ResourceManager> objet, mais la tentative de récupération d’une ressource spécifique lève une exception, généralement <xref:System.Resources.MissingManifestResourceException>. Pour plus d’informations sur le diagnostic de la cause de l’exception, consultez la section « Gestion du MissingManifestResourceException (Exception) » de la <xref:System.Resources.ResourceManager> rubrique de la classe.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>Applications [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]  
  
> [!IMPORTANT]
>  Bien que le <xref:System.Resources.ResourceManager> classe est pris en charge dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, nous ne recommandons pas son utilisation. Utilisez cette classe uniquement lorsque vous développez [!INCLUDE[net_portable](~/includes/net-portable-md.md)] qui peuvent être utilisés avec les projets [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Pour récupérer des ressources à partir de [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] , les applications utilisent le [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182) classe à la place.  
  
 Dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, le Gestionnaire de ressources utilise le nom simple de le `assembly` paramètre pour rechercher une ressource correspondant est défini dans le fichier de l’index (PRI) de ressource de package de l’application. Le `baseName` paramètre est utilisé pour rechercher un élément de ressource dans le jeu de ressources. Par exemple, le nom racine de PortableLibrary1.Resource1.de-.Resources est PortableLibrary1.Resource1.  
  
   
  
## Examples  
 L’exemple suivant utilise une simple application « Hello World » non localisée pour illustrer la <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> constructeur. Voici le contenu d’un fichier texte nommé ExampleResources.txt. Lorsque l’application est compilée, la ressource est incorporée dans l’assembly principal de l’application.  
  
```  
Greeting=Hello  
```  
  
 Le fichier texte peut être converti dans un fichier de ressources binaire à l’aide de l’à la commande invite de commandes comme suit :  
  
```  
resgen ExampleResources.txt  
```  
  
 L’exemple suivant fournit le code exécutable qui instancie un <xref:System.Resources.ResourceManager> invite l’utilisateur à entrer un nom d’objet et affiche un message d’accueil.  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/example.cs#1)]
 [!code-vb[System.Resources.ResourceManager.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/example.vb#1)]  
  
 Il peut être compilé à l’aide de la commande suivante en Visual Basic :  
  
```  
vbc Example.vb /resource:ExampleResources.resources  
```  
  
 ou, à l’aide de l’élément suivant de commande en c# :  
  
```  
csc Example.cs /resource:ExampleResources.resources  
```  
  
 Notez que l’exemple récupère une référence à l’assembly qui contient le fichier de ressources en passant d’un type défini dans cet assembly à la `typeof` (fonction) (en c#) ou `GetType` la fonction (en Visual Basic) et la récupération de la valeur de sa <xref:System.Type.Assembly%2A?displayProperty=nameWithType>propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="baseName" /> ou <paramref name="assembly" /> est <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Ce constructeur utilise fournie par le système <see cref="T:System.Resources.ResourceSet" /> implémentation. Pour utiliser un format de fichier de ressources personnalisé, vous devez dériver de la <see cref="T:System.Resources.ResourceSet" /> de classe, remplacez le <see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> et <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> des méthodes et passe de type pour le <see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" /> constructeur. L’aide d’un <see cref="T:System.Resources.ResourceSet" /> peut être utile pour contrôle ressource mise en cache de la stratégie ou prenant en charge votre propre format de fichier de ressources, mais n’est généralement pas nécessaire.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly, Type ^ usingResourceSet);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">Le nom racine du fichier de ressources sans son extension, mais avec un nom quelconque d’espace de noms qualifié complet. Par exemple, le nom de la racine pour le fichier de ressources nommé MyApplication.MyResource.en-US.resources est MyApplication.MyResource.</param>
        <param name="assembly">Assembly principal des ressources.</param>
        <param name="usingResourceSet">Type de <see cref="T:System.Resources.ResourceSet" /> personnalisé. Si la valeur est <see langword="null" />, l'objet <see cref="T:System.Resources.ResourceSet" /> d'exécution par défaut est utilisé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceManager" /> qui utilise une classe <see cref="T:System.Resources.ResourceSet" /> spécifiée pour rechercher les ressources contenues dans les fichiers portant le nom racine spécifié dans l'assembly donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les fichiers de ressources spécifiques à la culture doivent être contenus dans les assemblys satellites et fichier de ressources de la culture par défaut doit être contenu dans l’assembly principal. Un assembly satellite est supposé pour contenir des ressources pour une culture spécifiée dans le manifeste de cet assembly et est chargé en tant que nécessaire.  
  
> [!NOTE]
>  Pour extraire des ressources à partir des fichiers .resources directement au lieu de les récupérer à partir des assemblys, vous devez appeler la <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> méthode à la place pour instancier un <xref:System.Resources.ResourceManager> objet.  
  
 Si le fichier de ressources identifié par `baseName` ne figure pas dans `assembly`, la méthode instancie un <xref:System.Resources.ResourceManager> objet, mais la tentative de récupération d’une ressource spécifique lève une exception, généralement <xref:System.Resources.MissingManifestResourceException>. Pour plus d’informations sur le diagnostic de la cause de l’exception, consultez la section « Gestion du MissingManifestResourceException (Exception) » de la <xref:System.Resources.ResourceManager> rubrique de la classe.  
  
> [!NOTE]
>  Le `usingResourceSet` paramètre est utilisé pour prendre en charge le format de vos propres ressources et correspond généralement à `null`. Cela est différent d’un constructeur qui accepte un <xref:System.Type> uniquement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="usingResourceset" /> n'est pas une classe dérivée de <see cref="T:System.Resources.ResourceSet" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="baseName" /> ou <paramref name="assembly" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Ce constructeur vous permet de spécifier un <see cref="T:System.Resources.ResourceSet" /> mise en œuvre. Si vous ne souhaitez pas spécifique <see cref="T:System.Resources.ResourceSet" /> implémentation serait mais utiliser un format de fichier de ressources personnalisé, vous devez dériver de la <see cref="T:System.Resources.ResourceSet" /> classe, remplacez le <see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> et <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> des méthodes et étape de type à ce constructeur.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BaseName">
      <MemberSignature Language="C#" Value="public virtual string BaseName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseName" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.BaseName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom racine des fichiers de ressources dans lesquels <see cref="T:System.Resources.ResourceManager" /> recherche les ressources.</summary>
        <value>Nom racine des fichiers de ressources dans lesquels <see cref="T:System.Resources.ResourceManager" /> recherche les ressources.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.BaseName%2A> propriété reflète le nom de l’espace de noms qualifié complet et le nom de ressource racine d’un fichier de ressources sans son extension de nom de fichier ou de la culture. Par exemple, si le fichier de ressources par défaut d’une application se nomme `SampleApps.StringResources.resources`, la valeur de la <xref:System.Resources.ResourceManager.BaseName%2A> propriété est « SampleApps.StringResources ». Si le fichier de ressources par défaut d’une application se nomme `SampleApps.StringResources.en-US.resources` et qui est incorporée dans un assembly satellite, la valeur de la <xref:System.Resources.ResourceManager.BaseName%2A> propriété est toujours « SampleApps.StringResources ».  
  
> [!IMPORTANT]
>  Le <xref:System.Resources.ResourceManager.BaseName%2A> valeur de propriété d’un fichier de ressources qui est compilé et incorporé à partir de la ligne de commande n’inclut pas un espace de noms, sauf si vous incluez explicitement un lors de la compilation du fichier. En revanche, le <xref:System.Resources.ResourceManager.BaseName%2A> valeur de propriété d’un fichier de ressources qui est compilé et incorporé en général dans l’environnement Visual Studio n’inclut pas le nom d’espace de noms par défaut.  
  
 Le <xref:System.Resources.ResourceManager.BaseName%2A> valeur de propriété est identique à la chaîne passée à la <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> ou <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> constructeur lorsque vous instanciez un <xref:System.Resources.ResourceManager> instance.  
  
   
  
## Examples  
 Vous pouvez déterminer les noms des fichiers .resources incorporés en compilant et en exécutant l’utilitaire suivant. Il s’agit d’une application console qui accepte le nom d’un assembly principal ou un assembly satellite en tant que paramètre de ligne de commande. Il affiche les chaînes qui doivent être fournis comme le `baseName` paramètre de la <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> ou <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> constructeur afin que le Gestionnaire de ressources peut identifier correctement la ressource.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
 [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseNameField">
      <MemberSignature Language="C#" Value="protected string BaseNameField;" />
      <MemberSignature Language="ILAsm" Value=".field family string BaseNameField" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.BaseNameField" />
      <MemberSignature Language="VB.NET" Value="Protected BaseNameField As String " />
      <MemberSignature Language="C++ CLI" Value="protected: System::String ^ BaseNameField;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie le nom racine des fichiers de ressources dans lesquels <see cref="T:System.Resources.ResourceManager" /> recherche les ressources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.BaseNameField> champ est utile uniquement si vous écrivez votre propre classe qui dérive de la <xref:System.Resources.ResourceManager> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFileBasedResourceManager">
      <MemberSignature Language="C#" Value="public static System.Resources.ResourceManager CreateFileBasedResourceManager (string baseName, string resourceDir, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.CreateFileBasedResourceManager(System.String,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFileBasedResourceManager (baseName As String, resourceDir As String, usingResourceSet As Type) As ResourceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Resources::ResourceManager ^ CreateFileBasedResourceManager(System::String ^ baseName, System::String ^ resourceDir, Type ^ usingResourceSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="resourceDir" Type="System.String" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">Nom racine des ressources. Ainsi, le nom racine du fichier de ressources « MyResource.en-US.resources » est « MyResource ».</param>
        <param name="resourceDir">Nom du répertoire dans lequel rechercher les ressources. <c>resourceDir</c> peut être un chemin absolu ou un chemin relatif du répertoire de l’application.</param>
        <param name="usingResourceSet">Type de <see cref="T:System.Resources.ResourceSet" /> personnalisé. Si la valeur est <see langword="null" />, l'objet <see cref="T:System.Resources.ResourceSet" /> d'exécution par défaut est utilisé.</param>
        <summary>Retourne un objet <see cref="T:System.Resources.ResourceManager" /> qui recherche les ressources dans un répertoire spécifique, plutôt que dans le manifeste d'assembly.</summary>
        <returns>Nouvelle instance d'un gestionnaire de ressources qui recherche les ressources dans le répertoire spécifié plutôt que dans un manifeste d'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne un gestionnaire de ressources qui Récupère les ressources à partir d’un fichier .resources qui n’est pas incorporé dans un assembly. Vous pouvez utiliser cette <xref:System.Resources.ResourceManager> objet pour charger les ressources d’une page ASP.NET ou pour tester un <xref:System.Resources.ResourceSet> mise en œuvre.  Pour obtenir un exemple qui Récupère les ressources à partir d’un fichier .resources, consultez le [la récupération des ressources](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md) l’article.  
  
 Cette méthode vous permet de spécifier un <xref:System.Resources.ResourceSet> mise en œuvre. Si vous ne souhaitez pas un spécifique <xref:System.Resources.ResourceSet> implémentation, mais souhaitez utiliser un format de fichier de ressource personnalisée, vous devez dériver de la <xref:System.Resources.ResourceSet> classe, remplacez le <xref:System.Resources.ResourceSet.GetDefaultReader%2A> et <xref:System.Resources.ResourceSet.GetDefaultWriter%2A> des méthodes et étape de type à ce constructeur.  
  
> [!CAUTION]
>  À l’aide de fichiers .resources autonomes dans une application ASP.NET interrompt le déploiement XCOPY, étant donné que les ressources restent verrouillées jusqu'à ce qu’elles soient libérées explicitement par le <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> (méthode). Si vous souhaitez déployer des ressources avec vos applications ASP.NET, compilez vos fichiers .resources en assemblys satellites.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="baseName" /> ou <paramref name="resourceDir" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FallbackLocation">
      <MemberSignature Language="C#" Value="protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Resources.UltimateResourceFallbackLocation FallbackLocation" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.FallbackLocation" />
      <MemberSignature Language="VB.NET" Value="Protected Property FallbackLocation As UltimateResourceFallbackLocation" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Resources::UltimateResourceFallbackLocation FallbackLocation { System::Resources::UltimateResourceFallbackLocation get(); void set(System::Resources::UltimateResourceFallbackLocation value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.UltimateResourceFallbackLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'emplacement à partir duquel récupérer les ressources de secours par défaut.</summary>
        <value>L'une des valeurs d'énumération qui spécifie où le gestionnaire de ressources peut rechercher les ressources de secours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.FallbackLocation%2A> propriété est utile uniquement si vous écrivez votre propre classe qui dérive de la <xref:System.Resources.ResourceManager> classe.  
  
 Vous pouvez utiliser la <xref:System.Resources.NeutralResourcesLanguageAttribute> attribut pour informer le Gestionnaire de ressources où trouver la culture par défaut pour une application : dans l’assembly principal (par défaut) ou dans un assembly satellite.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Resources.UltimateResourceFallbackLocation" />
        <altmember cref="T:System.Resources.NeutralResourcesLanguageAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetNeutralResourcesLanguage">
      <MemberSignature Language="C#" Value="protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Globalization.CultureInfo GetNeutralResourcesLanguage(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetNeutralResourcesLanguage(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetNeutralResourcesLanguage (a As Assembly) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Globalization::CultureInfo ^ GetNeutralResourcesLanguage(System::Reflection::Assembly ^ a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">Assembly pour lequel retourner des informations spécifiques à la culture.</param>
        <summary>Retourne des informations spécifiques à la culture pour les ressources par défaut de l'assembly principal en récupérant la valeur de l'attribut <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> sur un assembly spécifié.</summary>
        <returns>Culture de l'attribut <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" />, si détecté ; sinon, la culture dite indifférente.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la valeur de la ressource non-chaîne spécifiée pour la culture actuelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la ressource à obtenir.</param>
        <summary>Retourne la valeur de la ressource non-chaîne spécifiée.</summary>
        <returns>Valeur de la ressource localisée pour les paramètres de culture actuels de l'appelant. Si un ensemble de ressources approprié existe, mais <paramref name="name" /> est introuvable, la méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.GetObject%2A> méthode est utilisée pour récupérer des ressources. Elles comprennent les valeurs qui appartiennent aux types de données primitifs, tels que <xref:System.Int32> ou <xref:System.Double>, les bitmaps (comme un <xref:System.Drawing.Bitmap?displayProperty=nameWithType> objet), ou personnaliser les objets sérialisés. En règle générale, l’objet retourné doit être casté (en c#) ou convertie (en Visual Basic) en objet du type approprié.  
  
 La ressource retournée est localisée pour la culture d’interface utilisateur du thread actuel, qui est définie par le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété. Si la ressource n’est pas localisée pour cette culture, le Gestionnaire de ressources utilise les règles de secours pour charger une ressource appropriée. Si aucun ensemble exploitable de ressources localisées est trouvé, le <xref:System.Resources.ResourceManager> revient sur les ressources de la culture par défaut. Si une ressource définie pour la culture par défaut est introuvable, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé se trouver dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (la valeur par défaut) ou respectant la casse.  
  
> [!CAUTION]
>  Cette méthode peut lever des exceptions plus que celles répertoriées. Cela peut se produire est si une méthode qui appelle de cette méthode lève une exception.  Par exemple, un <xref:System.IO.FileLoadException> exception peut être levée si une erreur a été lors du déploiement ou installation d’un assembly satellite, ou un <xref:System.Runtime.Serialization.SerializationException> exception peut être levée si un type défini par l’utilisateur lève une exception définie par l’utilisateur lorsque le type est désérialisé.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Si vous appelez le <xref:System.Resources.ResourceManager.GetObject%2A> méthode plusieurs fois avec la même `name` paramètre, ne dépendent pas de la méthode retourne une référence au même objet de chaque appel. C’est parce que le <xref:System.Resources.ResourceManager.GetObject%2A> méthode peut retourner une référence à un objet de ressource existant dans un cache, ou il peut recharger la ressource et retourner une référence à un nouvel objet de ressource.  
  
   
  
## Examples  
 L’exemple suivant utilise la méthode <xref:System.Resources.ResourceManager.GetObject%28System.String%29> pour désérialiser un objet personnalisé. L’exemple inclut un fichier de code source nommé UIElements.cs (UIElements.vb si vous utilisez Visual Basic) qui définit la structure suivante nommée `PersonTable`. Cette structure est ensuite utilisée par une routine d’affichage de table générale qui affiche les noms localisés des colonnes de table. Notez que la structure `PersonTable` est marquée avec l’attribut <xref:System.SerializableAttribute> .  
  
 [!code-csharp[Conceptual.Resources.Retrieving#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example.cs#6)]
 [!code-vb[Conceptual.Resources.Retrieving#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#6)]  
  
 Le code ci-dessous provient d’un fichier CreateResources.cs (CreateResources.vb pour Visual Basic). Il crée un fichier de ressources XML nommé UIResources.resx qui stocke un titre de table ainsi qu’un objet `PersonTable` qui contient des informations relatives à une application localisée en anglais.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example1.cs#7)]
 [!code-vb[Conceptual.Resources.Retrieving#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#7)]  
  
 Le code suivant, qui provient d’un fichier de code source nommé GetObject.cs (ou GetObject.vb), récupère ensuite les ressources et les affiche dans la console.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example2.cs#8)]
 [!code-vb[Conceptual.Resources.Retrieving#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example2.vb#8)]  
  
 Vous pouvez créer le fichier et les assemblys de ressources nécessaires, puis lancer l’application en exécutant le fichier de commandes suivant. Vous devez utiliser l’option `/r` pour fournir à Resgen.exe une référence à UIElements.dll qui lui permet d’accéder aux informations relatives à la structure `PersonTable` . Si vous utilisez C#, remplacez le nom du compilateur `vbc` par `csc`et modifiez l’extension `.vb` en `.cs`.  
  
```  
  
vbc /t:library UIElements.vb  
vbc CreateResources.vb /r:UIElements.dll  
CreateResources  
  
resgen UIResources.resx  /r:UIElements.dll  
vbc GetObject.vb /r:UIElements.dll /resource:UIResources.resources  
  
GetObject.exe  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources localisées pouvant être utilisé n'a été trouvé et il n'existe pas de ressources pour la culture par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la ressource à obtenir.</param>
        <param name="culture">Culture pour laquelle la ressource doit être localisée. Si la ressource n'est pas localisée pour cette culture, le gestionnaire de ressources utilise les règles de secours pour localiser une ressource appropriée.  
  
 Si cette valeur est <see langword="null" />, l'objet <see cref="T:System.Globalization.CultureInfo" /> est obtenu en utilisant la propriété <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" />.</param>
        <summary>Obtient la valeur de la ressource non-chaîne spécifiée localisée pour la culture spécifiée.</summary>
        <returns>Valeur de la ressource localisée pour la culture spécifiée. Si un ensemble de ressources approprié existe, mais <paramref name="name" /> est introuvable, la méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> méthode est utilisée pour récupérer des ressources. Elles comprennent les valeurs qui appartiennent aux types de données primitifs, tels que <xref:System.Int32> ou <xref:System.Double>, les bitmaps (comme un <xref:System.Drawing.Bitmap?displayProperty=nameWithType> objet), ou personnaliser les objets sérialisés. En règle générale, l’objet retourné doit être casté (en c#) ou convertie (en Visual Basic) en objet du type approprié.  
  
 La ressource retournée est localisée pour la culture spécifiée par `culture`, ou pour la culture spécifiée par le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété si `culture` est `null`. Si la ressource n’est pas localisée pour cette culture, le Gestionnaire de ressources utilise les règles de secours pour charger une ressource appropriée. Si aucun ensemble exploitable de ressources localisées est trouvé, le Gestionnaire de ressources revient sur les ressources de la culture par défaut. Si une ressource définie pour la culture par défaut est introuvable, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé se trouver dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (la valeur par défaut) ou respectant la casse.  
  
> [!CAUTION]
>  Cette méthode peut lever des exceptions plus que celles répertoriées. Cela peut se produire est si une méthode qui appelle de cette méthode lève une exception.  Par exemple, un <xref:System.IO.FileLoadException> exception peut être levée si une erreur a été lors du déploiement ou installation d’un assembly satellite, ou un <xref:System.Runtime.Serialization.SerializationException> exception peut être levée si un type défini par l’utilisateur lève une exception définie par l’utilisateur lorsque le type est désérialisé.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Si vous appelez le <xref:System.Resources.ResourceManager.GetObject%2A> méthode plusieurs fois avec la même `name` paramètre, ne dépendent pas de la méthode retourne une référence au même objet de chaque appel. C’est parce que le <xref:System.Resources.ResourceManager.GetObject%2A> méthode peut retourner une référence à un objet de ressource existant dans un cache, ou il peut recharger la ressource et retourner une référence à un nouvel objet de ressource.  
  
   
  
## Examples  
 L’exemple suivant utilise la méthode <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> pour désérialiser un objet personnalisé. L’exemple inclut un fichier de code source nommé NumberInfo.cs (NumberInfo.vb si vous utilisez Visual Basic) qui définit la structure suivante nommée `Numbers`. Cette structure est destinée à être utilisée par une application simple à titre éducatif enseigne non anglophones parlée à compter à 10 en anglais. Notez que la `Numbers` classe est marquée avec le <xref:System.SerializableAttribute> attribut.  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/numberinfo.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/numberinfo.vb#1)]  
  
 Le code source suivant à partir d’un fichier nommé CreateResources.cs (CreateResources.vb pour Visual Basic) crée des fichiers de ressources XML pour l’anglais par défaut, ainsi que pour les langues Français, portugais et russe.  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/createresources.cs#2)]
 [!code-vb[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/createresources.vb#2)]  
  
 Les ressources sont consommées par l’application suivante, qui définit la culture d’interface utilisateur actuelle pour le russe (Russie), portugais (Brésil) ou Français (France). Il appelle le <xref:System.Resources.ResourceManager.GetObject%28System.String%29> méthode pour obtenir un `Numbers` objet qui contient les nombres localisée et la <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> méthode pour obtenir un `Numbers` objet qui contient les nombres de langue anglaise. Il affiche ensuite des nombres impairs à l’aide de la culture d’interface utilisateur actuelle et la langue anglaise. Le fichier de code source est nommé ShowNumbers.cs (ShowNumbers.vb).  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/shownumbers.cs#3)]
 [!code-vb[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/shownumbers.vb#3)]  
  
 Vous pouvez utiliser le fichier de commandes suivant pour générer et exécuter la version Visual Basic de l’exemple. Si vous utilisez c#, remplacez `vbc` avec `csc`et remplacez le `.vb` extension avec `.cs`.  
  
```  
  
vbc /t:library NumberInfo.vb  
  
vbc CreateResources.vb /r:NumberInfo.dll  
CreateResources  
  
resgen NumberResources.resx /r:NumberInfo.dll  
  
resgen NumberResources.fr.resx /r:Numberinfo.dll  
Md fr  
al /embed:NumberResources.fr.resources /culture:fr /t:lib /out:fr\ShowNumbers.resources.dll  
  
resgen NumberResources.pt.resx  /r:Numberinfo.dll  
Md pt  
al /embed:NumberResources.pt.resources /culture:pt /t:lib /out:pt\ShowNumbers.resources.dll  
  
resgen NumberResources.ru.resx /r:Numberinfo.dll  
Md ru  
al /embed:NumberResources.ru.resources /culture:ru /t:lib /out:ru\ShowNumbers.resources.dll  
  
vbc ShowNumbers.vb /r:NumberInfo.dll /resource:NumberResources.resources  
ShowNumbers.exe  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources pouvant être utilisé n'a été trouvé et il n'existe pas de ressources de culture par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>Le <see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" /> méthode est thread-safe.</threadsafe>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceFileName">
      <MemberSignature Language="C#" Value="protected virtual string GetResourceFileName (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetResourceFileName(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResourceFileName (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetResourceFileName(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Objet de culture pour lequel un nom de fichier de ressources est construit.</param>
        <summary>Génère le nom du fichier de ressources pour l'objet <see cref="T:System.Globalization.CultureInfo" /> donné.</summary>
        <returns>Nom qui peut être utilisé pour un fichier de ressources de l'objet <see cref="T:System.Globalization.CultureInfo" /> donné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.GetResourceFileName%2A> méthode est utile uniquement si vous écrivez votre propre classe qui dérive de la <xref:System.Resources.ResourceManager> classe.  
  
 Cette méthode utilise le <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType> propriété en tant que partie du nom de fichier pour toutes les cultures autres que la culture dite indifférente. Cette méthode ne recherche pas dans le manifeste d’assembly ou tactile le disque et est utilisée uniquement pour construire un nom de fichier de ressources (approprié pour passer à la <xref:System.Resources.ResourceReader> constructeur) ou un nom d’objet blob de ressource de manifeste.  
  
 Une classe dérivée peut substituer cette méthode pour rechercher une autre extension, telles que ». ResX », ou un schéma de complètement différent pour nommer les fichiers de ressources. Notez que la méthode peut être utilisée pour personnaliser le nom d’un fichier de ressources dans un assembly satellite et non ne pas pour personnaliser le nom de l’assembly satellite lui-même.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceSet">
      <MemberSignature Language="C#" Value="public virtual System.Resources.ResourceSet GetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Resources.ResourceSet GetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Resources::ResourceSet ^ GetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">Culture dont les ressources doivent être récupérées.</param>
        <param name="createIfNotExists">
          <see langword="true" /> pour charger le jeu de ressources, s'il n'a pas encore été chargé, sinon <see langword="false" />.</param>
        <param name="tryParents">
          <see langword="true" /> pour utiliser le secours pour les ressources pour charger une ressource appropriée si l'ensemble de ressources est introuvable ; <see langword="false" /> pour ignorer le processus de secours.</param>
        <summary>Récupère la ressource définie pour une culture particulière.</summary>
        <returns>Ensemble de ressources pour la culture spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeu de ressources qui est retourné représente les ressources localisées pour la culture spécifiée. Si les ressources n’ont pas été localisées pour cette culture et `tryParents` est `true`, <xref:System.Resources.ResourceManager.GetResourceSet%2A> utilise des règles de secours pour charger une ressource appropriée. Si `tryParents` est `false` et un ensemble de ressources spécifiques à la culture est introuvable, la méthode retourne `null`. Pour plus d’informations sur les ressources de secours, consultez la section « Le processus de secours » dans le [empaquetage et déploiement de ressources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) l’article.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Resources.ResourceManager.GetResourceSet%2A> méthode pour récupérer des ressources spécifiques à la culture pour la culture Français (France). Ensuite, elle énumère toutes les ressources dans le jeu de ressources. Il contient le code source pour un fichier exécutable nommé ShowNumbers.exe. Il inclut également le fichier deux texte suivant qui contiennent les noms des nombres. La première, NumberResources.txt, contient les noms des nombres de 1 à 10 en anglais :  
  
```  
  
one=one  
two=two  
three=three  
four=four  
five=five  
six=six  
seven=seven  
eight=eight  
nine=nine  
ten=ten  
  
```  
  
 La seconde, NumberResources.fr-fr.txt, contient les noms des numéros d’un à quatre dans la langue Français :  
  
```  
  
one=un  
two=deux  
three=trois  
four=quatre  
  
```  
  
 Vous pouvez utiliser un fichier de commandes pour générer les fichiers de ressources, incorporer le fichier de ressources de langue anglaise dans le fichier exécutable et créer un assembly satellite pour les ressources de langue Français. Voici le fichier de commandes pour générer un fichier exécutable à l’aide du compilateur Visual Basic :  
  
```  
  
resgen NumberResources.txt  
vbc shownumbers.vb /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
```  
  
 Pour le compilateur c#, vous pouvez utiliser le fichier de commandes suivant :  
  
```  
  
resgen NumberResources.txt  
csc shownumbers.cs /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/cs/shownumbers.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/vb/shownumbers.vb#1)]  
  
 Notez que si vous modifiez la valeur de la `createIfNotExists` argument `false`, l’appel de méthode retourne `null`, car le Gestionnaire de ressources n’a pas encore chargé les ressources de langue Français.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="culture" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">
          <paramref name="tryParents" /> est <see langword="true" />, aucun ensemble de ressources n'est trouvé et il n'existe pas de ressources de culture par défaut.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteContractVersion">
      <MemberSignature Language="C#" Value="protected static Version GetSatelliteContractVersion (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Version GetSatelliteContractVersion(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetSatelliteContractVersion(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetSatelliteContractVersion (a As Assembly) As Version" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static Version ^ GetSatelliteContractVersion(System::Reflection::Assembly ^ a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">Assembly dont vous recherchez l'attribut <see cref="T:System.Resources.SatelliteContractVersionAttribute" />.</param>
        <summary>Retourne la version spécifiée par l'attribut <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> dans l'assembly donné.</summary>
        <returns>Version de contrat satellite de l'assembly donné ou <see langword="null" />, si aucune version n'est trouvée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur le versioning des assemblys satellites, consultez le <xref:System.Resources.SatelliteContractVersionAttribute> rubrique de référence.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Version" /> trouvé dans l'assembly <paramref name="a" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="a" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un objet de flux de mémoire non managé à partir d'une ressource spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom d'une ressource.</param>
        <summary>Retourne un objet de flux de mémoire non managé à partir de la ressource spécifiée.</summary>
        <returns>Objet de flux de mémoire non managé qui représente une ressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.GetStream%2A> méthode prend le nom d’une ressource qui est stocké en tant qu’un <xref:System.IO.MemoryStream> d’objet, obtient la valeur de la <xref:System.Object> ressource et retourne un <xref:System.IO.UnmanagedMemoryStream> objet. Il requiert que vous travaillez directement avec un flux d’octets, puis converti en un objet. Cette méthode est principalement utile pour des raisons de performances : récupération d’une ressource comme un flux d’octets au lieu d’un objet explicit peut améliorer les performances.  
  
 La ressource retournée est localisée pour la culture d’interface utilisateur du thread actuel, qui est définie par le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété. Si la ressource n’est pas localisée pour cette culture, le Gestionnaire de ressources utilise les règles de secours pour charger une ressource appropriée. Si aucun ensemble exploitable de ressources localisées est trouvé, le <xref:System.Resources.ResourceManager> revient sur les ressources de la culture par défaut. Si une ressource définie pour la culture par défaut est introuvable, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé se trouver dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (la valeur par défaut) ou respectant la casse.  
  
   
  
## Examples  
 L’exemple suivant utilise la méthode <xref:System.Resources.ResourceManager.GetStream%28System.String%29> pour récupérer une image bitmap qui s’affiche dans la fenêtre de démarrage à l’ouverture d’une application. Ce qui suit le code à partir d’un fichier nommé source CreateResources.cs (pour c#) ou CreateResources.vb (pour Visual Basic) génère un fichier .resx nommé AppResources.resx qui contient l’image sérialisée. Dans cet exemple, l’image est chargée à partir d’un fichier SplashScreen.jpg. Vous pouvez remplacer ce nom de fichier par votre image.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/createresources.cs#4)]
 [!code-vb[Conceptual.Resources.Retrieving#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/createresources.vb#4)]  
  
 Le code suivant à partir d’un fichier nommé GetStream.cs (pour c#) ou GetStream.vb (pour Visual Basic), puis récupère la ressource et affiche l’image dans un <xref:System.Windows.Forms.PictureBox?displayProperty=nameWithType> contrôle.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/getstream.cs#5)]
 [!code-vb[Conceptual.Resources.Retrieving#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/getstream.vb#5)]  
  
 Vous pouvez utiliser le fichier de commandes suivant pour générer l’exemple C#. Pour Visual Basic, modifiez `csc` à `vbc`et changez l’extension du fichier de code source à partir de `.cs` à `.vb`...  
  
```  
  
csc CreateResources.cs  
CreateResources  
  
resgen AppResources.resx  
  
csc GetStream.cs /resource:AppResources.resources  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La valeur de la ressource spécifiée n'est pas un objet <see cref="T:System.IO.MemoryStream" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources pouvant être utilisé n'a été trouvé et il n'existe pas de ressources par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String, culture As CultureInfo) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Nom d'une ressource.</param>
        <param name="culture">Objet spécifiant la culture à utiliser pour la recherche de ressource. Si <c>culture</c> a la valeur <see langword="null" />, la culture du thread actuel est utilisée.</param>
        <summary>Retourne un objet de flux de mémoire non managé à partir de la ressource spécifiée, à l'aide de la culture spécifiée.</summary>
        <returns>Objet de flux de mémoire non managé qui représente une ressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.GetStream%2A> méthode prend le nom d’une ressource qui est stocké en tant qu’un <xref:System.IO.MemoryStream> d’objet, obtient la valeur de la <xref:System.Object> ressource et retourne un <xref:System.IO.UnmanagedMemoryStream> objet. Il requiert que vous travaillez directement avec un flux d’octets, puis converti en un objet. Cette méthode est principalement utile pour des raisons de performances : récupération d’une ressource comme un flux d’octets au lieu d’un objet explicit peut améliorer les performances.  
  
 La ressource retournée est localisée pour la culture spécifiée par `culture`, ou pour la culture spécifiée par le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété si `culture` est `null`. Si la ressource n’est pas localisée pour cette culture, le Gestionnaire de ressources utilise les règles de secours pour charger une ressource appropriée. Si aucun ensemble exploitable de ressources localisées est trouvé, le <xref:System.Resources.ResourceManager> revient sur les ressources de la culture par défaut. Si une ressource définie pour la culture par défaut est introuvable, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé se trouver dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (la valeur par défaut) ou respectant la casse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La valeur de la ressource spécifiée n'est pas un objet <see cref="T:System.IO.MemoryStream" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources pouvant être utilisé n'a été trouvé et il n'existe pas de ressources par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la ressource de chaîne spécifiée pour la culture spécifiée ou la culture d'interface utilisateur actuelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la ressource à récupérer.</param>
        <summary>Retourne la valeur de la ressource de chaîne spécifiée.</summary>
        <returns>Valeur de la ressource localisée pour la culture d'interface utilisateur actuelle de l'appelant, ou <see langword="null" /> si <paramref name="name" /> est introuvable dans un ensemble de ressources.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Applications de bureau  
 Dans les applications de bureau, la ressource retournée est localisée pour la culture d’interface utilisateur du thread actuel, comme défini par le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété. Si la ressource n’a pas été localisée pour cette culture, le Gestionnaire de ressources détecte une ressource en suivant les étapes décrites dans la section « Processus de secours pour les ressources » de la [empaquetage et déploiement de ressources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) l’article. Si aucun ensemble exploitable de ressources localisées est trouvé, le Gestionnaire de ressources revient sur les ressources de la culture par défaut. Si le Gestionnaire de ressources ne peut pas charger le jeu de ressources de la culture par défaut, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé se trouver dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (la valeur par défaut) ou respectant la casse.  
  
> [!CAUTION]
>  Cette méthode peut lever des exceptions plus que celles répertoriées. Cela peut se produire est si une méthode qui appelle de cette méthode lève une exception.  Par exemple, un <xref:System.IO.FileLoadException> exception peut être levée si une erreur a été lors du déploiement ou installation d’un assembly satellite, ou un <xref:System.Runtime.Serialization.SerializationException> exception peut être levée si un type défini par l’utilisateur lève une exception définie par l’utilisateur lorsque le type est désérialisé.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>Applications [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]  
  
> [!IMPORTANT]
>  Bien que le <xref:System.Resources.ResourceManager> classe est pris en charge dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, nous ne recommandons pas son utilisation. Utilisez cette classe uniquement lorsque vous développez [!INCLUDE[net_portable](~/includes/net-portable-md.md)] qui peuvent être utilisés avec les projets [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Pour récupérer des ressources à partir de [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] , les applications utilisent le [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182) classe à la place.  
  
 Dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, le <xref:System.Resources.ResourceManager.GetString%28System.String%29> méthode retourne la valeur de la `name` chaîne de ressource localisée pour les paramètres de culture de l’interface utilisateur en cours de l’appelant. La liste des cultures est dérivée de la liste des langues du système d’exploitation par défaut l’interface utilisateur. Si le Gestionnaire de ressources ne peut pas correspondre à `name`, la méthode retourne `null`.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Resources.ResourceManager.GetString%2A> méthode pour récupérer des ressources spécifiques à la culture. Il se compose de ressources compilés à partir de fichiers .txt pour l’anglais (en), Français (France) (fr-FR) et russe (Russie) (ru-RU) cultures. L’exemple modifie la culture actuelle et la culture d’interface utilisateur actuelle pour l’anglais (États-Unis), Français (France), russe (Russie) et suédois (Suède). Il appelle ensuite la <xref:System.Resources.ResourceManager.GetString%2A> pour récupérer la chaîne localisée, qu’elle affiche, ainsi que le jour actuel et le mois. Notez que la sortie affiche la chaîne localisée appropriée, sauf si la culture d’interface utilisateur actuelle est suédois (Suède). Étant donné que les ressources de langue suédoise ne sont pas disponibles, l’application utilise à la place les ressources de la culture par défaut, qui est l’anglais. L’exemple requiert les fichiers de ressources texte répertoriées dans le tableau suivant. Chacun a une ressource de chaîne unique nommée `DateStart`.  
  
|culture|Nom de fichier|Nom de la ressource|Valeur de la ressource|  
|-------------|---------------|-------------------|--------------------|  
|fr-FR|DateStrings.txt|`DateStart`|Nous sommes|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 Vous pouvez utiliser le fichier de commandes suivantes pour compiler l’exemple c#. Pour Visual Basic, remplacez `csc` par `vbc`, et modifiez l’extension du fichier de code source `.cs` en `.vb`.  
  
```  
resgen DateStrings.txt  
csc showdate.cs /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 Voici le code source pour l’exemple (ShowDate.vb pour la version Visual Basic) ou ShowDate.cs pour la version c#.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La valeur de la ressource spécifiée n'est pas une chaîne.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources pouvant être utilisé n'a été trouvé et il n'existe pas de ressources pour la culture par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>Le <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> méthode est thread-safe.</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la ressource à récupérer.</param>
        <param name="culture">Objet qui représente la culture pour laquelle la ressource est localisée.</param>
        <summary>Retourne la valeur de la ressource de type chaîne localisée pour la culture spécifiée.</summary>
        <returns>Valeur de la ressource localisée pour la culture spécifiée, ou <see langword="null" /> si <paramref name="name" /> est introuvable dans un ensemble de ressources.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Applications de bureau  
 Applications de bureau, si `culture` est `null`, le <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> méthode utilise la culture d’interface utilisateur actuelle obtenue à partir de la <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété.  
  
 La ressource retournée est localisée pour la culture spécifiée par le `culture` paramètre. Si la ressource n’a pas été localisée pour `culture`, le Gestionnaire de ressources détecte une ressource en suivant les étapes décrites dans la section « Processus de secours pour les ressources » de la [empaquetage et déploiement de ressources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) rubrique. Si aucun ensemble exploitable de ressources n’est trouvé, le Gestionnaire de ressources revient sur les ressources de la culture par défaut. Si le Gestionnaire de ressources ne peut pas charger le jeu de ressources de la culture par défaut, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé se trouver dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (la valeur par défaut) ou respectant la casse.  
  
> [!CAUTION]
>  Cette méthode peut lever des exceptions plus que celles répertoriées. Cela peut se produire est si une méthode qui appelle de cette méthode lève une exception.  Par exemple, un <xref:System.IO.FileLoadException> exception peut être levée si une erreur a été lors du déploiement ou installation d’un assembly satellite, ou un <xref:System.Runtime.Serialization.SerializationException> exception peut être levée si un type défini par l’utilisateur lève une exception définie par l’utilisateur lorsque le type est désérialisé.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>Applications [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]  
  
> [!IMPORTANT]
>  Bien que le <xref:System.Resources.ResourceManager> classe est pris en charge dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, nous ne recommandons pas son utilisation. Utilisez cette classe uniquement lorsque vous développez [!INCLUDE[net_portable](~/includes/net-portable-md.md)] qui peuvent être utilisés avec les projets [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Pour récupérer des ressources à partir de [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] , les applications utilisent le [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182) classe à la place.  
  
 Dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, le <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> méthode retourne la valeur de la `name` chaîne de ressource localisée pour la culture spécifiée par le `culture` paramètre. Si la ressource n’est pas localisée pour la `culture` culture, la recherche utilise l’ensemble du [!INCLUDE[win8](~/includes/win8-md.md)] liste de secours de langage et s’arrête après la recherche dans la culture par défaut. Si le Gestionnaire de ressources ne peut pas correspondre à `name`, la méthode retourne `null`.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> méthode pour récupérer des ressources spécifiques à la culture. Culture par défaut de cet exemple est l’anglais (en), et elle inclut des assemblys satellites pour le Français (France) (fr-FR) et russe (Russie) (ru-RU) cultures. L’exemple modifie la culture actuelle et la culture d’interface utilisateur actuelle pour le russe (Russie) avant d’appeler <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>. Il appelle ensuite la <xref:System.Resources.ResourceManager.GetString%2A> (méthode) et le <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> méthode et passe <xref:System.Globalization.CultureInfo> objets qui représentent les cultures de suédois (Suède) et le Français (France) à chaque méthode. Dans la sortie, le mois et le jour du mois, ainsi que la chaîne qui précède les apparaissent en Français, car le <xref:System.Resources.ResourceManager.GetString%2A> (méthode) est en mesure de récupérer la ressource de langue Français. Toutefois, lorsque la culture suédois (Suède) est utilisée, le mois et le jour du mois s’affichent en suédois, bien que la chaîne qui précède leur soit en anglais. Il s’agit, car le Gestionnaire de ressources ne peut pas trouver des ressources de langue suédoise localisée, elle retourne une ressource pour la culture par défaut à la place.  
  
 L’exemple requiert les fichiers de ressources texte répertoriées dans le tableau suivant. Chacun a une ressource de chaîne unique nommée `DateStart`.  
  
|culture|Nom de fichier|Nom de la ressource|Valeur de la ressource|  
|-------------|---------------|-------------------|--------------------|  
|fr-FR|DateStrings.txt|`DateStart`|Nous sommes|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 Vous pouvez utiliser le fichier de commandes suivantes pour compiler l’exemple Visual Basic. Pour compiler en c#, changez `vbc` à `csc`et changez l’extension du fichier de code source à partir de `.vb` à `.cs`.  
  
```  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 Voici le code source pour l’exemple (ShowDate.vb pour la version Visual Basic) ou ShowDate.cs pour la version c#.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate2.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La valeur de la ressource spécifiée n'est pas une chaîne.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources pouvant être utilisé n'a été trouvé et il n'existe pas de ressources pour une culture par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>Le <see cref="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" /> méthode est thread-safe.</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="HeaderVersionNumber">
      <MemberSignature Language="C#" Value="public static readonly int HeaderVersionNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 HeaderVersionNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderVersionNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int HeaderVersionNumber;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie la version des en-têtes de fichier de ressources que l'implémentation actuelle de <see cref="T:System.Resources.ResourceManager" /> peut interpréter et obtenir.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreCase">
      <MemberSignature Language="C#" Value="public virtual bool IgnoreCase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.IgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IgnoreCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IgnoreCase { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le gestionnaire de ressources autorise les recherches de ressources ne respectant pas la casse dans les méthodes <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> et <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" />.</summary>
        <value>
          <see langword="true" /> pour ignorer la casse pendant la recherche de ressources ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur de la <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété `false`, une ressource portant le nom « Ressource » n’est pas équivalente à la ressource portant le nom « resource ». Si <xref:System.Resources.ResourceManager.IgnoreCase%2A> est `true`, une ressource portant le nom « Ressource » est équivalente à la ressource portant le nom « resource ». Toutefois, notez que quand <xref:System.Resources.ResourceManager.IgnoreCase%2A> est `true`, le <xref:System.Resources.ResourceManager.GetString%2A?displayProperty=nameWithType> et <xref:System.Resources.ResourceManager.GetObject%2A?displayProperty=nameWithType> méthodes effectuent des comparaisons de chaînes sans respecter la casse à l’aide de la culture dite indifférente. L’avantage est que les résultats des comparaisons de chaînes sans respecter la casse effectuées par ces méthodes sont les mêmes sur tous les ordinateurs, quelle que soit la culture. L’inconvénient est que les résultats ne sont pas cohérentes avec les règles de casse de toutes les cultures.  
  
 Par exemple, l’alphabet turc a deux versions du caractère i : une avec un point et une sans le point. En turc, le caractère I (Unicode 0049) est considéré comme la version majuscule d’un caractère différent ı (Unicode 0131). Le caractère i (Unicode 0069) est considéré comme la version minuscule d’un autre caractère (Unicode 0130). Conformément à ces règles de casse, une comparaison de chaînes sans respecter la casse des caractères i (Unicode 0069) et I (Unicode 0049) doit échouer pour la culture « tr-TR » (turc de Turquie). Toutefois, étant donné que la comparaison est effectuée à l’aide des règles de casse de la culture dite indifférente si <xref:System.Resources.ResourceManager.IgnoreCase%2A> est `true`, cette comparaison réussit.  
  
> [!NOTE]
>  Pour des raisons de performances, il est préférable de toujours spécifier la casse correcte pour les noms de ressources. Paramètre <xref:System.Resources.ResourceManager.IgnoreCase%2A> à `true` peut entraîner une augmentation significative dans le jeu de travail et une baisse significative des performances.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalGetResourceSet">
      <MemberSignature Language="C#" Value="protected virtual System.Resources.ResourceSet InternalGetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Resources.ResourceSet InternalGetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function InternalGetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Resources::ResourceSet ^ InternalGetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">Objet de culture à rechercher.</param>
        <param name="createIfNotExists">
          <see langword="true" /> pour charger le jeu de ressources, s'il n'a pas encore été chargé, sinon <see langword="false" />.</param>
        <param name="tryParents">
          <see langword="true" /> pour vérifier les objets <see cref="T:System.Globalization.CultureInfo" /> parents si l'ensemble de ressources ne peut pas être chargé ; sinon, <see langword="false" />.</param>
        <summary>Fournit l'implémentation utilisée pour rechercher un jeu de ressources.</summary>
        <returns>Ensemble de ressources spécifié.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">L'assembly principal ne contient aucun fichier .resources et ce fichier qui est requis pour rechercher une ressource.</exception>
        <exception cref="T:System.ExecutionEngineException">Une erreur interne s'est produite dans le runtime.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">L'assembly satellite associé à <paramref name="culture" />n'a pas pu être localisé.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <block subset="none" type="overrides">
          <para>Cette méthode termine le travail nécessaire pour rechercher une ressource définie et peut être récursive et réentrante. En d’autres termes, cette méthode peut charger un assembly et un déclencheur un <see cref="E:System.AppDomain.AssemblyLoad" /> événement, qui rappelle ensuite un <see cref="T:System.Resources.ResourceManager" /> objet n’a pas été complètement initialisée. Pour éviter des verrous supplémentaires, cette méthode n’est pas thread-safe. Le <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />, <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />, et <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> méthodes font la synchronisation requise.</para>
        </block>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="MagicNumber">
      <MemberSignature Language="C#" Value="public static readonly int MagicNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MagicNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MagicNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MagicNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int MagicNumber;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient le nombre utilisé pour identifier les fichiers de ressources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur est définie à 0xBEEFCACE. Les quatre premiers octets du format de fichier système par défaut contiennent un entier signé 32 bits au format little-endian (voir <xref:System.Text.Encoding>).  
  
 Si le <xref:System.Resources.ResourceManager.MagicNumber> est trouvé, les octets suivant sera un numéro de version pour un <xref:System.Resources.ResourceManager> en-tête, suivi d’un nombre indiquant le nombre d’octets doit être ignoré pour passer cet en-tête. Le numéro suivant indique la version de la <xref:System.Resources.ResourceManager> ayant créé l’en-tête, suivi d’informations sur la version spécifique.  
  
 Le numéro de version pour l’implémentation actuelle est un. Les octets sont une chaîne préfixée par sa longueur contenant le nom d’un <xref:System.Resources.IResourceReader>, ce qui peut lire ce fichier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainAssembly">
      <MemberSignature Language="C#" Value="protected System.Reflection.Assembly MainAssembly;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Reflection.Assembly MainAssembly" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MainAssembly" />
      <MemberSignature Language="VB.NET" Value="Protected MainAssembly As Assembly " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Reflection::Assembly ^ MainAssembly;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie l'assembly principal qui contient les ressources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.MainAssembly> champ est utile uniquement si vous écrivez votre propre classe qui dérive de la <xref:System.Resources.ResourceManager> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllResources">
      <MemberSignature Language="C#" Value="public virtual void ReleaseAllResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseAllResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.ReleaseAllResources" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReleaseAllResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseAllResources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique au gestionnaire de ressources d'appeler la méthode <see cref="M:System.Resources.ResourceSet.Close" /> sur tous les objets <see cref="T:System.Resources.ResourceSet" /> et de libérer toutes les ressources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode réduit la plage de travail dans une application en cours d’exécution. Toute recherche de ressources ultérieure sur ce <xref:System.Resources.ResourceManager> objet sera coûteuse que la première recherche, car le Gestionnaire de ressources doit rechercher et charger les ressources. Cela peut être utile dans certains scénarios de threads complexes, où la création d’un nouveau <xref:System.Resources.ResourceManager> objet est le comportement approprié.  
  
> [!NOTE]
>  En commençant par le .NET Framework version 2.0, le <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> méthode n’est pas thread-safe par rapport au <xref:System.Resources.ResourceManager.GetObject%2A>, <xref:System.Resources.ResourceManager.GetString%2A>, et <xref:System.Resources.ResourceManager.GetStream%2A> operations. L’avantage de cette modification est une amélioration des performances de plusieurs threads d’accéder aux ressources. Toutefois, si vous appelez le <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> méthode dans un thread lors de l’obtention d’une ressource simultanément dans un autre thread, l’opération d’obtention peut lever une <xref:System.ObjectDisposedException> exception.  
  
 Vous pouvez également utiliser cette méthode dans les situations où les instances gérées pour les ressources créées par le Gestionnaire de ressources en cours doivent être libérées de façon déterministe, sans attendre que le Gestionnaire de ressources sont complètement hors de portée et l’opération garbage collection.  
  
> [!NOTE]
>  Appel de cette méthode ne décharge pas les assemblys satellites. Pour décharger des assemblys satellites, utilisez le <xref:System.AppDomain.Unload%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ResourceSets">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable ResourceSets;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Hashtable ResourceSets" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.ResourceSets" />
      <MemberSignature Language="VB.NET" Value="Protected ResourceSets As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Collections::Hashtable ^ ResourceSets;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("call InternalGetResourceSet instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient <see cref="T:System.Collections.Hashtable" /> qui retourne un mappage des cultures aux objets <see cref="T:System.Resources.ResourceSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSetType">
      <MemberSignature Language="C#" Value="public virtual Type ResourceSetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ResourceSetType" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.ResourceSetType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ResourceSetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ResourceSetType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de l'objet d'ensemble de ressources que le gestionnaire des ressources utilise pour construire un objet <see cref="T:System.Resources.ResourceSet" />.</summary>
        <value>Type de l'objet d'ensemble de ressources que le gestionnaire des ressources utilise pour construire un objet <see cref="T:System.Resources.ResourceSet" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>