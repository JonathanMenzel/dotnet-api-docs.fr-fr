<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bd0cb8c8f9bab7b3d360dd2941d7f05aafb1edf5" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37472454" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <TypeSignature Language="F#" Value="type ResourceReader = class&#xA;    interface IResourceReader&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Enumerates the resources in a binary resources (.resources) file by reading sequential resource name/value pairs.  **Security Note**: Calling methods in this class with untrusted data is a security risk. Call the methods in the class only with trusted data. For more information, see [Untrusted Data Security Risks](https://docs.com/rick-anderson-1/8710/untrusted-data-security-risks).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceReader> classe fournit une implémentation standard de le <xref:System.Resources.IResourceReader> interface. Un <xref:System.Resources.ResourceReader> instance représente un fichier .resources ou un fichier .resources incorporé dans un assembly. Il est utilisé pour énumérer les ressources dans un fichier .resources et récupérer ses paires nom/valeur. Il diffère de la <xref:System.Resources.ResourceManager> (classe), qui est utilisée pour récupérer des ressources nommées spécifiés à partir d’un fichier .resources incorporé dans un assembly. Le <xref:System.Resources.ResourceManager> classe est utilisée pour récupérer des ressources dont les noms sont connus d’avance, tandis que la <xref:System.Resources.ResourceReader> classe est utile pour extraire des ressources dont nombre ou les noms exacts ne sont pas connus au moment de la compilation. Par exemple, une application peut utiliser un fichier de ressources pour stocker les informations de configuration qui sont organisées en sections et des éléments dans une section, où le nombre de sections ou des éléments dans une section n’est pas connu d’avance. Ressources peuvent ensuite être nommés de manière générique (tel que `Section1`, `Section1Item1`, `Section1Item2`, et ainsi de suite) et récupérées à l’aide un <xref:System.Resources.ResourceReader> objet.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.  
  
 Pour plus d’informations sur l’utilisation de la <xref:System.Resources.ResourceReader> de classe, consultez les sections suivantes :  
  
-   [Instanciation d’un objet ResourceReader](#instantiate)  
  
-   [L’énumération des ressources d’un objet ResourceReader](#enumerate)  
  
    -   [Récupérer des ressources à l’aide des propriétés de IDictionaryEnumerator](#idictionaryenumerator)  
  
    -   [Récupération de ressources par nom avec GetResourceData](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>Instanciation d’un objet ResourceReader  
 Un fichier .resources est un fichier binaire qui a été compilé à partir d’un fichier texte ou un fichier .resx XML par [Resgen.exe (Resource File Generator)](~/docs/framework/tools/resgen-exe-resource-file-generator.md). Un <xref:System.Resources.ResourceReader> objet peut représenter un fichier .resources ou un fichier .resources incorporé dans un assembly.  
  
 Pour instancier un <xref:System.Resources.ResourceReader> de l’objet que les lectures à partir d’un fichier .resources, utilisez le <xref:System.Resources.ResourceReader> constructeur de classe avec un flux d’entrée ou une chaîne qui contient le nom du fichier .resources. L’exemple suivant illustre les deux approches. Le premier instancie un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources nommé `Resources1.resources` à l’aide de son nom de fichier. La seconde instancie un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources nommé `Resources2.resources` à l’aide d’un flux de données créé à partir du fichier.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 Pour créer un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources incorporé, instanciez un <xref:System.Reflection.Assembly> objet à partir de l’assembly dans lequel le fichier .resources est incorporé. Son <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> méthode retourne un <xref:System.IO.Stream> objet qui peut être passé à la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur. L’exemple suivant instancie un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources incorporé.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>L’énumération des ressources d’un objet ResourceReader  
 Pour énumérer les ressources dans un fichier .resources, vous appelez le <xref:System.Resources.ResourceReader.GetEnumerator%2A> (méthode), qui retourne un <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> objet. Vous appelez le `IDictionaryEnumerator.MoveNext` méthode pour passer d’une ressource à l’autre. La méthode retourne `false` lorsque toutes les ressources dans le fichier .resources ont été énumérés.  
  
> [!NOTE]
>  Bien que le <xref:System.Resources.ResourceReader> la classe implémente le <xref:System.Collections.IEnumerable> interface et le <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> (méthode), le <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> ne fournit pas de méthode le <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> implémentation. Au lieu de cela, le <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> méthode retourne un <xref:System.Collections.IDictionaryEnumerator> objet d’interface qui fournit l’accès à la paire nom/valeur de chaque ressource.  
  
 Vous pouvez récupérer les ressources individuelles dans la collection de deux manières :  
  
-   Vous pouvez effectuer une itération de chaque ressource dans le <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> collecte et utilisation <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> propriétés à récupérer le nom de la ressource et la valeur. Nous recommandons cette technique lorsque toutes les ressources sont du même type, ou si vous connaissez le type de données de chaque ressource.  
  
-   Vous pouvez récupérer le nom de chaque ressource lorsque vous itérez les <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> collection et appeler le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode pour récupérer les données de la ressource. Nous recommandons cette approche lorsque vous ne connaissez pas le type de données de chaque ressource ou si l’approche précédente lève des exceptions.  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>Récupérer des ressources à l’aide des propriétés de IDictionaryEnumerator  
 La première méthode d’énumérer les ressources dans un fichier .resources implique de récupérer directement la paire nom/valeur de chaque ressource. Après avoir appelé la `IDictionaryEnumerator.MoveNext` nom de méthode pour déplacer vers chaque ressource dans la collection, vous pouvez récupérer la ressource à partir de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propriété et les données de ressources à partir de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété.  
  
 L’exemple suivant montre comment récupérer le nom et la valeur de chaque ressource dans un fichier .resources à l’aide de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> et <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriétés. Pour exécuter l’exemple, créez le fichier texte suivant, nommé ApplicationResources.txt pour définir des ressources de type chaîne.  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 Vous pouvez ensuite convertir le fichier de ressources de texte dans un fichier binaire nommé ApplicationResources.resources à l’aide de la commande suivante :  
  
 **Resgen ApplicationResources.txt**  
  
 L’exemple suivant utilise ensuite la <xref:System.Resources.ResourceReader> classe énumérer chaque ressource dans le fichier .resources binaire et afficher son nom de la clé et sa valeur correspondante.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 La tentative d’extraction de données de ressources à partir de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété peut lever les exceptions suivantes :  
  
-   Un <xref:System.FormatException> si les données ne sont pas au format attendu.  
  
-   Un <xref:System.IO.FileNotFoundException> si l’assembly qui contient le type auquel appartiennent les données ne peut pas être trouvé.  
  
-   Un <xref:System.TypeLoadException> si le type auquel appartiennent les données ne peut pas être est introuvable.  
  
 En règle générale, ces exceptions sont levées si le fichier .resources a été modifié manuellement, si l’assembly dans lequel un type est défini n’a ne pas été inclus dans une application ou a été supprimé par inadvertance, ou si l’assembly est une ancienne version est antérieure à un type. Si une de ces exceptions est levée, vous pouvez récupérer des ressources en énumérant chaque ressource et en appelant le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode, comme indiqué dans la section suivant. Cette approche fournit des informations sur les données frappe qui le <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété a tenté de retourner.  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>Récupération de ressources par nom avec GetResourceData  
 La deuxième approche de l’énumération des ressources dans un fichier .resources implique également de parcourir les ressources dans le fichier en appelant le `IDictionaryEnumerator.MoveNext` (méthode). Pour chaque ressource, vous récupérez le nom de ressource à partir de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propriété, qui est ensuite transmise à la <xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29> méthode pour récupérer les données de la ressource. Cette valeur est retournée en tant que tableau d’octets dans le `resourceData` argument.  
  
 Cette approche est plus délicat à récupérer le nom de la ressource et la valeur à partir de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> et <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriétés, car elle retourne les octets réels qui forment la valeur de ressource. Toutefois, si la tentative d’extraction de la ressource lève une exception, le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode permet d’identifier la source de l’exception en fournissant des informations sur le type de données de la ressource. Pour plus d’informations sur la chaîne qui indique le type de données de la ressource, consultez <xref:System.Resources.ResourceReader.GetResourceData%2A>.  
  
 L’exemple suivant illustre comment utiliser cette approche pour récupérer des ressources et pour gérer les exceptions sont levées. Il crée par programmation un fichier .resources binaire qui contient quatre chaînes, une valeur booléenne, un entier, une seule bitmap et une personnalisée `DateTimeTZI` objet. Pour exécuter l’exemple, procédez comme suit :  
  
1.  Créer un assembly nommé Library.dll qui contient le `DateTimeTZI` structure. Voici le code source pour l’assembly.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     Compilez le code source en c# à l’aide de la commande suivante :  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     Ou bien, vous pouvez les compiler dans Visual Basic à l’aide de la commande suivante :  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  Compilez et exécutez le code source suivant, qui crée un fichier .resources nommé ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     Le fichier de code source est nommé CreateResources.cs. Vous pouvez compiler qu’il en c# à l’aide de la commande suivante :  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     Ou bien, vous pouvez les compiler dans Visual Basic à l’aide de la commande suivante :  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  Compilez et exécutez le code suivant pour énumérer les ressources dans le fichier ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     Après avoir modifié le code source (par exemple, en levant délibérément un <xref:System.FormatException> à la fin de la `try` bloc) ou de la modification du nom de l’assembly Library.dll afin qu’il n’est pas disponible lors de l’exécution, vous pouvez exécuter l’exemple pour voir comment les appels à <xref:System.Resources.ResourceReader.GetResourceData%2A> permettent de récupérer ou recréer des informations de ressource.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Resources.ResourceReader" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  À l’aide d’une instance de cet objet avec les données non fiables est un risque de sécurité. Utilisez cet objet uniquement avec des données approuvées. Pour plus d’informations, consultez [Validation des données](https://www.owasp.org/index.php/Data_Validation).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : System.IO.Stream -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The input stream for reading resources.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Resources.ResourceReader" /> class for the specified stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur instancie un <xref:System.Resources.ResourceReader> objet qui Récupère les ressources à partir d’un fichier .resources ou de .resources fichier qui est incorporé dans un assembly. Pour lire à partir d’un fichier .resources, instanciez un <xref:System.IO.Stream> de l’objet et transmettez-le à la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur. Pour lire à partir d’un fichier .resources incorporé, appelez le <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> méthode portant le nom de la casse du fichier .resources et pass retourné <xref:System.IO.Stream> de l’objet à le <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur.  
  
> [!IMPORTANT]
>  À l’aide d’une instance de cet objet avec les données non fiables est un risque de sécurité. Utilisez cet objet uniquement avec des données approuvées. Pour plus d’informations, consultez [Validation des données](https://www.owasp.org/index.php/Data_Validation).  
  
   
  
## Examples  
 L’exemple dans cette section utilise le fichier .txt suivant nommé `PatientForm.txt` pour définir les ressources utilisées par une application.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Vous pouvez compiler le fichier .txt en fichier .resources en émettant la commande suivante :  
  
 **Resgen PatientForm.txt**  
  
 L’exemple suivant suppose que le fichier de ressources est incorporé dans l’assembly qui contient le code exécutable de l’application. Il récupère un fichier de ressources nommé `PatientForm.resources` à partir des assemblys en cours d’exécution et affiche le nom et la valeur de chacune de ses ressources.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 Si l’exemple c# est nommé `Example.cs`, vous pouvez la compiler à l’aide de la commande suivante :  
  
 **csc Example.cs /res:PatientForm.resources**  
  
 Si l’exemple Visual Basic se nomme `Example.vb`, vous pouvez la compiler à l’aide de la commande suivante :  
  
 **vbc Example.vb /res:PatientForm.resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="stream" /> parameter is not readable.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="stream" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">An I/O error has occurred while accessing <paramref name="stream" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir des services de sérialisation. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : string -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The path and name of the resource file to read. <c>filename</c> is not case-sensitive.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Resources.ResourceReader" /> class for the specified named resource file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceReader.%23ctor%28System.String%29> constructeur instancie un <xref:System.Resources.ResourceReader> objet qui Récupère les ressources à partir d’un fichier .resources. Pour récupérer des ressources à partir d’un fichier .resources incorporé, utilisez la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur.  
  
> [!IMPORTANT]
>  À l’aide d’une instance de cet objet avec les données non fiables est un risque de sécurité. Utilisez cet objet uniquement avec des données approuvées. Pour plus d’informations, consultez [Validation des données](https://www.owasp.org/index.php/Data_Validation).  
  
   
  
## Examples  
 L’exemple dans cette section utilise le fichier .txt suivant nommé `PatientForm.txt` pour définir les ressources utilisées par une application.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Vous pouvez compiler ce fichier .txt en fichier .resources en émettant la commande suivante :  
  
 **Resgen PatientForm.txt**  
  
 L’exemple suivant énumère les ressources dans `PatientForm.resources` et affiche le nom et la valeur de chacun d’eux.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="fileName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error has occurred.</exception>
        <exception cref="T:System.BadImageFormatException">The resource file has an invalid format. For example, the length of the file may be zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="resourceReader.Close " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all operating system resources associated with this <see cref="T:System.Resources.ResourceReader" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A> peut être appelée en toute sécurité plusieurs fois.  
  
   
  
## Examples  
 L’exemple suivant déplace via des ressources d’un fichier et affiche toutes les paires clé/valeur qu’il trouve. Le code utilise ensuite la <xref:System.Resources.ResourceReader.Close%2A> méthode pour arrêter le <xref:System.Resources.ResourceReader> et libérer toutes les ressources utilisées par ce dernier.  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="resourceReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Resources.ResourceReader" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous avez terminé à l’aide de cette instance de <xref:System.Resources.ResourceReader>, appelez <xref:System.Resources.ResourceReader.Dispose%2A> pour libérer toutes les ressources utilisées par cette instance. Vous devez supprimer les références à ce <xref:System.Resources.ResourceReader> afin que le garbage collector puisse récupérer la mémoire de l’instance au lieu de garder actif pour la finalisation de l’instance.  
  
 <xref:System.Resources.ResourceReader.Dispose%2A> appelle la méthode Dispose (Boolean) privée, qui contient le code pour libérer les ressources managées et non managées. Pour plus d’informations, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator for this <see cref="T:System.Resources.ResourceReader" /> object.</summary>
        <returns>An enumerator for this <see cref="T:System.Resources.ResourceReader" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, vous énumérer les ressources en appelant le <xref:System.Resources.ResourceReader.GetEnumerator%2A> méthode et appeler à plusieurs reprises la <xref:System.Collections.IEnumerator.MoveNext%2A> méthode sur retourné <xref:System.Collections.IDictionaryEnumerator> jusqu'à ce que la méthode retourne l’objet `false`. Le nom de la ressource est disponible à partir de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propriété ; sa valeur à partir de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété. L’exemple illustre comment énumérer les ressources de cette façon.  
  
 L’implémentation de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété par le <xref:System.Resources.ResourceReader> classe peut lever les exceptions suivantes :  
  
-   <xref:System.IO.FileNotFoundException>  
  
     Impossible de trouver l’assembly qui contient le type auquel appartiennent les données.  
  
-   <xref:System.FormatException>  
  
     Les données ne sont pas au format attendu.  
  
-   <xref:System.TypeLoadException>  
  
     Impossible de trouver le type auquel appartiennent les données.  
  
 Vous pouvez gérer l’exception en appelant le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode pour récupérer des informations sur le type de données et le tableau d’octets affectée à la ressource nommée. Pour plus d’informations, consultez la section « Récupération des ressources par nom avec GetResourceData » dans le <xref:System.Resources.ResourceReader> rubrique de la classe.  
  
> [!IMPORTANT]
>  Le <xref:System.Resources.ResourceReader> classe inclut deux méthodes qui retournent des énumérateurs. Le <xref:System.Resources.ResourceReader.GetEnumerator%2A> méthode retourne un <xref:System.Collections.IDictionaryEnumerator> objet d’interface et est la méthode recommandée pour appeler lorsque l’énumération des ressources.  
  
   
  
## Examples  
 L’exemple dans cette section utilise le fichier .txt suivant nommé `PatientForm.txt` pour définir les ressources utilisées par une application.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Vous pouvez compiler le fichier .txt en fichier .resources en émettant la commande suivante :  
  
 **Resgen PatientForm.txt**  
  
 L’exemple suivant énumère les ressources dans `PatientForm.resources` et affiche le nom et la valeur de chacun d’eux.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The reader has been closed or disposed, and cannot be accessed.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberSignature Language="F#" Value="member this.GetResourceData : string *  *  -&gt; unit" Usage="resourceReader.GetResourceData (resourceName, resourceType, resourceData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
        <Parameter Name="resourceType" Type="System.String&amp;" RefType="out" />
        <Parameter Name="resourceData" Type="System.Byte[]&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resourceName">The name of a resource.</param>
        <param name="resourceType">When this method returns, contains a string that represents the type name of the retrieved resource. This parameter is passed uninitialized.</param>
        <param name="resourceData">When this method returns, contains a byte array that is the binary representation of the retrieved type. This parameter is passed uninitialized.</param>
        <summary>Retrieves the type name and data of a named resource from an open resource file or stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode récupère la valeur d’une ressource nommée en tant que tableau d’octets. Il est généralement utilisé lorsque le <xref:System.Collections.IDictionaryEnumerator.Value%2A> propriété lève une exception lorsqu’elle tente de récupérer la valeur d’une ressource.  
  
 `resourceType` est une chaîne qui représente le type de données de la ressource. Il peut être une des valeurs suivantes :  
  
-   La représentation sous forme de chaîne d’un `ResourceTypeCode` membre d’énumération qui indique le type de données de la ressource. `ResourceTypeCode` est une énumération privée qui est utilisée par .pour indiquer qu’un format binaire spécial est utilisé pour stocker un des types de données courants 19. Ceux-ci incluent les types de données primitifs .NET Framework (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Single>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>), ainsi que <xref:System.String>, <xref:System.DateTime>, et <xref:System.TimeSpan>, en outre, le `ResourceTypeCode` énumération inclut les valeurs indiquées dans le tableau suivant.  
  
    |Valeur de ResourceTypeCode|Description|  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|Les données sont un tableau d’octets. Cette type de données couramment des résultats de l’appel à la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType> (méthode).|  
    |`ResourceTypeCode.Null`|Les données sont une référence null. Cette type de données couramment des résultats de l’appel à la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType> méthode avec un objet dont la valeur est `null`.|  
    |`ResourceTypeCode.Stream`|Les données sont stockées dans un flux de données. Cette type de données couramment des résultats de l’appel à la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType> ou <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType> (méthode).|  
  
     En supposant que `resourceData` n’a pas été endommagé, il peut généralement être converti à partir d’un tableau d’octets à sa valeur d’origine en appelant un <xref:System.BitConverter> ou <xref:System.IO.BinaryReader> (méthode).  
  
-   Chaîne qui contient le nom qualifié complet du type dont les données sérialisées sont affectées à la `resourceData` argument (par exemple, `System.String`). En outre, pour les types qui ne font pas partie de la bibliothèque de classes .NET Framework, la chaîne inclut le nom, la version, la culture et la clé publique de l’assembly qui contient le type. Par exemple, la chaîne suivante indique que les données sérialisées représentent une instance de la `Person` tapez dans la `Extensions` espace de noms, qui se trouve dans la version 1.0 d’un assembly nommé utilitaire qui a aucune clé publique et aucune culture désignée.  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     En supposant que `resourceData` n’a pas été endommagée et que le type de source est disponible, `resourceData` peut être converti à partir d’un tableau d’octets à sa valeur d’origine en convertissant le tableau d’octets à un <xref:System.IO.Stream> objet et en passant le flux à la <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>(méthode).  
  
-   La chaîne utilisée pour décrire le type de données dans le <xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType> appel de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> does not exist.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="resourceName" /> has an invalid type.</exception>
        <exception cref="T:System.FormatException">The retrieved resource data is corrupt.</exception>
        <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Resources.ResourceReader" /> object is not initialized, probably because it is closed.</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator for this <see cref="T:System.Resources.ResourceReader" /> object.</summary>
        <returns>An enumerator for this <see cref="T:System.Resources.ResourceReader" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType> est une implémentation d’interface explicite. Il peut être utilisé uniquement lorsqu'un cast de l'instance de <xref:System.Resources.ResourceReader> est effectué en une interface <xref:System.Collections.IEnumerable>. L’approche recommandée pour l’énumération des ressources dans un fichier .resources consiste à appeler le <xref:System.Collections.IEnumerator.MoveNext%2A> méthode de la <xref:System.Collections.IDictionaryEnumerator> objet retourné par la <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The reader has already been closed and cannot be accessed.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>