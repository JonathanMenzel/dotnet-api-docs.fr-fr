<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f2814539bf76d998ae0f4c7bdb789f22102804ce" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52734771" /></Metadata><TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <TypeSignature Language="F#" Value="type ResourceReader = class&#xA;    interface IResourceReader&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Énumère les ressources dans un fichier de ressources binaire (.resources) en lisant les paires nom/valeur séquentielles de ressources.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 Le <xref:System.Resources.ResourceReader> classe fournit une implémentation standard de le <xref:System.Resources.IResourceReader> interface. Un <xref:System.Resources.ResourceReader> instance représente un fichier .resources ou un fichier .resources incorporé dans un assembly. Il est utilisé pour énumérer les ressources dans un fichier .resources et récupérer ses paires nom/valeur. Il diffère de la <xref:System.Resources.ResourceManager> (classe), qui est utilisée pour récupérer des ressources nommées spécifiés à partir d’un fichier .resources incorporé dans un assembly. Le <xref:System.Resources.ResourceManager> classe est utilisée pour récupérer des ressources dont les noms sont connus d’avance, tandis que la <xref:System.Resources.ResourceReader> classe est utile pour extraire des ressources dont nombre ou les noms exacts ne sont pas connus au moment de la compilation. Par exemple, une application peut utiliser un fichier de ressources pour stocker les informations de configuration qui sont organisées en sections et des éléments dans une section, où le nombre de sections ou des éléments dans une section n’est pas connu d’avance. Ressources peuvent ensuite être nommés de manière générique (tel que `Section1`, `Section1Item1`, `Section1Item2`, et ainsi de suite) et récupérées à l’aide un <xref:System.Resources.ResourceReader> objet.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.  
  
 Pour plus d’informations sur l’utilisation de la <xref:System.Resources.ResourceReader> de classe, consultez les sections suivantes :  
  
-   [Instanciation d’un objet ResourceReader](#instantiate)  
  
-   [L’énumération des ressources d’un objet ResourceReader](#enumerate)  
  
    -   [Récupérer des ressources à l’aide des propriétés de IDictionaryEnumerator](#idictionaryenumerator)  
  
    -   [Récupération de ressources par nom avec GetResourceData](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>Instanciation d’un objet ResourceReader  
 Un fichier .resources est un fichier binaire qui a été compilé à partir d’un fichier texte ou un fichier .resx XML par [Resgen.exe (Resource File Generator)](~/docs/framework/tools/resgen-exe-resource-file-generator.md). Un <xref:System.Resources.ResourceReader> objet peut représenter un fichier .resources ou un fichier .resources incorporé dans un assembly.  
  
 Pour instancier un <xref:System.Resources.ResourceReader> de l’objet que les lectures à partir d’un fichier .resources, utilisez le <xref:System.Resources.ResourceReader> constructeur de classe avec un flux d’entrée ou une chaîne qui contient le nom du fichier .resources. L’exemple suivant illustre les deux approches. Le premier instancie un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources nommé `Resources1.resources` à l’aide de son nom de fichier. La seconde instancie un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources nommé `Resources2.resources` à l’aide d’un flux de données créé à partir du fichier.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 Pour créer un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources incorporé, instanciez un <xref:System.Reflection.Assembly> objet à partir de l’assembly dans lequel le fichier .resources est incorporé. Son <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> méthode retourne un <xref:System.IO.Stream> objet qui peut être passé à la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur. L’exemple suivant instancie un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources incorporé.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>L’énumération des ressources d’un objet ResourceReader  
 Pour énumérer les ressources dans un fichier .resources, vous appelez le <xref:System.Resources.ResourceReader.GetEnumerator%2A> (méthode), qui retourne un <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> objet. Vous appelez le `IDictionaryEnumerator.MoveNext` méthode pour passer d’une ressource à l’autre. La méthode retourne `false` lorsque toutes les ressources dans le fichier .resources ont été énumérés.  
  
> [!NOTE]
>  Bien que le <xref:System.Resources.ResourceReader> la classe implémente le <xref:System.Collections.IEnumerable> interface et le <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> (méthode), le <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> ne fournit pas de méthode le <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> implémentation. Au lieu de cela, le <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> méthode retourne un <xref:System.Collections.IDictionaryEnumerator> objet d’interface qui fournit l’accès à la paire nom/valeur de chaque ressource.  
  
 Vous pouvez récupérer les ressources individuelles dans la collection de deux manières :  
  
-   Vous pouvez effectuer une itération de chaque ressource dans le <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> collecte et utilisation <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> propriétés à récupérer le nom de la ressource et la valeur. Nous recommandons cette technique lorsque toutes les ressources sont du même type, ou si vous connaissez le type de données de chaque ressource.  
  
-   Vous pouvez récupérer le nom de chaque ressource lorsque vous itérez les <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> collection et appeler le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode pour récupérer les données de la ressource. Nous recommandons cette approche lorsque vous ne connaissez pas le type de données de chaque ressource ou si l’approche précédente lève des exceptions.  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>Récupérer des ressources à l’aide des propriétés de IDictionaryEnumerator  
 La première méthode d’énumérer les ressources dans un fichier .resources implique de récupérer directement la paire nom/valeur de chaque ressource. Après avoir appelé la `IDictionaryEnumerator.MoveNext` nom de méthode pour déplacer vers chaque ressource dans la collection, vous pouvez récupérer la ressource à partir de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propriété et les données de ressources à partir de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété.  
  
 L’exemple suivant montre comment récupérer le nom et la valeur de chaque ressource dans un fichier .resources à l’aide de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> et <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriétés. Pour exécuter l’exemple, créez le fichier texte suivant, nommé ApplicationResources.txt pour définir des ressources de type chaîne.  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 Vous pouvez ensuite convertir le fichier de ressources de texte dans un fichier binaire nommé ApplicationResources.resources à l’aide de la commande suivante :  
  
 **Resgen ApplicationResources.txt**  
  
 L’exemple suivant utilise ensuite la <xref:System.Resources.ResourceReader> classe énumérer chaque ressource dans le fichier .resources binaire et afficher son nom de la clé et sa valeur correspondante.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 La tentative d’extraction de données de ressources à partir de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété peut lever les exceptions suivantes :  
  
-   Un <xref:System.FormatException> si les données ne sont pas au format attendu.  
  
-   Un <xref:System.IO.FileNotFoundException> si l’assembly qui contient le type auquel appartiennent les données ne peut pas être trouvé.  
  
-   Un <xref:System.TypeLoadException> si le type auquel appartiennent les données ne peut pas être est introuvable.  
  
 En règle générale, ces exceptions sont levées si le fichier .resources a été modifié manuellement, si l’assembly dans lequel un type est défini n’a ne pas été inclus dans une application ou a été supprimé par inadvertance, ou si l’assembly est une ancienne version est antérieure à un type. Si une de ces exceptions est levée, vous pouvez récupérer des ressources en énumérant chaque ressource et en appelant le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode, comme indiqué dans la section suivant. Cette approche fournit des informations sur les données frappe qui le <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété a tenté de retourner.  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>Récupération de ressources par nom avec GetResourceData  
 La deuxième approche de l’énumération des ressources dans un fichier .resources implique également de parcourir les ressources dans le fichier en appelant le `IDictionaryEnumerator.MoveNext` (méthode). Pour chaque ressource, vous récupérez le nom de ressource à partir de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propriété, qui est ensuite transmise à la <xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29> méthode pour récupérer les données de la ressource. Cette valeur est retournée en tant que tableau d’octets dans le `resourceData` argument.  
  
 Cette approche est plus délicat à récupérer le nom de la ressource et la valeur à partir de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> et <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriétés, car elle retourne les octets réels qui forment la valeur de ressource. Toutefois, si la tentative d’extraction de la ressource lève une exception, le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode permet d’identifier la source de l’exception en fournissant des informations sur le type de données de la ressource. Pour plus d’informations sur la chaîne qui indique le type de données de la ressource, consultez <xref:System.Resources.ResourceReader.GetResourceData%2A>.  
  
 L’exemple suivant illustre comment utiliser cette approche pour récupérer des ressources et pour gérer les exceptions sont levées. Il crée par programmation un fichier .resources binaire qui contient quatre chaînes, une valeur booléenne, un entier, une seule bitmap et une personnalisée `DateTimeTZI` objet. Pour exécuter l’exemple, procédez comme suit :  
  
1.  Créer un assembly nommé Library.dll qui contient le `DateTimeTZI` structure. Voici le code source pour l’assembly.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     Compilez le code source en c# à l’aide de la commande suivante :  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     Ou bien, vous pouvez les compiler dans Visual Basic à l’aide de la commande suivante :  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  Compilez et exécutez le code source suivant, qui crée un fichier .resources nommé ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     Le fichier de code source est nommé CreateResources.cs. Vous pouvez compiler qu’il en c# à l’aide de la commande suivante :  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     Ou bien, vous pouvez les compiler dans Visual Basic à l’aide de la commande suivante :  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  Compilez et exécutez le code suivant pour énumérer les ressources dans le fichier ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     Après avoir modifié le code source (par exemple, en levant délibérément un <xref:System.FormatException> à la fin de la `try` bloc) ou de la modification du nom de l’assembly Library.dll afin qu’il n’est pas disponible lors de l’exécution, vous pouvez exécuter l’exemple pour voir comment les appels à <xref:System.Resources.ResourceReader.GetResourceData%2A> permettent de récupérer ou recréer des informations de ressource.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)].
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : System.IO.Stream -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flux d'entrée pour lire des ressources.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceReader" /> pour le flux spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur instancie un <xref:System.Resources.ResourceReader> objet qui Récupère les ressources à partir d’un fichier .resources ou de .resources fichier qui est incorporé dans un assembly. Pour lire à partir d’un fichier .resources, instanciez un <xref:System.IO.Stream> de l’objet et transmettez-le à la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur. Pour lire à partir d’un fichier .resources incorporé, appelez le <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> méthode portant le nom de la casse du fichier .resources et pass retourné <xref:System.IO.Stream> de l’objet à le <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur.  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
## Examples  
 L’exemple dans cette section utilise le fichier .txt suivant nommé `PatientForm.txt` pour définir les ressources utilisées par une application.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Vous pouvez compiler le fichier .txt en fichier .resources en émettant la commande suivante :  
  
 **Resgen PatientForm.txt**  
  
 L’exemple suivant suppose que le fichier de ressources est incorporé dans l’assembly qui contient le code exécutable de l’application. Il récupère un fichier de ressources nommé `PatientForm.resources` à partir des assemblys en cours d’exécution et affiche le nom et la valeur de chacune de ses ressources.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 Si l’exemple c# est nommé `Example.cs`, vous pouvez la compiler à l’aide de la commande suivante :  
  
 **csc Example.cs /res:PatientForm.resources**  
  
 Si l’exemple Visual Basic se nomme `Example.vb`, vous pouvez la compiler à l’aide de la commande suivante :  
  
 **vbc Example.vb /res:PatientForm.resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="stream" /> n'est pas accessible en lecture.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="stream" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'accès à <paramref name="stream" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir des services de sérialisation. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : string -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Chemin d’accès et nom du fichier de ressources à lire. <c>filename</c> ne respecte pas la casse.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceReader" /> pour le fichier de ressources nommé spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceReader.%23ctor%28System.String%29> constructeur instancie un <xref:System.Resources.ResourceReader> objet qui Récupère les ressources à partir d’un fichier .resources. Pour récupérer des ressources à partir d’un fichier .resources incorporé, utilisez la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur.  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]

## Examples  
 L’exemple dans cette section utilise le fichier .txt suivant nommé `PatientForm.txt` pour définir les ressources utilisées par une application.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Vous pouvez compiler ce fichier .txt en fichier .resources en émettant la commande suivante :  
  
 **Resgen PatientForm.txt**  
  
 L’exemple suivant énumère les ressources dans `PatientForm.resources` et affiche le nom et la valeur de chacun d’eux.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="fileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite.</exception>
        <exception cref="T:System.BadImageFormatException">Le format du fichier de ressources n'est pas valide. Par exemple, la longueur du fichier peut être égale à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="resourceReader.Close " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources du système d'exploitation associées à cet objet <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A> peut être appelée en toute sécurité plusieurs fois.  
  
   
  
## Examples  
 L’exemple suivant déplace via des ressources d’un fichier et affiche toutes les paires clé/valeur qu’il trouve. Le code utilise ensuite la <xref:System.Resources.ResourceReader.Close%2A> méthode pour arrêter le <xref:System.Resources.ResourceReader> et libérer toutes les ressources utilisées par ce dernier.  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="resourceReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous avez terminé à l’aide de cette instance de <xref:System.Resources.ResourceReader>, appelez <xref:System.Resources.ResourceReader.Dispose%2A> pour libérer toutes les ressources utilisées par cette instance. Vous devez supprimer les références à ce <xref:System.Resources.ResourceReader> afin que le garbage collector puisse récupérer la mémoire de l’instance au lieu de garder actif pour la finalisation de l’instance.  
  
 <xref:System.Resources.ResourceReader.Dispose%2A> appelle la méthode Dispose (Boolean) privée, qui contient le code pour libérer les ressources managées et non managées. Pour plus d’informations, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur pour cet objet <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Énumérateur pour cet objet <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, vous énumérer les ressources en appelant le <xref:System.Resources.ResourceReader.GetEnumerator%2A> méthode et appeler à plusieurs reprises la <xref:System.Collections.IEnumerator.MoveNext%2A> méthode sur retourné <xref:System.Collections.IDictionaryEnumerator> jusqu'à ce que la méthode retourne l’objet `false`. Le nom de la ressource est disponible à partir de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propriété ; sa valeur à partir de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété. L’exemple illustre comment énumérer les ressources de cette façon.  
  
 L’implémentation de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété par le <xref:System.Resources.ResourceReader> classe peut lever les exceptions suivantes :  
  
-   <xref:System.IO.FileNotFoundException>  
  
     Impossible de trouver l’assembly qui contient le type auquel appartiennent les données.  
  
-   <xref:System.FormatException>  
  
     Les données ne sont pas au format attendu.  
  
-   <xref:System.TypeLoadException>  
  
     Impossible de trouver le type auquel appartiennent les données.  
  
 Vous pouvez gérer l’exception en appelant le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode pour récupérer des informations sur le type de données et le tableau d’octets affectée à la ressource nommée. Pour plus d’informations, consultez la section « Récupération des ressources par nom avec GetResourceData » dans le <xref:System.Resources.ResourceReader> rubrique de la classe.  
  
> [!IMPORTANT]
>  Le <xref:System.Resources.ResourceReader> classe inclut deux méthodes qui retournent des énumérateurs. Le <xref:System.Resources.ResourceReader.GetEnumerator%2A> méthode retourne un <xref:System.Collections.IDictionaryEnumerator> objet d’interface et est la méthode recommandée pour appeler lorsque l’énumération des ressources.  
  
   
  
## Examples  
 L’exemple dans cette section utilise le fichier .txt suivant nommé `PatientForm.txt` pour définir les ressources utilisées par une application.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Vous pouvez compiler le fichier .txt en fichier .resources en émettant la commande suivante :  
  
 **Resgen PatientForm.txt**  
  
 L’exemple suivant énumère les ressources dans `PatientForm.resources` et affiche le nom et la valeur de chacun d’eux.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le lecteur a été fermé ou supprimé, et il n'est plus possible d'y accéder.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberSignature Language="F#" Value="member this.GetResourceData : string *  *  -&gt; unit" Usage="resourceReader.GetResourceData (resourceName, resourceType, resourceData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
        <Parameter Name="resourceType" Type="System.String" RefType="out" />
        <Parameter Name="resourceData" Type="System.Byte[]" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resourceName">Nom d'une ressource.</param>
        <param name="resourceType">Quand cette méthode retourne une valeur, contient une chaîne qui représente le nom de type de la ressource récupérée. Ce paramètre est passé sans être initialisé.</param>
        <param name="resourceData">Lorsque cette méthode est retournée, contient un tableau d'octets correspondant à la représentation binaire du type récupéré. Ce paramètre est passé sans être initialisé.</param>
        <summary>Récupère le nom du type et les données d'une ressource nommée à partir d'un fichier de ressources ouvert ou d'un flux.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode récupère la valeur d’une ressource nommée en tant que tableau d’octets. Il est généralement utilisé lorsque le <xref:System.Collections.IDictionaryEnumerator.Value%2A> propriété lève une exception lorsqu’elle tente de récupérer la valeur d’une ressource.  
  
 `resourceType` est une chaîne qui représente le type de données de la ressource. Il peut être une des valeurs suivantes :  
  
-   La représentation sous forme de chaîne d’un `ResourceTypeCode` membre d’énumération qui indique le type de données de la ressource. `ResourceTypeCode` est une énumération privée qui est utilisée par .pour indiquer qu’un format binaire spécial est utilisé pour stocker un des types de données courants 19. Ceux-ci incluent les types de données primitifs .NET Framework (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Single>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>), ainsi que <xref:System.String>, <xref:System.DateTime>, et <xref:System.TimeSpan>, en outre, le `ResourceTypeCode` énumération inclut les valeurs indiquées dans le tableau suivant.  
  
    |Valeur de ResourceTypeCode|Description |  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|Les données sont un tableau d’octets. Cette type de données couramment des résultats de l’appel à la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType> (méthode).|  
    |`ResourceTypeCode.Null`|Les données sont une référence null. Cette type de données couramment des résultats de l’appel à la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType> méthode avec un objet dont la valeur est `null`.|  
    |`ResourceTypeCode.Stream`|Les données sont stockées dans un flux de données. Cette type de données couramment des résultats de l’appel à la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType> ou <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType> (méthode).|  
  
     En supposant que `resourceData` n’a pas été endommagé, il peut généralement être converti à partir d’un tableau d’octets à sa valeur d’origine en appelant un <xref:System.BitConverter> ou <xref:System.IO.BinaryReader> (méthode).  
  
-   Chaîne qui contient le nom qualifié complet du type dont les données sérialisées sont affectées à la `resourceData` argument (par exemple, `System.String`). En outre, pour les types qui ne font pas partie de la bibliothèque de classes .NET Framework, la chaîne inclut le nom, la version, la culture et la clé publique de l’assembly qui contient le type. Par exemple, la chaîne suivante indique que les données sérialisées représentent une instance de la `Person` tapez dans la `Extensions` espace de noms, qui se trouve dans la version 1.0 d’un assembly nommé utilitaire qui a aucune clé publique et aucune culture désignée.  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     En supposant que `resourceData` n’a pas été endommagée et que le type de source est disponible, `resourceData` peut être converti à partir d’un tableau d’octets à sa valeur d’origine en convertissant le tableau d’octets à un <xref:System.IO.Stream> objet et en passant le flux à la <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>(méthode).  
  
-   La chaîne utilisée pour décrire le type de données dans le <xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType> appel de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceName" /> n’existe pas.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="resourceName" /> a un type non valide.</exception>
        <exception cref="T:System.FormatException">Les données de ressources récupérées sont endommagées.</exception>
        <exception cref="T:System.InvalidOperationException">L'objet <see cref="T:System.Resources.ResourceReader" /> actuel n'est pas initialisé, probablement parce qu'il est fermé.</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur pour cet objet <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Énumérateur pour cet objet <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType> est une implémentation d’interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Resources.ResourceReader> est castée en interface <xref:System.Collections.IEnumerable>. L’approche recommandée pour l’énumération des ressources dans un fichier .resources consiste à appeler le <xref:System.Collections.IEnumerator.MoveNext%2A> méthode de la <xref:System.Collections.IDictionaryEnumerator> objet retourné par la <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le lecteur a déjà été fermé et il n'est plus possible d'y accéder.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par le <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Permet d’appeler Dispose les ressources utilisées par le <xref:System.Resources.ResourceReader> d’être réaffectées à d’autres fins. Pour plus d’informations sur la méthode Dispose, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).

## Examples  
L’exemple de code suivant parcourt les ressources d’un fichier et imprime toutes les paires clé/valeur qu’il trouve. Le code utilise ensuite la méthode de theIDisposable.Dispose pour arrêter le <xref:System.Resources.ResourceReader> et libérer toutes les ressources utilisées par ce dernier.

```vb
Imports System
Imports System.Resources
Imports System.Collections

Public Class ReadResources

    Public Shared Sub Main(args() As String)
        ' Create a resource reader for items.resources 
        ' and get an enumerator to iterate through the file. 
        Dim reader As IResourceReader = New ResourceReader("items.resources")
        Dim en As IDictionaryEnumerator = reader.GetEnumerator()

        ' Iterate through the file, printing the key and value pairs. 
        While en.MoveNext()
            Console.WriteLine()
            Console.WriteLine("Name: {0}", en.Key)
            Console.WriteLine("Value: {0}", en.Value)
        End While 

        ' Clean up all resources associated with the reader. 
        ' Calling Dispose is equivalent to calling Close.
        reader.Dispose()
    End Sub 

End Class
```

```csharp
using System;
using System.Resources;
using System.Collections;

public class ReadResources 
{
    public static void Main(string[] args) 
    {
        // Create a resource reader for items.resources 
        // and get an enumerator to iterate through the file.
        IResourceReader reader = new ResourceReader("items.resources");
        IDictionaryEnumerator en = reader.GetEnumerator();

        // Iterate through the file, printing the key/value pairs. 
        while (en.MoveNext()) 
        {
            Console.WriteLine();
            Console.WriteLine("Name: {0}", en.Key);
            Console.WriteLine("Value: {0}", en.Value);
        }

        // Clean up all resources associated with the reader. 
        // Calling Dispose is equivalent to calling Close.
        reader.Dispose();
    }
}
```

```cpp
using namespace System;
using namespace System::Resources;
using namespace System::Collections;
int main()
{
   array<String^>^args = Environment::GetCommandLineArgs();

   // Create a resource reader for items.resources 
   // and get an enumerator to iterate through the file.
   IResourceReader^ reader = gcnew ResourceReader( "items.resources" );
   IDictionaryEnumerator^ en = reader->GetEnumerator();

   // Iterate through the file, printing the key/value pairs. 
   while ( en->MoveNext() )
   {
      Console::WriteLine();
      Console::WriteLine( "Name: {0}", en->Key );
      Console::WriteLine( "Value: {0}", en->Value );
   }

   // Clean up all resources associated with the reader. 
   // Calling the destructor is equivalent to calling Close.
   reader->~IResourceReader();
}
```

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>