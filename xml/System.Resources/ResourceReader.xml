<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="682738b4136d074223cbe025a9380b3cca9bc1d0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480253" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Énumère les ressources dans un fichier de ressources binaire (.resources) en lisant les paires nom/valeur séquentielles de ressources.  
  
 **Note de sécurité** : L’appel de méthodes dans cette classe avec des données non approuvées constitue un risque pour la sécurité. Appelez les méthodes dans la classe uniquement avec des données approuvées. Pour plus d’informations, consultez [Risques de sécurité liés aux données non approuvées](https://docs.com/rick-anderson-1/8710/untrusted-data-security-risks).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceReader> classe fournit une implémentation standard de le <xref:System.Resources.IResourceReader> interface. A <xref:System.Resources.ResourceReader> instance représente un fichier .resources ou un fichier .resources incorporé dans un assembly. Il est utilisé pour énumérer les ressources dans un fichier .resources et récupérer ses paires nom/valeur. Il diffère de la <xref:System.Resources.ResourceManager> (classe), qui est utilisée pour récupérer des ressources nommés spécifiés à partir d’un fichier .resources incorporé dans un assembly. Le <xref:System.Resources.ResourceManager> classe est utilisée pour récupérer les ressources dont les noms sont connus d’avance, alors que la <xref:System.Resources.ResourceReader> classe est utile pour extraire des ressources dont nombre ou les noms exacts ne sont pas connus au moment de la compilation. Par exemple, une application peut utiliser un fichier de ressources pour stocker les informations de configuration qui sont organisées en sections et les éléments d’une section, où le nombre de sections ou d’éléments dans une section n’est pas connu à l’avance. Ressources peuvent ensuite être nommés de manière générique (tel que `Section1`, `Section1Item1`, `Section1Item2`, et ainsi de suite) et récupérés à l’aide un <xref:System.Resources.ResourceReader> objet.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez la supprimer directement ou indirectement. Pour supprimer le type directement, vous devez appeler sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour la supprimer indirectement, utiliser une construction de langage telles que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <xref:System.IDisposable> rubrique de l’interface.  
  
 Pour plus d’informations sur l’utilisation de la <xref:System.Resources.ResourceReader> de classe, consultez les sections suivantes :  
  
-   [Instanciation d’un objet ResourceReader](#instantiate)  
  
-   [L’énumération des ressources d’un objet ResourceReader](#enumerate)  
  
    -   [La récupération des ressources à l’aide des propriétés de IDictionaryEnumerator](#idictionaryenumerator)  
  
    -   [La récupération des ressources par nom avec GetResourceData](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>Instanciation d’un objet ResourceReader  
 Un fichier .resources est un fichier binaire qui a été compilé à partir d’un fichier texte ou d’un fichier .resx XML par [Resgen.exe (Resource File Generator)](~/docs/framework/tools/resgen-exe-resource-file-generator.md). A <xref:System.Resources.ResourceReader> objet peut représenter un fichier .resources ou un fichier .resources incorporé dans un assembly.  
  
 Pour instancier un <xref:System.Resources.ResourceReader> de l’objet que lit à partir d’un fichier .resources, utilisez le <xref:System.Resources.ResourceReader> constructeur de classe avec un flux d’entrée ou une chaîne qui contient le nom du fichier .resources. L’exemple suivant illustre ces deux approches. Le premier instancie un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources nommé `Resources1.resources` à l’aide de son nom de fichier. La seconde instancie un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources nommé `Resources2.resources` à l’aide d’un flux de données créé à partir du fichier.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 Pour créer un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources incorporé, instanciez un <xref:System.Reflection.Assembly> objet à partir de l’assembly dans lequel le fichier .resources est incorporé. Son <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> méthode retourne un <xref:System.IO.Stream> objet qui peut être passé à la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur. L’exemple suivant instancie un <xref:System.Resources.ResourceReader> objet qui représente un fichier .resources incorporé.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>L’énumération des ressources d’un objet ResourceReader  
 Pour énumérer les ressources dans un fichier .resources, vous appelez le <xref:System.Resources.ResourceReader.GetEnumerator%2A> (méthode), qui retourne un <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> objet. Vous appelez le `IDictionaryEnumerator.MoveNext` méthode pour déplacer d’une ressource à l’autre. La méthode retourne `false` lorsque toutes les ressources dans le fichier .resources ont été énumérés.  
  
> [!NOTE]
>  Bien que le <xref:System.Resources.ResourceReader> la classe implémente le <xref:System.Collections.IEnumerable> interface et la <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> (méthode), la <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> ne fournit pas de méthode le <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> implémentation. Au lieu de cela, le <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> méthode retourne un <xref:System.Collections.IDictionaryEnumerator> objet d’interface qui fournit l’accès à une paire nom/valeur de chaque ressource.  
  
 Vous pouvez récupérer les ressources individuelles dans la collection de deux manières :  
  
-   Vous pouvez itérer au sein de chaque ressource dans le <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> collecte et utilisation <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> propriétés à récupérer le nom de la ressource et la valeur. Nous recommandons cette technique lorsque toutes les ressources sont du même type, ou si vous connaissez le type de données de chaque ressource.  
  
-   Vous pouvez récupérer le nom de chaque ressource lorsque vous itérez la <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> collection et appelez le <xref:System.Resources.ResourceReader.GetResourceData%2A> pour récupérer les données de la ressource. Nous recommandons cette approche lorsque vous ne connaissez pas le type de données de chaque ressource, ou si l’approche précédente lève des exceptions.  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>La récupération des ressources à l’aide des propriétés de IDictionaryEnumerator  
 La première méthode d’énumération des ressources dans un fichier .resources implique de récupérer directement une paire nom/valeur de chaque ressource. Après avoir appelé la `IDictionaryEnumerator.MoveNext` nom de méthode pour déplacer vers chaque ressource dans la collection, vous pouvez récupérer la ressource à partir de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propriété et les données de ressources à partir de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété.  
  
 L’exemple suivant montre comment récupérer le nom et la valeur de chaque ressource dans un fichier .resources à l’aide de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> et <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriétés. Pour exécuter l’exemple, créez le fichier texte suivant nommé ApplicationResources.txt pour définir des ressources de chaîne.  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 Vous pouvez ensuite convertir le fichier de ressources du texte dans un fichier binaire nommé ApplicationResources.resources à l’aide de la commande suivante :  
  
 **resgen ApplicationResources.txt**  
  
 L’exemple suivant utilise ensuite la <xref:System.Resources.ResourceReader> classe énumérer chaque ressource dans le fichier .resources binaire et afficher son nom de la clé et la valeur correspondante.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 La tentative de récupérer des données de ressources de le <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété peut lever les exceptions suivantes :  
  
-   A <xref:System.FormatException> si les données ne sont pas au format attendu.  
  
-   A <xref:System.IO.FileNotFoundException> si l’assembly qui contient le type auquel appartient les données est introuvable.  
  
-   A <xref:System.TypeLoadException> si le type auquel appartient les données ne peut pas être ne peut pas être trouvé.  
  
 En règle générale, ces exceptions sont levées si le fichier .resources a été modifié manuellement, si l’assembly dans lequel un type est défini n’a ne pas été inclus dans une application ou a été supprimé par inadvertance, ou si l’assembly est une ancienne version qui est antérieure à un type. Si une de ces exceptions est levée, vous pouvez récupérer des ressources par l’énumération de chaque ressource et en appelant le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode, comme l’indique la section suivante. Cette approche fournit certaines informations sur les données de type qui le <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété a tenté de retourner.  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>La récupération des ressources par nom avec GetResourceData  
 La deuxième approche de l’énumération des ressources dans un fichier .resources implique également de parcourir les ressources dans le fichier en appelant le `IDictionaryEnumerator.MoveNext` (méthode). Pour chaque ressource, vous récupérez le nom de la ressource à partir de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propriété, qui est ensuite transmise à la <xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29> méthode pour récupérer les données de la ressource. Cela est retourné comme un tableau d’octets dans le `resourceData` argument.  
  
 Cette approche est plus difficile que la récupération du nom de la ressource et la valeur de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> et <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriétés, car elle retourne les octets réels qui forment la valeur de ressource. Toutefois, si la tentative de récupération de la ressource lève une exception, le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode peut aider à identifier la source de l’exception, vous devez fournir des informations sur le type de données de la ressource. Pour plus d’informations sur la chaîne qui indique le type de données de la ressource, consultez <xref:System.Resources.ResourceReader.GetResourceData%2A>.  
  
 L’exemple suivant illustre comment utiliser cette approche pour récupérer des ressources et pour gérer les exceptions sont levées. Il crée par programmation un fichier .resources binaire qui contient quatre chaînes, une valeur booléenne, un entier, une image bitmap et un personnalisée `DateTimeTZI` objet. Pour exécuter l’exemple, procédez comme suit :  
  
1.  Créer un assembly nommé Library.dll qui contient le `DateTimeTZI` structure. Voici le code source pour l’assembly.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     Compiler du code source c# à l’aide de la commande suivante :  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     Ou bien, vous pouvez les compiler dans Visual Basic à l’aide de la commande suivante :  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  Compilez et exécutez le code source suivant, qui crée un fichier .resources nommé ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     Le fichier de code source est nommé CreateResources.cs. Vous pouvez le compiler en c# à l’aide de la commande suivante :  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     Ou bien, vous pouvez les compiler dans Visual Basic à l’aide de la commande suivante :  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  Compilez et exécutez le code suivant pour énumérer les ressources dans le fichier ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     Après avoir modifié le code source (par exemple, en levant délibérément une <xref:System.FormatException> à la fin de la `try` bloc) ou renommez l’assembly Library.dll afin qu’il n’est pas disponible lors de l’exécution, vous pouvez exécuter l’exemple pour comprendre comment les appels à <xref:System.Resources.ResourceReader.GetResourceData%2A> permettent de récupérer ou de recréer des informations sur la ressource.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  À l’aide d’une instance de cet objet de données non fiables est un risque de sécurité. Utilisez cet objet uniquement avec des données approuvées. Pour plus d’informations, consultez [Validation des données](https://www.owasp.org/index.php/Data_Validation).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flux d'entrée pour lire des ressources.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceReader" /> pour le flux spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur instancie un <xref:System.Resources.ResourceReader> objet qui Récupère les ressources à partir d’un fichier .resources ou .resources à partir de fichier qui est incorporé dans un assembly. Pour lire un fichier .resources, instanciez un <xref:System.IO.Stream> de l’objet et le passer à la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur. Pour lire à partir d’un fichier .resources incorporé, appelez le <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> méthode portant le nom qui respecte la casse du fichier .resources et passez retourné <xref:System.IO.Stream> de l’objet à le <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur.  
  
> [!IMPORTANT]
>  À l’aide d’une instance de cet objet de données non fiables est un risque de sécurité. Utilisez cet objet uniquement avec des données approuvées. Pour plus d’informations, consultez [Validation des données](https://www.owasp.org/index.php/Data_Validation).  
  
   
  
## Examples  
 L’exemple de cette section utilise le fichier .txt suivant nommé `PatientForm.txt` pour définir les ressources utilisées par une application.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Vous pouvez compiler le fichier .txt dans un fichier .resources en émettant la commande suivante :  
  
 **resgen PatientForm.txt**  
  
 L’exemple suivant suppose que le fichier de ressources est incorporé dans l’assembly qui contienne du code exécutable de l’application. Il récupère un fichier de ressources nommé `PatientForm.resources` à partir des assemblys en cours d’exécution et affiche le nom et la valeur de chacune de ses ressources.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 Si l’exemple c# est nommé `Example.cs`, vous pouvez la compiler à l’aide de la commande suivante :  
  
 **csc Example.cs /res:PatientForm.resources**  
  
 Si l’exemple Visual Basic nommé `Example.vb`, vous pouvez la compiler à l’aide de la commande suivante :  
  
 **vbc Example.vb /res:PatientForm.resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="stream" /> n'est pas accessible en lecture.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="stream" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'accès à <paramref name="stream" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir des services de sérialisation. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Chemin d’accès et nom du fichier de ressources à lire. <c>filename</c> ne respecte pas la casse.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceReader" /> pour le fichier de ressources nommé spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceReader.%23ctor%28System.String%29> constructeur instancie un <xref:System.Resources.ResourceReader> objet qui Récupère les ressources à partir d’un fichier .resources. Pour récupérer des ressources à partir d’un fichier .resources incorporé, utilisez la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructeur.  
  
> [!IMPORTANT]
>  À l’aide d’une instance de cet objet de données non fiables est un risque de sécurité. Utilisez cet objet uniquement avec des données approuvées. Pour plus d’informations, consultez [Validation des données](https://www.owasp.org/index.php/Data_Validation).  
  
   
  
## Examples  
 L’exemple de cette section utilise le fichier .txt suivant nommé `PatientForm.txt` pour définir les ressources utilisées par une application.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Vous pouvez compiler ce fichier .txt en fichier .resources en émettant la commande suivante :  
  
 **resgen PatientForm.txt**  
  
 L’exemple suivant énumère les ressources dans `PatientForm.resources` et affiche le nom et la valeur de chaque.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="fileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite.</exception>
        <exception cref="T:System.BadImageFormatException">Le format du fichier de ressources n'est pas valide. Par exemple, la longueur du fichier peut être égale à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources du système d'exploitation associées à cet objet <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A> peut être appelée en toute sécurité plusieurs fois.  
  
   
  
## Examples  
 L’exemple suivant déplace via des ressources d’un fichier et affiche toutes les paires clé/valeur qu’il trouve. Le code utilise ensuite la <xref:System.Resources.ResourceReader.Close%2A> méthode pour arrêter le <xref:System.Resources.ResourceReader> et libérer toutes les ressources utilisées par ce dernier.  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous avez terminé à l’aide de cette instance de <xref:System.Resources.ResourceReader>, appelez <xref:System.Resources.ResourceReader.Dispose%2A> pour libérer toutes les ressources utilisées par cette instance. Vous devez supprimer les références à ce <xref:System.Resources.ResourceReader> afin que le garbage collector puisse récupérer la mémoire de l’instance au lieu de conserver actif pour la finalisation de l’instance.  
  
 <xref:System.Resources.ResourceReader.Dispose%2A> appelle la méthode privée dispose (Boolean), qui contient le code pour libérer les ressources managées et non managées. Pour plus d’informations, consultez [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur pour cet objet <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Énumérateur pour cet objet <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, vous énumérer les ressources en appelant le <xref:System.Resources.ResourceReader.GetEnumerator%2A> (méthode), puis à plusieurs reprises la <xref:System.Collections.IEnumerator.MoveNext%2A> méthode sur le <xref:System.Collections.IDictionaryEnumerator> jusqu'à ce que la méthode retourne l’objet `false`. Le nom de la ressource est disponible à partir de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propriété ; sa valeur à partir de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété. L’exemple illustre comment énumérer les ressources de cette façon.  
  
 L’implémentation de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propriété par le <xref:System.Resources.ResourceReader> classe peut lever les exceptions suivantes :  
  
-   <xref:System.IO.FileNotFoundException>  
  
     Impossible de trouver l’assembly qui contient le type auquel les données appartient.  
  
-   <xref:System.FormatException>  
  
     Les données ne sont pas au format attendu.  
  
-   <xref:System.TypeLoadException>  
  
     Impossible de trouver le type auquel les données appartient.  
  
 Vous pouvez gérer l’exception en appelant le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode pour récupérer des informations sur le type de données et le tableau d’octets affecté à la ressource nommée. Pour plus d’informations, consultez la section « Récupération des ressources par nom avec GetResourceData » dans le <xref:System.Resources.ResourceReader> rubrique de la classe.  
  
> [!IMPORTANT]
>  La <xref:System.Resources.ResourceReader> classe inclut deux méthodes qui retournent des énumérateurs. Le <xref:System.Resources.ResourceReader.GetEnumerator%2A> méthode retourne un <xref:System.Collections.IDictionaryEnumerator> objet d’interface et est la méthode recommandée à appeler lorsque l’énumération des ressources.  
  
   
  
## Examples  
 L’exemple de cette section utilise le fichier .txt suivant nommé `PatientForm.txt` pour définir les ressources utilisées par une application.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Vous pouvez compiler le fichier .txt dans un fichier .resources en émettant la commande suivante :  
  
 **resgen PatientForm.txt**  
  
 L’exemple suivant énumère les ressources dans `PatientForm.resources` et affiche le nom et la valeur de chaque.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le lecteur a été fermé ou supprimé, et il n'est plus possible d'y accéder.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
        <Parameter Name="resourceType" Type="System.String&amp;" RefType="out" />
        <Parameter Name="resourceData" Type="System.Byte[]&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resourceName">Nom d'une ressource.</param>
        <param name="resourceType">Quand cette méthode retourne une valeur, contient une chaîne qui représente le nom de type de la ressource récupérée. Ce paramètre est passé sans être initialisé.</param>
        <param name="resourceData">Lorsque cette méthode est retournée, contient un tableau d'octets correspondant à la représentation binaire du type récupéré. Ce paramètre est passé sans être initialisé.</param>
        <summary>Récupère le nom du type et les données d'une ressource nommée à partir d'un fichier de ressources ouvert ou d'un flux.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceReader.GetResourceData%2A> méthode extrait la valeur d’une ressource nommée en tant que tableau d’octets. Il est généralement utilisé lorsque le <xref:System.Collections.IDictionaryEnumerator.Value%2A> propriété lève une exception lorsqu’il tente de récupérer la valeur d’une ressource.  
  
 `resourceType` est une chaîne qui représente le type de données de la ressource. Il peut être une des valeurs suivantes :  
  
-   La représentation sous forme de chaîne d’un `ResourceTypeCode` membre d’énumération qui indique le type de données de la ressource. `ResourceTypeCode` est une énumération privée qui est utilisée par .pour indique qu’un format binaire spécial permet de stocker un des types de données communs 19. Ceux-ci comprennent les types de données primitifs .NET Framework (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Single>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>), ainsi que <xref:System.String>, <xref:System.DateTime>, et <xref:System.TimeSpan>, en outre, le `ResourceTypeCode` énumération inclut les valeurs indiquées dans le tableau suivant.  
  
    |Valeur de ResourceTypeCode|Description |  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|Les données sont un tableau d’octets. Ces données type couramment résulte de l’appel à la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType> (méthode).|  
    |`ResourceTypeCode.Null`|Les données sont une référence null. Ces données type couramment résulte de l’appel à la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType> méthode avec un objet dont la valeur est `null`.|  
    |`ResourceTypeCode.Stream`|Les données sont stockées dans un flux de données. Ces données type couramment résulte de l’appel à la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType> ou <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType> (méthode).|  
  
     En supposant que `resourceData` n’a pas été endommagé, il peut généralement être converti à partir d’un tableau d’octets à sa valeur d’origine en appelant une <xref:System.BitConverter> ou <xref:System.IO.BinaryReader> (méthode).  
  
-   Chaîne qui contient le nom qualifié complet du type dont les données sérialisées sont assignées à la `resourceData` argument (par exemple, `System.String`). En outre, pour les types qui ne font pas partie de la bibliothèque de classes .NET Framework, la chaîne inclut le nom, la version, la culture et la clé publique de l’assembly qui contient le type. Par exemple, la chaîne suivante indique que les données sérialisées représentent une instance de la `Person` de type dans le `Extensions` espace de noms, qui se trouve dans la version 1.0 d’un assembly nommé utilitaire qui a aucune clé publique et aucune culture désignée.  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     En supposant que `resourceData` n’a pas été endommagée et que le type de source est disponible, `resourceData` peut être converti à partir d’un tableau d’octets à sa valeur d’origine en les convertissant en tableau d’octets à un <xref:System.IO.Stream> objet et en passant le flux de données pour le <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>(méthode).  
  
-   La chaîne utilisée pour décrire le type de données dans le <xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType> appel de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> n’existe pas.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="resourceName" /> a un type non valide.</exception>
        <exception cref="T:System.FormatException">Les données de ressources récupérées sont endommagées.</exception>
        <exception cref="T:System.InvalidOperationException">L'objet <see cref="T:System.Resources.ResourceReader" /> actuel n'est pas initialisé, probablement parce qu'il est fermé.</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur pour cet objet <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Énumérateur pour cet objet <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType> est une implémentation d’interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Resources.ResourceReader> est castée en interface <xref:System.Collections.IEnumerable>. L’approche recommandée pour énumérer les ressources dans un fichier .resources consiste à appeler la <xref:System.Collections.IEnumerator.MoveNext%2A> méthode de la <xref:System.Collections.IDictionaryEnumerator> objet retourné par la <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le lecteur a déjà été fermé et il n'est plus possible d'y accéder.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
  </Members>
</Type>