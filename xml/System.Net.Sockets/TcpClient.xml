<Type Name="TcpClient" FullName="System.Net.Sockets.TcpClient">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3f522b75d1f24f730339ccccb66549177444e9c4" /><Meta Name="ms.sourcegitcommit" Value="9e7aa84070156026697d2898b5311e6c025a1e6a" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="02/28/2019" /><Meta Name="ms.locfileid" Value="56996848" /></Metadata><TypeSignature Language="C#" Value="public class TcpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpClient&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpClient : IDisposable" />
  <TypeSignature Language="F#" Value="type TcpClient = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit des connexions clientes pour les services réseau TCP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `TcpClient` classe fournit des méthodes simples pour la connexion, envoi, et la réception de flux de données sur un réseau en mode blocage synchrone.  
  
 Dans l’ordre pour `TcpClient` pour vous connecter et d’échanger des données, un <xref:System.Net.Sockets.TcpListener> ou <xref:System.Net.Sockets.Socket> créé avec le protocole TCP <xref:System.Net.Sockets.ProtocolType> doit être à l’écoute des demandes de connexion entrante. Vous pouvez vous connecter à cet écouteur dans un des deux manières suivantes :  
  
-   Créer un `TcpClient` et appelez une des trois disponibles <xref:System.Net.Sockets.TcpClient.Connect%2A> méthodes.  
  
-   Créer un `TcpClient` en utilisant le nom d’hôte et le numéro de port de l’hôte distant. Ce constructeur tentera automatiquement une connexion.  
  
> [!NOTE]
>  Si vous souhaitez envoyer des datagrammes sans connexion en mode blocage synchrone, utilisez la <xref:System.Net.Sockets.UdpClient> classe.  
  
   
  
## Examples  
 L’exemple de code suivant établit une `TcpClient` connexion.  
  
 [!code-cpp[System.Net.Sockets.TcpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CPP/tcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CS/tcpclient.cs#1)]
 [!code-vb[System.Net.Sockets.TcpClient#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/VB/tcpclient.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Autorisation d’établir une connexion sortante ou accepter une demande entrante.</permission>
    <block subset="none" type="overrides"><para>Pour envoyer et recevoir des données, utilisez le <see cref="M:System.Net.Sockets.TcpClient.GetStream" /> méthode pour obtenir un <see cref="T:System.Net.Sockets.NetworkStream" />. Appelez le <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> et <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> méthodes de la <see cref="T:System.Net.Sockets.NetworkStream" /> pour envoyer et recevoir des données avec l’hôte distant. Utilisez le <see cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" /> méthode pour libérer toutes les ressources associées à la <see cref="T:System.Net.Sockets.TcpClient" />.</para></block>
    <altmember cref="T:System.Net.Sockets.TcpListener" />
    <altmember cref="T:System.Net.Sockets.NetworkStream" />
    <altmember cref="T:System.Net.Sockets.Socket" />
    <altmember cref="T:System.Net.Sockets.ProtocolType" />
    <altmember cref="T:System.Net.IPEndPoint" />
    <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
    <related type="Article" href="~/docs/framework/network-programming/tcp-udp.md">TCP-UDP</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un nouveau <xref:System.Net.Sockets.TcpClient> et permet au fournisseur de service sous-jacent affecter le plus approprié local IP adresse et numéro de port. Vous devez d’abord appeler la <xref:System.Net.Sockets.TcpClient.Connect%2A> méthode avant d’envoyer et recevoir des données.  
  
> [!NOTE]
>  Ce constructeur fonctionne uniquement avec les types d’adresses IPv4.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le constructeur par défaut pour créer un nouveau <xref:System.Net.Sockets.TcpClient>.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : System.Net.IPEndPoint -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><see cref="T:System.Net.IPEndPoint" /> auquel vous liez le <see cref="T:System.Net.Sockets.Socket" /> TCP.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.TcpClient" /> et la lie au point de terminaison local spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un nouveau <xref:System.Net.Sockets.TcpClient> et le lie à la <xref:System.Net.IPEndPoint> spécifié par le `localEP` paramètre. Avant d’appeler ce constructeur, vous devez créer un `IPEndPoint` à l’aide de l’adresse IP et port numéro à partir de laquelle vous souhaitez envoyer et recevoir des données. Vous n’avez pas besoin de spécifier un numéro d’adresse et le port IP local avant de se connecter et communiquer. Si vous créez un `TcpClient` à l’aide de n’importe quel autre constructeur, le fournisseur de services sous-jacent affectera le plus approprié local IP adresse et numéro de port.  
  
 Vous devez appeler la <xref:System.Net.Sockets.TcpClient.Connect%2A> méthode avant d’envoyer et recevoir des données.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une instance de la <xref:System.Net.Sockets.TcpClient> classe à l’aide d’un point de terminaison local.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="localEP" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient family" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family"><see cref="P:System.Net.IPAddress.AddressFamily" /> du protocole IP.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.TcpClient" /> avec la famille spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une instance de la <xref:System.Net.Sockets.TcpClient> classe.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="family" /> n'est pas égal à AddressFamily.InterNetwork. 
ou 
Le paramètre <paramref name="family" /> n'est pas égal à AddressFamily.InterNetworkV6.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : string * int -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient (hostname, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nom DNS de l'hôte distant auquel vous souhaitez vous connecter.</param>
        <param name="port">Numéro de port de l'hôte distant auquel vous souhaitez vous connecter.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.TcpClient" /> et établit une connexion au port spécifié sur l'hôte spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un nouveau <xref:System.Net.Sockets.TcpClient> et effectue une connexion synchrone tentative au nom d’hôte fourni et le numéro de port. Le fournisseur de services sous-jacent affectera le plus approprié local IP adresse et numéro de port. `TcpClient` bloque jusqu'à ce qu’il se connecte ou échoue. Ce constructeur vous permet d’initialiser, résoudre le nom d’hôte DNS et vous connecter en une seule étape pratique.  
  
 Si IPv6 est activé et le <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29> est appelée pour vous connecter à un hôte qui résout les deux IPv6 et des adresses IPv4, la connexion à l’adresse IPv6 sera tentée en premier avant l’adresse IPv4. Cela peut avoir pour effet de retarder l’heure pour établir la connexion si l’hôte n’écoute pas sur l’adresse IPv6.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une instance de la <xref:System.Net.Sockets.TcpClient> classe à l’aide d’un nom d’hôte et le numéro de port.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="hostname" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="port" /> n’est pas compris entre <see cref="F:System.Net.IPEndPoint.MinPort" /> et <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de l'accès au socket.</exception>
        <altmember cref="Overload:System.Net.Sockets.TcpClient.#ctor" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Active" />
      <MemberSignature Language="VB.NET" Value="Protected Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool with get, set" Usage="System.Net.Sockets.TcpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si une connexion a été établie.</summary>
        <value><see langword="true" /> si la connexion a été établie ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de <xref:System.Net.Sockets.TcpClient> pouvez utiliser cette propriété pour déterminer si une tentative de connexion a réussi. Il ne surveille pas l’état de connexion en cours de `TcpClient`. Si l’hôte distant ferme la connexion, `Active` ne sera pas mis à jour. Si vous dérivez de `TcpClient` et nécessitent une attention plus en détail à l’état de connexion, utilisez le <xref:System.Net.Sockets.Socket.Connected%2A> propriété de la <xref:System.Net.Sockets.Socket> retourné par la <xref:System.Net.Sockets.TcpClient.Client%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.Connected" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.TcpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de données reçues du réseau et disponibles pour la lecture.</summary>
        <value>Nombre d'octets de données reçues du réseau et disponibles pour la lecture.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Le `Available` propriété consiste à déterminer si les données sont en file d’attente pour la lecture. Si les données sont disponibles, appelez <xref:System.Net.Sockets.NetworkStream.Read%2A> pour obtenir les données. Les données disponibles sont que la quantité totale de données en file d’attente dans la mémoire tampon réseau pour la lecture. Si aucune donnée n’est en file d’attente dans la mémoire tampon réseau, `Available` retourne 0.  
  
 Si l’hôte distant arrête ou ferme la connexion, `Available` peut lever une <xref:System.Net.Sockets.SocketException>. Si vous recevez un `SocketException`, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la `Available` propriété.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre une demande asynchrone pour une connexion d'hôte distant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (address, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address"><see cref="T:System.Net.IPAddress" /> de l'hôte distant.</param>
        <param name="port">Numéro de port de l'hôte distant.</param>
        <param name="requestCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion. Cet objet est passé au délégué <paramref name="requestCallback" /> lorsque l'opération est terminée.</param>
        <summary>Démarre une demande asynchrone pour une connexion d'hôte distant. L'hôte distant est spécifié par <see cref="T:System.Net.IPAddress" /> et un numéro de port (<see cref="T:System.Int32" />).</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui fait référence à la connexion asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone `BeginConnect` opération doit être effectuée en appelant le <xref:System.Net.Sockets.TcpClient.EndConnect%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.TcpClient.Connect%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.TcpClient> et se connecte à un hôte distant.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpClient1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="address" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le numéro de port n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (addresses, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="addresses">Au moins un <see cref="T:System.Net.IPAddress" /> qui désigne les hôtes distants.</param>
        <param name="port">Numéro de port des hôtes distants.</param>
        <param name="requestCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler lorsque l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion. Cet objet est passé au délégué <paramref name="requestCallback" /> lorsque l'opération est terminée.</param>
        <summary>Démarre une demande asynchrone pour une connexion d'hôte distant. L'hôte distant est spécifié par un tableau <see cref="T:System.Net.IPAddress" /> et un numéro de port (<see cref="T:System.Int32" />).</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui fait référence à la connexion asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone `BeginConnect` opération doit être effectuée en appelant le <xref:System.Net.Sockets.TcpClient.EndConnect%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.TcpClient.Connect%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Cette méthode est généralement utilisée immédiatement après un appel à la <xref:System.Net.Dns.BeginGetHostAddresses%2A> (méthode), qui peut retourner plusieurs adresses IP pour un seul hôte.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.TcpClient> et se connecte à un hôte distant.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpClient1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="addresses" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le numéro de port n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (host, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="host">Nom de l'hôte distant.</param>
        <param name="port">Numéro de port de l'hôte distant.</param>
        <param name="requestCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui contient des informations sur l'opération de connexion. Cet objet est passé au délégué <paramref name="requestCallback" /> lorsque l'opération est terminée.</param>
        <summary>Démarre une demande asynchrone pour une connexion d'hôte distant. L'hôte distant est spécifié par un nom d'hôte (<see cref="T:System.String" />) et un numéro de port (<see cref="T:System.Int32" />).</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui fait référence à la connexion asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone `BeginConnect` opération doit être effectuée en appelant le <xref:System.Net.Sockets.TcpClient.EndConnect%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.TcpClient.Connect%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.TcpClient> et se connecte à un hôte distant.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.TcpClient1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="host" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n’a pas l’autorisation pour l’opération demandée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le numéro de port n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Client" />
      <MemberSignature Language="VB.NET" Value="Public Property Client As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Client : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.TcpClient.Client" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> de réseau sous-jacent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient> Crée un <xref:System.Net.Sockets.Socket> pour envoyer et recevoir des données sur un réseau. Les classes dérivées de `TcpClient` cette propriété permet d’obtenir ou définir ce `Socket`. Utilisez sous-jacent `Socket` retourné à partir de `Client` si vous avez besoin d’accéder aux au-delà de celles qui `TcpClient` fournit. Vous pouvez également utiliser `Client` définir sous-jacent `Socket` à un existant `Socket`. Cela peut être utile si vous souhaitez tirer parti de la simplicité de `TcpClient` à l’aide d’un préexistants `Socket`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la `Client` propriété. Dans cet exemple, la taille de mémoire tampon de réception de sous-jacent <xref:System.Net.Sockets.Socket> est modifiée.  
  
 [!code-csharp[TcpClientProtectedMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[TcpClientProtectedMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="tcpClient.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime cette instance de <see cref="T:System.Net.Sockets.TcpClient" /> et demande que la connexion TCP sous-jacente soit fermée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Close` méthode marque l’instance comme étant supprimé et demande qu’associé <xref:System.Net.Sockets.Socket> fermer la connexion TCP. Selon le <xref:System.Net.Sockets.TcpClient.LingerState%2A> propriété, la connexion TCP peut rester ouverte pendant un certain temps après la `Close` méthode est appelée lorsque le restent des données à envoyer. Aucune notification n’est fournie lors de la connexion sous-jacente est terminée.  
  
 Appel de cette méthode entraîne la fermeture d’associé `Socket` et ferme également associé <xref:System.Net.Sockets.NetworkStream> qui est utilisé pour envoyer et recevoir des données s’il a été créé.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre la fermeture un <xref:System.Net.Sockets.TcpClient> en appelant le `Close` (méthode).  
  
 [!code-cpp[NCLTCPClientSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLTcpClientSync/CPP/tcpclient.cpp#1)]
 [!code-csharp[NCLTCPClientSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Connecte le client à un hôte TCP distant en utilisant le nom d'hôte et le numéro de port spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPEndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPEndPoint -&gt; unit" Usage="tcpClient.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><see cref="T:System.Net.IPEndPoint" /> auquel vous souhaitez vous connecter.</param>
        <summary>Connecte le client à un hôte TCP distant en utilisant le point de terminaison réseau distant spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode pour établir une connexion d’hôte distant synchrone spécifié <xref:System.Net.IPEndPoint>. Avant d’appeler `Connect`, vous devez créer une instance de la `IPEndPoint` classe à l’aide d’une adresse IP et un numéro de port. Utilisez cette `IPEndPoint` comme le `remoteEP` paramètre. Le `Connect` méthode se bloque jusqu'à ce qu’il se connecte ou échoue. Après vous être connecté avec l’hôte distant, utilisez le <xref:System.Net.Sockets.TcpClient.GetStream%2A> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.NetworkStream>. Utilisez cette `NetworkStream` pour envoyer et recevoir des données.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md)  
  
   
  
## Examples  
 Le code suivant exemple utilise un <xref:System.Net.IPEndPoint> pour vous connecter avec un hôte distant.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="remoteEp" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de l'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> est fermé.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="tcpClient.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><see cref="T:System.Net.IPAddress" /> de l'hôte auquel vous souhaitez vous connecter.</param>
        <param name="port">Numéro de port auquel vous souhaitez vous connecter.</param>
        <summary>Connecte le client à un hôte TCP distant en utilisant l'adresse IP et le numéro de port spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode pour établir une connexion d’hôte distant synchrone spécifié <xref:System.Net.IPAddress> et numéro de port. Le <xref:System.Net.Sockets.TcpClient.Connect%2A> méthode se bloque jusqu'à ce qu’il se connecte ou échoue. Après vous être connecté avec l’hôte distant, utilisez le <xref:System.Net.Sockets.TcpClient.GetStream%2A> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.NetworkStream>. Utilisez cette `NetworkStream` pour envoyer et recevoir des données.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant utilise une adresse IP et le numéro de port pour se connecter avec un hôte distant.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="address" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="port" /> n'est pas compris entre <see cref="F:System.Net.IPEndPoint.MinPort" /> et <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de l'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] ipAddresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] ipAddresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (ipAddresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ ipAddresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="tcpClient.Connect (ipAddresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipAddresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ipAddresses">Tableau <see cref="T:System.Net.IPAddress" /> de l'hôte auquel vous souhaitez vous connecter.</param>
        <param name="port">Numéro de port auquel vous souhaitez vous connecter.</param>
        <summary>Connecte le client à un hôte TCP distant en utilisant les adresses IP et le numéro de port spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est généralement utilisée immédiatement après un appel à la <xref:System.Net.Dns.BeginGetHostAddresses%2A> (méthode), qui peut retourner plusieurs adresses IP pour un seul hôte. Appelez le `Connect` méthode pour établir une connexion d’hôte distant synchrone à l’hôte spécifié par le tableau de <xref:System.Net.IPAddress> éléments et le numéro de port. Le `Connect` méthode se bloque jusqu'à ce qu’il se connecte ou échoue. Après vous être connecté avec l’hôte distant, utilisez le <xref:System.Net.Sockets.TcpClient.GetStream%2A> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.NetworkStream>. Utilisez cette `NetworkStream` pour envoyer et recevoir des données.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant utilise une adresse IP et le numéro de port pour se connecter avec un hôte distant.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#8)]
 [!code-csharp[System.Net.Sockets.TcpClient1#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="ipAddresses" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le numéro de port n'est pas valide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n'a pas l'autorisation pour l'opération demandée.</exception>
        <exception cref="T:System.NotSupportedException">Cette méthode est valide pour les sockets qui utilisent l'indicateur <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou l'indicateur <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="tcpClient.Connect (hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nom DNS de l'hôte distant auquel vous souhaitez vous connecter.</param>
        <param name="port">Numéro de port de l'hôte distant auquel vous souhaitez vous connecter.</param>
        <summary>Connecte le client au port spécifié sur l'hôte spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode pour établir une connexion d’hôte distant synchrone au nom d’hôte spécifié et le numéro de port. Le `Connect` méthode se bloque jusqu'à ce qu’il se connecte ou échoue. Après vous être connecté avec l’hôte distant, utilisez le <xref:System.Net.Sockets.TcpClient.GetStream%2A> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.NetworkStream>. Utilisez cette `NetworkStream` pour envoyer et recevoir des données.  
  
 Si IPv6 est activé et le `Connect(String, Int32)` est appelée pour vous connecter à un hôte qui résout les deux IPv6 et des adresses IPv4, la connexion à l’adresse IPv6 sera tentée en premier avant l’adresse IPv4. Cela peut avoir pour effet de retarder l’heure pour établir la connexion si l’hôte n’écoute pas sur l’adresse IPv6.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant utilise le nom d’hôte et le port numéro pour vous connecter avec un hôte distant.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="hostname" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="port" /> n’est pas compris entre <see cref="F:System.Net.IPEndPoint.MinPort" /> et <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de l'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Connecte le client à un hôte TCP distant en utilisant le nom d'hôte et le numéro de port spécifiés sous forme d'opération asynchrone.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (address As IPAddress, port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.IPAddress * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><see cref="T:System.Net.IPAddress" /> de l'hôte auquel vous souhaitez vous connecter.</param>
        <param name="port">Numéro de port auquel vous souhaitez vous connecter.</param>
        <summary>Connecte le client à un hôte TCP distant en utilisant l'adresse IP et le numéro de port spécifiés sous forme d'opération asynchrone.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération ne bloque pas. Les retours retournés <xref:System.Threading.Tasks.Task> objet se termine après avoir établi la connexion TCP. Cette méthode ne bloque pas le thread appelant pendant que la demande de connexion est en cours d’exécution.  
  
 Appelez cette méthode pour établir une connexion d’hôte distant synchrone spécifié <xref:System.Net.IPAddress> et numéro de port en tant qu’une opération asynchrone. Après vous être connecté avec l’hôte distant, utilisez le <xref:System.Net.Sockets.TcpClient.GetStream%2A> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.NetworkStream>. Utilisez cette `NetworkStream` pour envoyer et recevoir des données.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="address" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="port" /> n'est pas compris entre <see cref="F:System.Net.IPEndPoint.MinPort" /> et <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de l'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (addresses As IPAddress(), port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.IPAddress[] * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">Tableau <see cref="T:System.Net.IPAddress" /> de l'hôte auquel vous souhaitez vous connecter.</param>
        <param name="port">Numéro de port auquel vous souhaitez vous connecter.</param>
        <summary>Connecte le client à un hôte TCP distant en utilisant les adresses IP et le numéro de port spécifiés sous forme d'opération asynchrone.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération ne bloque pas. Les retours retournés <xref:System.Threading.Tasks.Task> objet se termine après avoir établi la connexion TCP. Cette méthode ne bloque pas le thread appelant pendant que la demande de connexion est en cours d’exécution.  
  
 Cette méthode est généralement utilisée immédiatement après un appel à la <xref:System.Net.Dns.BeginGetHostAddresses%2A> (méthode), qui peut retourner plusieurs adresses IP pour un seul hôte. Appelez cette méthode pour établir une connexion d’hôte distant synchrone à l’hôte spécifié par le tableau de <xref:System.Net.IPAddress> éléments et le numéro de port en tant qu’une opération asynchrone. Après vous être connecté avec l’hôte distant, utilisez le <xref:System.Net.Sockets.TcpClient.GetStream%2A> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.NetworkStream>. Utilisez cette `NetworkStream` pour envoyer et recevoir des données.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="ipAddresses" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le numéro de port n'est pas valide.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">Un appelant situé plus haut dans la pile des appels n'a pas l'autorisation pour l'opération demandée.</exception>
        <exception cref="T:System.NotSupportedException">Cette méthode est valide pour les sockets qui utilisent l'indicateur <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou l'indicateur <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (host As String, port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : string * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">Nom DNS de l'hôte distant auquel vous souhaitez vous connecter.</param>
        <param name="port">Numéro de port de l'hôte distant auquel vous souhaitez vous connecter.</param>
        <summary>Connecte le client au port TCP spécifié sur l'hôte spécifié en tant qu'opération asynchrone.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération ne bloque pas. Les retours retournés <xref:System.Threading.Tasks.Task> objet se termine après avoir établi la connexion TCP. Cette méthode ne bloque pas le thread appelant pendant que la demande de connexion est en cours d’exécution.  
  
 Appelez cette méthode pour établir une connexion d’hôte distant synchrone au nom d’hôte spécifié et son numéro en tant qu’une opération asynchrone. Après vous être connecté avec l’hôte distant, utilisez le <xref:System.Net.Sockets.TcpClient.GetStream%2A> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.NetworkStream>. Utilisez cette `NetworkStream` pour envoyer et recevoir des données.  
  
 Si IPv6 est activé et le <xref:System.Net.Sockets.TcpClient.ConnectAsync%28System.String%2CSystem.Int32%29> est appelée pour vous connecter à un hôte qui résout les deux IPv6 et des adresses IPv4, la connexion à l’adresse IPv6 sera tentée en premier avant l’adresse IPv4. Cela peut avoir pour effet de retarder l’heure pour établir la connexion si l’hôte n’écoute pas sur l’adresse IPv6.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="hostname" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="port" /> n’est pas compris entre <see cref="F:System.Net.IPEndPoint.MinPort" /> et <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de l'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> est fermé.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.TcpClient.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent de <see cref="T:System.Net.Sockets.TcpClient" /> est connecté à un hôte distant.</summary>
        <value><see langword="true" /> si le socket <see cref="P:System.Net.Sockets.TcpClient.Client" /> était connecté à une ressource distante lors de l'opération la plus récente ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Connected` propriété obtient l’état de connexion de le <xref:System.Net.Sockets.TcpClient.Client%2A> socket à compter de la dernière opération d’e/s. Quand il renvoie `false`, le `Client` socket n’a jamais été connecté ou n’est plus connecté.  
  
 Étant donné que le `Connected` propriété reflète uniquement l’état de la connexion depuis la dernière opération effectuée, vous devez tenter d’envoyer ou recevoir un message pour déterminer l’état actuel. Une fois que l’envoi du message échoue, cette propriété ne retourne plus `true`. Notez que ce comportement est normal. Vous ne pouvez pas tester de manière fiable l’état de la connexion car, dans le délai entre le test et l’envoi/réception, la connexion pourrait ont été perdue. Votre code doit supposer que le socket est connecté, et normalement handle échecs de transmission.  
  
   
  
## Examples  
 L’exemple de code suivant se connecte à un point de terminaison distant, puis vérifie la connexion.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="tcpClient.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources managées et non managées utilisées par <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="tcpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer à la fois les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Net.Sockets.TcpClient" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose()` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle cette méthode avec le `disposing` paramètre défini sur `true`. `Finalize` appelle cette méthode avec `disposing` défini sur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Net.Sockets.TcpClient>. Pour ce faire appeler le `Dispose()` (méthode) de chaque objet référencé.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution de <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="tcpClient.EndConnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objet <see cref="T:System.IAsyncResult" /> retourné par un appel à <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" />.</param>
        <summary>Met fin à une tentative de connexion asynchrone en attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se bloque jusqu'à ce que l’opération soit terminer. Pour effectuer cette opération de façon synchrone, utilisez un <xref:System.Net.Sockets.TcpClient.Connect%2A> (méthode).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple de code suivant met fin à la tentative de connexion asynchrone.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.TcpClient1#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" />.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" /> a été précédemment appelée pour la connexion asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès à <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.TcpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.TcpClient" /> n'autorise qu'un seul client à utiliser un port.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.TcpClient" /> n'autorise qu'un seul client à utiliser un port spécifique ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" /> pour Windows Server 2003 et Windows XP Service Pack 2 et ultérieur, et <see langword="false" /> pour toutes les autres versions.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, plusieurs clients peuvent utiliser un port spécifique ; Toutefois, seul l’un des clients peut effectuer des opérations sur le trafic réseau envoyé au port. Vous pouvez utiliser le `ExclusiveAddressUse` propriété pour empêcher plusieurs clients à l’aide d’un port spécifique.  
  
 Cette propriété doit être définie avant que le socket sous-jacent est lié à un port du client. Si vous appelez <xref:System.Net.Sockets.TcpClient.Connect%2A>, <xref:System.Net.Sockets.TcpClient.BeginConnect%2A>, <xref:System.Net.Sockets.TcpClient.%23ctor%28System.Net.IPEndPoint%29>, ou <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29>, le port client est lié en tant qu’un effet secondaire de la méthode, et vous ne pouvez pas définir par la suite le `ExclusiveAddressUse` propriété.
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.TcpClient> et obtient et définit la valeur de la `ExclusiveAddressUse` propriété.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpClient1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket sous-jacent.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpClient ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tcpClient.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par la classe <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Code d’application ne doit pas appeler cette méthode ; d’un objet `Finalize` méthode est appelée automatiquement lors du garbage collection, à moins que la finalisation par le garbage collector a été désactivée par un appel à la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).  
  
 Le <xref:System.Net.Sockets.TcpClient> finaliseur de leur classe ferme la connexion TCP et libère toutes les ressources managées associées le `TcpClient`. Ces ressources incluent sous-jacent <xref:System.Net.Sockets.Socket> utilisés pour la connexion avec l’hôte distant et le <xref:System.Net.Sockets.NetworkStream> utilisé pour envoyer et recevoir des données. Le finaliseur ne libère pas les ressources non managées.  
  
 Pour plus d’informations, consultez [destructeurs et méthodes Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md), et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
        <related type="Article" href="~/docs/standard/garbage-collection/index.md">Garbage Collection</related>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.NetworkStream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.NetworkStream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As NetworkStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::NetworkStream ^ GetStream();" />
      <MemberSignature Language="F#" Value="member this.GetStream : unit -&gt; System.Net.Sockets.NetworkStream" Usage="tcpClient.GetStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.NetworkStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le <see cref="T:System.Net.Sockets.NetworkStream" /> utilisé pour l'envoi et la réception de données.</summary>
        <returns><see cref="T:System.Net.Sockets.NetworkStream" /> sous-jacent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Le `GetStream` méthode retourne un <xref:System.Net.Sockets.NetworkStream> que vous pouvez utiliser pour envoyer et recevoir des données. Le `NetworkStream` classe hérite de la <xref:System.IO.Stream> classe, qui fournit une vaste collection de méthodes et propriétés utilisées pour faciliter les communications réseau.  
  
 Vous devez appeler la <xref:System.Net.Sockets.TcpClient.Connect%2A> méthode tout d’abord, ou le <xref:System.Net.Sockets.TcpClient.GetStream%2A> méthode lèvera une <xref:System.InvalidOperationException>. Une fois que vous avez obtenu le `NetworkStream`, appelez le <xref:System.Net.Sockets.NetworkStream.Write%2A> méthode pour envoyer des données à l’hôte distant. Appelez le <xref:System.Net.Sockets.NetworkStream.Read%2A> méthode pour recevoir des données en provenance de l’hôte distant. Ces deux méthodes bloquent jusqu'à ce que l’opération spécifiée est effectuée. Vous pouvez éviter le blocage sur une opération de lecture en vérifiant la <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> propriété. Un `true` valeur signifie que les données sont arrivé à partir de l’hôte distant et est disponibles pour la lecture. Dans ce cas, <xref:System.Net.Sockets.NetworkStream.Read%2A> est assurée de se terminer immédiatement. Si l’hôte distant a arrêté sa connexion, <xref:System.Net.Sockets.NetworkStream.Read%2A> est retournée immédiatement avec zéro octet.  
  
> [!NOTE]
>  Vous devez fermer le `NetworkStream` lorsque vous avez terminé d’envoyer et recevoir des données. Fermeture <xref:System.Net.Sockets.TcpClient> ne libère pas le `NetworkStream`.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la [code d’erreur API Windows Sockets version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise `GetStream` obtenir sous-jacent <xref:System.Net.Sockets.NetworkStream>. Après avoir obtenu le <xref:System.Net.Sockets.NetworkStream>, il envoie et reçoit en utilisant ses <xref:System.Net.Sockets.NetworkStream.Write%2A> et <xref:System.Net.Sockets.NetworkStream.Read%2A> méthodes.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#14)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#14)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.TcpClient" /> n'est pas connecté à un hôte distant.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> a été fermé.</exception>
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.TcpClient.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les informations relatives à l'état de maintien du socket associé.</summary>
        <value><see cref="T:System.Net.Sockets.LingerOption" /> Par défaut, le maintien est désactivé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `LingerState` propriété modifie la façon dont <xref:System.Net.Sockets.Socket.Close%2A> méthode se comporte. Cette propriété lors de l’ensemble modifie les conditions sous lesquelles la connexion peut être réinitialisée à Winsock. Réinitialisations de connexion peuvent encore se produire en fonction du comportement de protocole IP.  
  
 Cette propriété contrôle la durée pendant laquelle la connexion TCP reste ouverte après un appel à <xref:System.Net.Sockets.TcpClient.Close%2A> lorsqu’il reste des données à envoyer. Lorsque vous appelez le <xref:System.Net.Sockets.NetworkStream.Write%2A> (méthode), données est placé dans le tampon réseau sortant. Cette propriété peut être utilisée pour vous assurer que ces données sont envoyées à l’hôte distant avant le <xref:System.Net.Sockets.TcpClient.Close%2A> méthode annule la connexion.  
  
 Pour activer le maintien, créez un <xref:System.Net.Sockets.LingerOption> de l’instance qui contient les valeurs souhaitées, puis définissez le `LingerState` propriété à cette instance.  
  
 Le tableau suivant décrit le comportement de la <xref:System.Net.Sockets.TcpClient.Close%2A> méthode pour les valeurs possibles de la <xref:System.Net.Sockets.LingerOption.Enabled%2A> propriété et la <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriété stockée dans le `LingerState` propriété.  
  
|LingerState.Enabled|LingerState.LingerTime|Comportement|  
|-------------------------|----------------------------|--------------|  
|`false` (désactivé), la valeur par défaut|Le délai d’attente n’est pas applicable, (par défaut).|Essaie d’envoyer les données en attente jusqu'à ce que le délai expire.|  
|`true` (activé)|Un délai d’expiration différent de zéro|Essaie d’envoyer les données en attente jusqu'à ce que le délai spécifié expire et si la tentative échoue, Winsock réinitialise la connexion.|  
|`true` (activé)|Un délai d’attente nulle.|Ignore toute donnée en attente et Winsock réinitialise la connexion.|  
  
 La pile IP calcule le délai par défaut protocole IP à utiliser en fonction du temps d’aller-retour de la connexion. Dans la plupart des cas, le délai d’attente calculé par la pile est plus pertinent que celui défini par une application. Il s’agit du comportement par défaut pour un socket lors de la `LingerState` propriété n’est pas définie.  
  
 Lorsque le <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriété stockée dans le `LingerState` propriété est supérieure au délai de protocole IP par défaut, le délai de protocole IP par défaut sera toujours s’appliquent et remplacent.  
  
   
  
## Examples  
 Le code suivant exemple définit et obtient les sockets maintenir sa durée.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#12)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#12)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.LingerOption" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.TcpClient.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui désactive un délai de temporisation lorsque les mémoires tampons d'envoi ou de réception ne sont pas saturées.</summary>
        <value><see langword="true" /> Si le délai est désactivé ; Sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque `NoDelay` est `false`, un <xref:System.Net.Sockets.TcpClient> n’envoie pas de paquet sur le réseau jusqu'à ce qu’il a recueillies une quantité significative de données sortantes. En raison de la quantité de surcharge dans un segment TCP, l’envoi de petites quantités de données est inefficace. Toutefois, les situations existent où vous devez envoyer de très petites quantités de données ou attendre des réponses immédiates à partir de chaque paquet envoyé. Votre décision doit pondérer l’importance relative de l’efficacité du réseau par rapport aux exigences de l’application.  
  
   
  
## Examples  
 L’exemple de code suivant désactive le délai. Elle vérifie ensuite la valeur de `NoDelay` pour vérifier que la propriété a été correctement définie.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.TcpClient.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de la mémoire tampon de réception.</summary>
        <value>Taille de la mémoire tampon de réception en octets. La valeur par défaut est de 8 192 octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ReceiveBufferSize` propriété obtient ou définit le nombre d’octets que vous prévoyez de stocker dans la mémoire tampon de réception pour chaque opération de lecture. Cette propriété manipule en fait l’espace de mémoire tampon réseau alloué pour la réception des données entrantes.  
  
 Votre mémoire tampon réseau doit être au moins aussi grande mémoire tampon de votre application pour vous assurer que les données souhaitées seront disponibles lorsque vous appelez le <xref:System.Net.Sockets.NetworkStream.Read%2A?displayProperty=nameWithType> (méthode). Utilisez le <xref:System.Net.Sockets.TcpClient.ReceiveBufferSize%2A> propriété à définir cette taille. Si votre application recevra des données en bloc, vous devez passer le `Read` méthode une mémoire tampon d’application de très grande taille.  
  
 Si la mémoire tampon réseau est inférieure à la quantité de données que vous demandez dans le `Read` (méthode), vous ne pourrez récupérer la quantité de données dans une opération de lecture souhaitée. Cela entraîne la surcharge d’appels supplémentaires à la `Read` (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant définit et obtient la taille de mémoire tampon de réception.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la définition de la taille de la mémoire tampon.  
  
ou 
Dans les applications .NET Compact Framework, vous ne pouvez pas définir cette propriété. Pour obtenir une solution de contournement, consultez la partie Remarque sur la plateforme de la section Notes.</exception>
        <altmember cref="P:System.Net.Sockets.TcpClient.SendBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.TcpClient.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée pendant laquelle <see cref="T:System.Net.Sockets.TcpClient" /> attendra de recevoir des données une fois l'opération de lecture initialisée.</summary>
        <value>Valeur du délai d'attente de la connexion en millisecondes. La valeur par défaut est 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ReceiveTimeout` propriété détermine la quantité de temps que le <xref:System.Net.Sockets.NetworkStream.Read%2A> méthode se bloque jusqu'à ce qu’il soit en mesure de recevoir des données. Ce temps est mesuré en millisecondes. Si le délai expire avant `Read` se termine correctement, <xref:System.Net.Sockets.TcpClient> lève un <xref:System.IO.IOException>. Il n’existe aucun délai d’attente par défaut.  
  
   
  
## Examples  
 L’exemple de code suivant définit et obtient le délai d’attente de réception.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.SendTimeout" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.TcpClient.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de la mémoire tampon d'envoi.</summary>
        <value>Taille de la mémoire tampon d'envoi en octets. La valeur par défaut est de 8 192 octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `SendBufferSize` propriété obtient ou définit le nombre d’octets que vous prévoyez d’envoyer dans chaque appel à la <xref:System.Net.Sockets.NetworkStream.Write%2A?displayProperty=nameWithType> (méthode). Cette propriété manipule en fait l’espace de mémoire tampon réseau alloué pour l’opération d’envoi.  
  
 Votre mémoire tampon réseau doit être au moins aussi grande mémoire tampon de votre application pour vous assurer que les données souhaitées seront stockées et envoyées en une seule opération. Utilisez le <xref:System.Net.Sockets.TcpClient.SendBufferSize%2A> propriété à définir cette taille. Si votre application enverront des données en bloc, vous devez passer le `Write` méthode une mémoire tampon d’application de très grande taille.  
  
 Si la mémoire tampon réseau est inférieure à la quantité de données que vous fournissez la `Write` (méthode), plusieurs réseau envoi opérations seront effectuées pour chaque appel que vous apportez à la `Write` (méthode). Vous pouvez obtenir le meilleur débit de données en veillant à ce que votre mémoire tampon réseau est au moins aussi grand que la mémoire tampon de votre application.  
  
   
  
## Examples  
 L’exemple de code suivant définit et obtient la taille de mémoire tampon d’envoi.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.TcpClient.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée pendant laquelle <see cref="T:System.Net.Sockets.TcpClient" /> attendra qu'une opération d'envoi se termine correctement.</summary>
        <value>Valeur de délai d'attente d'envoi, en millisecondes. La valeur par défaut est 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `SendTimeout` propriété détermine la quantité de temps que le <xref:System.Net.Sockets.Socket.Send%2A> méthode se bloque jusqu'à ce qu’il soit en mesure de retourner correctement. Ce temps est mesuré en millisecondes.  
  
 Après avoir appelé la <xref:System.Net.Sockets.NetworkStream.Write%2A> méthode, sous-jacent <xref:System.Net.Sockets.Socket> retourne le nombre d’octets réellement envoyés à l’hôte. Le `SendTimeout` propriété détermine la durée pendant laquelle un <xref:System.Net.Sockets.TcpClient> attendra avant de recevoir le nombre d’octets retourné. Si le délai expire avant le `Send` méthode se termine correctement, `TcpClient` lèvera une <xref:System.Net.Sockets.SocketException>. Il n’existe aucun délai d’attente par défaut.  
  
   
  
## Examples  
 L’exemple de code suivant définit et obtient le `SendTimeout` valeur.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Appelez IDisposable.Dispose lorsque vous avez terminé à l’aide de la <xref:System.Net.Sockets.TcpClient>. La méthode IDisposable.Dispose quitte le <xref:System.Net.Sockets.TcpClient> dans un état inutilisable. Après l’appel à IDisposable.Dispose, vous devez libérer toutes les références à la <xref:System.Net.Sockets.TcpClient> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Net.Sockets.TcpClient> occupée. Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Appelez toujours IDisposable.Dispose avant de libérer votre dernière référence à la <xref:System.Net.Sockets.TcpClient>. Sinon, les ressources qu’il utilise ne seront pas libérées jusqu'à ce que le garbage collector appelle la <xref:System.Net.Sockets.TcpClient> l’objet **Finalize** (méthode).

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
  </Members>
</Type>