<Type Name="TcpListener" FullName="System.Net.Sockets.TcpListener">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0745613c4e13b086fa4d68e1356349ed35a3b9ba" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36550573" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TcpListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpListener extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpListener" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpListener" />
  <TypeSignature Language="F#" Value="type TcpListener = class" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Écoute des connexions de clients réseau TCP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Net.Sockets.TcpListener> classe fournit des méthodes simples qui écoutent et acceptent les demandes de connexion entrante en mode blocage synchrone. Vous pouvez utiliser un <xref:System.Net.Sockets.TcpClient> ou un <xref:System.Net.Sockets.Socket> pour vous connecter avec un <xref:System.Net.Sockets.TcpListener>. Créer un <xref:System.Net.Sockets.TcpListener> à l’aide un <xref:System.Net.IPEndPoint>, une adresse IP locale et numéro de port ou seulement un numéro de port. Spécifiez <xref:System.Net.IPAddress.Any> pour l’adresse IP locale et 0 pour le numéro de port local si vous souhaitez que le fournisseur de services sous-jacent assigne ces valeurs pour vous. Si vous choisissez pour ce faire, vous pouvez utiliser le <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propriété pour identifier les informations assignées une fois le socket connecté.  
  
 Utilisez la <xref:System.Net.Sockets.TcpListener.Start%2A> méthode commencer à écouter les demandes de connexion entrantes. <xref:System.Net.Sockets.TcpListener.Start%2A> file d’attente les connexions entrantes jusqu'à ce que vous appeliez soit le <xref:System.Net.Sockets.TcpListener.Stop%2A> (méthode), ou il a mis en attente <xref:System.Net.Sockets.SocketOptionName.MaxConnections>. Utilisez <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> ou <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> pour extraire une connexion à partir de la file d’attente de demande connexion entrante. Ces deux méthodes se bloquent. Si vous souhaitez éviter le blocage, vous pouvez utiliser la <xref:System.Net.Sockets.TcpListener.Pending%2A> méthode afin de déterminer si les demandes de connexion sont disponibles dans la file d’attente.  
  
 Appelez le <xref:System.Net.Sockets.TcpListener.Stop%2A> méthode pour fermer le <xref:System.Net.Sockets.TcpListener>.  
  
> [!NOTE]
>  Le <xref:System.Net.Sockets.TcpListener.Stop%2A> méthode ne ferme pas les connexions acceptées. Vous êtes chargé de fermer ces séparément.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.TcpListener>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 Consultez <xref:System.Net.Sockets.TcpClient> pour obtenir un exemple de client.  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Pour établir une connexion sortante ou accepter une demande entrante.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use TcpListener (IPAddress address, int port) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Port sur lequel écouter les tentatives de connexion entrante.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.TcpListener" /> qui écoute sur le port spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est obsolète. Utilisez le <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=nameWithType> ou <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType> constructeurs.  
  
 Ce constructeur vous permet de spécifier le numéro de port sur lequel écouter les tentatives de connexion entrante. Avec ce constructeur, le fournisseur de services sous-jacent assigne l’adresse réseau la plus appropriée. Si vous ne souhaitez pas le port local est utilisé, vous pouvez spécifier 0 pour le numéro de port. Dans ce cas, le fournisseur de services affecte un nombre de ports éphémères disponibles. Si vous utilisez cette approche, vous pouvez découvrir quel numéro d’adresse et le port de réseau local a été attribué à l’aide de la <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propriété.  
  
 Appelez le <xref:System.Net.Sockets.TcpListener.Start%2A> méthode commencer à écouter les tentatives de connexion entrantes.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.TcpListener> à l’aide d’un numéro de port local.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> n'est pas entre <see cref="F:System.Net.IPEndPoint.MinPort" /> et <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPEndPoint -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <see cref="T:System.Net.IPEndPoint" /> qui représente le point de terminaison local auquel lier l'écouteur <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.TcpListener" /> avec le point de terminaison local spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur vous permet de spécifier l’adresse IP locale et tente de numéro de port sur lequel écouter les connexions entrantes. Avant d’utiliser ce constructeur, vous devez créer un <xref:System.Net.IPEndPoint> à l’aide de l’IP locale adresse et le port numéro souhaités. Passer ce <xref:System.Net.IPEndPoint> au constructeur en tant que le `localEP` paramètre.  
  
 Si vous ne souhaitez pas quelle adresse locale est affectée, vous pouvez créer un <xref:System.Net.IPEndPoint> à l’aide de <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> en tant que le paramètre d’adresse et le service sous-jacent fournisseur assigne l’adresse réseau la plus appropriée. Cela peut vous aider à simplifier votre application si vous avez plusieurs interfaces réseau. Si vous ne souhaitez pas de port local est utilisé, vous pouvez créer un <xref:System.Net.IPEndPoint> à l’aide de 0 pour le numéro de port. Dans ce cas, le fournisseur de services affecte un nombre de ports éphémères disponibles. Si vous utilisez cette approche, vous pouvez découvrir quel numéro d’adresse et le port de réseau local a été attribué à l’aide de la <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propriété.  
  
 Appelez le <xref:System.Net.Sockets.TcpListener.Start%2A> méthode commencer à écouter les tentatives de connexion entrantes.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée une instance de la <xref:System.Net.Sockets.TcpListener> classe à l’aide du point de terminaison local.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPAddress localaddr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPAddress localaddr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localaddr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPAddress ^ localaddr, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPAddress * int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener (localaddr, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localaddr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localaddr">
          <see cref="T:System.Net.IPAddress" /> qui représente l'adresse IP locale.</param>
        <param name="port">Port sur lequel écouter les tentatives de connexion entrante.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.TcpListener" /> qui écoute les tentatives de connexion entrante sur l'adresse IP locale et le numéro de port spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur vous permet de spécifier l’adresse IP locale et tente de numéro de port sur lequel écouter les connexions entrantes. Avant d’appeler ce constructeur vous devez d’abord créer un <xref:System.Net.IPAddress> à l’aide de l’adresse locale souhaitée. Passer ce <xref:System.Net.IPAddress> au constructeur en tant que le `localaddr` paramètre. Si vous ne souhaitez pas quelle adresse locale est affectée, spécifiez <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> pour la `localaddr` paramètre et le fournisseur de services sous-jacent assignera l’adresse réseau la plus appropriée. Cela peut vous aider à simplifier votre application si vous avez plusieurs interfaces réseau. Si vous ne souhaitez pas le port local est utilisé, vous pouvez spécifier 0 pour le numéro de port. Dans ce cas, le fournisseur de services affecte un numéro de port disponible entre 1024 et 5000. Si vous utilisez cette approche, vous pouvez découvrir quel numéro d’adresse et le port de réseau local a été attribué à l’aide de la <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propriété.  
  
 Appelez le <xref:System.Net.Sockets.TcpListener.Start%2A> méthode commencer à écouter les tentatives de connexion entrantes.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée une instance de la <xref:System.Net.Sockets.TcpListener> classe à l’aide d’un numéro d’adresse et le port IP local.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localaddr" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> n'est pas entre <see cref="F:System.Net.IPEndPoint.MinPort" /> et <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket AcceptSocket ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket AcceptSocket() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocket" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocket () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ AcceptSocket();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocket : unit -&gt; System.Net.Sockets.Socket" Usage="tcpListener.AcceptSocket " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accepte une demande de connexion en attente.</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> utilisé pour envoyer et recevoir des données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> est une méthode bloquante qui retourne un <xref:System.Net.Sockets.Socket> que vous pouvez utiliser pour envoyer et recevoir des données. Si vous souhaitez éviter le blocage, utilisez la <xref:System.Net.Sockets.TcpListener.Pending%2A> méthode pour déterminer si les demandes de connexion sont disponibles dans la file d’attente de connexion entrante.  
  
 Le <xref:System.Net.Sockets.Socket> retourné est initialisé avec l’adresse IP et port numéro de l’hôte distant. Vous pouvez utiliser toutes les <xref:System.Net.Sockets.Socket.Send%2A> et <xref:System.Net.Sockets.Socket.Receive%2A> méthodes disponibles dans la <xref:System.Net.Sockets.Socket> classe pour communiquer avec l’hôte distant. Lorsque vous avez terminé à l’aide de la <xref:System.Net.Sockets.Socket>, veillez à appeler son <xref:System.Net.Sockets.Socket.Close%2A> (méthode). Si votre application est relativement simple, envisagez d’utiliser le <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> méthode plutôt que la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (méthode). <xref:System.Net.Sockets.TcpClient> Fournit des méthodes simples pour envoyer et recevoir des données sur un réseau en mode blocage synchrone.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Dans l’exemple de code suivant, le <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> méthode est utilisée pour retourner un <xref:System.Net.Sockets.Socket>. Cela <xref:System.Net.Sockets.Socket> est utilisé pour communiquer avec le client qui vient d’être connecté.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'écouteur n'a pas démarré avec un appel à la méthode <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocketAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt; AcceptSocketAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.Socket&gt; AcceptSocketAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocketAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocketAsync () As Task(Of Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::Socket ^&gt; ^ AcceptSocketAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocketAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;" Usage="tcpListener.AcceptSocketAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accepte une demande de connexion en attente en tant qu'opération asynchrone.</summary>
        <returns>Retourne <see cref="T:System.Threading.Tasks.Task`1" />  Objet de tâche représentant l’opération asynchrone. La propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> sur l'objet de tâche retourne un <see cref="T:System.Net.Sockets.Socket" /> utilisé pour envoyer et recevoir des données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération ne bloque pas. Retourné <xref:System.Threading.Tasks.Task%601> objet s’achève une fois la connexion de socket a été acceptée.  
  
 Le <xref:System.Net.Sockets.Socket> retournée dans <xref:System.Threading.Tasks.Task%601> est initialisé avec l’adresse IP et port numéro de l’hôte distant. Vous pouvez utiliser toutes les <xref:System.Net.Sockets.Socket.Send%2A> et <xref:System.Net.Sockets.Socket.Receive%2A> méthodes disponibles dans la <xref:System.Net.Sockets.Socket> classe pour communiquer avec l’hôte distant. Lorsque vous avez terminé à l’aide de la <xref:System.Net.Sockets.Socket>, veillez à appeler son <xref:System.Net.Sockets.Socket.Close%2A> (méthode). Si votre application est relativement simple, envisagez d’utiliser le <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> méthode plutôt que la <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A> (méthode). <xref:System.Net.Sockets.TcpClient> Fournit des méthodes simples pour envoyer et recevoir des données sur un réseau en mode blocage synchrone.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'écouteur n'a pas démarré avec un appel à la méthode <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient AcceptTcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient AcceptTcpClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClient () As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ AcceptTcpClient();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClient : unit -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.AcceptTcpClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accepte une demande de connexion en attente.</summary>
        <returns>
          <see cref="T:System.Net.Sockets.TcpClient" /> utilisé pour envoyer et recevoir des données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> est une méthode bloquante qui retourne un <xref:System.Net.Sockets.TcpClient> que vous pouvez utiliser pour envoyer et recevoir des données. Utilisez la <xref:System.Net.Sockets.TcpListener.Pending%2A> méthode pour déterminer si les demandes de connexion sont disponibles dans la file d’attente de connexion entrant si vous souhaitez éviter le blocage.  
  
 Utilisez le <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.NetworkStream> de retourné <xref:System.Net.Sockets.TcpClient>. Le <xref:System.Net.Sockets.NetworkStream> vous fournira avec des méthodes pour l’envoi et de réception avec l’hôte distant. Lorsque vous avez fini avec la <xref:System.Net.Sockets.TcpClient>, veillez à appeler son <xref:System.Net.Sockets.TcpClient.Close%2A> (méthode). Si vous souhaitez que la plus grande souplesse qu’un <xref:System.Net.Sockets.TcpClient> offres, envisagez d’utiliser <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Dans l’exemple de code suivant, le <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> méthode est utilisée pour retourner un <xref:System.Net.Sockets.TcpClient>. Cela <xref:System.Net.Sockets.TcpClient> est utilisé pour communiquer avec le client qui vient d’être connecté.  
  
 [!code-cpp[Classic TcpListenerExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListenerExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListenerExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListenerExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListenerExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListenerExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'écouteur n'a pas démarré avec un appel à la méthode <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Utilisez la propriété <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> pour obtenir le code d'erreur spécifique. Quand vous avez obtenu ce code, vous pouvez consulter la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClientAsync () As Task(Of TcpClient)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::TcpClient ^&gt; ^ AcceptTcpClientAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClientAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;" Usage="tcpListener.AcceptTcpClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accepte une demande de connexion en attente en tant qu'opération asynchrone.</summary>
        <returns>Retourne <see cref="T:System.Threading.Tasks.Task`1" />  Objet de tâche représentant l’opération asynchrone. La propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> sur l'objet de tâche retourne un <see cref="T:System.Net.Sockets.TcpClient" /> utilisé pour envoyer et recevoir des données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération ne bloque pas. Retourné <xref:System.Threading.Tasks.Task%601> objet s’achève une fois la connexion TCP a été acceptée.  
  
 Utilisez le <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.NetworkStream> de retourné <xref:System.Net.Sockets.TcpClient> dans le <xref:System.Threading.Tasks.Task%601>. Le <xref:System.Net.Sockets.NetworkStream> vous fournira avec des méthodes pour l’envoi et de réception avec l’hôte distant. Lorsque vous avez fini avec la <xref:System.Net.Sockets.TcpClient>, veillez à appeler son <xref:System.Net.Sockets.TcpClient.Close%2A> (méthode). Si vous souhaitez que la plus grande souplesse qu’un <xref:System.Net.Sockets.TcpClient> offres, envisagez d’utiliser <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> ou <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'écouteur n'a pas démarré avec un appel à la méthode <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Utilisez la propriété <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> pour obtenir le code d'erreur spécifique. Quand vous avez obtenu ce code, vous pouvez consulter la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Active" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool" Usage="System.Net.Sockets.TcpListener.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Net.Sockets.TcpListener" /> écoute activement des connexions clientes.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Net.Sockets.TcpListener" /> écoute activement ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de <xref:System.Net.Sockets.TcpListener> pouvez utiliser cette propriété pour déterminer si le <xref:System.Net.Sockets.Socket> est actuellement à l’écoute des tentatives de connexion entrante. Le <xref:System.Net.Sockets.TcpClient.Active%2A> propriété peut être utilisée pour éviter la redondance <xref:System.Net.Sockets.TcpListener.Start%2A> tentatives.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="tcpListener.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowed">Valeur booléenne qui spécifie s'il faut activer ou désactiver la traversée du NAT.</param>
        <summary>Active ou désactive la traversée du traducteur d'accès réseau (NAT) sur une instance de <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> méthode est utilisée pour activer ou désactiver parcours NAT pour une <xref:System.Net.Sockets.TcpListener> instance. Parcours NAT peut être fourni à l’aide d’un tunnel ISATAP, 6to4 ou Teredo.  
  
 Lorsque le `allowed` paramètre est false, le <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> option du socket associé a la valeur <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>. Cela désactive explicitement la traversée NAT pour une <xref:System.Net.Sockets.TcpListener> instance.  
  
 Lorsque le `allowed` paramètre est true, le <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> option du socket associé a la valeur <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Cela peut permettre de parcours NAT pour une <xref:System.Net.Sockets.TcpListener> selon les règles de pare-feu en place sur le système.  
  
 Le <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> méthode doit être appelée avant d’appeler le <xref:System.Net.Sockets.TcpListener.Start%2A> méthode commencer à écouter les demandes de connexion entrantes (avant que le socket est lié). Si <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> méthode est appelée après le <xref:System.Net.Sockets.TcpListener.Start%2A> (méthode), alors un <xref:System.InvalidOperationException> sera levée.  
  
 Une adresse Teredo est une adresse IPv6 avec le préfixe de 2001 :: / 32. Adresses Teredo peuvent être retournées par la résolution de nom DNS normale ou énumérées comme une adresse IPv6 affectée à une interface locale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" /> a été appelée après l'appel à la méthode <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptSocket">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptSocket(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptSocket (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptSocket(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptSocket : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptSocket (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur comportant des informations sur l'opération d'acceptation. Cet objet est passé au délégué <c>callback</c> quand l’opération est terminée.</param>
        <summary>Démarre une opération asynchrone pour accepter une tentative de connexion entrante.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui fait référence à la création asynchrone de <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> (méthode). En règle générale, la méthode est appelée par le `callback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez le <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (méthode).  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [appel asynchrone des méthodes synchrones](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Vous pouvez appeler la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriété retourné <xref:System.Net.Sockets.Socket> pour identifier le numéro d’adresse et le port réseau de l’hôte distant.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN library à [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) pour une liste détaillée Description de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> méthode pour créer et connecter un socket. Le délégué de rappel appelle la <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> méthode pour terminer la demande asynchrone.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptTcpClient">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptTcpClient(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptTcpClient (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptTcpClient(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptTcpClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptTcpClient (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur comportant des informations sur l'opération d'acceptation. Cet objet est passé au délégué <c>callback</c> quand l’opération est terminée.</param>
        <summary>Démarre une opération asynchrone pour accepter une tentative de connexion entrante.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui fait référence à la création asynchrone de <see cref="T:System.Net.Sockets.TcpClient" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> (méthode). En règle générale, la méthode est appelée par le `callback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez le <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> (méthode).  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [appel asynchrone des méthodes synchrones](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN library à [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) pour une liste détaillée Description de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> méthode pour créer et connecter un socket. Le délégué de rappel appelle la <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> méthode pour terminer la demande asynchrone.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Net.Sockets.TcpListener Create (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.Sockets.TcpListener Create(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Create(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (port As Integer) As TcpListener" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::Sockets::TcpListener ^ Create(int port);" />
      <MemberSignature Language="F#" Value="static member Create : int -&gt; System.Net.Sockets.TcpListener" Usage="System.Net.Sockets.TcpListener.Create port" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpListener</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Port sur lequel écouter les tentatives de connexion entrante.</param>
        <summary>Crée une nouvelle instance <see cref="T:System.Net.Sockets.TcpListener" /> pour écouter sur le port spécifié.</summary>
        <returns>Retourne <see cref="T:System.Net.Sockets.TcpListener" />.  Nouvelle instance <see cref="T:System.Net.Sockets.TcpListener" /> à écouter sur le port spécifié.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAcceptSocket(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptSocket (asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAcceptSocket(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptSocket : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="tcpListener.EndAcceptSocket asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> retourné par un appel à la méthode <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />.</param>
        <summary>Accepte de manière asynchrone une tentative de connexion entrante et crée un nouveau <see cref="T:System.Net.Sockets.Socket" /> pour gérer les communications de l'hôte distant.</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" />
          <see cref="T:System.Net.Sockets.Socket" /> utilisé pour envoyer et recevoir des données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode s’interrompt jusqu'à ce que l’opération de fin. Pour effectuer cette opération de manière synchrone, utilisez la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (méthode).  
  
> [!NOTE]
>  Vous pouvez appeler la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriété retourné <xref:System.Net.Sockets.Socket> pour identifier le numéro d’adresse et le port réseau de l’hôte distant.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN library à [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) pour une liste détaillée Description de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> méthode pour créer et connecter un socket. Le délégué de rappel appelle la <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> méthode pour terminer la demande asynchrone.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="asyncResult" /> n'a pas été créé par un appel à la méthode <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" /> a été appelée au préalable.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès à <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient EndAcceptTcpClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptTcpClient (asyncResult As IAsyncResult) As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ EndAcceptTcpClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptTcpClient : IAsyncResult -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.EndAcceptTcpClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> retourné par un appel à la méthode <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />.</param>
        <summary>Accepte de manière asynchrone une tentative de connexion entrante et crée un nouveau <see cref="T:System.Net.Sockets.TcpClient" /> pour gérer les communications de l'hôte distant.</summary>
        <returns>
          <see cref="T:System.Net.Sockets.TcpClient" />
          <see cref="T:System.Net.Sockets.TcpClient" /> utilisé pour envoyer et recevoir des données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode s’interrompt jusqu'à ce que l’opération de fin. Pour effectuer cette opération de manière synchrone, utilisez la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> (méthode).  
  
> [!NOTE]
>  Vous pouvez appeler la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriété du socket sous-jacent (<xref:System.Net.Sockets.TcpClient.Client%2A>) pour identifier le numéro d’adresse et le port réseau de l’hôte distant.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN library à [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) pour une liste détaillée Description de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> méthode pour créer et connecter un socket. Le délégué de rappel appelle la <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> méthode pour terminer la demande asynchrone.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.TcpListener" /> n'autorise qu'un seul socket sous-jacent à écouter un port spécifique.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Net.Sockets.TcpListener" /> n'autorise qu'un seul <see cref="T:System.Net.Sockets.TcpListener" /> à écouter un port spécifique ; sinon, <see langword="false" />. . La valeur par défaut est <see langword="true" /> pour Windows Server 2003 et Windows XP Service Pack 2 et ultérieur, et <see langword="false" /> pour toutes les autres versions.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, plusieurs écouteurs peuvent écouter un port spécifique. Toutefois, seul le d'entre eux peut effectuer des opérations sur le trafic réseau envoyé au port. Si plusieurs écouteurs tente de se lier à un port particulier, celui dont l’adresse IP plus spécifique gère le trafic réseau envoyé à ce port. Vous pouvez utiliser le <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> propriété pour empêcher plusieurs écouteurs d’écouter un port spécifique.  
  
 Définissez cette propriété avant d’appeler <xref:System.Net.Sockets.TcpListener.Start%2A>, ou appelez le <xref:System.Net.Sockets.TcpListener.Stop%2A> (méthode), puis définissez cette propriété.  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit le <xref:System.Net.Sockets.TcpListener.ExclusiveAddressUse%2A> propriété.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#2)]
 [!code-vb[System.Net.Sockets.TcpListener1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.TcpListener" /> a démarré. Appelez la méthode <see cref="M:System.Net.Sockets.TcpListener.Stop" />, puis définissez la propriété <see cref="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket sous-jacent.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpListener ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tcpListener.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalEndpoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndpoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndpoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndpoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndpoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndpoint : System.Net.EndPoint" Usage="System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Net.EndPoint" /> sous-jacent du <see cref="T:System.Net.Sockets.TcpListener" /> actuel.</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> auquel <see cref="T:System.Net.Sockets.Socket" /> est lié.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propriété pour identifier le réseau local interface et numéro de port utilisé pour écouter les demandes entrantes des clients, une fois une connexion de socket a été établie. Vous devez tout d’abord effectuer un cast <xref:System.Net.EndPoint> à un <xref:System.Net.IPEndPoint>. Vous pouvez ensuite appeler la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> propriété à récupérer l’adresse IP locale et le <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> propriété à récupérer le numéro de port local.  
  
   
  
## Examples  
 L’exemple de code suivant affiche le nombre d’adresse et le port IP local sur lequel le <xref:System.Net.Sockets.TcpListener> est à l’écoute des demandes de connexion entrantes.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.EndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Pending">
      <MemberSignature Language="C#" Value="public bool Pending ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Pending() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Pending" />
      <MemberSignature Language="VB.NET" Value="Public Function Pending () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Pending();" />
      <MemberSignature Language="F#" Value="member this.Pending : unit -&gt; bool" Usage="tcpListener.Pending " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine la présence éventuelle de demandes de connexion en attente.</summary>
        <returns>
          <see langword="true" /> si des connexions sont en attente ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode non bloquante détermine s’il existe des demandes de connexion en attente. Étant donné que la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> et <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> méthodes bloquent l’exécution jusqu'à ce que le <xref:System.Net.Sockets.TcpListener.Start%2A> méthode a en file d’attente une demande de connexion entrante, le <xref:System.Net.Sockets.TcpListener.Pending%2A> méthode peut être utilisée pour déterminer si les connexions sont disponibles avant de tenter de les accepter.  
  
   
  
## Examples  
 Le code suivant exemple vérifie le <xref:System.Net.Sockets.TcpListener.Pending%2A> (méthode). Si une demande de connexion est en attente d’être acceptés, puis un appel à la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> méthode est effectuée.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'écouteur n'a pas démarré avec un appel à la méthode <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Server" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Server { System::Net::Sockets::Socket ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Net.Sockets.Socket" Usage="System.Net.Sockets.TcpListener.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Net.Sockets.Socket" /> réseau sous-jacent.</summary>
        <value>L'élément <see cref="T:System.Net.Sockets.Socket" /> sous-jacent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener> Crée un <xref:System.Net.Sockets.Socket> pour écouter les demandes entrantes des clients. Les classes dérivées de <xref:System.Net.Sockets.TcpListener> pouvez utiliser cette propriété pour obtenir <xref:System.Net.Sockets.Socket>. Utilisez sous-jacent <xref:System.Net.Sockets.Socket> retournée par le <xref:System.Net.Sockets.TcpListener.Server%2A> propriété si vous avez besoin d’accéder aux au-delà de celles qui <xref:System.Net.Sockets.TcpListener> fournit.  
  
> [!NOTE]
>  Le <xref:System.Net.Sockets.TcpListener.Server%2A> propriété renvoie uniquement les <xref:System.Net.Sockets.Socket> utilisé pour écouter les demandes entrantes des clients. Utilisez le <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> méthode pour accepter une demande de connexion en attente et obtenir un <xref:System.Net.Sockets.Socket> pour envoyer et recevoir des données. Vous pouvez également utiliser le <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> méthode pour accepter une demande de connexion en attente et obtenir un <xref:System.Net.Sockets.TcpClient> pour envoyer et recevoir des données.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.TcpListener.Server%2A> propriété. Sous-jacent <xref:System.Net.Sockets.Socket> est récupérée et le <xref:System.Net.Sockets.SocketOptionName.Linger> <xref:System.Net.Sockets.Socket> option est configurée pour le délai d’expiration après 10 secondes si les données sont conservées dans la mémoire tampon réseau après la fermeture de la connexion.  
  
 [!code-csharp[TcpListenerProtectedMembers1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListenerProtectedMembers1/CS/source.cs#1)]
 [!code-vb[TcpListenerProtectedMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListenerProtectedMembers1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre l'écoute de demandes de connexion entrante.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="tcpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Démarre l'écoute de demandes de connexion entrante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.TcpListener.Start%2A> méthode initialise sous-jacent <xref:System.Net.Sockets.Socket>lie à un point de terminaison local et écoute les tentatives de connexion entrantes. Si une demande de connexion est reçue, le <xref:System.Net.Sockets.TcpListener.Start%2A> méthode file d’attente de la demande et continue à écouter les demandes supplémentaires jusqu'à ce que vous appeliez la <xref:System.Net.Sockets.TcpListener.Stop%2A> (méthode). Si <xref:System.Net.Sockets.TcpListener> reçoit une demande de connexion une fois qu’il a déjà en file d’attente le nombre maximal de connexions, il lève une <xref:System.Net.Sockets.SocketException> sur le client.  
  
 Pour supprimer une connexion à partir de la file d’attente de connexion entrante, utiliser le <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> méthode ou la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (méthode). Le <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> méthode supprime une connexion à partir de la file d’attente et retourne un <xref:System.Net.Sockets.TcpClient> que vous pouvez utiliser pour envoyer et recevoir des données. Le <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> méthode retournera un <xref:System.Net.Sockets.Socket> que vous pouvez utiliser pour faire de même. Si votre application requiert uniquement les e/s synchrones, utilisez <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Pour plus de contrôle de comportement, utilisez <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>. Ces deux méthodes bloquent jusqu'à ce qu’une demande de connexion est disponible dans la file d’attente.  
  
 Utilisez le <xref:System.Net.Sockets.TcpListener.Stop%2A> méthode pour fermer le <xref:System.Net.Sockets.TcpListener> et arrêtent l’écoute. Vous êtes chargé de fermer vos connexions acceptées séparément.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment <xref:System.Net.Sockets.TcpListener.Start%2A> est utilisé pour écouter les tentatives de connexions clientes entrantes.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Utilisez la propriété <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> pour obtenir le code d'erreur spécifique. Quand vous avez obtenu ce code, vous pouvez consulter la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Start : int -&gt; unit" Usage="tcpListener.Start backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Longueur maximale de la file d'attente des connexions en attente.</param>
        <summary>Lance l'écoute des demandes de connexion entrantes avec un nombre maximal de connexions en attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.TcpListener.Start%2A> méthode initialise sous-jacent <xref:System.Net.Sockets.Socket>lie à un point de terminaison local et écoute les tentatives de connexion entrantes. Si une demande de connexion est reçue, <xref:System.Net.Sockets.TcpListener.Start%2A> sera file d’attente de la demande et continue à écouter les demandes supplémentaires jusqu'à ce que vous appeliez la <xref:System.Net.Sockets.TcpListener.Stop%2A> (méthode). Si <xref:System.Net.Sockets.TcpListener> reçoit une demande de connexion une fois qu’il a déjà en file d’attente le nombre maximal de connexions, il lève une <xref:System.Net.Sockets.SocketException> sur le client.  
  
 Pour supprimer une connexion à partir de la file d’attente de connexion entrante, utiliser le <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> méthode ou la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (méthode). Le <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> méthode supprime une connexion à partir de la file d’attente et retourne un <xref:System.Net.Sockets.TcpClient> que vous pouvez utiliser pour envoyer et recevoir des données. Le <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> méthode retournera un <xref:System.Net.Sockets.Socket> que vous pouvez utiliser pour faire de même. Si votre application requiert uniquement les e/s synchrones, utilisez le <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Pour plus de contrôle de comportement, utilisez <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (méthode). Ces deux méthodes bloquent jusqu'à ce qu’une demande de connexion est disponible dans la file d’attente.  
  
 Utilisez le <xref:System.Net.Sockets.TcpListener.Stop%2A> méthode pour fermer le <xref:System.Net.Sockets.TcpListener> et arrêtent l’écoute. Vous êtes chargé de fermer vos connexions acceptées séparément.  
  
> [!NOTE]
>  Utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN library à [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment <xref:System.Net.Sockets.TcpListener.Start%2A> est utilisé pour écouter les tentatives de connexions clientes entrantes.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de l'accès au socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="backlog" /> est inférieur à zéro ou dépasse le nombre maximal de connexions autorisées.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent est null.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="tcpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme l'écouteur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.Stop%2A> Ferme l’écouteur. Toutes les demandes de connexion non acceptées dans la file d’attente seront perdues. Hôtes distants en attente d’une connexion d’être acceptés lèvera une <xref:System.Net.Sockets.SocketException>. Vous êtes chargé de fermer vos connexions acceptées séparément.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Net.Sockets.TcpListener.Stop%2A> méthode sous-jacent <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Utilisez la propriété <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> pour obtenir le code d'erreur spécifique. Quand vous avez obtenu ce code, vous pouvez consulter la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.</exception>
        <block subset="none" type="usage">
          <para>Le <see cref="M:System.Net.Sockets.TcpListener.Stop" /> méthode ferme également sous-jacent <see cref="T:System.Net.Sockets.Socket" />et crée un nouveau <see cref="T:System.Net.Sockets.Socket" /> pour le <see cref="T:System.Net.Sockets.TcpListener" />. Si vous définissez des propriétés sur sous-jacent <see cref="T:System.Net.Sockets.Socket" /> avant d’appeler le <see cref="M:System.Net.Sockets.TcpListener.Stop" /> (méthode), ces propriétés ne seront pas reprises au nouveau <see cref="T:System.Net.Sockets.Socket" />.</para>
        </block>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
  </Members>
</Type>