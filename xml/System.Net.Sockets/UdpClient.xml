<Type Name="UdpClient" FullName="System.Net.Sockets.UdpClient">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f263c49be787811b27cf3eaa57ce140baff48b28" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37644288" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UdpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UdpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.UdpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class UdpClient&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class UdpClient : IDisposable" />
  <TypeSignature Language="F#" Value="type UdpClient = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit les services de réseau UDP (User Datagram Protocol).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient> classe fournit des méthodes simples pour envoyer et recevoir des datagrammes UDP sans connexion en mode blocage synchrone. UDP étant un protocole de transport sans connexion, vous n’avez pas besoin d’établir une connexion d’hôte distant avant d’envoyer et recevoir des données. Toutefois, avoir la possibilité de l’établissement d’un hôte distant par défaut dans un des deux manières suivantes :  
  
-   Créez une instance de la <xref:System.Net.Sockets.UdpClient> classe en utilisant le nom de l’hôte distant et le numéro de port en tant que paramètres.  
  
-   Créez une instance de la <xref:System.Net.Sockets.UdpClient> classe, puis appelez le <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode).  
  
 Vous pouvez utiliser une des méthodes d’envoi fournies dans le <xref:System.Net.Sockets.UdpClient> pour envoyer des données à un périphérique distant. Utilisez le <xref:System.Net.Sockets.UdpClient.Receive%2A> méthode pour recevoir des données à partir d’hôtes distants.  
  
> [!NOTE]
>  N’appelez pas <xref:System.Net.Sockets.UdpClient.Send%2A> à l’aide d’un nom d’hôte ou <xref:System.Net.IPEndPoint> si vous avez déjà spécifié un hôte distant par défaut. Si vous le faites, <xref:System.Net.Sockets.UdpClient> lève une exception.  
  
 <xref:System.Net.Sockets.UdpClient> méthodes vous permettent également d’envoyer et recevoir des datagrammes multicast. Utilisez le <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> méthode pour vous abonner un <xref:System.Net.Sockets.UdpClient> à un groupe multicast. Utilisez le <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> méthode pour annuler l’abonnement un <xref:System.Net.Sockets.UdpClient> à partir d’un groupe de multidiffusion.  
  
   
  
## Examples  
 L’exemple suivant établit une <xref:System.Net.Sockets.UdpClient> connexion à l’aide du nom d’hôte www.contoso.com sur le port 11000. Un petit message de chaîne est envoyé à deux ordinateurs hôtes distants séparés. Le <xref:System.Net.Sockets.UdpClient.Receive%2A> méthode bloque l’exécution jusqu'à ce qu’un message est reçu. À l’aide de la <xref:System.Net.IPEndPoint> passé à <xref:System.Net.Sockets.UdpClient.Receive%2A>, l’identité de l’hôte qui répond est révélée.  
  
 [!code-cpp[Classic UdpClientExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClientExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClientExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClientExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClientExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Pour établir une connexion sortante ou accepter une demande entrante.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.UdpClient" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.UdpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un nouveau <xref:System.Net.Sockets.UdpClient> et permet au fournisseur de service sous-jacent affecter le plus approprié local IPv4 adresse et numéro de port. Si ce constructeur est utilisé, le <xref:System.Net.Sockets.UdpClient> instance est définie avec une famille d’adresses IPv4 qui ne peut pas être modifié ou remplacé par un appel de méthode connect avec une cible d’IPv6.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Ce constructeur n’est pas approprié pour rejoindre un groupe multicast, car il n’effectue pas de liaison du socket. En outre, il fonctionne uniquement avec les types d’adresses IPv4.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le constructeur par défaut pour créer une instance de la <xref:System.Net.Sockets.UdpClient> classe.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Numéro de port local à partir duquel vous souhaitez communiquer.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.UdpClient" /> et la lie au numéro de port local fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un sous-jacent <xref:System.Net.Sockets.Socket> et le lie au numéro de port à partir de laquelle vous souhaitez communiquer. Utilisez ce constructeur si vous vous intéressez uniquement dans la définition du numéro de port local. Le fournisseur de services sous-jacent assigne l’adresse IP locale. Si vous passez 0 au constructeur, le fournisseur de services sous-jacent affecte un numéro de port. Si ce constructeur est utilisé, le <xref:System.Net.Sockets.UdpClient> instance est définie avec une famille d’adresses IPv4 qui ne peut pas être modifié ou remplacé par un appel de méthode connect avec une cible d’IPv6.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Ce constructeur fonctionne uniquement avec les types d’adresses IPv4.  
  
   
  
## Examples  
 L’exemple suivant montre à l’aide d’un numéro de port local pour créer une instance de la <xref:System.Net.Sockets.UdpClient> classe.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="port" /> est supérieur au champ <see cref="F:System.Net.IPEndPoint.MaxPort" /> ou inférieur au champ <see cref="F:System.Net.IPEndPoint.MinPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.IPEndPoint -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <see cref="T:System.Net.IPEndPoint" /> qui représente le point de terminaison local auquel lier la connexion UDP.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.UdpClient" /> et la lie au point de terminaison local spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un nouveau <xref:System.Net.Sockets.UdpClient> et le lie à la <xref:System.Net.IPEndPoint> spécifié par le `localEP` paramètre. Avant d’appeler ce constructeur, vous devez créer un <xref:System.Net.IPEndPoint> à l’aide de l’adresse IP et port numéro à partir de laquelle vous souhaitez envoyer et recevoir des données. Vous n’avez pas besoin de spécifier un numéro d’adresse et le port IP local pour envoyer et recevoir des données. Si vous ne le faites pas, le fournisseur de services sous-jacent affectera le plus approprié local IP adresse et numéro de port.  
  
 Si ce constructeur est utilisé, le <xref:System.Net.Sockets.UdpClient> instance est définie avec la famille d’adresses spécifiée par le `localEP` paramètre qui ne peut pas être modifié ou remplacé par un appel de méthode connect avec une famille d’adresses différentes.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une instance de la <xref:System.Net.Sockets.UdpClient> classe à l’aide d’un point de terminaison local.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient family" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family">Une des valeurs <see cref="T:System.Net.Sockets.AddressFamily" /> qui spécifie le schéma d'adressage du socket.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.UdpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `family` paramètre détermine si l’écouteur utilise une adresse IP version 4 (IPv4) ou une adresse IP version 6 (IPv6) adresse. Pour utiliser une adresse IPv4, passez la <xref:System.Net.Sockets.AddressFamily.InterNetwork> valeur. Pour utiliser une adresse IPv6, passez la <xref:System.Net.Sockets.AddressFamily.InterNetworkV6> valeur. En passant de toute autre valeur entraîne la méthode lève un <xref:System.ArgumentException>.  
  
 Si ce constructeur est utilisé, le <xref:System.Net.Sockets.UdpClient> instance est définie avec la famille d’adresses spécifiée par le `family` paramètre qui ne peut pas être modifié ou remplacé par un appel de méthode connect avec une famille d’adresses différentes.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Le <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType> n’est pas approprié pour rejoindre un groupe multicast, car il n’effectue pas de liaison du socket.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="family" /> n'est pas <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />, ni <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port, System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port, valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32,System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer, family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port, System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int * System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (port, family)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="port">Port sur lequel écouter les tentatives de connexion entrante.</param>
        <param name="family">Une des valeurs <see cref="T:System.Net.Sockets.AddressFamily" /> qui spécifie le schéma d'adressage du socket.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.UdpClient" /> et la lie au numéro de port local fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un sous-jacent <xref:System.Net.Sockets.Socket> et le lie au numéro de port à partir de laquelle vous souhaitez communiquer.  
  
 Le `family` paramètre détermine si l’écouteur utilise une adresse IP version 4 (IPv4) ou une adresse IP version 6 (IPv6) adresse. Pour utiliser une adresse IPv4, passez la <xref:System.Net.Sockets.AddressFamily.InterNetwork> valeur. Pour utiliser une adresse IPv6, passez la <xref:System.Net.Sockets.AddressFamily.InterNetworkV6> valeur. En passant de toute autre valeur entraîne la méthode lève un <xref:System.ArgumentException>.  
  
 Si ce constructeur est utilisé, le <xref:System.Net.Sockets.UdpClient> instance est définie avec la famille d’adresses spécifiée par le `family` paramètre qui ne peut pas être modifié ou remplacé par un appel de méthode connect avec une famille d’adresses différentes.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, consultez la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un client UDP à utiliser dans un groupe de multidiffusion.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#3)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="family" /> n'est pas <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />, ni <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> est supérieur à <see cref="F:System.Net.IPEndPoint.MaxPort" /> ou inférieur à <see cref="F:System.Net.IPEndPoint.MinPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : string * int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (hostname, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nom de l'hôte DNS distant auquel vous souhaitez vous connecter.</param>
        <param name="port">Numéro de port distant auquel vous souhaitez vous connecter.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Sockets.UdpClient" /> et établit un hôte distant par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise un nouveau <xref:System.Net.Sockets.UdpClient> et établit un hôte distant à l’aide de la `hostname` et `port` paramètres. L’établissement d’un hôte distant par défaut est facultatif. Si vous utilisez ce constructeur, il est inutile de spécifier un hôte distant dans chaque appel à la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode). Spécification d’un hôte distant par défaut vous limite à l’hôte uniquement. Vous pouvez modifier l’hôte distant par défaut à tout moment en appelant le <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode). Si vous souhaitez spécifier un hôte distant dans votre appel à la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode), n’utilisez pas ce constructeur.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une instance de la <xref:System.Net.Sockets.UdpClient> classe à l’aide d’un nom d’hôte et le numéro de port.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostname" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> n'est pas entre <see cref="F:System.Net.IPEndPoint.MinPort" /> et <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Active" />
      <MemberSignature Language="VB.NET" Value="Protected Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool with get, set" Usage="System.Net.Sockets.UdpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si un hôte distant par défaut a été établi.</summary>
        <value>
          <see langword="true" /> si une connexion est active ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de <xref:System.Net.Sockets.UdpClient> pouvez utiliser cette propriété pour déterminer si un hôte distant par défaut a été établi. Vous pouvez établir un hôte distant par défaut à l’aide du constructeur approprié ou en appelant le <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode). Si vous établissez un hôte distant par défaut, vous ne pouvez pas spécifier un hôte distant dans votre appel à <xref:System.Net.Sockets.UdpClient.Send%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.UdpClient" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="udpClient.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowed">Valeur booléenne qui spécifie s'il faut activer ou désactiver la traversée du NAT.</param>
        <summary>Active ou désactive la traversée du traducteur d'accès réseau (NAT) sur une instance de <see cref="T:System.Net.Sockets.UdpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.AllowNatTraversal%2A> méthode est utilisée pour activer ou désactiver le parcours NAT pour une <xref:System.Net.Sockets.UdpClient> instance. Parcours NAT peut être fourni à l’aide de Teredo, 6to4 ou un tunnel ISATAP.  
  
 Lorsque le `allowed` paramètre est false, le <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> option du socket associé a la valeur <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>. Cela désactive explicitement NAT traversal pour un <xref:System.Net.Sockets.UdpClient> instance.  
  
 Lorsque le `allowed` paramètre est true, le <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> option du socket associé a la valeur <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Cela peut permettre de parcours NAT pour une <xref:System.Net.Sockets.UdpClient> selon les règles de pare-feu en place sur le système.  
  
 Une adresse Teredo est une adresse IPv6 avec le préfixe de 2001 :: / 32. Adresses Teredo peuvent être retournées via la résolution de nom DNS normale ou énumérées comme une adresse IPv6 affectée à une interface locale.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.UdpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le volume de données reçues du réseau et accessibles en lecture.</summary>
        <value>Nombre d'octets de données reçues du réseau.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.Available%2A> propriété est utilisée pour déterminer la quantité de données en file d’attente dans la mémoire tampon réseau pour la lecture. Si les données sont disponibles, appelez <xref:System.Net.Sockets.NetworkStream.Read%2A> pour obtenir les données. Si aucune donnée n’est disponible, le <xref:System.Net.Sockets.UdpClient.Available%2A> propriété retourne 0.  
  
 Si l’hôte distant arrête ou ferme la connexion, le <xref:System.Net.Sockets.UdpClient.Available%2A> propriété lève une <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique et reportez-vous à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN library à le [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library)/ pour une description détaillée de la erreur.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.UdpClient.Available%2A> propriété.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginReceive (requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="requestCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui comporte des informations sur l'opération de réception. Cet objet est passé au délégué <c>requestCallback</c> quand l’opération est terminée.</param>
        <summary>Reçoit un datagramme d'un hôte distant de manière asynchrone.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui fait référence à la réception asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.UdpClient.BeginReceive%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.UdpClient.EndReceive%2A> (méthode). En règle générale, la méthode est appelée par le `requestCallback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez le <xref:System.Net.Sockets.UdpClient.Receive%2A> (méthode).  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.UdpClient.BeginReceive%2A> réception asynchrone d’une réponse du serveur.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envoie un datagramme à un hôte distant de manière asynchrone.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">Tableau <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="bytes">Le nombre d’octets à envoyer.</param>
        <param name="requestCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui comporte des informations sur l'opération d'envoi. Cet objet est passé au délégué <c>requestCallback</c> quand l’opération est terminée.</param>
        <summary>Envoie un datagramme à un hôte distant de manière asynchrone. La destination a été spécifiée précédemment par un appel à <see cref="Overload:System.Net.Sockets.UdpClient.Connect" />.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.UdpClient.BeginSend%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.UdpClient.EndSend%2A> (méthode). En règle générale, la méthode est appelée par le `requestCallback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.UdpClient.Send%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.UdpClient.BeginSend%2A> pour envoyer une demande de serveur de façon asynchrone.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.Net.IPEndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * System.Net.IPEndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, endPoint, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">Tableau <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="bytes">Le nombre d’octets à envoyer.</param>
        <param name="endPoint">
          <see cref="T:System.Net.EndPoint" /> qui représente la destination des données.</param>
        <param name="requestCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui comporte des informations sur l'opération d'envoi. Cet objet est passé au délégué <c>requestCallback</c> quand l’opération est terminée.</param>
        <summary>Envoie un datagramme à une destination de manière asynchrone. La destination est spécifiée par un <see cref="T:System.Net.EndPoint" />.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.UdpClient.BeginSend%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.UdpClient.EndSend%2A> (méthode). En règle générale, la méthode est appelée par le `requestCallback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.UdpClient.Send%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.UdpClient.BeginSend%2A> pour envoyer une demande de serveur de façon asynchrone.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, string hostname, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, hostname As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, hostname, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">Tableau <see cref="T:System.Byte" /> qui contient les données à envoyer.</param>
        <param name="bytes">Le nombre d’octets à envoyer.</param>
        <param name="hostname">Hôte de destination.</param>
        <param name="port">Numéro du port de destination.</param>
        <param name="requestCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l'opération est terminée.</param>
        <param name="state">Objet défini par l'utilisateur qui comporte des informations sur l'opération d'envoi. Cet objet est passé au délégué <c>requestCallback</c> quand l’opération est terminée.</param>
        <summary>Envoie un datagramme à une destination de manière asynchrone. La destination est spécifiée par le nom d'hôte et le numéro de port.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui fait référence à l'envoi asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.Net.Sockets.UdpClient.BeginSend%2A> opération doit être effectuée en appelant le <xref:System.Net.Sockets.UdpClient.EndSend%2A> (méthode). En règle générale, la méthode est appelée par le `requestCallback` déléguer.  
  
 Cette méthode ne bloque pas jusqu'à ce que l’opération est terminée. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Sockets.UdpClient.Send%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.UdpClient.BeginSend%2A> pour envoyer une demande de serveur de façon asynchrone.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Client" />
      <MemberSignature Language="VB.NET" Value="Public Property Client As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Client : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.UdpClient.Client" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Net.Sockets.Socket" /> de réseau sous-jacent.</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> de réseau sous-jacent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient> Crée un <xref:System.Net.Sockets.Socket> utilisé pour envoyer et recevoir des données sur un réseau. Les classes dérivées de <xref:System.Net.Sockets.UdpClient> cette propriété permet d’obtenir ou définir ce <xref:System.Net.Sockets.Socket>. Utilisez sous-jacent <xref:System.Net.Sockets.Socket> retourné à partir de <xref:System.Net.Sockets.UdpClient.Client%2A> si vous avez besoin d’accéder aux au-delà de celles qui <xref:System.Net.Sockets.UdpClient> fournit. Vous pouvez également utiliser <xref:System.Net.Sockets.UdpClient.Client%2A> définir sous-jacent <xref:System.Net.Sockets.Socket> à un existant <xref:System.Net.Sockets.Socket>. Cela est utile si vous souhaitez tirer parti de la simplicité de <xref:System.Net.Sockets.UdpClient> à l’aide d’un préexistants <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Net.Sockets.UdpClient.Client%2A> propriété. Dans cet exemple, la diffusion est activée pour sous-jacent <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="udpClient.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme la connexion UDP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.Close%2A> désactive sous-jacent <xref:System.Net.Sockets.Socket> et libère toutes les ressources managées et non managées associées le <xref:System.Net.Sockets.UdpClient>.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple suivant illustre la fermeture un <xref:System.Net.Sockets.UdpClient> en appelant le <xref:System.Net.Sockets.UdpClient.Close%2A> (méthode).  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Établit un hôte distant par défaut.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (endPoint As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPEndPoint -&gt; unit" Usage="udpClient.Connect endPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" /> qui spécifie le point de terminaison du réseau auquel vous souhaitez envoyer les données.</param>
        <summary>Établit un hôte distant par défaut en utilisant le point de terminaison du réseau spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode établit un hôte distant par défaut à l’aide de la valeur spécifiée dans le `endPoint` paramètre. Une fois établie, vous n’êtes pas obligé de spécifier un hôte distant dans chaque appel à la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode).  
  
 L’établissement d’un hôte distant par défaut est facultatif. Spécification d’un hôte distant par défaut vous limite à l’hôte uniquement. Si vous souhaitez envoyer des datagrammes à un hôte distant différent, vous devez vous rappeler la fonction le <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode ou créer un autre <xref:System.Net.Sockets.UdpClient> sans un hôte distant par défaut. Si vous avez établi un à distance par défaut hôte également fournir un hôte distant dans votre appel à la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode), <xref:System.Net.Sockets.UdpClient.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Si vous appelez le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode), tous les datagrammes qui arrivent à partir d’une adresse autre que la valeur par défaut spécifiée est ignorée. Vous ne pouvez pas définir l’hôte distant par défaut à une adresse de diffusion à l’aide de cette méthode, sauf si vous héritez de <xref:System.Net.Sockets.UdpClient>, utilisez la méthode de Client pour obtenir sous-jacent <xref:System.Net.Sockets.Socket>et définissez l’option de socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Vous pouvez toutefois, diffuser des données à la valeur par défaut adresse de diffusion, 255.255.255.255, si vous spécifiez <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> dans votre appel à la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode). Si votre application nécessite un plus grand contrôle sur les adresses de diffusion, vous pouvez également revenir à l’aide la <xref:System.Net.Sockets.Socket> classe.  
  
> [!NOTE]
>  Étant donné que le protocole UDP est sans connexion, le <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode ne bloque pas. N’appelez pas la <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode si vous souhaitez recevoir des datagrammes multicast.  
  
   
  
## Examples  
 L’exemple suivant utilise un <xref:System.Net.IPEndPoint> pour établir un hôte distant par défaut.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="endPoint" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.UdpClient" /> est fermé.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress addr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress addr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ addr, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.Connect (addr, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addr">
          <see cref="T:System.Net.IPAddress" /> de l'hôte distant auquel vous souhaitez envoyer des données.</param>
        <param name="port">Numéro de port auquel vous souhaitez envoyer des données.</param>
        <summary>Établit un hôte distant par défaut en utilisant l'adresse IP et le numéro de port spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode établit un hôte distant par défaut en utilisant les valeurs spécifiées dans le `addr` et `port` paramètres. Une fois établie, vous n’êtes pas obligé de spécifier un hôte distant dans chaque appel à la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode).  
  
 L’établissement d’un hôte distant par défaut est facultatif. Spécification d’un hôte distant par défaut vous limite à l’hôte uniquement. Si vous souhaitez envoyer des datagrammes à un hôte distant différent, vous devez vous rappeler la fonction le <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode ou créer un autre <xref:System.Net.Sockets.UdpClient> sans un hôte distant par défaut. Si vous avez établi un à distance par défaut hôte également fournir un hôte distant dans votre appel à la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode), <xref:System.Net.Sockets.UdpClient.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Si vous appelez le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode), tous les datagrammes qui arrivent à partir d’une adresse autre que la valeur par défaut spécifiée est ignorée. Vous ne pouvez pas définir l’hôte distant par défaut à une adresse de diffusion à l’aide de cette méthode, sauf si vous héritez de <xref:System.Net.Sockets.UdpClient>, utilisez la méthode de client pour obtenir sous-jacent <xref:System.Net.Sockets.Socket>et définissez l’option de socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Vous pouvez toutefois, diffuser des données à la valeur par défaut adresse de diffusion, 255.255.255.255, si vous spécifiez <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> dans votre appel à la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode). Si votre application nécessite un plus grand contrôle sur les adresses de diffusion, vous pouvez également revenir à l’aide la <xref:System.Net.Sockets.Socket> classe.  
  
> [!NOTE]
>  Étant donné que le protocole UDP est sans connexion, le <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode ne bloque pas. N’appelez pas la <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode si vous souhaitez recevoir des datagrammes multicast.  
  
   
  
## Examples  
 L’exemple suivant utilise une adresse IP et port numéro pour vous connecter avec un hôte distant.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> est fermé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addr" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> n'est pas entre <see cref="F:System.Net.IPEndPoint.MinPort" /> et <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="udpClient.Connect (hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nom DNS de l'hôte distant auquel vous souhaitez envoyer des données.</param>
        <param name="port">Numéro de port de l'hôte distant auquel vous souhaitez envoyer des données.</param>
        <summary>Établit un hôte distant par défaut en utilisant le nom d'hôte et le numéro de port spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode établit un hôte distant par défaut en utilisant les valeurs spécifiées dans le `port` et `hostname` paramètres. Une fois établie, vous n’êtes pas obligé de spécifier un hôte distant dans chaque appel à la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode).  
  
 L’établissement d’un hôte distant par défaut est facultatif. Spécification d’un hôte distant par défaut vous limite à l’hôte uniquement. Si vous souhaitez envoyer des datagrammes à un hôte distant différent, vous devez vous rappeler la fonction le <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode ou créer un autre <xref:System.Net.Sockets.UdpClient> sans un hôte distant par défaut.  
  
 Si vous avez établi un à distance par défaut hôte également fournir un hôte distant dans votre appel à la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode), <xref:System.Net.Sockets.UdpClient.Send%2A> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Si vous appelez le <xref:System.Net.Sockets.Socket.Connect%2A> (méthode), tous les datagrammes qui arrivent à partir d’une adresse autre que la valeur par défaut spécifiée est ignorée. Vous ne pouvez pas définir l’hôte distant par défaut à une adresse de diffusion à l’aide de cette méthode, sauf si vous héritez de <xref:System.Net.Sockets.UdpClient>, utilisez la méthode de client pour obtenir sous-jacent <xref:System.Net.Sockets.Socket>et définissez l’option de socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Vous pouvez toutefois, diffuser des données à la valeur par défaut adresse de diffusion, 255.255.255.255, si vous spécifiez <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> dans votre appel à la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode). Si votre application nécessite un plus grand contrôle sur les adresses de diffusion, vous pouvez également revenir à l’aide la <xref:System.Net.Sockets.Socket> classe.  
  
> [!NOTE]
>  Étant donné que le protocole UDP est sans connexion, le <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode ne bloque pas. N’appelez pas la <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode si vous souhaitez recevoir des datagrammes multicast.  
  
   
  
## Examples  
 L’exemple suivant utilise le nom d’hôte et le port numéro pour vous connecter à un hôte distant.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.UdpClient" /> est fermé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> n'est pas entre <see cref="F:System.Net.IPEndPoint.MinPort" /> et <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="udpClient.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources managées et non managées utilisées par <see cref="T:System.Net.Sockets.UdpClient" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="udpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Net.Sockets.UdpClient" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose()` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Lorsque le `disposing` paramètre est true, cette méthode libère toutes les ressources détenues par les objets managés par ce <xref:System.Net.Sockets.UdpClient> références. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d’autres objets. Lors de la substitution <see langword="Dispose(Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’un Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [nettoyage des Resources](~/docs/standard/garbage-collection/unmanaged.md) non managé et [substitution de la méthode Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.UdpClient.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.UdpClient" /> autorise la fragmentation des datagrammes IP (Internet Protocol).</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Net.Sockets.UdpClient" /> autorise la fragmentation des datagrammes ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les datagrammes exigent une fragmentation lorsque leur taille dépasse le transfert unité maximale (MTU) du support de transmission. Les datagrammes peuvent être fragmentés par l’hôte d’envoi ou par un routeur intermédiaire. Si un datagramme doit être fragmenté et le <xref:System.Net.Sockets.Socket.DontFragment%2A> option est définie, le datagramme est ignoré, et un message d’erreur de contrôle Message ICMP (Internet Protocol) est envoyé à l’expéditeur du datagramme.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.Socket.DontFragment%2A> propriété.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Cette propriété ne peut être définie que pour les sockets qui utilisent l'indicateur <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou l'indicateur <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DropMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quitte un groupe multicast.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.DropMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> du groupe multicast à quitter.</param>
        <summary>Quitte un groupe multicast.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> méthode retire le <xref:System.Net.Sockets.UdpClient> du groupe de multidiffusion identifié par l’objet <xref:System.Net.IPAddress>. Après avoir appelé la <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> méthode, sous-jacent <xref:System.Net.Sockets.Socket> envoie un paquet de groupe gestion IGMP (Internet Protocol) vers le routeur, en supprimant le routeur du groupe multicast. Après un <xref:System.Net.Sockets.UdpClient> retire du groupe, il ne seront plus en mesure de recevoir des datagrammes envoyés à ce groupe.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple suivant montre comment déplacer un groupe multicast en fournissant une adresse de multidiffusion.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ArgumentException">L'adresse IP n'est pas compatible avec la valeur de <see cref="T:System.Net.Sockets.AddressFamily" /> qui définit le schéma d'adressage du socket.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr, int ifindex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr, int32 ifindex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress, ifindex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr, int ifindex);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.DropMulticastGroup (multicastAddr, ifindex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="ifindex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> du groupe multicast à quitter.</param>
        <param name="ifindex">Adresse locale du groupe multicast à quitter.</param>
        <summary>Quitte un groupe multicast.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> méthode retire le <xref:System.Net.Sockets.UdpClient> du groupe de multidiffusion identifié par l’objet <xref:System.Net.IPAddress>. Après avoir appelé la <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> méthode, sous-jacent <xref:System.Net.Sockets.Socket> envoie un paquet de groupe gestion IGMP (Internet Protocol) vers le routeur, en supprimant le routeur du groupe multicast. Après un <xref:System.Net.Sockets.UdpClient> retire du groupe, il ne seront plus en mesure de recevoir des datagrammes envoyés à ce groupe.  
  
> [!NOTE]
>  Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez le <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriété pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment déplacer un groupe multicast en fournissant une adresse de multidiffusion.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ArgumentException">L'adresse IP n'est pas compatible avec la valeur de <see cref="T:System.Net.Sockets.AddressFamily" /> qui définit le schéma d'adressage du socket.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si <see cref="T:System.Net.Sockets.UdpClient" /> peut envoyer ou recevoir des paquets de diffusion.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Net.Sockets.UdpClient" /> autorise les paquets de diffusion ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La diffusion est limitée à un sous-réseau spécifique. Vous pouvez diffuser à votre sous-réseau local en envoyant un paquet à 255.255.255.255 ; ou bien, vous pouvez utiliser l’adresse de diffusion dirigée, qui est la partie du réseau d’une adresse IP (Internet Protocol) avec tous les bits définis dans la partie hôte. Par exemple, si votre adresse IP est 192.168.1.40 (une adresse de classe C, avec la partie du réseau en tant que les trois premiers octets et la partie hôte est le dernier octet), votre adresse de diffusion dirigée est 192.168.1.255.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.UdpClient.EnableBroadcast%2A> propriété.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public byte[] EndReceive (IAsyncResult asyncResult, ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] EndReceive(class System.IAsyncResult asyncResult, class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ EndReceive(IAsyncResult ^ asyncResult, System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; byte[]" Usage="udpClient.EndReceive (asyncResult, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objet <see cref="T:System.IAsyncResult" /> retourné par un appel à <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />.</param>
        <param name="remoteEP">Point de terminaison distant spécifié.</param>
        <summary>Met fin à une réception asynchrone en attente.</summary>
        <returns>En cas de réussite, un tableau d’octets qui contient les données du datagramme.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se bloque jusqu'à ce que l’opération soit terminer.  
  
 Pour effectuer cette opération de façon synchrone, utilisez la <xref:System.Net.Sockets.UdpClient.Receive%2A> (méthode).  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.UdpClient.BeginSend%2A> pour effectuer une réception asynchrone d’une réponse du serveur.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" /> a été précédemment appelé pour la lecture asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au <see cref="T:System.Net.Sockets.Socket" /> sous-jacent.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="udpClient.EndSend asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objet <see cref="T:System.IAsyncResult" /> retourné par un appel à <see cref="Overload:System.Net.Sockets.UdpClient.BeginSend" />.</param>
        <summary>Met fin à un envoi asynchrone en attente.</summary>
        <returns>En cas de réussite, nombre d'octets envoyés à <see cref="T:System.Net.Sockets.UdpClient" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se bloque jusqu'à ce que l’opération soit terminer.  
  
 Pour effectuer cette opération de façon synchrone, utilisez la <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode).  
  
   
  
## Examples  
 Le code suivant exemple utilise <xref:System.Net.Sockets.UdpClient.BeginSend%2A> pour réaliser un envoi asynchrone d’une demande de serveur.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> n'a pas été retourné par un appel à la méthode <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> a été précédemment appelé pour la lecture asynchrone.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket sous-jacent.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui spécifie si l'élément <see cref="T:System.Net.Sockets.UdpClient" /> n'autorise qu'un seul client à utiliser un port.</summary>
        <value>
          <see langword="true" /> si l'élément <see cref="T:System.Net.Sockets.UdpClient" /> n'autorise qu'un seul client à utiliser un port spécifique ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" /> pour Windows Server 2003 et Windows XP Service Pack 2 et ultérieur, et <see langword="false" /> pour toutes les autres versions.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, plusieurs clients peuvent utiliser un port spécifique ; Toutefois, seul l’un des clients peut effectuer des opérations sur le trafic réseau envoyé au port. Vous pouvez utiliser le <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> propriété pour empêcher plusieurs clients à l’aide d’un port spécifique.  
  
 Cette propriété doit être définie avant que le socket sous-jacent est lié à un port du client. Si vous appelez <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%29?displayProperty=nameWithType>, <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%2CSystem.Net.Sockets.AddressFamily%29?displayProperty=nameWithType>, <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.UdpClient.%23ctor%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, le port client est lié en tant qu’un effet secondaire du constructeur, et vous ne pouvez pas définir par la suite le <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> propriété  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Sockets.UdpClient>et obtient et définit le <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> propriété.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s'est produite lors de la tentative d'accès au socket sous-jacent.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!UdpClient ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="udpClient.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="JoinMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute <see cref="T:System.Net.Sockets.UdpClient" /> à un groupe multicast.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> multicast du groupe auquel vous souhaitez vous joindre.</param>
        <summary>Ajoute <see cref="T:System.Net.Sockets.UdpClient" /> à un groupe multicast.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> méthode s’abonne le <xref:System.Net.Sockets.UdpClient> à un groupe multicast à l’aide de la <xref:System.Net.IPAddress>. Après avoir appelé la <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> méthode, sous-jacent <xref:System.Net.Sockets.Socket> envoie un paquet de groupe gestion IGMP (Internet Protocol) vers le routeur demandant l’appartenance au groupe de multidiffusion. La plage d’adresses de multidiffusion est entre 224.0.0.0 et 239.255.255.255. Si vous spécifiez une adresse en dehors de cette plage, ou si le routeur sur lequel la demande est effectuée n’est pas multidiffusion est activée, <xref:System.Net.Sockets.UdpClient> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur. Une fois le <xref:System.Net.Sockets.UdpClient> est répertorié avec le routeur en tant que membre du groupe de multidiffusion, il sera en mesure de recevoir des datagrammes multicast envoyés spécifié <xref:System.Net.IPAddress>.  
  
> [!NOTE]
>  Vous devez créer le <xref:System.Net.Sockets.UdpClient> à l’aide du numéro de port ; sinon, vous serez pas en mesure de recevoir les datagrammes multicast. N’appelez pas la <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode avant d’appeler le <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> (méthode), ou le <xref:System.Net.Sockets.UdpClient.Receive%2A> méthode ne fonctionne pas. Vous n’avez pas besoin d’appartenir à un groupe de multidiffusion pour envoyer des datagrammes à une adresse IP de multidiffusion.  
  
 Avant de rejoindre un groupe multicast, assurez-vous que le socket est lié au port ou au point de terminaison. Pour cela, en appelant un des constructeurs qui acceptent un port ou un point de terminaison en tant que paramètre.  
  
 Pour arrêter de recevoir des datagrammes multicast, appelez le <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> méthode et fournir le <xref:System.Net.IPAddress> du groupe à partir de laquelle vous souhaitez retirer.  
  
> [!NOTE]
>  Dans le cas de IPv6, il existe plusieurs plages d’adresses de multidiffusion que sélectionnables. Reportez-vous à l’IETF RFC 2375.  
  
> [!NOTE]
>  Vous ne pouvez pas appeler <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> sur un <xref:System.Net.Sockets.UdpClient> construit sans port local spécifique (autrement dit, à l’aide de la <xref:System.Net.Sockets.UdpClient.%23ctor> ou <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> constructeur).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment joindre un groupe multicast en fournissant une adresse de multidiffusion.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#1)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ArgumentException">L'adresse IP n'est pas compatible avec la valeur de <see cref="T:System.Net.Sockets.AddressFamily" /> qui définit le schéma d'adressage du socket.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (int ifindex, System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(int32 ifindex, class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Int32,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (ifindex As Integer, multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(int ifindex, System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : int * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (ifindex, multicastAddr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ifindex" Type="System.Int32" />
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="ifindex">Index d'interface associé à l'adresse IP locale à laquelle joindre le groupe multicast.</param>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> multicast du groupe auquel vous souhaitez vous joindre.</param>
        <summary>Ajoute <see cref="T:System.Net.Sockets.UdpClient" /> à un groupe multicast.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avant de rejoindre un groupe de multidiffusion, veillez à ce que le socket est lié au port ou au point de terminaison. Pour cela, en appelant un des constructeurs qui acceptent un port ou un point de terminaison en tant que paramètre.  
  
 Le `infindex` paramètre est utilisé pour identifier une interface matérielle sur le même lien.  
  
> [!NOTE]
>  Il existe plusieurs plages d’adresses de multidiffusion sélectionnables. Reportez-vous à la norme IETF RFC 2375.  
  
> [!NOTE]
>  Vous ne pouvez pas appeler <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> sur un <xref:System.Net.Sockets.UdpClient> construit sans port local spécifique (autrement dit, à l’aide de la <xref:System.Net.Sockets.UdpClient.%23ctor?displayProperty=nameWithType> ou <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType> constructeur).  
  
   
  
## Examples  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#5)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, int timeToLive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, int32 timeToLive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, timeToLive As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, int timeToLive);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, timeToLive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="timeToLive" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> du groupe multicast à joindre.</param>
        <param name="timeToLive">TTL mesurée en tronçons de routeur.</param>
        <summary>Ajoute <see cref="T:System.Net.Sockets.UdpClient" /> à un groupe multicast avec la durée de vie (TTL, Time to Live) spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> méthode s’abonne le <xref:System.Net.Sockets.UdpClient> à un groupe multicast à l’aide de la <xref:System.Net.IPAddress>. Après avoir appelé la <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> méthode, sous-jacent <xref:System.Net.Sockets.Socket> envoie un paquet de groupe gestion IGMP (Internet Protocol) vers le routeur demandant l’appartenance au groupe de multidiffusion. La plage d’adresses de multidiffusion est entre 224.0.0.0 et 239.255.255.255. Si vous spécifiez une adresse en dehors de cette plage, ou si le routeur sur lequel la demande est effectuée n’est pas multidiffusion est activée, <xref:System.Net.Sockets.UdpClient> lèvera une <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur. Le `timeToLive` paramètre spécifie le nombre de tronçons de routeur autorisé pour un datagramme multicast avant d’être supprimés. Une fois le <xref:System.Net.Sockets.UdpClient> est répertorié avec le routeur en tant que membre du groupe de multidiffusion, il sera en mesure de recevoir des datagrammes multicast envoyés spécifié <xref:System.Net.IPAddress>.  
  
> [!NOTE]
>  Vous devez créer le <xref:System.Net.Sockets.UdpClient> à l’aide du numéro de port sinon vous ne serez pas en mesure de recevoir les datagrammes multicast. N’appelez pas la <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode avant d’appeler le <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> méthode ou la méthode de réception ne fonctionnera pas. Vous n’avez pas besoin d’appartenir à un groupe de multidiffusion pour envoyer des datagrammes à une adresse IP de multidiffusion.  
  
 Avant de rejoindre un groupe multicast Assurez-vous que le socket est lié au port ou au point de terminaison. Pour cela, en appelant un des constructeurs qui acceptent un port ou un point de terminaison comme paramètre.  
  
 Pour arrêter de recevoir des datagrammes multicast, appelez le <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> méthode et fournir le <xref:System.Net.IPAddress> du groupe à partir de laquelle vous souhaitez retirer.  
  
> [!NOTE]
>  Vous ne pouvez pas appeler <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> sur un <xref:System.Net.Sockets.UdpClient> construit sans port local spécifique (autrement dit, à l’aide de la <xref:System.Net.Sockets.UdpClient.%23ctor> ou <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> constructeur).  
  
   
  
## Examples  
 L’exemple suivant montre comment joindre un groupe multicast en fournissant deux paramètres, une adresse de multidiffusion et un nombre qui représente la durée de vie.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le TTL spécifié n'est pas compris entre 0 et 255.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'adresse IP n'est pas compatible avec la valeur de <see cref="T:System.Net.Sockets.AddressFamily" /> qui définit le schéma d'adressage du socket.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, System.Net.IPAddress localAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, class System.Net.IPAddress localAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, localAddress As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, System::Net::IPAddress ^ localAddress);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, localAddress)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="localAddress" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> multicast du groupe auquel vous souhaitez vous joindre.</param>
        <param name="localAddress">
          <see cref="T:System.Net.IPAddress" /> local.</param>
        <summary>Ajoute <see cref="T:System.Net.Sockets.UdpClient" /> à un groupe multicast.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avant de joindre un groupe de multidiffusion, n’oubliez pas que le socket est lié au port ou au point de terminaison. Pour cela, en appelant un des constructeurs qui acceptent un port ou un point de terminaison en tant que paramètre.  
  
> [!NOTE]
>  Il existe plusieurs plages d’adresses de multidiffusion sélectionnables. Vous les trouverez dans IETF RFC 2375.  
  
> [!NOTE]
>  Vous ne pouvez pas appeler <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> sur un <xref:System.Net.Sockets.UdpClient> construit sans port local spécifique (autrement dit, à l’aide de la <xref:System.Net.Sockets.UdpClient.%23ctor> ou <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> constructeur).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> (méthode).  
  
 [!code-cpp[System.Net.Sockets.UdpClient#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.UdpClient#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> spécifiant si les paquets multicast sortants sont remis à l'application émettrice.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Net.Sockets.UdpClient" /> reçoit les paquets multicast sortants ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La multidiffusion est une méthode évolutive pour la communication de type plusieurs-à-plusieurs sur Internet. Si un processus s’abonne à une adresse de multidiffusion, tout paquet envoyé par ce processus sont reçus par tous les processus qui se sont abonné à l’adresse de multidiffusion.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.UdpClient.MulticastLoopback%2A> propriété.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.UdpClient#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public byte[] Receive (ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Receive(class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Receive(System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Receive :  -&gt; byte[]" Usage="udpClient.Receive remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <see cref="T:System.Net.IPEndPoint" /> qui représente l'hôte distant à partir duquel les données ont été envoyées.</param>
        <summary>Retourne un datagramme UDP qui a été envoyé par un hôte distant.</summary>
        <returns>Tableau de type <see cref="T:System.Byte" /> qui contient les données du datagramme.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.Receive%2A> méthode se bloque jusqu'à l’arrivée d’un datagramme à partir d’un hôte distant. Lorsque les données sont disponibles, le <xref:System.Net.Sockets.UdpClient.Receive%2A> méthode lit le premier datagramme en file d’attente et retourne la partie données de tableau d’octets. Cette méthode remplit le `remoteEP` paramètre avec le <xref:System.Net.IPAddress> et numéro de port de l’expéditeur.  
  
 Si vous spécifiez un hôte distant par défaut dans le <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode), le <xref:System.Net.Sockets.UdpClient.Receive%2A> méthode acceptera les datagrammes à partir de cet hôte uniquement. Tous les autres datagrammes sont ignorés.  
  
 Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!NOTE]
>  Si vous souhaitez recevoir des datagrammes multicast, n’appelez pas la <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode avant d’appeler le <xref:System.Net.Sockets.UdpClient.Receive%2A> (méthode). Le <xref:System.Net.Sockets.UdpClient> vous permet de recevoir des datagrammes doivent être créés à l’aide du numéro de port.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Net.Sockets.UdpClient.Receive%2A> (méthode). Le <xref:System.Net.Sockets.UdpClient.Receive%2A> méthode bloque l’exécution jusqu'à ce qu’il reçoit un message. À l’aide de la <xref:System.Net.IPEndPoint> passé à <xref:System.Net.Sockets.UdpClient.Receive%2A>, l’identité de l’hôte qui répond est révélée.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;valuetype System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.ReceiveAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync () As Task(Of UdpReceiveResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::UdpReceiveResult&gt; ^ ReceiveAsync();" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;" Usage="udpClient.ReceiveAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un datagramme UDP (de manière asynchrone), envoyé par un hôte distant.</summary>
        <returns>Retourne <see cref="T:System.Threading.Tasks.Task`1" />.  Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération ne bloque pas. Retourné <xref:System.Threading.Tasks.Task%601>> objet se termine une fois que le paquet UDP a été reçu.  
  
 Si vous spécifiez un hôte distant par défaut dans le <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode), cette méthode accepte les datagrammes à partir de cet hôte uniquement. Tous les autres datagrammes sont ignorés.  
  
 Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
> [!WARNING]
>  Si vous souhaitez recevoir des datagrammes multicast, n’appelez pas la <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode avant d’appeler cette méthode. Le <xref:System.Net.Sockets.UdpClient> vous permet de recevoir des datagrammes doivent être créés à l’aide du numéro de port.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.Socket" /> sous-jacent a été fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envoie un datagramme UDP à un hôte distant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int -&gt; int" Usage="udpClient.Send (dgram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dgram">Tableau de type <see cref="T:System.Byte" /> qui spécifie le datagramme UDP à envoyer, représenté sous la forme d'un tableau d'octets.</param>
        <param name="bytes">Nombre d’octets dans le datagramme.</param>
        <summary>Envoie un datagramme UDP à un hôte distant.</summary>
        <returns>Nombre d’octets envoyés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge envoie les datagrammes à l’hôte distant établie dans le <xref:System.Net.Sockets.UdpClient.Connect%2A> méthode et retourne le nombre d’octets envoyés. Si vous n’appelez pas <xref:System.Net.Sockets.UdpClient.Connect%2A> avant d’appeler cette surcharge, le <xref:System.Net.Sockets.UdpClient.Send%2A> méthode lève un <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Si vous souhaitez envoyer des datagrammes à un hôte distant différent, vous devez appeler la <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode) et spécifiez l’hôte distant souhaité. Utilisez une des autres <xref:System.Net.Sockets.UdpClient.Send%2A> surcharges de méthode pour envoyer des datagrammes à une adresse de diffusion.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode). Vous devez établir un hôte distant par défaut avant d’utiliser cette surcharge.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> a déjà établi un hôte distant par défaut.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.UdpClient" /> est fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.IPEndPoint -&gt; int" Usage="udpClient.Send (dgram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="dgram">Tableau de type <see cref="T:System.Byte" /> qui spécifie le datagramme UDP à envoyer, représenté sous la forme d'un tableau d'octets.</param>
        <param name="bytes">Nombre d’octets dans le datagramme.</param>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" /> qui représente l'hôte et le port auquel envoyer le datagramme.</param>
        <summary>Envoie un datagramme UDP à l’hôte au point de terminaison distant spécifié.</summary>
        <returns>Nombre d’octets envoyés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.Send%2A> méthode envoie les datagrammes au point de terminaison spécifié et retourne le nombre d’octets envoyés avec succès. Avant d’appeler cette surcharge, vous devez d’abord créer un <xref:System.Net.IPEndPoint> à l’aide de l’adresse IP et port numéro de l’hôte distant auquel seront délivrés vos datagrammes. Vous pouvez envoyer des datagrammes à la diffusion par défaut d’adresses, 255.255.255.255, en spécifiant <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> pour le <xref:System.Net.IPAddress.Address%2A> propriété de la <xref:System.Net.IPEndPoint>. Une fois que vous avez créé ce <xref:System.Net.IPEndPoint>, passez-la à la <xref:System.Net.Sockets.UdpClient.Send%2A> méthode en tant que le `endPoint` paramètre.  
  
 Si vous souhaitez envoyer des datagrammes à une autre adresse de diffusion, utilisez le <xref:System.Net.Sockets.UdpClient.Client%2A> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.Socket>et définissez l’option de socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Vous pouvez également revenir à l’aide la <xref:System.Net.Sockets.Socket> classe.  
  
> [!NOTE]
>  Ne fournissez pas un `endPoint` paramètre à cette méthode si vous avez déjà établi un hôte distant avec la <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode). Si vous le faites, les <xref:System.Net.Sockets.UdpClient.Send%2A> méthode lève un <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode). Cet exemple utilise un <xref:System.Net.IPEndPoint> pour spécifier l’ordinateur hôte cible.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> a déjà établi un hôte distant par défaut.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> est fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, hostname As String, port As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * string * int -&gt; int" Usage="udpClient.Send (dgram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dgram">Tableau de type <see cref="T:System.Byte" /> qui spécifie le datagramme UDP à envoyer, représenté sous la forme d'un tableau d'octets.</param>
        <param name="bytes">Nombre d’octets dans le datagramme.</param>
        <param name="hostname">Nom de l’hôte distant auquel vous voulez envoyer le datagramme.</param>
        <param name="port">Numéro de port distant avec lequel vous souhaitez communiquer.</param>
        <summary>Envoie un datagramme UDP à un port indiqué sur un hôte distant spécifié.</summary>
        <returns>Nombre d’octets envoyés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.Sockets.UdpClient.Send%2A> méthode envoie les datagrammes aux valeurs spécifiées par le `hostname` et `port` paramètres et retourne le nombre d’octets envoyé avec succès. Vous pouvez envoyer des datagrammes à l’adresse de diffusion par défaut en spécifiant « 255.255.255.255 » pour le `hostname` la valeur du paramètre.  
  
 Si vous souhaitez envoyer des datagrammes à une autre adresse de diffusion, utilisez le <xref:System.Net.Sockets.UdpClient.Client%2A> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.Socket>et définissez l’option de socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Vous pouvez également revenir à l’aide la <xref:System.Net.Sockets.Socket> classe.  
  
> [!NOTE]
>  Ne pas fournir un nom d’hôte ou numéro de port à cette méthode si vous avez déjà établi un hôte distant avec la <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode). Si vous le faites, les <xref:System.Net.Sockets.UdpClient.Send%2A> méthode lève un <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Net.Sockets.UdpClient.Send%2A> (méthode). Cet exemple utilise un nom d’hôte et un numéro de port pour identifier l’ordinateur hôte cible.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> a déjà établi un hôte distant par défaut.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.UdpClient" /> est fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SendAsync">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envoie un datagramme UDP à un hôte distant de manière asynchrone.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="datagram">Tableau de type <see cref="T:System.Byte" /> qui spécifie le datagramme UDP à envoyer, représenté sous la forme d'un tableau d'octets.</param>
        <param name="bytes">Nombre d’octets dans le datagramme.</param>
        <summary>Envoie un datagramme UDP à un hôte distant de manière asynchrone.</summary>
        <returns>Retourne <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge envoie les datagrammes à l’hôte distant établie dans le <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode). Si vous n’appelez pas <xref:System.Net.Sockets.UdpClient.Connect%2A> avant d’appeler cette surcharge, la méthode lève un <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 Si vous souhaitez envoyer des datagrammes à un hôte distant différent, vous devez appeler la <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode) et spécifiez l’hôte distant souhaité. Utilisez une des autres <xref:System.Net.Sockets.UdpClient.SendAsync%2A> surcharges de méthode pour envoyer des datagrammes à une adresse de diffusion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> a déjà établi un hôte distant par défaut.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.UdpClient" /> est fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * System.Net.IPEndPoint -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="datagram">Tableau de type <see cref="T:System.Byte" /> qui spécifie le datagramme UDP à envoyer, représenté sous la forme d'un tableau d'octets.</param>
        <param name="bytes">Nombre d’octets dans le datagramme.</param>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" /> qui représente l'hôte et le port auquel envoyer le datagramme.</param>
        <summary>Envoie un datagramme UDP à un hôte distant de manière asynchrone.</summary>
        <returns>Retourne <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode envoie les datagrammes au point de terminaison spécifié. Avant d’appeler cette surcharge, vous devez d’abord créer un <xref:System.Net.IPEndPoint> à l’aide de l’adresse IP et port numéro de l’hôte distant auquel seront délivrés vos datagrammes. Vous pouvez envoyer des datagrammes à la diffusion par défaut d’adresses, 255.255.255.255, en spécifiant <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> pour le <xref:System.Net.IPAddress.Address%2A> propriété de la <xref:System.Net.IPEndPoint>. Une fois que vous avez créé ce <xref:System.Net.IPEndPoint>, passez à cette méthode en tant que le `endPoint` paramètre.  
  
 Si vous souhaitez envoyer des datagrammes à une autre adresse de diffusion, utilisez le <xref:System.Net.Sockets.UdpClient.Client%2A> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.Socket>et définissez l’option de socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Vous pouvez également revenir à l’aide la <xref:System.Net.Sockets.Socket> classe.  
  
> [!WARNING]
>  Ne fournissez pas un `endPoint` paramètre à cette méthode si vous avez déjà établi un hôte distant avec la <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode). Si vous le faites, cette méthode lève un <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> a déjà établi un hôte distant par défaut.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> est fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, hostname As String, port As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * string * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="datagram">Tableau de type <see cref="T:System.Byte" /> qui spécifie le datagramme UDP à envoyer, représenté sous la forme d'un tableau d'octets.</param>
        <param name="bytes">Nombre d’octets dans le datagramme.</param>
        <param name="hostname">Nom de l’hôte distant auquel vous voulez envoyer le datagramme.</param>
        <param name="port">Numéro de port distant avec lequel vous souhaitez communiquer.</param>
        <summary>Envoie un datagramme UDP à un hôte distant de manière asynchrone.</summary>
        <returns>Retourne <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode envoie les datagrammes aux valeurs spécifiées par le `hostname` et `port` paramètres. Vous pouvez envoyer des datagrammes à l’adresse de diffusion par défaut en spécifiant « 255.255.255.255 » pour le `hostname` la valeur du paramètre.  
  
 Si vous souhaitez envoyer des datagrammes à une autre adresse de diffusion, utilisez le <xref:System.Net.Sockets.UdpClient.Client%2A> méthode pour obtenir sous-jacent <xref:System.Net.Sockets.Socket>et définissez l’option de socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Vous pouvez également revenir à l’aide la <xref:System.Net.Sockets.Socket> classe.  
  
> [!WARNING]
>  Ne pas fournir un nom d’hôte ou numéro de port à cette méthode si vous avez déjà établi un hôte distant avec la <xref:System.Net.Sockets.UdpClient.Connect%2A> (méthode). Si vous le faites, cette méthode lève un <xref:System.Net.Sockets.SocketException>. Si vous recevez un <xref:System.Net.Sockets.SocketException>, utilisez <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> pour obtenir le code d’erreur spécifique. Une fois que vous avez obtenu ce code, vous pouvez faire référence à la documentation sur les codes d’erreur de l’API Windows Sockets version 2 dans MSDN pour obtenir une description détaillée de l’erreur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> a déjà établi un hôte distant par défaut.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.Sockets.UdpClient" /> est fermé.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Une erreur s’est produite pendant l’accès au socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.UdpClient.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie la durée de vie des paquets IP (Internet Protocol) envoyés par <see cref="T:System.Net.Sockets.UdpClient" />.</summary>
        <value>Durée de vie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de durée de vie indique le nombre maximal de routeurs un paquet peut parcourir avant que le routeur n’ignore le paquet et un Message de protocole ICMP (Internet Control) « TTL dépassé » message d’erreur est renvoyé à l’expéditeur.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.Sockets.UdpClient.Ttl%2A> propriété.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>